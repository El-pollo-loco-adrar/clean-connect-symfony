"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_vue-loader_dist_exportHelper_js-node_modules_core-js_modules_es_array_fi-f6872a"],{

/***/ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js"
/*!***************************************************************************!*\
  !*** ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js ***!
  \***************************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BASE_TRANSITION: () => (/* binding */ BASE_TRANSITION),
/* harmony export */   BindingTypes: () => (/* binding */ BindingTypes),
/* harmony export */   CAMELIZE: () => (/* binding */ CAMELIZE),
/* harmony export */   CAPITALIZE: () => (/* binding */ CAPITALIZE),
/* harmony export */   CREATE_BLOCK: () => (/* binding */ CREATE_BLOCK),
/* harmony export */   CREATE_COMMENT: () => (/* binding */ CREATE_COMMENT),
/* harmony export */   CREATE_ELEMENT_BLOCK: () => (/* binding */ CREATE_ELEMENT_BLOCK),
/* harmony export */   CREATE_ELEMENT_VNODE: () => (/* binding */ CREATE_ELEMENT_VNODE),
/* harmony export */   CREATE_SLOTS: () => (/* binding */ CREATE_SLOTS),
/* harmony export */   CREATE_STATIC: () => (/* binding */ CREATE_STATIC),
/* harmony export */   CREATE_TEXT: () => (/* binding */ CREATE_TEXT),
/* harmony export */   CREATE_VNODE: () => (/* binding */ CREATE_VNODE),
/* harmony export */   CompilerDeprecationTypes: () => (/* binding */ CompilerDeprecationTypes),
/* harmony export */   ConstantTypes: () => (/* binding */ ConstantTypes),
/* harmony export */   ElementTypes: () => (/* binding */ ElementTypes),
/* harmony export */   ErrorCodes: () => (/* binding */ ErrorCodes),
/* harmony export */   FRAGMENT: () => (/* binding */ FRAGMENT),
/* harmony export */   GUARD_REACTIVE_PROPS: () => (/* binding */ GUARD_REACTIVE_PROPS),
/* harmony export */   IS_MEMO_SAME: () => (/* binding */ IS_MEMO_SAME),
/* harmony export */   IS_REF: () => (/* binding */ IS_REF),
/* harmony export */   KEEP_ALIVE: () => (/* binding */ KEEP_ALIVE),
/* harmony export */   MERGE_PROPS: () => (/* binding */ MERGE_PROPS),
/* harmony export */   NORMALIZE_CLASS: () => (/* binding */ NORMALIZE_CLASS),
/* harmony export */   NORMALIZE_PROPS: () => (/* binding */ NORMALIZE_PROPS),
/* harmony export */   NORMALIZE_STYLE: () => (/* binding */ NORMALIZE_STYLE),
/* harmony export */   Namespaces: () => (/* binding */ Namespaces),
/* harmony export */   NodeTypes: () => (/* binding */ NodeTypes),
/* harmony export */   OPEN_BLOCK: () => (/* binding */ OPEN_BLOCK),
/* harmony export */   POP_SCOPE_ID: () => (/* binding */ POP_SCOPE_ID),
/* harmony export */   PUSH_SCOPE_ID: () => (/* binding */ PUSH_SCOPE_ID),
/* harmony export */   RENDER_LIST: () => (/* binding */ RENDER_LIST),
/* harmony export */   RENDER_SLOT: () => (/* binding */ RENDER_SLOT),
/* harmony export */   RESOLVE_COMPONENT: () => (/* binding */ RESOLVE_COMPONENT),
/* harmony export */   RESOLVE_DIRECTIVE: () => (/* binding */ RESOLVE_DIRECTIVE),
/* harmony export */   RESOLVE_DYNAMIC_COMPONENT: () => (/* binding */ RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   RESOLVE_FILTER: () => (/* binding */ RESOLVE_FILTER),
/* harmony export */   SET_BLOCK_TRACKING: () => (/* binding */ SET_BLOCK_TRACKING),
/* harmony export */   SUSPENSE: () => (/* binding */ SUSPENSE),
/* harmony export */   TELEPORT: () => (/* binding */ TELEPORT),
/* harmony export */   TO_DISPLAY_STRING: () => (/* binding */ TO_DISPLAY_STRING),
/* harmony export */   TO_HANDLERS: () => (/* binding */ TO_HANDLERS),
/* harmony export */   TO_HANDLER_KEY: () => (/* binding */ TO_HANDLER_KEY),
/* harmony export */   TS_NODE_TYPES: () => (/* binding */ TS_NODE_TYPES),
/* harmony export */   UNREF: () => (/* binding */ UNREF),
/* harmony export */   WITH_CTX: () => (/* binding */ WITH_CTX),
/* harmony export */   WITH_DIRECTIVES: () => (/* binding */ WITH_DIRECTIVES),
/* harmony export */   WITH_MEMO: () => (/* binding */ WITH_MEMO),
/* harmony export */   advancePositionWithClone: () => (/* binding */ advancePositionWithClone),
/* harmony export */   advancePositionWithMutation: () => (/* binding */ advancePositionWithMutation),
/* harmony export */   assert: () => (/* binding */ assert),
/* harmony export */   baseCompile: () => (/* binding */ baseCompile),
/* harmony export */   baseParse: () => (/* binding */ baseParse),
/* harmony export */   buildDirectiveArgs: () => (/* binding */ buildDirectiveArgs),
/* harmony export */   buildProps: () => (/* binding */ buildProps),
/* harmony export */   buildSlots: () => (/* binding */ buildSlots),
/* harmony export */   checkCompatEnabled: () => (/* binding */ checkCompatEnabled),
/* harmony export */   convertToBlock: () => (/* binding */ convertToBlock),
/* harmony export */   createArrayExpression: () => (/* binding */ createArrayExpression),
/* harmony export */   createAssignmentExpression: () => (/* binding */ createAssignmentExpression),
/* harmony export */   createBlockStatement: () => (/* binding */ createBlockStatement),
/* harmony export */   createCacheExpression: () => (/* binding */ createCacheExpression),
/* harmony export */   createCallExpression: () => (/* binding */ createCallExpression),
/* harmony export */   createCompilerError: () => (/* binding */ createCompilerError),
/* harmony export */   createCompoundExpression: () => (/* binding */ createCompoundExpression),
/* harmony export */   createConditionalExpression: () => (/* binding */ createConditionalExpression),
/* harmony export */   createForLoopParams: () => (/* binding */ createForLoopParams),
/* harmony export */   createFunctionExpression: () => (/* binding */ createFunctionExpression),
/* harmony export */   createIfStatement: () => (/* binding */ createIfStatement),
/* harmony export */   createInterpolation: () => (/* binding */ createInterpolation),
/* harmony export */   createObjectExpression: () => (/* binding */ createObjectExpression),
/* harmony export */   createObjectProperty: () => (/* binding */ createObjectProperty),
/* harmony export */   createReturnStatement: () => (/* binding */ createReturnStatement),
/* harmony export */   createRoot: () => (/* binding */ createRoot),
/* harmony export */   createSequenceExpression: () => (/* binding */ createSequenceExpression),
/* harmony export */   createSimpleExpression: () => (/* binding */ createSimpleExpression),
/* harmony export */   createStructuralDirectiveTransform: () => (/* binding */ createStructuralDirectiveTransform),
/* harmony export */   createTemplateLiteral: () => (/* binding */ createTemplateLiteral),
/* harmony export */   createTransformContext: () => (/* binding */ createTransformContext),
/* harmony export */   createVNodeCall: () => (/* binding */ createVNodeCall),
/* harmony export */   errorMessages: () => (/* binding */ errorMessages),
/* harmony export */   extractIdentifiers: () => (/* binding */ extractIdentifiers),
/* harmony export */   findDir: () => (/* binding */ findDir),
/* harmony export */   findProp: () => (/* binding */ findProp),
/* harmony export */   forAliasRE: () => (/* binding */ forAliasRE),
/* harmony export */   generate: () => (/* binding */ generate),
/* harmony export */   generateCodeFrame: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   getBaseTransformPreset: () => (/* binding */ getBaseTransformPreset),
/* harmony export */   getConstantType: () => (/* binding */ getConstantType),
/* harmony export */   getMemoedVNodeCall: () => (/* binding */ getMemoedVNodeCall),
/* harmony export */   getVNodeBlockHelper: () => (/* binding */ getVNodeBlockHelper),
/* harmony export */   getVNodeHelper: () => (/* binding */ getVNodeHelper),
/* harmony export */   hasDynamicKeyVBind: () => (/* binding */ hasDynamicKeyVBind),
/* harmony export */   hasScopeRef: () => (/* binding */ hasScopeRef),
/* harmony export */   helperNameMap: () => (/* binding */ helperNameMap),
/* harmony export */   injectProp: () => (/* binding */ injectProp),
/* harmony export */   isAllWhitespace: () => (/* binding */ isAllWhitespace),
/* harmony export */   isCommentOrWhitespace: () => (/* binding */ isCommentOrWhitespace),
/* harmony export */   isCoreComponent: () => (/* binding */ isCoreComponent),
/* harmony export */   isFnExpression: () => (/* binding */ isFnExpression),
/* harmony export */   isFnExpressionBrowser: () => (/* binding */ isFnExpressionBrowser),
/* harmony export */   isFnExpressionNode: () => (/* binding */ isFnExpressionNode),
/* harmony export */   isFunctionType: () => (/* binding */ isFunctionType),
/* harmony export */   isInDestructureAssignment: () => (/* binding */ isInDestructureAssignment),
/* harmony export */   isInNewExpression: () => (/* binding */ isInNewExpression),
/* harmony export */   isMemberExpression: () => (/* binding */ isMemberExpression),
/* harmony export */   isMemberExpressionBrowser: () => (/* binding */ isMemberExpressionBrowser),
/* harmony export */   isMemberExpressionNode: () => (/* binding */ isMemberExpressionNode),
/* harmony export */   isReferencedIdentifier: () => (/* binding */ isReferencedIdentifier),
/* harmony export */   isSimpleIdentifier: () => (/* binding */ isSimpleIdentifier),
/* harmony export */   isSlotOutlet: () => (/* binding */ isSlotOutlet),
/* harmony export */   isStaticArgOf: () => (/* binding */ isStaticArgOf),
/* harmony export */   isStaticExp: () => (/* binding */ isStaticExp),
/* harmony export */   isStaticProperty: () => (/* binding */ isStaticProperty),
/* harmony export */   isStaticPropertyKey: () => (/* binding */ isStaticPropertyKey),
/* harmony export */   isTemplateNode: () => (/* binding */ isTemplateNode),
/* harmony export */   isText: () => (/* binding */ isText$1),
/* harmony export */   isVPre: () => (/* binding */ isVPre),
/* harmony export */   isVSlot: () => (/* binding */ isVSlot),
/* harmony export */   isWhitespaceText: () => (/* binding */ isWhitespaceText),
/* harmony export */   locStub: () => (/* binding */ locStub),
/* harmony export */   noopDirectiveTransform: () => (/* binding */ noopDirectiveTransform),
/* harmony export */   processExpression: () => (/* binding */ processExpression),
/* harmony export */   processFor: () => (/* binding */ processFor),
/* harmony export */   processIf: () => (/* binding */ processIf),
/* harmony export */   processSlotOutlet: () => (/* binding */ processSlotOutlet),
/* harmony export */   registerRuntimeHelpers: () => (/* binding */ registerRuntimeHelpers),
/* harmony export */   resolveComponentType: () => (/* binding */ resolveComponentType),
/* harmony export */   stringifyExpression: () => (/* binding */ stringifyExpression),
/* harmony export */   toValidAssetId: () => (/* binding */ toValidAssetId),
/* harmony export */   trackSlotScopes: () => (/* binding */ trackSlotScopes),
/* harmony export */   trackVForSlotScopes: () => (/* binding */ trackVForSlotScopes),
/* harmony export */   transform: () => (/* binding */ transform),
/* harmony export */   transformBind: () => (/* binding */ transformBind),
/* harmony export */   transformElement: () => (/* binding */ transformElement),
/* harmony export */   transformExpression: () => (/* binding */ transformExpression),
/* harmony export */   transformModel: () => (/* binding */ transformModel),
/* harmony export */   transformOn: () => (/* binding */ transformOn),
/* harmony export */   transformVBindShorthand: () => (/* binding */ transformVBindShorthand),
/* harmony export */   traverseNode: () => (/* binding */ traverseNode),
/* harmony export */   unwrapTSNode: () => (/* binding */ unwrapTSNode),
/* harmony export */   validFirstIdentCharRE: () => (/* binding */ validFirstIdentCharRE),
/* harmony export */   walkBlockDeclarations: () => (/* binding */ walkBlockDeclarations),
/* harmony export */   walkFunctionParams: () => (/* binding */ walkFunctionParams),
/* harmony export */   walkIdentifiers: () => (/* binding */ walkIdentifiers),
/* harmony export */   warnDeprecation: () => (/* binding */ warnDeprecation)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/**
* @vue/compiler-core v3.5.26
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/



const FRAGMENT = /* @__PURE__ */ Symbol( true ? `Fragment` : 0);
const TELEPORT = /* @__PURE__ */ Symbol( true ? `Teleport` : 0);
const SUSPENSE = /* @__PURE__ */ Symbol( true ? `Suspense` : 0);
const KEEP_ALIVE = /* @__PURE__ */ Symbol( true ? `KeepAlive` : 0);
const BASE_TRANSITION = /* @__PURE__ */ Symbol(
   true ? `BaseTransition` : 0
);
const OPEN_BLOCK = /* @__PURE__ */ Symbol( true ? `openBlock` : 0);
const CREATE_BLOCK = /* @__PURE__ */ Symbol( true ? `createBlock` : 0);
const CREATE_ELEMENT_BLOCK = /* @__PURE__ */ Symbol(
   true ? `createElementBlock` : 0
);
const CREATE_VNODE = /* @__PURE__ */ Symbol( true ? `createVNode` : 0);
const CREATE_ELEMENT_VNODE = /* @__PURE__ */ Symbol(
   true ? `createElementVNode` : 0
);
const CREATE_COMMENT = /* @__PURE__ */ Symbol(
   true ? `createCommentVNode` : 0
);
const CREATE_TEXT = /* @__PURE__ */ Symbol(
   true ? `createTextVNode` : 0
);
const CREATE_STATIC = /* @__PURE__ */ Symbol(
   true ? `createStaticVNode` : 0
);
const RESOLVE_COMPONENT = /* @__PURE__ */ Symbol(
   true ? `resolveComponent` : 0
);
const RESOLVE_DYNAMIC_COMPONENT = /* @__PURE__ */ Symbol(
   true ? `resolveDynamicComponent` : 0
);
const RESOLVE_DIRECTIVE = /* @__PURE__ */ Symbol(
   true ? `resolveDirective` : 0
);
const RESOLVE_FILTER = /* @__PURE__ */ Symbol(
   true ? `resolveFilter` : 0
);
const WITH_DIRECTIVES = /* @__PURE__ */ Symbol(
   true ? `withDirectives` : 0
);
const RENDER_LIST = /* @__PURE__ */ Symbol( true ? `renderList` : 0);
const RENDER_SLOT = /* @__PURE__ */ Symbol( true ? `renderSlot` : 0);
const CREATE_SLOTS = /* @__PURE__ */ Symbol( true ? `createSlots` : 0);
const TO_DISPLAY_STRING = /* @__PURE__ */ Symbol(
   true ? `toDisplayString` : 0
);
const MERGE_PROPS = /* @__PURE__ */ Symbol( true ? `mergeProps` : 0);
const NORMALIZE_CLASS = /* @__PURE__ */ Symbol(
   true ? `normalizeClass` : 0
);
const NORMALIZE_STYLE = /* @__PURE__ */ Symbol(
   true ? `normalizeStyle` : 0
);
const NORMALIZE_PROPS = /* @__PURE__ */ Symbol(
   true ? `normalizeProps` : 0
);
const GUARD_REACTIVE_PROPS = /* @__PURE__ */ Symbol(
   true ? `guardReactiveProps` : 0
);
const TO_HANDLERS = /* @__PURE__ */ Symbol( true ? `toHandlers` : 0);
const CAMELIZE = /* @__PURE__ */ Symbol( true ? `camelize` : 0);
const CAPITALIZE = /* @__PURE__ */ Symbol( true ? `capitalize` : 0);
const TO_HANDLER_KEY = /* @__PURE__ */ Symbol(
   true ? `toHandlerKey` : 0
);
const SET_BLOCK_TRACKING = /* @__PURE__ */ Symbol(
   true ? `setBlockTracking` : 0
);
const PUSH_SCOPE_ID = /* @__PURE__ */ Symbol( true ? `pushScopeId` : 0);
const POP_SCOPE_ID = /* @__PURE__ */ Symbol( true ? `popScopeId` : 0);
const WITH_CTX = /* @__PURE__ */ Symbol( true ? `withCtx` : 0);
const UNREF = /* @__PURE__ */ Symbol( true ? `unref` : 0);
const IS_REF = /* @__PURE__ */ Symbol( true ? `isRef` : 0);
const WITH_MEMO = /* @__PURE__ */ Symbol( true ? `withMemo` : 0);
const IS_MEMO_SAME = /* @__PURE__ */ Symbol( true ? `isMemoSame` : 0);
const helperNameMap = {
  [FRAGMENT]: `Fragment`,
  [TELEPORT]: `Teleport`,
  [SUSPENSE]: `Suspense`,
  [KEEP_ALIVE]: `KeepAlive`,
  [BASE_TRANSITION]: `BaseTransition`,
  [OPEN_BLOCK]: `openBlock`,
  [CREATE_BLOCK]: `createBlock`,
  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
  [CREATE_VNODE]: `createVNode`,
  [CREATE_ELEMENT_VNODE]: `createElementVNode`,
  [CREATE_COMMENT]: `createCommentVNode`,
  [CREATE_TEXT]: `createTextVNode`,
  [CREATE_STATIC]: `createStaticVNode`,
  [RESOLVE_COMPONENT]: `resolveComponent`,
  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
  [RESOLVE_DIRECTIVE]: `resolveDirective`,
  [RESOLVE_FILTER]: `resolveFilter`,
  [WITH_DIRECTIVES]: `withDirectives`,
  [RENDER_LIST]: `renderList`,
  [RENDER_SLOT]: `renderSlot`,
  [CREATE_SLOTS]: `createSlots`,
  [TO_DISPLAY_STRING]: `toDisplayString`,
  [MERGE_PROPS]: `mergeProps`,
  [NORMALIZE_CLASS]: `normalizeClass`,
  [NORMALIZE_STYLE]: `normalizeStyle`,
  [NORMALIZE_PROPS]: `normalizeProps`,
  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
  [TO_HANDLERS]: `toHandlers`,
  [CAMELIZE]: `camelize`,
  [CAPITALIZE]: `capitalize`,
  [TO_HANDLER_KEY]: `toHandlerKey`,
  [SET_BLOCK_TRACKING]: `setBlockTracking`,
  [PUSH_SCOPE_ID]: `pushScopeId`,
  [POP_SCOPE_ID]: `popScopeId`,
  [WITH_CTX]: `withCtx`,
  [UNREF]: `unref`,
  [IS_REF]: `isRef`,
  [WITH_MEMO]: `withMemo`,
  [IS_MEMO_SAME]: `isMemoSame`
};
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}

const Namespaces = {
  "HTML": 0,
  "0": "HTML",
  "SVG": 1,
  "1": "SVG",
  "MATH_ML": 2,
  "2": "MATH_ML"
};
const NodeTypes = {
  "ROOT": 0,
  "0": "ROOT",
  "ELEMENT": 1,
  "1": "ELEMENT",
  "TEXT": 2,
  "2": "TEXT",
  "COMMENT": 3,
  "3": "COMMENT",
  "SIMPLE_EXPRESSION": 4,
  "4": "SIMPLE_EXPRESSION",
  "INTERPOLATION": 5,
  "5": "INTERPOLATION",
  "ATTRIBUTE": 6,
  "6": "ATTRIBUTE",
  "DIRECTIVE": 7,
  "7": "DIRECTIVE",
  "COMPOUND_EXPRESSION": 8,
  "8": "COMPOUND_EXPRESSION",
  "IF": 9,
  "9": "IF",
  "IF_BRANCH": 10,
  "10": "IF_BRANCH",
  "FOR": 11,
  "11": "FOR",
  "TEXT_CALL": 12,
  "12": "TEXT_CALL",
  "VNODE_CALL": 13,
  "13": "VNODE_CALL",
  "JS_CALL_EXPRESSION": 14,
  "14": "JS_CALL_EXPRESSION",
  "JS_OBJECT_EXPRESSION": 15,
  "15": "JS_OBJECT_EXPRESSION",
  "JS_PROPERTY": 16,
  "16": "JS_PROPERTY",
  "JS_ARRAY_EXPRESSION": 17,
  "17": "JS_ARRAY_EXPRESSION",
  "JS_FUNCTION_EXPRESSION": 18,
  "18": "JS_FUNCTION_EXPRESSION",
  "JS_CONDITIONAL_EXPRESSION": 19,
  "19": "JS_CONDITIONAL_EXPRESSION",
  "JS_CACHE_EXPRESSION": 20,
  "20": "JS_CACHE_EXPRESSION",
  "JS_BLOCK_STATEMENT": 21,
  "21": "JS_BLOCK_STATEMENT",
  "JS_TEMPLATE_LITERAL": 22,
  "22": "JS_TEMPLATE_LITERAL",
  "JS_IF_STATEMENT": 23,
  "23": "JS_IF_STATEMENT",
  "JS_ASSIGNMENT_EXPRESSION": 24,
  "24": "JS_ASSIGNMENT_EXPRESSION",
  "JS_SEQUENCE_EXPRESSION": 25,
  "25": "JS_SEQUENCE_EXPRESSION",
  "JS_RETURN_STATEMENT": 26,
  "26": "JS_RETURN_STATEMENT"
};
const ElementTypes = {
  "ELEMENT": 0,
  "0": "ELEMENT",
  "COMPONENT": 1,
  "1": "COMPONENT",
  "SLOT": 2,
  "2": "SLOT",
  "TEMPLATE": 3,
  "3": "TEMPLATE"
};
const ConstantTypes = {
  "NOT_CONSTANT": 0,
  "0": "NOT_CONSTANT",
  "CAN_SKIP_PATCH": 1,
  "1": "CAN_SKIP_PATCH",
  "CAN_CACHE": 2,
  "2": "CAN_CACHE",
  "CAN_STRINGIFY": 3,
  "3": "CAN_STRINGIFY"
};
const locStub = {
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 },
  source: ""
};
function createRoot(children, source = "") {
  return {
    type: 0,
    source,
    children,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: [],
    temps: 0,
    codegenNode: void 0,
    loc: locStub
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, needPauseTracking = false, inVOnce = false) {
  return {
    type: 20,
    index,
    value,
    needPauseTracking,
    inVOnce,
    needArraySpread: false,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent) {
  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}

const defaultDelimitersOpen = new Uint8Array([123, 123]);
const defaultDelimitersClose = new Uint8Array([125, 125]);
function isTagStartChar(c) {
  return c >= 97 && c <= 122 || c >= 65 && c <= 90;
}
function isWhitespace(c) {
  return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
}
function isEndOfTagSection(c) {
  return c === 47 || c === 62 || isWhitespace(c);
}
function toCharCodes(str) {
  const ret = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
const Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea
};
class Tokenizer {
  constructor(stack, cbs) {
    this.stack = stack;
    this.cbs = cbs;
    /** The current state the tokenizer is in. */
    this.state = 1;
    /** The read buffer. */
    this.buffer = "";
    /** The beginning of the section that is currently being read. */
    this.sectionStart = 0;
    /** The index within the buffer that we are currently looking at. */
    this.index = 0;
    /** The start of the last entity. */
    this.entityStart = 0;
    /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
    this.baseState = 1;
    /** For special parsing behavior inside of script and style tags. */
    this.inRCDATA = false;
    /** For disabling RCDATA tags handling */
    this.inXML = false;
    /** For disabling interpolation parsing in v-pre */
    this.inVPre = false;
    /** Record newline positions for fast line / column calculation */
    this.newlines = [];
    this.mode = 0;
    this.delimiterOpen = defaultDelimitersOpen;
    this.delimiterClose = defaultDelimitersClose;
    this.delimiterIndex = -1;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
  }
  get inSFCRoot() {
    return this.mode === 2 && this.stack.length === 0;
  }
  reset() {
    this.state = 1;
    this.mode = 0;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = 1;
    this.inRCDATA = false;
    this.currentSequence = void 0;
    this.newlines.length = 0;
    this.delimiterOpen = defaultDelimitersOpen;
    this.delimiterClose = defaultDelimitersClose;
  }
  /**
   * Generate Position object with line / column information using recorded
   * newline positions. We know the index is always going to be an already
   * processed index, so all the newlines up to this index should have been
   * recorded.
   */
  getPos(index) {
    let line = 1;
    let column = index + 1;
    const length = this.newlines.length;
    let j = -1;
    if (length > 100) {
      let l = -1;
      let r = length;
      while (l + 1 < r) {
        const m = l + r >>> 1;
        this.newlines[m] < index ? l = m : r = m;
      }
      j = l;
    } else {
      for (let i = length - 1; i >= 0; i--) {
        if (index > this.newlines[i]) {
          j = i;
          break;
        }
      }
    }
    if (j >= 0) {
      line = j + 2;
      column = index - this.newlines[j];
    }
    return {
      column,
      line,
      offset: index
    };
  }
  peek() {
    return this.buffer.charCodeAt(this.index + 1);
  }
  stateText(c) {
    if (c === 60) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = 5;
      this.sectionStart = this.index;
    } else if (!this.inVPre && c === this.delimiterOpen[0]) {
      this.state = 2;
      this.delimiterIndex = 0;
      this.stateInterpolationOpen(c);
    }
  }
  stateInterpolationOpen(c) {
    if (c === this.delimiterOpen[this.delimiterIndex]) {
      if (this.delimiterIndex === this.delimiterOpen.length - 1) {
        const start = this.index + 1 - this.delimiterOpen.length;
        if (start > this.sectionStart) {
          this.cbs.ontext(this.sectionStart, start);
        }
        this.state = 3;
        this.sectionStart = start;
      } else {
        this.delimiterIndex++;
      }
    } else if (this.inRCDATA) {
      this.state = 32;
      this.stateInRCDATA(c);
    } else {
      this.state = 1;
      this.stateText(c);
    }
  }
  stateInterpolation(c) {
    if (c === this.delimiterClose[0]) {
      this.state = 4;
      this.delimiterIndex = 0;
      this.stateInterpolationClose(c);
    }
  }
  stateInterpolationClose(c) {
    if (c === this.delimiterClose[this.delimiterIndex]) {
      if (this.delimiterIndex === this.delimiterClose.length - 1) {
        this.cbs.oninterpolation(this.sectionStart, this.index + 1);
        if (this.inRCDATA) {
          this.state = 32;
        } else {
          this.state = 1;
        }
        this.sectionStart = this.index + 1;
      } else {
        this.delimiterIndex++;
      }
    } else {
      this.state = 3;
      this.stateInterpolation(c);
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.inRCDATA = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = 6;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> and <textarea>, also decode entities. */
  stateInRCDATA(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === 62 || isWhitespace(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        this.inRCDATA = false;
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
        if (!this.inVPre && c === this.delimiterOpen[0]) {
          this.state = 2;
          this.delimiterIndex = 0;
          this.stateInterpolationOpen(c);
        }
      } else if (this.fastForwardTo(60)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === 60);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = 28;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = 23;
      this.stateInDeclaration(c);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length) {
      const cc = this.buffer.charCodeAt(this.index);
      if (cc === 10) {
        this.newlines.push(this.index);
      }
      if (cc === c) {
        return true;
      }
    }
    this.index = this.buffer.length - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index - 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index - 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = 1;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  startSpecial(sequence, offset) {
    this.enterRCDATA(sequence, offset);
    this.state = 31;
  }
  enterRCDATA(sequence, offset) {
    this.inRCDATA = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
  }
  stateBeforeTagName(c) {
    if (c === 33) {
      this.state = 22;
      this.sectionStart = this.index + 1;
    } else if (c === 63) {
      this.state = 24;
      this.sectionStart = this.index + 1;
    } else if (isTagStartChar(c)) {
      this.sectionStart = this.index;
      if (this.mode === 0) {
        this.state = 6;
      } else if (this.inSFCRoot) {
        this.state = 34;
      } else if (!this.inXML) {
        if (c === 116) {
          this.state = 30;
        } else {
          this.state = c === 115 ? 29 : 6;
        }
      } else {
        this.state = 6;
      }
    } else if (c === 47) {
      this.state = 8;
    } else {
      this.state = 1;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.handleTagName(c);
    }
  }
  stateInSFCRootTagName(c) {
    if (isEndOfTagSection(c)) {
      const tag = this.buffer.slice(this.sectionStart, this.index);
      if (tag !== "template") {
        this.enterRCDATA(toCharCodes(`</` + tag), 0);
      }
      this.handleTagName(c);
    }
  }
  handleTagName(c) {
    this.cbs.onopentagname(this.sectionStart, this.index);
    this.sectionStart = -1;
    this.state = 11;
    this.stateBeforeAttrName(c);
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace(c)) ; else if (c === 62) {
      if (true) {
        this.cbs.onerr(14, this.index);
      }
      this.state = 1;
      this.sectionStart = this.index + 1;
    } else {
      this.state = isTagStartChar(c) ? 9 : 27;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === 62 || isWhitespace(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = 10;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === 62) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttrName(c) {
    if (c === 62) {
      this.cbs.onopentagend(this.index);
      if (this.inRCDATA) {
        this.state = 32;
      } else {
        this.state = 1;
      }
      this.sectionStart = this.index + 1;
    } else if (c === 47) {
      this.state = 7;
      if (( true) && this.peek() !== 62) {
        this.cbs.onerr(22, this.index);
      }
    } else if (c === 60 && this.peek() === 47) {
      this.cbs.onopentagend(this.index);
      this.state = 5;
      this.sectionStart = this.index;
    } else if (!isWhitespace(c)) {
      if (( true) && c === 61) {
        this.cbs.onerr(
          19,
          this.index
        );
      }
      this.handleAttrStart(c);
    }
  }
  handleAttrStart(c) {
    if (c === 118 && this.peek() === 45) {
      this.state = 13;
      this.sectionStart = this.index;
    } else if (c === 46 || c === 58 || c === 64 || c === 35) {
      this.cbs.ondirname(this.index, this.index + 1);
      this.state = 14;
      this.sectionStart = this.index + 1;
    } else {
      this.state = 12;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === 62) {
      this.cbs.onselfclosingtag(this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
      this.inRCDATA = false;
    } else if (!isWhitespace(c)) {
      this.state = 11;
      this.stateBeforeAttrName(c);
    }
  }
  stateInAttrName(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (( true) && (c === 34 || c === 39 || c === 60)) {
      this.cbs.onerr(
        17,
        this.index
      );
    }
  }
  stateInDirName(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 58) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.state = 14;
      this.sectionStart = this.index + 1;
    } else if (c === 46) {
      this.cbs.ondirname(this.sectionStart, this.index);
      this.state = 16;
      this.sectionStart = this.index + 1;
    }
  }
  stateInDirArg(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirarg(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 91) {
      this.state = 15;
    } else if (c === 46) {
      this.cbs.ondirarg(this.sectionStart, this.index);
      this.state = 16;
      this.sectionStart = this.index + 1;
    }
  }
  stateInDynamicDirArg(c) {
    if (c === 93) {
      this.state = 14;
    } else if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirarg(this.sectionStart, this.index + 1);
      this.handleAttrNameEnd(c);
      if (true) {
        this.cbs.onerr(
          27,
          this.index
        );
      }
    }
  }
  stateInDirModifier(c) {
    if (c === 61 || isEndOfTagSection(c)) {
      this.cbs.ondirmodifier(this.sectionStart, this.index);
      this.handleAttrNameEnd(c);
    } else if (c === 46) {
      this.cbs.ondirmodifier(this.sectionStart, this.index);
      this.sectionStart = this.index + 1;
    }
  }
  handleAttrNameEnd(c) {
    this.sectionStart = this.index;
    this.state = 17;
    this.cbs.onattribnameend(this.index);
    this.stateAfterAttrName(c);
  }
  stateAfterAttrName(c) {
    if (c === 61) {
      this.state = 18;
    } else if (c === 47 || c === 62) {
      this.cbs.onattribend(0, this.sectionStart);
      this.sectionStart = -1;
      this.state = 11;
      this.stateBeforeAttrName(c);
    } else if (!isWhitespace(c)) {
      this.cbs.onattribend(0, this.sectionStart);
      this.handleAttrStart(c);
    }
  }
  stateBeforeAttrValue(c) {
    if (c === 34) {
      this.state = 19;
      this.sectionStart = this.index + 1;
    } else if (c === 39) {
      this.state = 20;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c)) {
      this.sectionStart = this.index;
      this.state = 21;
      this.stateInAttrValueNoQuotes(c);
    }
  }
  handleInAttrValue(c, quote) {
    if (c === quote || this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(
        quote === 34 ? 3 : 2,
        this.index + 1
      );
      this.state = 11;
    }
  }
  stateInAttrValueDoubleQuotes(c) {
    this.handleInAttrValue(c, 34);
  }
  stateInAttrValueSingleQuotes(c) {
    this.handleInAttrValue(c, 39);
  }
  stateInAttrValueNoQuotes(c) {
    if (isWhitespace(c) || c === 62) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(1, this.index);
      this.state = 11;
      this.stateBeforeAttrName(c);
    } else if (( true) && c === 34 || c === 39 || c === 60 || c === 61 || c === 96) {
      this.cbs.onerr(
        18,
        this.index
      );
    } else ;
  }
  stateBeforeDeclaration(c) {
    if (c === 91) {
      this.state = 26;
      this.sequenceIndex = 0;
    } else {
      this.state = c === 45 ? 25 : 23;
    }
  }
  stateInDeclaration(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === 45) {
      this.state = 28;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = 23;
    }
  }
  stateInSpecialComment(c) {
    if (c === 62 || this.fastForwardTo(62)) {
      this.cbs.oncomment(this.sectionStart, this.index);
      this.state = 1;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    if (c === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (c === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = 6;
      this.stateInTagName(c);
    }
  }
  stateBeforeSpecialT(c) {
    if (c === Sequences.TitleEnd[3]) {
      this.startSpecial(Sequences.TitleEnd, 4);
    } else if (c === Sequences.TextareaEnd[3]) {
      this.startSpecial(Sequences.TextareaEnd, 4);
    } else {
      this.state = 6;
      this.stateInTagName(c);
    }
  }
  startEntity() {
  }
  stateInEntity() {
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse(input) {
    this.buffer = input;
    while (this.index < this.buffer.length) {
      const c = this.buffer.charCodeAt(this.index);
      if (c === 10 && this.state !== 33) {
        this.newlines.push(this.index);
      }
      switch (this.state) {
        case 1: {
          this.stateText(c);
          break;
        }
        case 2: {
          this.stateInterpolationOpen(c);
          break;
        }
        case 3: {
          this.stateInterpolation(c);
          break;
        }
        case 4: {
          this.stateInterpolationClose(c);
          break;
        }
        case 31: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case 32: {
          this.stateInRCDATA(c);
          break;
        }
        case 26: {
          this.stateCDATASequence(c);
          break;
        }
        case 19: {
          this.stateInAttrValueDoubleQuotes(c);
          break;
        }
        case 12: {
          this.stateInAttrName(c);
          break;
        }
        case 13: {
          this.stateInDirName(c);
          break;
        }
        case 14: {
          this.stateInDirArg(c);
          break;
        }
        case 15: {
          this.stateInDynamicDirArg(c);
          break;
        }
        case 16: {
          this.stateInDirModifier(c);
          break;
        }
        case 28: {
          this.stateInCommentLike(c);
          break;
        }
        case 27: {
          this.stateInSpecialComment(c);
          break;
        }
        case 11: {
          this.stateBeforeAttrName(c);
          break;
        }
        case 6: {
          this.stateInTagName(c);
          break;
        }
        case 34: {
          this.stateInSFCRootTagName(c);
          break;
        }
        case 9: {
          this.stateInClosingTagName(c);
          break;
        }
        case 5: {
          this.stateBeforeTagName(c);
          break;
        }
        case 17: {
          this.stateAfterAttrName(c);
          break;
        }
        case 20: {
          this.stateInAttrValueSingleQuotes(c);
          break;
        }
        case 18: {
          this.stateBeforeAttrValue(c);
          break;
        }
        case 8: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case 10: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case 29: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case 30: {
          this.stateBeforeSpecialT(c);
          break;
        }
        case 21: {
          this.stateInAttrValueNoQuotes(c);
          break;
        }
        case 7: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case 23: {
          this.stateInDeclaration(c);
          break;
        }
        case 22: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case 25: {
          this.stateBeforeComment(c);
          break;
        }
        case 24: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case 33: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
    this.finish();
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.sectionStart !== this.index) {
      if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === 19 || this.state === 20 || this.state === 21) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  finish() {
    this.handleTrailingData();
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length;
    if (this.sectionStart >= endIndex) {
      return;
    }
    if (this.state === 28) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex);
      }
    } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9) ; else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitCodePoint(cp, consumed) {
  }
}

const CompilerDeprecationTypes = {
  "COMPILER_IS_ON_ELEMENT": "COMPILER_IS_ON_ELEMENT",
  "COMPILER_V_BIND_SYNC": "COMPILER_V_BIND_SYNC",
  "COMPILER_V_BIND_OBJECT_ORDER": "COMPILER_V_BIND_OBJECT_ORDER",
  "COMPILER_V_ON_NATIVE": "COMPILER_V_ON_NATIVE",
  "COMPILER_V_IF_V_FOR_PRECEDENCE": "COMPILER_V_IF_V_FOR_PRECEDENCE",
  "COMPILER_NATIVE_TEMPLATE": "COMPILER_NATIVE_TEMPLATE",
  "COMPILER_INLINE_TEMPLATE": "COMPILER_INLINE_TEMPLATE",
  "COMPILER_FILTERS": "COMPILER_FILTERS"
};
const deprecationData = {
  ["COMPILER_IS_ON_ELEMENT"]: {
    message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
  },
  ["COMPILER_V_BIND_SYNC"]: {
    message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
  },
  ["COMPILER_V_BIND_OBJECT_ORDER"]: {
    message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
  },
  ["COMPILER_V_ON_NATIVE"]: {
    message: `.native modifier for v-on has been removed as is no longer necessary.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
  },
  ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
    message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
  },
  ["COMPILER_NATIVE_TEMPLATE"]: {
    message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
  },
  ["COMPILER_INLINE_TEMPLATE"]: {
    message: `"inline-template" has been removed in Vue 3.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
  },
  ["COMPILER_FILTERS"]: {
    message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
  }
};
function getCompatValue(key, { compatConfig }) {
  const value = compatConfig && compatConfig[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  if ( true && enabled) {
    warnDeprecation(key, context, loc, ...args);
  }
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc) err.loc = loc;
  context.onWarn(err);
}

function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
   true && console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg =  true ? (messages || errorMessages)[code] + (additionalMessage || ``) : 0;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
const ErrorCodes = {
  "ABRUPT_CLOSING_OF_EMPTY_COMMENT": 0,
  "0": "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
  "CDATA_IN_HTML_CONTENT": 1,
  "1": "CDATA_IN_HTML_CONTENT",
  "DUPLICATE_ATTRIBUTE": 2,
  "2": "DUPLICATE_ATTRIBUTE",
  "END_TAG_WITH_ATTRIBUTES": 3,
  "3": "END_TAG_WITH_ATTRIBUTES",
  "END_TAG_WITH_TRAILING_SOLIDUS": 4,
  "4": "END_TAG_WITH_TRAILING_SOLIDUS",
  "EOF_BEFORE_TAG_NAME": 5,
  "5": "EOF_BEFORE_TAG_NAME",
  "EOF_IN_CDATA": 6,
  "6": "EOF_IN_CDATA",
  "EOF_IN_COMMENT": 7,
  "7": "EOF_IN_COMMENT",
  "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT": 8,
  "8": "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
  "EOF_IN_TAG": 9,
  "9": "EOF_IN_TAG",
  "INCORRECTLY_CLOSED_COMMENT": 10,
  "10": "INCORRECTLY_CLOSED_COMMENT",
  "INCORRECTLY_OPENED_COMMENT": 11,
  "11": "INCORRECTLY_OPENED_COMMENT",
  "INVALID_FIRST_CHARACTER_OF_TAG_NAME": 12,
  "12": "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
  "MISSING_ATTRIBUTE_VALUE": 13,
  "13": "MISSING_ATTRIBUTE_VALUE",
  "MISSING_END_TAG_NAME": 14,
  "14": "MISSING_END_TAG_NAME",
  "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES": 15,
  "15": "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
  "NESTED_COMMENT": 16,
  "16": "NESTED_COMMENT",
  "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME": 17,
  "17": "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
  "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE": 18,
  "18": "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
  "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME": 19,
  "19": "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
  "UNEXPECTED_NULL_CHARACTER": 20,
  "20": "UNEXPECTED_NULL_CHARACTER",
  "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME": 21,
  "21": "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
  "UNEXPECTED_SOLIDUS_IN_TAG": 22,
  "22": "UNEXPECTED_SOLIDUS_IN_TAG",
  "X_INVALID_END_TAG": 23,
  "23": "X_INVALID_END_TAG",
  "X_MISSING_END_TAG": 24,
  "24": "X_MISSING_END_TAG",
  "X_MISSING_INTERPOLATION_END": 25,
  "25": "X_MISSING_INTERPOLATION_END",
  "X_MISSING_DIRECTIVE_NAME": 26,
  "26": "X_MISSING_DIRECTIVE_NAME",
  "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END": 27,
  "27": "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
  "X_V_IF_NO_EXPRESSION": 28,
  "28": "X_V_IF_NO_EXPRESSION",
  "X_V_IF_SAME_KEY": 29,
  "29": "X_V_IF_SAME_KEY",
  "X_V_ELSE_NO_ADJACENT_IF": 30,
  "30": "X_V_ELSE_NO_ADJACENT_IF",
  "X_V_FOR_NO_EXPRESSION": 31,
  "31": "X_V_FOR_NO_EXPRESSION",
  "X_V_FOR_MALFORMED_EXPRESSION": 32,
  "32": "X_V_FOR_MALFORMED_EXPRESSION",
  "X_V_FOR_TEMPLATE_KEY_PLACEMENT": 33,
  "33": "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
  "X_V_BIND_NO_EXPRESSION": 34,
  "34": "X_V_BIND_NO_EXPRESSION",
  "X_V_ON_NO_EXPRESSION": 35,
  "35": "X_V_ON_NO_EXPRESSION",
  "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET": 36,
  "36": "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
  "X_V_SLOT_MIXED_SLOT_USAGE": 37,
  "37": "X_V_SLOT_MIXED_SLOT_USAGE",
  "X_V_SLOT_DUPLICATE_SLOT_NAMES": 38,
  "38": "X_V_SLOT_DUPLICATE_SLOT_NAMES",
  "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN": 39,
  "39": "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
  "X_V_SLOT_MISPLACED": 40,
  "40": "X_V_SLOT_MISPLACED",
  "X_V_MODEL_NO_EXPRESSION": 41,
  "41": "X_V_MODEL_NO_EXPRESSION",
  "X_V_MODEL_MALFORMED_EXPRESSION": 42,
  "42": "X_V_MODEL_MALFORMED_EXPRESSION",
  "X_V_MODEL_ON_SCOPE_VARIABLE": 43,
  "43": "X_V_MODEL_ON_SCOPE_VARIABLE",
  "X_V_MODEL_ON_PROPS": 44,
  "44": "X_V_MODEL_ON_PROPS",
  "X_V_MODEL_ON_CONST": 45,
  "45": "X_V_MODEL_ON_CONST",
  "X_INVALID_EXPRESSION": 46,
  "46": "X_INVALID_EXPRESSION",
  "X_KEEP_ALIVE_INVALID_CHILDREN": 47,
  "47": "X_KEEP_ALIVE_INVALID_CHILDREN",
  "X_PREFIX_ID_NOT_SUPPORTED": 48,
  "48": "X_PREFIX_ID_NOT_SUPPORTED",
  "X_MODULE_MODE_NOT_SUPPORTED": 49,
  "49": "X_MODULE_MODE_NOT_SUPPORTED",
  "X_CACHE_HANDLER_NOT_SUPPORTED": 50,
  "50": "X_CACHE_HANDLER_NOT_SUPPORTED",
  "X_SCOPE_ID_NOT_SUPPORTED": 51,
  "51": "X_SCOPE_ID_NOT_SUPPORTED",
  "X_VNODE_HOOKS": 52,
  "52": "X_VNODE_HOOKS",
  "X_V_BIND_INVALID_SAME_NAME_ARGUMENT": 53,
  "53": "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
  "__EXTEND_POINT__": 54,
  "54": "__EXTEND_POINT__"
};
const errorMessages = {
  // parse errors
  [0]: "Illegal comment.",
  [1]: "CDATA section is allowed only in XML context.",
  [2]: "Duplicate attribute.",
  [3]: "End tag cannot have attributes.",
  [4]: "Illegal '/' in tags.",
  [5]: "Unexpected EOF in tag.",
  [6]: "Unexpected EOF in CDATA section.",
  [7]: "Unexpected EOF in comment.",
  [8]: "Unexpected EOF in script.",
  [9]: "Unexpected EOF in tag.",
  [10]: "Incorrectly closed comment.",
  [11]: "Incorrectly opened comment.",
  [12]: "Illegal tag name. Use '&lt;' to print '<'.",
  [13]: "Attribute value was expected.",
  [14]: "End tag name was expected.",
  [15]: "Whitespace was expected.",
  [16]: "Unexpected '<!--' in comment.",
  [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  [19]: "Attribute name cannot start with '='.",
  [21]: "'<?' is allowed only in XML context.",
  [20]: `Unexpected null character.`,
  [22]: "Illegal '/' in tags.",
  // Vue-specific parse errors
  [23]: "Invalid end tag.",
  [24]: "Element is missing end tag.",
  [25]: "Interpolation end sign was not found.",
  [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  [26]: "Legal directive name was expected.",
  // transform errors
  [28]: `v-if/v-else-if is missing expression.`,
  [29]: `v-if/else branches must use unique keys.`,
  [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
  [31]: `v-for is missing expression.`,
  [32]: `v-for has invalid expression.`,
  [33]: `<template v-for> key should be placed on the <template> tag.`,
  [34]: `v-bind is missing expression.`,
  [53]: `v-bind with same-name shorthand only allows static argument.`,
  [35]: `v-on is missing expression.`,
  [36]: `Unexpected custom directive on <slot> outlet.`,
  [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
  [38]: `Duplicate slot names found. `,
  [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
  [40]: `v-slot can only be used on components or <template> tags.`,
  [41]: `v-model is missing expression.`,
  [42]: `v-model value must be a valid JavaScript member expression.`,
  [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
  [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
  [45]: `v-model cannot be used on a const binding because it is not writable.`,
  [46]: `Error parsing JavaScript expression: `,
  [47]: `<KeepAlive> expects exactly one child component.`,
  [52]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
  // generic errors
  [48]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
  [49]: `ES module mode is not supported in this build of compiler.`,
  [50]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
  [51]: `"scopeId" option is only supported in module mode.`,
  // just to fulfill types
  [54]: ``
};

function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p = parentStack[i];
      if (p.type === "AssignmentExpression") {
        return true;
      } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function isInNewExpression(parentStack) {
  let i = parentStack.length;
  while (i--) {
    const p = parentStack[i];
    if (p.type === "NewExpression") {
      return true;
    } else if (p.type !== "MemberExpression") {
      break;
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  const body = block.type === "SwitchCase" ? block.consequent : block.body;
  for (const stmt of body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare) continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id) continue;
      onIdent(stmt.id);
    } else if (isForStatement(stmt)) {
      walkForStatement(stmt, true, onIdent);
    } else if (stmt.type === "SwitchStatement") {
      walkSwitchStatement(stmt, true, onIdent);
    }
  }
}
function isForStatement(stmt) {
  return stmt.type === "ForOfStatement" || stmt.type === "ForInStatement" || stmt.type === "ForStatement";
}
function walkForStatement(stmt, isVar, onIdent) {
  const variable = stmt.type === "ForStatement" ? stmt.init : stmt.left;
  if (variable && variable.type === "VariableDeclaration" && (variable.kind === "var" ? isVar : !isVar)) {
    for (const decl of variable.declarations) {
      for (const id of extractIdentifiers(decl.id)) {
        onIdent(id);
      }
    }
  }
}
function walkSwitchStatement(stmt, isVar, onIdent) {
  for (const cs of stmt.cases) {
    for (const stmt2 of cs.consequent) {
      if (stmt2.type === "VariableDeclaration" && (stmt2.kind === "var" ? isVar : !isVar)) {
        for (const decl of stmt2.declarations) {
          for (const id of extractIdentifiers(decl.id)) {
            onIdent(id);
          }
        }
      }
    }
    walkBlockDeclarations(cs, onIdent);
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element) extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
const isFunctionType = (node) => {
  return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
};
const isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
const isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
const TS_NODE_TYPES = [
  "TSAsExpression",
  // foo as number
  "TSTypeAssertion",
  // (<number>foo)
  "TSNonNullExpression",
  // foo!
  "TSInstantiationExpression",
  // foo<string>
  "TSSatisfiesExpression"
  // foo satisfies T
];
function unwrapTSNode(node) {
  if (TS_NODE_TYPES.includes(node.type)) {
    return unwrapTSNode(node.expression);
  } else {
    return node;
  }
}

const isStaticExp = (p) => p.type === 4 && p.isStatic;
function isCoreComponent(tag) {
  switch (tag) {
    case "Teleport":
    case "teleport":
      return TELEPORT;
    case "Suspense":
    case "suspense":
      return SUSPENSE;
    case "KeepAlive":
    case "keep-alive":
      return KEEP_ALIVE;
    case "BaseTransition":
    case "base-transition":
      return BASE_TRANSITION;
  }
}
const nonIdentifierRE = /^$|^\d|[^\$\w\xA0-\uFFFF]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
const getExpSource = (exp) => exp.type === 4 ? exp.content : exp.loc.source;
const isMemberExpressionBrowser = (exp) => {
  const path = getExpSource(exp).trim().replace(whitespaceRE, (s) => s.trim());
  let state = 0 /* inMemberExp */;
  let stateStack = [];
  let currentOpenBracketCount = 0;
  let currentOpenParensCount = 0;
  let currentStringType = null;
  for (let i = 0; i < path.length; i++) {
    const char = path.charAt(i);
    switch (state) {
      case 0 /* inMemberExp */:
        if (char === "[") {
          stateStack.push(state);
          state = 1 /* inBrackets */;
          currentOpenBracketCount++;
        } else if (char === "(") {
          stateStack.push(state);
          state = 2 /* inParens */;
          currentOpenParensCount++;
        } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
          return false;
        }
        break;
      case 1 /* inBrackets */:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3 /* inString */;
          currentStringType = char;
        } else if (char === `[`) {
          currentOpenBracketCount++;
        } else if (char === `]`) {
          if (!--currentOpenBracketCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 2 /* inParens */:
        if (char === `'` || char === `"` || char === "`") {
          stateStack.push(state);
          state = 3 /* inString */;
          currentStringType = char;
        } else if (char === `(`) {
          currentOpenParensCount++;
        } else if (char === `)`) {
          if (i === path.length - 1) {
            return false;
          }
          if (!--currentOpenParensCount) {
            state = stateStack.pop();
          }
        }
        break;
      case 3 /* inString */:
        if (char === currentStringType) {
          state = stateStack.pop();
          currentStringType = null;
        }
        break;
    }
  }
  return !currentOpenBracketCount && !currentOpenParensCount;
};
const isMemberExpressionNode = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP ;
const isMemberExpression = isMemberExpressionBrowser ;
const fnExpRE = /^\s*(?:async\s*)?(?:\([^)]*?\)|[\w$_]+)\s*(?::[^=]+)?=>|^\s*(?:async\s+)?function(?:\s+[\w$]+)?\s*\(/;
const isFnExpressionBrowser = (exp) => fnExpRE.test(getExpSource(exp));
const isFnExpressionNode = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP ;
const isFnExpression = isFnExpressionBrowser ;
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(
    {
      offset: pos.offset,
      line: pos.line,
      column: pos.column
    },
    source,
    numberOfCharacters
  );
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly) continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p) => p.type === 7 && p.name === "bind" && (!p.arg || // v-bind="obj"
    p.arg.type !== 4 || // v-bind:[_ctx.foo]
    !p.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVPre(p) {
  return p.type === 7 && p.name === "pre";
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
const propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
function getUnnormalizedProps(props, callPath = []) {
  if (props && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) && props.type === 14) {
    const callee = props.callee;
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      );
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some(
      (p) => p.key.type === 4 && p.key.content === propKeyName
    );
  }
  return result;
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some((c) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
    case 20:
      return false;
    default:
      if (true) ;
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/;
function isAllWhitespace(str) {
  for (let i = 0; i < str.length; i++) {
    if (!isWhitespace(str.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
function isWhitespaceText(node) {
  return node.type === 2 && isAllWhitespace(node.content) || node.type === 12 && isWhitespaceText(node.content);
}
function isCommentOrWhitespace(node) {
  return node.type === 3 || isWhitespaceText(node);
}

const defaultParserOptions = {
  parseMode: "base",
  ns: 0,
  delimiters: [`{{`, `}}`],
  getNamespace: () => 0,
  isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  isPreTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  isIgnoreNewlineTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: !!("development" !== "production"),
  prefixIdentifiers: false
};
let currentOptions = defaultParserOptions;
let currentRoot = null;
let currentInput = "";
let currentOpenTag = null;
let currentProp = null;
let currentAttrValue = "";
let currentAttrStartIndex = -1;
let currentAttrEndIndex = -1;
let inPre = 0;
let inVPre = false;
let currentVPreBoundary = null;
const stack = [];
const tokenizer = new Tokenizer(stack, {
  onerr: emitError,
  ontext(start, end) {
    onText(getSlice(start, end), start, end);
  },
  ontextentity(char, start, end) {
    onText(char, start, end);
  },
  oninterpolation(start, end) {
    if (inVPre) {
      return onText(getSlice(start, end), start, end);
    }
    let innerStart = start + tokenizer.delimiterOpen.length;
    let innerEnd = end - tokenizer.delimiterClose.length;
    while (isWhitespace(currentInput.charCodeAt(innerStart))) {
      innerStart++;
    }
    while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
      innerEnd--;
    }
    let exp = getSlice(innerStart, innerEnd);
    if (exp.includes("&")) {
      {
        exp = currentOptions.decodeEntities(exp, false);
      }
    }
    addNode({
      type: 5,
      content: createExp(exp, false, getLoc(innerStart, innerEnd)),
      loc: getLoc(start, end)
    });
  },
  onopentagname(start, end) {
    const name = getSlice(start, end);
    currentOpenTag = {
      type: 1,
      tag: name,
      ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
      tagType: 0,
      // will be refined on tag close
      props: [],
      children: [],
      loc: getLoc(start - 1, end),
      codegenNode: void 0
    };
  },
  onopentagend(end) {
    endOpenTag(end);
  },
  onclosetag(start, end) {
    const name = getSlice(start, end);
    if (!currentOptions.isVoidTag(name)) {
      let found = false;
      for (let i = 0; i < stack.length; i++) {
        const e = stack[i];
        if (e.tag.toLowerCase() === name.toLowerCase()) {
          found = true;
          if (i > 0) {
            emitError(24, stack[0].loc.start.offset);
          }
          for (let j = 0; j <= i; j++) {
            const el = stack.shift();
            onCloseTag(el, end, j < i);
          }
          break;
        }
      }
      if (!found) {
        emitError(23, backTrack(start, 60));
      }
    }
  },
  onselfclosingtag(end) {
    const name = currentOpenTag.tag;
    currentOpenTag.isSelfClosing = true;
    endOpenTag(end);
    if (stack[0] && stack[0].tag === name) {
      onCloseTag(stack.shift(), end);
    }
  },
  onattribname(start, end) {
    currentProp = {
      type: 6,
      name: getSlice(start, end),
      nameLoc: getLoc(start, end),
      value: void 0,
      loc: getLoc(start)
    };
  },
  ondirname(start, end) {
    const raw = getSlice(start, end);
    const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
    if (!inVPre && name === "") {
      emitError(26, start);
    }
    if (inVPre || name === "") {
      currentProp = {
        type: 6,
        name: raw,
        nameLoc: getLoc(start, end),
        value: void 0,
        loc: getLoc(start)
      };
    } else {
      currentProp = {
        type: 7,
        name,
        rawName: raw,
        exp: void 0,
        arg: void 0,
        modifiers: raw === "." ? [createSimpleExpression("prop")] : [],
        loc: getLoc(start)
      };
      if (name === "pre") {
        inVPre = tokenizer.inVPre = true;
        currentVPreBoundary = currentOpenTag;
        const props = currentOpenTag.props;
        for (let i = 0; i < props.length; i++) {
          if (props[i].type === 7) {
            props[i] = dirToAttr(props[i]);
          }
        }
      }
    }
  },
  ondirarg(start, end) {
    if (start === end) return;
    const arg = getSlice(start, end);
    if (inVPre && !isVPre(currentProp)) {
      currentProp.name += arg;
      setLocEnd(currentProp.nameLoc, end);
    } else {
      const isStatic = arg[0] !== `[`;
      currentProp.arg = createExp(
        isStatic ? arg : arg.slice(1, -1),
        isStatic,
        getLoc(start, end),
        isStatic ? 3 : 0
      );
    }
  },
  ondirmodifier(start, end) {
    const mod = getSlice(start, end);
    if (inVPre && !isVPre(currentProp)) {
      currentProp.name += "." + mod;
      setLocEnd(currentProp.nameLoc, end);
    } else if (currentProp.name === "slot") {
      const arg = currentProp.arg;
      if (arg) {
        arg.content += "." + mod;
        setLocEnd(arg.loc, end);
      }
    } else {
      const exp = createSimpleExpression(mod, true, getLoc(start, end));
      currentProp.modifiers.push(exp);
    }
  },
  onattribdata(start, end) {
    currentAttrValue += getSlice(start, end);
    if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
    currentAttrEndIndex = end;
  },
  onattribentity(char, start, end) {
    currentAttrValue += char;
    if (currentAttrStartIndex < 0) currentAttrStartIndex = start;
    currentAttrEndIndex = end;
  },
  onattribnameend(end) {
    const start = currentProp.loc.start.offset;
    const name = getSlice(start, end);
    if (currentProp.type === 7) {
      currentProp.rawName = name;
    }
    if (currentOpenTag.props.some(
      (p) => (p.type === 7 ? p.rawName : p.name) === name
    )) {
      emitError(2, start);
    }
  },
  onattribend(quote, end) {
    if (currentOpenTag && currentProp) {
      setLocEnd(currentProp.loc, end);
      if (quote !== 0) {
        if (currentAttrValue.includes("&")) {
          currentAttrValue = currentOptions.decodeEntities(
            currentAttrValue,
            true
          );
        }
        if (currentProp.type === 6) {
          if (currentProp.name === "class") {
            currentAttrValue = condense(currentAttrValue).trim();
          }
          if (quote === 1 && !currentAttrValue) {
            emitError(13, end);
          }
          currentProp.value = {
            type: 2,
            content: currentAttrValue,
            loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
          };
          if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
            tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
          }
        } else {
          let expParseMode = 0 /* Normal */;
          currentProp.exp = createExp(
            currentAttrValue,
            false,
            getLoc(currentAttrStartIndex, currentAttrEndIndex),
            0,
            expParseMode
          );
          if (currentProp.name === "for") {
            currentProp.forParseResult = parseForExpression(currentProp.exp);
          }
          let syncIndex = -1;
          if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.findIndex(
            (mod) => mod.content === "sync"
          )) > -1 && checkCompatEnabled(
            "COMPILER_V_BIND_SYNC",
            currentOptions,
            currentProp.loc,
            currentProp.arg.loc.source
          )) {
            currentProp.name = "model";
            currentProp.modifiers.splice(syncIndex, 1);
          }
        }
      }
      if (currentProp.type !== 7 || currentProp.name !== "pre") {
        currentOpenTag.props.push(currentProp);
      }
    }
    currentAttrValue = "";
    currentAttrStartIndex = currentAttrEndIndex = -1;
  },
  oncomment(start, end) {
    if (currentOptions.comments) {
      addNode({
        type: 3,
        content: getSlice(start, end),
        loc: getLoc(start - 4, end + 3)
      });
    }
  },
  onend() {
    const end = currentInput.length;
    if (( true) && tokenizer.state !== 1) {
      switch (tokenizer.state) {
        case 5:
        case 8:
          emitError(5, end);
          break;
        case 3:
        case 4:
          emitError(
            25,
            tokenizer.sectionStart
          );
          break;
        case 28:
          if (tokenizer.currentSequence === Sequences.CdataEnd) {
            emitError(6, end);
          } else {
            emitError(7, end);
          }
          break;
        case 6:
        case 7:
        case 9:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        // "
        case 20:
        // '
        case 21:
          emitError(9, end);
          break;
      }
    }
    for (let index = 0; index < stack.length; index++) {
      onCloseTag(stack[index], end - 1);
      emitError(24, stack[index].loc.start.offset);
    }
  },
  oncdata(start, end) {
    if (stack[0].ns !== 0) {
      onText(getSlice(start, end), start, end);
    } else {
      emitError(1, start - 9);
    }
  },
  onprocessinginstruction(start) {
    if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
      emitError(
        21,
        start - 1
      );
    }
  }
});
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch) return;
  const [, LHS, RHS] = inMatch;
  const createAliasExpression = (content, offset, asParam = false) => {
    const start = loc.start.offset + offset;
    const end = start + content.length;
    return createExp(
      content,
      false,
      getLoc(start, end),
      0,
      asParam ? 1 /* Params */ : 0 /* Normal */
    );
  };
  const result = {
    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: false
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(keyContent, keyOffset, true);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(
          indexContent,
          exp.indexOf(
            indexContent,
            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
          ),
          true
        );
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(valueContent, trimmedOffset, true);
  }
  return result;
}
function getSlice(start, end) {
  return currentInput.slice(start, end);
}
function endOpenTag(end) {
  if (tokenizer.inSFCRoot) {
    currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
  }
  addNode(currentOpenTag);
  const { tag, ns } = currentOpenTag;
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre++;
  }
  if (currentOptions.isVoidTag(tag)) {
    onCloseTag(currentOpenTag, end);
  } else {
    stack.unshift(currentOpenTag);
    if (ns === 1 || ns === 2) {
      tokenizer.inXML = true;
    }
  }
  currentOpenTag = null;
}
function onText(content, start, end) {
  {
    const tag = stack[0] && stack[0].tag;
    if (tag !== "script" && tag !== "style" && content.includes("&")) {
      content = currentOptions.decodeEntities(content, false);
    }
  }
  const parent = stack[0] || currentRoot;
  const lastNode = parent.children[parent.children.length - 1];
  if (lastNode && lastNode.type === 2) {
    lastNode.content += content;
    setLocEnd(lastNode.loc, end);
  } else {
    parent.children.push({
      type: 2,
      content,
      loc: getLoc(start, end)
    });
  }
}
function onCloseTag(el, end, isImplied = false) {
  if (isImplied) {
    setLocEnd(el.loc, backTrack(end, 60));
  } else {
    setLocEnd(el.loc, lookAhead(end, 62) + 1);
  }
  if (tokenizer.inSFCRoot) {
    if (el.children.length) {
      el.innerLoc.end = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, el.children[el.children.length - 1].loc.end);
    } else {
      el.innerLoc.end = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, el.innerLoc.start);
    }
    el.innerLoc.source = getSlice(
      el.innerLoc.start.offset,
      el.innerLoc.end.offset
    );
  }
  const { tag, ns, children } = el;
  if (!inVPre) {
    if (tag === "slot") {
      el.tagType = 2;
    } else if (isFragmentTemplate(el)) {
      el.tagType = 3;
    } else if (isComponent(el)) {
      el.tagType = 1;
    }
  }
  if (!tokenizer.inRCDATA) {
    el.children = condenseWhitespace(children);
  }
  if (ns === 0 && currentOptions.isIgnoreNewlineTag(tag)) {
    const first = children[0];
    if (first && first.type === 2) {
      first.content = first.content.replace(/^\r?\n/, "");
    }
  }
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre--;
  }
  if (currentVPreBoundary === el) {
    inVPre = tokenizer.inVPre = false;
    currentVPreBoundary = null;
  }
  if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
    tokenizer.inXML = false;
  }
  {
    const props = el.props;
    if ( true && isCompatEnabled(
      "COMPILER_V_IF_V_FOR_PRECEDENCE",
      currentOptions
    )) {
      let hasIf = false;
      let hasFor = false;
      for (let i = 0; i < props.length; i++) {
        const p = props[i];
        if (p.type === 7) {
          if (p.name === "if") {
            hasIf = true;
          } else if (p.name === "for") {
            hasFor = true;
          }
        }
        if (hasIf && hasFor) {
          warnDeprecation(
            "COMPILER_V_IF_V_FOR_PRECEDENCE",
            currentOptions,
            el.loc
          );
          break;
        }
      }
    }
    if (!tokenizer.inSFCRoot && isCompatEnabled(
      "COMPILER_NATIVE_TEMPLATE",
      currentOptions
    ) && el.tag === "template" && !isFragmentTemplate(el)) {
       true && warnDeprecation(
        "COMPILER_NATIVE_TEMPLATE",
        currentOptions,
        el.loc
      );
      const parent = stack[0] || currentRoot;
      const index = parent.children.indexOf(el);
      parent.children.splice(index, 1, ...el.children);
    }
    const inlineTemplateProp = props.find(
      (p) => p.type === 6 && p.name === "inline-template"
    );
    if (inlineTemplateProp && checkCompatEnabled(
      "COMPILER_INLINE_TEMPLATE",
      currentOptions,
      inlineTemplateProp.loc
    ) && el.children.length) {
      inlineTemplateProp.value = {
        type: 2,
        content: getSlice(
          el.children[0].loc.start.offset,
          el.children[el.children.length - 1].loc.end.offset
        ),
        loc: inlineTemplateProp.loc
      };
    }
  }
}
function lookAhead(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1) i++;
  return i;
}
function backTrack(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i >= 0) i--;
  return i;
}
const specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
function isFragmentTemplate({ tag, props }) {
  if (tag === "template") {
    for (let i = 0; i < props.length; i++) {
      if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
        return true;
      }
    }
  }
  return false;
}
function isComponent({ tag, props }) {
  if (currentOptions.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          currentOptions,
          p.loc
        )) {
          return true;
        }
      }
    } else if (// :is on plain element - only treat as component in compat mode
    p.name === "bind" && isStaticArgOf(p.arg, "is") && checkCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      currentOptions,
      p.loc
    )) {
      return true;
    }
  }
  return false;
}
function isUpperCase(c) {
  return c > 64 && c < 91;
}
const windowsNewlineRE = /\r\n/g;
function condenseWhitespace(nodes) {
  const shouldCondense = currentOptions.whitespace !== "preserve";
  let removedWhitespace = false;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === 2) {
      if (!inPre) {
        if (isAllWhitespace(node.content)) {
          const prev = nodes[i - 1] && nodes[i - 1].type;
          const next = nodes[i + 1] && nodes[i + 1].type;
          if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = condense(node.content);
        }
      } else {
        node.content = node.content.replace(windowsNewlineRE, "\n");
      }
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function hasNewlineChar(str) {
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c === 10 || c === 13) {
      return true;
    }
  }
  return false;
}
function condense(str) {
  let ret = "";
  let prevCharIsWhitespace = false;
  for (let i = 0; i < str.length; i++) {
    if (isWhitespace(str.charCodeAt(i))) {
      if (!prevCharIsWhitespace) {
        ret += " ";
        prevCharIsWhitespace = true;
      }
    } else {
      ret += str[i];
      prevCharIsWhitespace = false;
    }
  }
  return ret;
}
function addNode(node) {
  (stack[0] || currentRoot).children.push(node);
}
function getLoc(start, end) {
  return {
    start: tokenizer.getPos(start),
    // @ts-expect-error allow late attachment
    end: end == null ? end : tokenizer.getPos(end),
    // @ts-expect-error allow late attachment
    source: end == null ? end : getSlice(start, end)
  };
}
function cloneLoc(loc) {
  return getLoc(loc.start.offset, loc.end.offset);
}
function setLocEnd(loc, end) {
  loc.end = tokenizer.getPos(end);
  loc.source = getSlice(loc.start.offset, end);
}
function dirToAttr(dir) {
  const attr = {
    type: 6,
    name: dir.rawName,
    nameLoc: getLoc(
      dir.loc.start.offset,
      dir.loc.start.offset + dir.rawName.length
    ),
    value: void 0,
    loc: dir.loc
  };
  if (dir.exp) {
    const loc = dir.exp.loc;
    if (loc.end.offset < dir.loc.end.offset) {
      loc.start.offset--;
      loc.start.column--;
      loc.end.offset++;
      loc.end.column++;
    }
    attr.value = {
      type: 2,
      content: dir.exp.content,
      loc
    };
  }
  return attr;
}
function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0 /* Normal */) {
  const exp = createSimpleExpression(content, isStatic, loc, constType);
  return exp;
}
function emitError(code, index, message) {
  currentOptions.onError(
    createCompilerError(code, getLoc(index, index), void 0, message)
  );
}
function reset() {
  tokenizer.reset();
  currentOpenTag = null;
  currentProp = null;
  currentAttrValue = "";
  currentAttrStartIndex = -1;
  currentAttrEndIndex = -1;
  stack.length = 0;
}
function baseParse(input, options) {
  reset();
  currentInput = input;
  currentOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defaultParserOptions);
  if (options) {
    let key;
    for (key in options) {
      if (options[key] != null) {
        currentOptions[key] = options[key];
      }
    }
  }
  if (true) {
    if (!currentOptions.decodeEntities) {
      throw new Error(
        `[@vue/compiler-core] decodeEntities option is required in browser builds.`
      );
    }
  }
  tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
  tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
  const delimiters = options && options.delimiters;
  if (delimiters) {
    tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
    tokenizer.delimiterClose = toCharCodes(delimiters[1]);
  }
  const root = currentRoot = createRoot([], input);
  tokenizer.parse(currentInput);
  root.loc = getLoc(0, input.length);
  root.children = condenseWhitespace(root.children);
  currentRoot = null;
  return root;
}

function cacheStatic(root, context) {
  walk(
    root,
    void 0,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    !!getSingleElementRoot(root)
  );
}
function getSingleElementRoot(root) {
  const children = root.children.filter((x) => x.type !== 3);
  return children.length === 1 && children[0].type === 1 && !isSlotOutlet(children[0]) ? children[0] : null;
}
function walk(node, parent, context, doNotHoistNode = false, inFor = false) {
  const { children } = node;
  const toCache = [];
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1;
          toCache.push(child);
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = codegenNode.patchFlag;
          if ((flag === void 0 || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    } else if (child.type === 12) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType >= 2) {
        if (child.codegenNode.type === 14 && child.codegenNode.arguments.length > 0) {
          child.codegenNode.arguments.push(
            -1 + ( true ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[-1]} */` : 0)
          );
        }
        toCache.push(child);
        continue;
      }
    }
    if (child.type === 1) {
      const isComponent = child.tagType === 1;
      if (isComponent) {
        context.scopes.vSlot++;
      }
      walk(child, node, context, false, inFor);
      if (isComponent) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, node, context, child.children.length === 1, true);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(
          child.branches[i2],
          node,
          context,
          child.branches[i2].children.length === 1,
          inFor
        );
      }
    }
  }
  let cachedAsArray = false;
  if (toCache.length === children.length && node.type === 1) {
    if (node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node.codegenNode.children)) {
      node.codegenNode.children = getCacheExpression(
        createArrayExpression(node.codegenNode.children)
      );
      cachedAsArray = true;
    } else if (node.tagType === 1 && node.codegenNode && node.codegenNode.type === 13 && node.codegenNode.children && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node.codegenNode.children) && node.codegenNode.children.type === 15) {
      const slot = getSlotNode(node.codegenNode, "default");
      if (slot) {
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    } else if (node.tagType === 3 && parent && parent.type === 1 && parent.tagType === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(parent.codegenNode.children) && parent.codegenNode.children.type === 15) {
      const slotName = findDir(node, "slot", true);
      const slot = slotName && slotName.arg && getSlotNode(parent.codegenNode, slotName.arg);
      if (slot) {
        slot.returns = getCacheExpression(
          createArrayExpression(slot.returns)
        );
        cachedAsArray = true;
      }
    }
  }
  if (!cachedAsArray) {
    for (const child of toCache) {
      child.codegenNode = context.cache(child.codegenNode);
    }
  }
  function getCacheExpression(value) {
    const exp = context.cache(value);
    exp.needArraySpread = true;
    return exp;
  }
  function getSlotNode(node2, name) {
    if (node2.children && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node2.children) && node2.children.type === 15) {
      const slot = node2.children.properties.find(
        (p) => p.key === name || p.key.content === name
      );
      return slot && slot.value;
    }
  }
  if (toCache.length && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject" && node.tag !== "math") {
        return 0;
      }
      if (codegenNode.patchFlag === void 0) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    case 20:
      return 2;
    default:
      if (true) ;
      return 0;
  }
}
const allowHoistedHelperSet = /* @__PURE__ */ new Set([
  NORMALIZE_CLASS,
  NORMALIZE_STYLE,
  NORMALIZE_PROPS,
  GUARD_REACTIVE_PROPS
]);
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}

function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic = false,
  hmr = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP,
  isCustomElement = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    // options
    filename,
    selfName: nameMatch && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic,
    hmr,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    cached: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    grandParent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      if (true) {
        if (!context.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if ( true && !context.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if ( true && removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP,
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(exp)) exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        2
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false, inVOnce = false) {
      const cacheExp = createCacheExpression(
        context.cached.length,
        exp,
        isVNode,
        inVOnce
      );
      context.cached.push(cacheExp);
      return cacheExp;
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    cacheStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  root.transformed = true;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const singleElementRootChild = getSingleElementRoot(root);
    if (singleElementRootChild && singleElementRootChild.codegenNode) {
      const codegenNode = singleElementRootChild.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = children[0];
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    if ( true && children.filter((c) => c.type !== 3).length === 1) {
      patchFlag |= 2048;
    }
    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      void 0,
      root.children,
      patchFlag,
      void 0,
      void 0,
      true,
      void 0,
      false
    );
  } else ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) continue;
    context.grandParent = context.parent;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    // for container types, further traverse downwards
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit) exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}

const PURE_ANNOTATION = `/*@__PURE__*/`;
const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, newlineIndex = -2 /* None */, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push("\n" + `  `.repeat(n), 0 /* Start */);
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated) options.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(
        `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
        -1 /* End */
      );
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`
`, 0 /* Start */);
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    {
      push(`const _Vue = ${VueBinding}
`, -1 /* End */);
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(`const { ${staticHelpers} } = _Vue
`, -1 /* End */);
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(
    type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  );
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
    );
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(`const _hoisted_${i + 1} = `);
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function isText(n) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 ||  true && nodes.some((n) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(n) || !isText(n));
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
      push(node, -3 /* Unknown */);
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
    context.push(node, -3 /* Unknown */);
    return;
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
       true && assert(
        node.codegenNode != null,
        `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`
      );
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    // SSR only types
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    /* v8 ignore start */
    case 10:
      break;
    default:
      if (true) {
        assert(false, `unhandled codegen node type: ${node.type}`);
        const exhaustiveCheck = node;
        return exhaustiveCheck;
      }
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), -3 /* Unknown */, node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(
    isStatic ? JSON.stringify(content) : content,
    -3 /* Unknown */,
    node
  );
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure) push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) {
      context.push(child, -3 /* Unknown */);
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, -2 /* None */, node);
  } else {
    push(`[${node.content}]`, -3 /* Unknown */, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(
    `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
    -3 /* Unknown */,
    node
  );
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent
  } = node;
  let patchFlagString;
  if (patchFlag) {
    if (true) {
      if (patchFlag < 0) {
        patchFlagString = patchFlag + ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[patchFlag]} */`;
      } else {
        const flagNames = Object.keys(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[n]).join(`, `);
        patchFlagString = patchFlag + ` /* ${flagNames} */`;
      }
    } else // removed by dead control flow
{}
  }
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent) : getVNodeHelper(context.inSSR, isComponent);
  push(helper(callHelper) + `(`, -2 /* None */, node);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlagString, dynamicProps]),
    context
  );
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null) break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, -2 /* None */, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, -2 /* None */, node);
    return;
  }
  const multilines = properties.length > 1 ||  true && properties.some((p) => p.value.type !== 4);
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, -2 /* None */, node);
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(
    true
    /* without newline */
  );
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  const { needPauseTracking, needArraySpread } = node;
  if (needArraySpread) {
    push(`[...(`);
  }
  push(`_cache[${node.index}] || (`);
  if (needPauseTracking) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1`);
    if (node.inVOnce) push(`, true`);
    push(`),`);
    newline();
    push(`(`);
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (needPauseTracking) {
    push(`).cacheIndex = ${node.index},`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
  if (needArraySpread) {
    push(`)]`);
  }
}

const prohibitedKeywordRE = new RegExp(
  "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
);
const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
  const exp = node.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(
      asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`
    );
  } catch (e) {
    let message = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context.onError(
      createCompilerError(
        46,
        node.loc,
        void 0,
        message
      )
    );
  }
}

const transformExpression = (node, context) => {
  if (node.type === 5) {
    node.content = processExpression(
      node.content,
      context
    );
  } else if (node.type === 1) {
    const memo = findDir(node, "memo");
    for (let i = 0; i < node.props.length; i++) {
      const dir = node.props[i];
      if (dir.type === 7 && dir.name !== "for") {
        const exp = dir.exp;
        const arg = dir.arg;
        if (exp && exp.type === 4 && !(dir.name === "on" && arg) && // key has been processed in transformFor(vMemo + vFor)
        !(memo && arg && arg.type === 4 && arg.content === "key")) {
          dir.exp = processExpression(
            exp,
            context,
            // slot args must be processed as function params
            dir.name === "slot"
          );
        }
        if (arg && arg.type === 4 && !arg.isStatic) {
          dir.arg = processExpression(arg, context);
        }
      }
    }
  }
};
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    if (true) {
      validateBrowserExpression(node, context, asParams, asRawStatements);
    }
    return node;
  }
}
function stringifyExpression(exp) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(exp)) {
    return exp;
  } else if (exp.type === 4) {
    return exp.content;
  } else {
    return exp.children.map(stringifyExpression).join("");
  }
}

const transformIf = createStructuralDirectiveTransform(
  /^(?:if|else|else-if)$/,
  (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
      const siblings = context.parent.children;
      let i = siblings.indexOf(ifNode);
      let key = 0;
      while (i-- >= 0) {
        const sibling = siblings[i];
        if (sibling && sibling.type === 9) {
          key += sibling.branches.length;
        }
      }
      return () => {
        if (isRoot) {
          ifNode.codegenNode = createCodegenNodeForBranch(
            branch,
            key,
            context
          );
        } else {
          const parentCondition = getParentCondition(ifNode.codegenNode);
          parentCondition.alternate = createCodegenNodeForBranch(
            branch,
            key + ifNode.branches.length - 1,
            context
          );
        }
      };
    });
  }
);
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if ( true && dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: cloneLoc(node.loc),
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && isCommentOrWhitespace(sibling)) {
        context.removeNode(sibling);
        if ( true && sibling.type === 3) {
          comments.unshift(sibling);
        }
        continue;
      }
      if (sibling && sibling.type === 9) {
        if ((dir.name === "else-if" || dir.name === "else") && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        if ( true && comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(context.parent && context.parent.type === 1 && (context.parent.tag === "transition" || context.parent.tag === "Transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        if (true) {
          const key = branch.userKey;
          if (key) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key)) {
                context.onError(
                  createCompilerError(
                    29,
                    branch.userKey.loc
                  )
                );
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit) onExit();
        context.currentNode = null;
      } else {
        context.onError(
          createCompilerError(30, node.loc)
        );
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context.helper(CREATE_COMMENT), [
         true ? '"v-if"' : 0,
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      if ( true && !branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
      }
      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag,
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}

const transformFor = createStructuralDirectiveTransform(
  "for",
  (node, dir, context) => {
    const { helper, removeHelper } = context;
    return processFor(node, dir, context, (forNode) => {
      const renderExp = createCallExpression(helper(RENDER_LIST), [
        forNode.source
      ]);
      const isTemplate = isTemplateNode(node);
      const memo = findDir(node, "memo");
      const keyProp = findProp(node, `key`, false, true);
      keyProp && keyProp.type === 7;
      let keyExp = keyProp && (keyProp.type === 6 ? keyProp.value ? createSimpleExpression(keyProp.value.content, true) : void 0 : keyProp.exp);
      const keyProperty = keyProp && keyExp ? createObjectProperty(`key`, keyExp) : null;
      const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
      const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
      forNode.codegenNode = createVNodeCall(
        context,
        helper(FRAGMENT),
        void 0,
        renderExp,
        fragmentFlag,
        void 0,
        void 0,
        true,
        !isStableFragment,
        false,
        node.loc
      );
      return () => {
        let childBlock;
        const { children } = forNode;
        if (( true) && isTemplate) {
          node.children.some((c) => {
            if (c.type === 1) {
              const key = findProp(c, "key");
              if (key) {
                context.onError(
                  createCompilerError(
                    33,
                    key.loc
                  )
                );
                return true;
              }
            }
          });
        }
        const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
        const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
        if (slotOutlet) {
          childBlock = slotOutlet.codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
        } else if (needFragmentWrapper) {
          childBlock = createVNodeCall(
            context,
            helper(FRAGMENT),
            keyProperty ? createObjectExpression([keyProperty]) : void 0,
            node.children,
            64,
            void 0,
            void 0,
            true,
            void 0,
            false
          );
        } else {
          childBlock = children[0].codegenNode;
          if (isTemplate && keyProperty) {
            injectProp(childBlock, keyProperty, context);
          }
          if (childBlock.isBlock !== !isStableFragment) {
            if (childBlock.isBlock) {
              removeHelper(OPEN_BLOCK);
              removeHelper(
                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
              );
            } else {
              removeHelper(
                getVNodeHelper(context.inSSR, childBlock.isComponent)
              );
            }
          }
          childBlock.isBlock = !isStableFragment;
          if (childBlock.isBlock) {
            helper(OPEN_BLOCK);
            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
          } else {
            helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
          }
        }
        if (memo) {
          const loop = createFunctionExpression(
            createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ])
          );
          loop.body = createBlockStatement([
            createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
            createCompoundExpression([
              `if (_cached`,
              ...keyExp ? [` && _cached.key === `, keyExp] : [],
              ` && ${context.helperString(
                IS_MEMO_SAME
              )}(_cached, _memo)) return _cached`
            ]),
            createCompoundExpression([`const _item = `, childBlock]),
            createSimpleExpression(`_item.memo = _memo`),
            createSimpleExpression(`return _item`)
          ]);
          renderExp.arguments.push(
            loop,
            createSimpleExpression(`_cache`),
            createSimpleExpression(String(context.cached.length))
          );
          context.cached.push(null);
        } else {
          renderExp.arguments.push(
            createFunctionExpression(
              createForLoopParams(forNode.parseResult),
              childBlock,
              true
            )
          );
        }
      };
    });
  }
);
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = dir.forParseResult;
  if (!parseResult) {
    context.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  finalizeForParseResult(parseResult, context);
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit) onExit();
  };
}
function finalizeForParseResult(result, context) {
  if (result.finalized) return;
  if (true) {
    validateBrowserExpression(result.source, context);
    if (result.key) {
      validateBrowserExpression(
        result.key,
        context,
        true
      );
    }
    if (result.index) {
      validateBrowserExpression(
        result.index,
        context,
        true
      );
    }
    if (result.value) {
      validateBrowserExpression(
        result.value,
        context,
        true
      );
    }
  }
  result.finalized = true;
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i]) break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}

const defaultFallback = createSimpleExpression(`undefined`, false);
const trackSlotScopes = (node, context) => {
  if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
    const vSlot = findDir(node, "slot");
    if (vSlot) {
      vSlot.exp;
      context.scopes.vSlot++;
      return () => {
        context.scopes.vSlot--;
      };
    }
  }
};
const trackVForSlotScopes = (node, context) => {
  let vFor;
  if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
    const result = vFor.forParseResult;
    if (result) {
      finalizeForParseResult(result, context);
      const { value, key, index } = result;
      const { addIdentifiers, removeIdentifiers } = context;
      value && addIdentifiers(value);
      key && addIdentifiers(key);
      index && addIdentifiers(index);
      return () => {
        value && removeIdentifiers(value);
        key && removeIdentifiers(key);
        index && removeIdentifiers(index);
      };
    }
  }
};
const buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
  props,
  children,
  false,
  true,
  children.length ? children[0].loc : loc
);
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, void 0, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(
        createCompilerError(37, slotDir.loc)
      );
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const vFor = findDir(slotElement, "for");
    const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
    let vIf;
    let vElse;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
          defaultFallback
        )
      );
    } else if (vElse = findDir(
      slotElement,
      /^else(?:-if)?$/,
      true
      /* allowEmpty */
    )) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (!isCommentOrWhitespace(prev)) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, /^(?:else-)?if$/)) {
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(
          vElse.exp,
          buildDynamicSlot(
            slotName,
            slotFunction,
            conditionalBranchIndex++
          ),
          defaultFallback
        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(
          createCompilerError(30, vElse.loc)
        );
      }
    } else if (vFor) {
      hasDynamicSlots = true;
      const parseResult = vFor.forParseResult;
      if (parseResult) {
        finalizeForParseResult(parseResult, context);
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
            )
          ])
        );
      } else {
        context.onError(
          createCompilerError(
            32,
            vFor.loc
          )
        );
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(
            createCompilerError(
              38,
              dirLoc
            )
          );
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, void 0, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    !implicitDefaultChildren.every(isWhitespaceText)) {
      if (hasNamedDefaultSlot) {
        context.onError(
          createCompilerError(
            39,
            implicitDefaultChildren[0].loc
          )
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + ( true ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.slotFlagsText[slotFlag]} */` : 0),
          false
        )
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn, index) {
  const props = [
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ];
  if (index != null) {
    props.push(
      createObjectProperty(`key`, createSimpleExpression(String(index), true))
    );
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches)) return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children)) return true;
        break;
    }
  }
  return false;
}

const directiveImportMap = /* @__PURE__ */ new WeakMap();
const transformElement = (node, context) => {
  return function postTransformElement() {
    node = context.currentNode;
    if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
      return;
    }
    const { tag, props } = node;
    const isComponent = node.tagType === 1;
    let vnodeTag = isComponent ? resolveComponentType(node, context) : `"${tag}"`;
    const isDynamicComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    let vnodeProps;
    let vnodeChildren;
    let patchFlag = 0;
    let vnodeDynamicProps;
    let dynamicPropNames;
    let vnodeDirectives;
    let shouldUseBlock = (
      // dynamic component may resolve to plain elements
      isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent && // <svg> and <foreignObject> must be forced into blocks so that block
      // updates inside get proper isSVG flag at runtime. (#639, #643)
      // This is technically web-specific, but splitting the logic out of core
      // leads to too much unnecessary complexity.
      (tag === "svg" || tag === "foreignObject" || tag === "math")
    );
    if (props.length > 0) {
      const propsBuildResult = buildProps(
        node,
        context,
        void 0,
        isComponent,
        isDynamicComponent
      );
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      const directives = propsBuildResult.directives;
      vnodeDirectives = directives && directives.length ? createArrayExpression(
        directives.map((dir) => buildDirectiveArgs(dir, context))
      ) : void 0;
      if (propsBuildResult.shouldUseBlock) {
        shouldUseBlock = true;
      }
    }
    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        shouldUseBlock = true;
        patchFlag |= 1024;
        if ( true && node.children.length > 1) {
          context.onError(
            createCompilerError(47, {
              start: node.children[0].loc.start,
              end: node.children[node.children.length - 1].loc.end,
              source: ""
            })
          );
        }
      }
      const shouldBuildAsSlots = isComponent && // Teleport is not a real component and has dedicated runtime handling
      vnodeTag !== TELEPORT && // explained above.
      vnodeTag !== KEEP_ALIVE;
      if (shouldBuildAsSlots) {
        const { slots, hasDynamicSlots } = buildSlots(node, context);
        vnodeChildren = slots;
        if (hasDynamicSlots) {
          patchFlag |= 1024;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        const child = node.children[0];
        const type = child.type;
        const hasDynamicTextChild = type === 5 || type === 8;
        if (hasDynamicTextChild && getConstantType(child, context) === 0) {
          patchFlag |= 1;
        }
        if (hasDynamicTextChild || type === 2) {
          vnodeChildren = child;
        } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    }
    if (dynamicPropNames && dynamicPropNames.length) {
      vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
    }
    node.codegenNode = createVNodeCall(
      context,
      vnodeTag,
      vnodeProps,
      vnodeChildren,
      patchFlag === 0 ? void 0 : patchFlag,
      vnodeDynamicProps,
      vnodeDirectives,
      !!shouldUseBlock,
      false,
      isComponent,
      node.loc
    );
  };
};
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(
    node,
    "is",
    false,
    true
    /* allow empty */
  );
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      context
    )) {
      let exp;
      if (isProp.type === 6) {
        exp = isProp.value && createSimpleExpression(isProp.value.content, true);
      } else {
        exp = isProp.exp;
        if (!exp) {
          exp = createSimpleExpression(`is`, false, isProp.arg.loc);
        }
      }
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr) context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      );
      properties = [];
    }
    if (arg) mergeArgs.push(arg);
  };
  const pushRefVForMarker = () => {
    if (context.scopes.vFor > 0) {
      properties.push(
        createObjectProperty(
          createSimpleExpression("ref_for", true),
          createSimpleExpression("true")
        )
      );
    }
  };
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name);
      if (isEventHandler && (!isComponent || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== "onclick" && // omit v-model handlers
      name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
        hasVnodeHook = true;
      }
      if (isEventHandler && value.type === 14) {
        value = value.arguments[0];
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, nameLoc, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        pushRefVForMarker();
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(name, true, nameLoc),
          createSimpleExpression(
            value ? value.content : "",
            isStatic,
            value ? value.loc : loc
          )
        )
      );
    } else {
      const { name, arg, exp, loc, modifiers } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent) {
          context.onError(
            createCompilerError(40, loc)
          );
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref")) {
        pushRefVForMarker();
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            {
              pushMergeArg();
              if (true) {
                const hasOverridableKeys = mergeArgs.some((arg2) => {
                  if (arg2.type === 15) {
                    return arg2.properties.some(({ key }) => {
                      if (key.type !== 4 || !key.isStatic) {
                        return true;
                      }
                      return key.content !== "class" && key.content !== "style" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(key.content);
                    });
                  } else {
                    return true;
                  }
                });
                if (hasOverridableKeys) {
                  checkCompatEnabled(
                    "COMPILER_V_BIND_OBJECT_ORDER",
                    context,
                    loc
                  );
                }
              }
              if (isCompatEnabled(
                "COMPILER_V_BIND_OBJECT_ORDER",
                context
              )) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            pushRefVForMarker();
            pushMergeArg();
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(
            createCompilerError(
              isVBind ? 34 : 35,
              loc
            )
          );
        }
        continue;
      }
      if (isVBind && modifiers.some((mod) => mod.content === "prop")) {
        patchFlag |= 32;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isBuiltInDirective)(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (styleProp && // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp) dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(
          (modifier) => createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1) propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}

const transformSlotOutlet = (node, context) => {
  if (isSlotOutlet(node)) {
    const { children, loc } = node;
    const { slotName, slotProps } = processSlotOutlet(node, context);
    const slotArgs = [
      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
      slotName,
      "{}",
      "undefined",
      "true"
    ];
    let expectedLen = 2;
    if (slotProps) {
      slotArgs[2] = slotProps;
      expectedLen = 3;
    }
    if (children.length) {
      slotArgs[3] = createFunctionExpression([], children, false, false, loc);
      expectedLen = 4;
    }
    if (context.scopeId && !context.slotted) {
      expectedLen = 5;
    }
    slotArgs.splice(expectedLen);
    node.codegenNode = createCallExpression(
      context.helper(RENDER_SLOT),
      slotArgs,
      loc
    );
  }
};
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp) {
          slotName = p.exp;
        } else if (p.arg && p.arg.type === 4) {
          const name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(p.arg.content);
          slotName = p.exp = createSimpleExpression(name, false, p.arg.loc);
        }
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(
      node,
      context,
      nonNameProps,
      false,
      false
    );
    slotProps = props;
    if (directives.length) {
      context.onError(
        createCompilerError(
          36,
          directives[0].loc
        )
      );
    }
  }
  return {
    slotName,
    slotProps
  };
}

const transformOn = (dir, node, context, augmentor) => {
  const { loc, modifiers, arg } = dir;
  if (!dir.exp && !modifiers.length) {
    context.onError(createCompilerError(35, loc));
  }
  let eventName;
  if (arg.type === 4) {
    if (arg.isStatic) {
      let rawName = arg.content;
      if ( true && rawName.startsWith("vnode")) {
        context.onError(createCompilerError(52, arg.loc));
      }
      if (rawName.startsWith("vue:")) {
        rawName = `vnode-${rawName.slice(4)}`;
      }
      const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(rawName))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${rawName}`
      );
      eventName = createSimpleExpression(eventString, true, arg.loc);
    } else {
      eventName = createCompoundExpression([
        `${context.helperString(TO_HANDLER_KEY)}(`,
        arg,
        `)`
      ]);
    }
  } else {
    eventName = arg;
    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
    eventName.children.push(`)`);
  }
  let exp = dir.exp;
  if (exp && !exp.content.trim()) {
    exp = void 0;
  }
  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
  if (exp) {
    const isMemberExp = isMemberExpression(exp);
    const isInlineStatement = !(isMemberExp || isFnExpression(exp));
    const hasMultipleStatements = exp.content.includes(`;`);
    if (true) {
      validateBrowserExpression(
        exp,
        context,
        false,
        hasMultipleStatements
      );
    }
    if (isInlineStatement || shouldCache && isMemberExp) {
      exp = createCompoundExpression([
        `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
        exp,
        hasMultipleStatements ? `}` : `)`
      ]);
    }
  }
  let ret = {
    props: [
      createObjectProperty(
        eventName,
        exp || createSimpleExpression(`() => {}`, false, loc)
      )
    ]
  };
  if (augmentor) {
    ret = augmentor(ret);
  }
  if (shouldCache) {
    ret.props[0].value = context.cache(ret.props[0].value);
  }
  ret.props.forEach((p) => p.key.isHandlerKey = true);
  return ret;
};

const transformBind = (dir, _node, context) => {
  const { modifiers, loc } = dir;
  const arg = dir.arg;
  let { exp } = dir;
  if (exp && exp.type === 4 && !exp.content.trim()) {
    {
      exp = void 0;
    }
  }
  if (arg.type !== 4) {
    arg.children.unshift(`(`);
    arg.children.push(`) || ""`);
  } else if (!arg.isStatic) {
    arg.content = arg.content ? `${arg.content} || ""` : `""`;
  }
  if (modifiers.some((mod) => mod.content === "camel")) {
    if (arg.type === 4) {
      if (arg.isStatic) {
        arg.content = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content);
      } else {
        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
      }
    } else {
      arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
      arg.children.push(`)`);
    }
  }
  if (!context.inSSR) {
    if (modifiers.some((mod) => mod.content === "prop")) {
      injectPrefix(arg, ".");
    }
    if (modifiers.some((mod) => mod.content === "attr")) {
      injectPrefix(arg, "^");
    }
  }
  return {
    props: [createObjectProperty(arg, exp)]
  };
};
const injectPrefix = (arg, prefix) => {
  if (arg.type === 4) {
    if (arg.isStatic) {
      arg.content = prefix + arg.content;
    } else {
      arg.content = `\`${prefix}\${${arg.content}}\``;
    }
  } else {
    arg.children.unshift(`'${prefix}' + (`);
    arg.children.push(`)`);
  }
};

const transformText = (node, context) => {
  if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
    return () => {
      const children = node.children;
      let currentContainer = void 0;
      let hasText = false;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child)) {
          hasText = true;
          for (let j = i + 1; j < children.length; j++) {
            const next = children[j];
            if (isText$1(next)) {
              if (!currentContainer) {
                currentContainer = children[i] = createCompoundExpression(
                  [child],
                  child.loc
                );
              }
              currentContainer.children.push(` + `, next);
              children.splice(j, 1);
              j--;
            } else {
              currentContainer = void 0;
              break;
            }
          }
        }
      }
      if (!hasText || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !node.props.find(
        (p) => p.type === 7 && !context.directiveTransforms[p.name]
      ) && // in compat mode, <template> tags with no special directives
      // will be rendered as a fragment so its children must be
      // converted into vnodes.
      !(node.tag === "template"))) {
        return;
      }
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isText$1(child) || child.type === 8) {
          const callArgs = [];
          if (child.type !== 2 || child.content !== " ") {
            callArgs.push(child);
          }
          if (!context.ssr && getConstantType(child, context) === 0) {
            callArgs.push(
              1 + ( true ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[1]} */` : 0)
            );
          }
          children[i] = {
            type: 12,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(
              context.helper(CREATE_TEXT),
              callArgs
            )
          };
        }
      }
    };
  }
};

const seen$1 = /* @__PURE__ */ new WeakSet();
const transformOnce = (node, context) => {
  if (node.type === 1 && findDir(node, "once", true)) {
    if (seen$1.has(node) || context.inVOnce || context.inSSR) {
      return;
    }
    seen$1.add(node);
    context.inVOnce = true;
    context.helper(SET_BLOCK_TRACKING);
    return () => {
      context.inVOnce = false;
      const cur = context.currentNode;
      if (cur.codegenNode) {
        cur.codegenNode = context.cache(
          cur.codegenNode,
          true,
          true
        );
      }
    };
  }
};

const transformModel = (dir, node, context) => {
  const { exp, arg } = dir;
  if (!exp) {
    context.onError(
      createCompilerError(41, dir.loc)
    );
    return createTransformProps();
  }
  const rawExp = exp.loc.source.trim();
  const expString = exp.type === 4 ? exp.content : rawExp;
  const bindingType = context.bindingMetadata[rawExp];
  if (bindingType === "props" || bindingType === "props-aliased") {
    context.onError(createCompilerError(44, exp.loc));
    return createTransformProps();
  }
  if (bindingType === "literal-const" || bindingType === "setup-const") {
    context.onError(createCompilerError(45, exp.loc));
    return createTransformProps();
  }
  if (!expString.trim() || !isMemberExpression(exp) && true) {
    context.onError(
      createCompilerError(42, exp.loc)
    );
    return createTransformProps();
  }
  const propName = arg ? arg : createSimpleExpression("modelValue", true);
  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
  let assignmentExp;
  const eventArg = context.isTS ? `($event: any)` : `$event`;
  {
    assignmentExp = createCompoundExpression([
      `${eventArg} => ((`,
      exp,
      `) = $event)`
    ]);
  }
  const props = [
    // modelValue: foo
    createObjectProperty(propName, dir.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    createObjectProperty(eventName, assignmentExp)
  ];
  if (dir.modifiers.length && node.tagType === 1) {
    const modifiers = dir.modifiers.map((m) => m.content).map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
    props.push(
      createObjectProperty(
        modifiersKey,
        createSimpleExpression(
          `{ ${modifiers} }`,
          false,
          dir.loc,
          2
        )
      )
    );
  }
  return createTransformProps(props);
};
function createTransformProps(props = []) {
  return { props };
}

const validDivisionCharRE = /[\w).+\-_$\]]/;
const transformFilter = (node, context) => {
  if (!isCompatEnabled("COMPILER_FILTERS", context)) {
    return;
  }
  if (node.type === 5) {
    rewriteFilter(node.content, context);
  } else if (node.type === 1) {
    node.props.forEach((prop) => {
      if (prop.type === 7 && prop.name !== "for" && prop.exp) {
        rewriteFilter(prop.exp, context);
      }
    });
  }
};
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object") continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92) inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92) inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92) inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92) inRegex = false;
    } else if (c === 124 && // pipe
    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        // "
        case 39:
          inSingle = true;
          break;
        // '
        case 96:
          inTemplateString = true;
          break;
        // `
        case 40:
          paren++;
          break;
        // (
        case 41:
          paren--;
          break;
        // )
        case 91:
          square++;
          break;
        // [
        case 93:
          square--;
          break;
        // ]
        case 123:
          curly++;
          break;
        // {
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ") break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
     true && warnDeprecation(
      "COMPILER_FILTERS",
      context,
      node.loc
    );
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
    node.ast = void 0;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}

const seen = /* @__PURE__ */ new WeakSet();
const transformMemo = (node, context) => {
  if (node.type === 1) {
    const dir = findDir(node, "memo");
    if (!dir || seen.has(node) || context.inSSR) {
      return;
    }
    seen.add(node);
    return () => {
      const codegenNode = node.codegenNode || context.currentNode.codegenNode;
      if (codegenNode && codegenNode.type === 13) {
        if (node.tagType !== 1) {
          convertToBlock(codegenNode, context);
        }
        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
          dir.exp,
          createFunctionExpression(void 0, codegenNode),
          `_cache`,
          String(context.cached.length)
        ]);
        context.cached.push(null);
      }
    };
  }
};

const transformVBindShorthand = (node, context) => {
  if (node.type === 1) {
    for (const prop of node.props) {
      if (prop.type === 7 && prop.name === "bind" && (!prop.exp || // #13930 :foo in in-DOM templates will be parsed into :foo="" by browser
      prop.exp.type === 4 && !prop.exp.content.trim()) && prop.arg) {
        const arg = prop.arg;
        if (arg.type !== 4 || !arg.isStatic) {
          context.onError(
            createCompilerError(
              53,
              arg.loc
            )
          );
          prop.exp = createSimpleExpression("", true, arg.loc);
        } else {
          const propName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content);
          if (validFirstIdentCharRE.test(propName[0]) || // allow hyphen first char for https://github.com/vuejs/language-tools/pull/3424
          propName[0] === "-") {
            prop.exp = createSimpleExpression(propName, false, arg.loc);
          }
        }
      }
    }
  }
};

function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformVBindShorthand,
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter] ,
      ... true ? [transformExpression] : 0,
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn,
      bind: transformBind,
      model: transformModel
    }
  ];
}
function baseCompile(source, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(48));
    } else if (isModuleMode) {
      onError(createCompilerError(49));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(50));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(51));
  }
  const resolvedOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
    prefixIdentifiers
  });
  const ast = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(source) ? baseParse(source, resolvedOptions) : source;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(
    ast,
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, resolvedOptions, {
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate(ast, resolvedOptions);
}

const BindingTypes = {
  "DATA": "data",
  "PROPS": "props",
  "PROPS_ALIASED": "props-aliased",
  "SETUP_LET": "setup-let",
  "SETUP_CONST": "setup-const",
  "SETUP_REACTIVE_CONST": "setup-reactive-const",
  "SETUP_MAYBE_REF": "setup-maybe-ref",
  "SETUP_REF": "setup-ref",
  "OPTIONS": "options",
  "LITERAL_CONST": "literal-const"
};

const noopDirectiveTransform = () => ({ props: [] });




/***/ },

/***/ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js"
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js ***!
  \*************************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BASE_TRANSITION: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.BASE_TRANSITION),
/* harmony export */   BindingTypes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.BindingTypes),
/* harmony export */   CAMELIZE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAMELIZE),
/* harmony export */   CAPITALIZE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAPITALIZE),
/* harmony export */   CREATE_BLOCK: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_BLOCK),
/* harmony export */   CREATE_COMMENT: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_COMMENT),
/* harmony export */   CREATE_ELEMENT_BLOCK: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_BLOCK),
/* harmony export */   CREATE_ELEMENT_VNODE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_VNODE),
/* harmony export */   CREATE_SLOTS: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_SLOTS),
/* harmony export */   CREATE_STATIC: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_STATIC),
/* harmony export */   CREATE_TEXT: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_TEXT),
/* harmony export */   CREATE_VNODE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_VNODE),
/* harmony export */   CompilerDeprecationTypes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CompilerDeprecationTypes),
/* harmony export */   ConstantTypes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.ConstantTypes),
/* harmony export */   DOMDirectiveTransforms: () => (/* binding */ DOMDirectiveTransforms),
/* harmony export */   DOMErrorCodes: () => (/* binding */ DOMErrorCodes),
/* harmony export */   DOMErrorMessages: () => (/* binding */ DOMErrorMessages),
/* harmony export */   DOMNodeTransforms: () => (/* binding */ DOMNodeTransforms),
/* harmony export */   ElementTypes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.ElementTypes),
/* harmony export */   ErrorCodes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.ErrorCodes),
/* harmony export */   FRAGMENT: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.FRAGMENT),
/* harmony export */   GUARD_REACTIVE_PROPS: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.GUARD_REACTIVE_PROPS),
/* harmony export */   IS_MEMO_SAME: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_MEMO_SAME),
/* harmony export */   IS_REF: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_REF),
/* harmony export */   KEEP_ALIVE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.KEEP_ALIVE),
/* harmony export */   MERGE_PROPS: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.MERGE_PROPS),
/* harmony export */   NORMALIZE_CLASS: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_CLASS),
/* harmony export */   NORMALIZE_PROPS: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_PROPS),
/* harmony export */   NORMALIZE_STYLE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_STYLE),
/* harmony export */   Namespaces: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.Namespaces),
/* harmony export */   NodeTypes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NodeTypes),
/* harmony export */   OPEN_BLOCK: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.OPEN_BLOCK),
/* harmony export */   POP_SCOPE_ID: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.POP_SCOPE_ID),
/* harmony export */   PUSH_SCOPE_ID: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.PUSH_SCOPE_ID),
/* harmony export */   RENDER_LIST: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_LIST),
/* harmony export */   RENDER_SLOT: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_SLOT),
/* harmony export */   RESOLVE_COMPONENT: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_COMPONENT),
/* harmony export */   RESOLVE_DIRECTIVE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DIRECTIVE),
/* harmony export */   RESOLVE_DYNAMIC_COMPONENT: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   RESOLVE_FILTER: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_FILTER),
/* harmony export */   SET_BLOCK_TRACKING: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SET_BLOCK_TRACKING),
/* harmony export */   SUSPENSE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SUSPENSE),
/* harmony export */   TELEPORT: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TELEPORT),
/* harmony export */   TO_DISPLAY_STRING: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING),
/* harmony export */   TO_HANDLERS: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLERS),
/* harmony export */   TO_HANDLER_KEY: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLER_KEY),
/* harmony export */   TRANSITION: () => (/* binding */ TRANSITION),
/* harmony export */   TRANSITION_GROUP: () => (/* binding */ TRANSITION_GROUP),
/* harmony export */   TS_NODE_TYPES: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TS_NODE_TYPES),
/* harmony export */   UNREF: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.UNREF),
/* harmony export */   V_MODEL_CHECKBOX: () => (/* binding */ V_MODEL_CHECKBOX),
/* harmony export */   V_MODEL_DYNAMIC: () => (/* binding */ V_MODEL_DYNAMIC),
/* harmony export */   V_MODEL_RADIO: () => (/* binding */ V_MODEL_RADIO),
/* harmony export */   V_MODEL_SELECT: () => (/* binding */ V_MODEL_SELECT),
/* harmony export */   V_MODEL_TEXT: () => (/* binding */ V_MODEL_TEXT),
/* harmony export */   V_ON_WITH_KEYS: () => (/* binding */ V_ON_WITH_KEYS),
/* harmony export */   V_ON_WITH_MODIFIERS: () => (/* binding */ V_ON_WITH_MODIFIERS),
/* harmony export */   V_SHOW: () => (/* binding */ V_SHOW),
/* harmony export */   WITH_CTX: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_CTX),
/* harmony export */   WITH_DIRECTIVES: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_DIRECTIVES),
/* harmony export */   WITH_MEMO: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_MEMO),
/* harmony export */   advancePositionWithClone: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithClone),
/* harmony export */   advancePositionWithMutation: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithMutation),
/* harmony export */   assert: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.assert),
/* harmony export */   baseCompile: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile),
/* harmony export */   baseParse: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse),
/* harmony export */   buildDirectiveArgs: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildDirectiveArgs),
/* harmony export */   buildProps: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildProps),
/* harmony export */   buildSlots: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildSlots),
/* harmony export */   checkCompatEnabled: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled),
/* harmony export */   compile: () => (/* binding */ compile),
/* harmony export */   convertToBlock: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.convertToBlock),
/* harmony export */   createArrayExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createArrayExpression),
/* harmony export */   createAssignmentExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createAssignmentExpression),
/* harmony export */   createBlockStatement: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createBlockStatement),
/* harmony export */   createCacheExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCacheExpression),
/* harmony export */   createCallExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression),
/* harmony export */   createCompilerError: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError),
/* harmony export */   createCompoundExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression),
/* harmony export */   createConditionalExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createConditionalExpression),
/* harmony export */   createDOMCompilerError: () => (/* binding */ createDOMCompilerError),
/* harmony export */   createForLoopParams: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createForLoopParams),
/* harmony export */   createFunctionExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createFunctionExpression),
/* harmony export */   createIfStatement: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createIfStatement),
/* harmony export */   createInterpolation: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createInterpolation),
/* harmony export */   createObjectExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectExpression),
/* harmony export */   createObjectProperty: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty),
/* harmony export */   createReturnStatement: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createReturnStatement),
/* harmony export */   createRoot: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createRoot),
/* harmony export */   createSequenceExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSequenceExpression),
/* harmony export */   createSimpleExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression),
/* harmony export */   createStructuralDirectiveTransform: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createStructuralDirectiveTransform),
/* harmony export */   createTemplateLiteral: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTemplateLiteral),
/* harmony export */   createTransformContext: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTransformContext),
/* harmony export */   createVNodeCall: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createVNodeCall),
/* harmony export */   errorMessages: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.errorMessages),
/* harmony export */   extractIdentifiers: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.extractIdentifiers),
/* harmony export */   findDir: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findDir),
/* harmony export */   findProp: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp),
/* harmony export */   forAliasRE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.forAliasRE),
/* harmony export */   generate: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generate),
/* harmony export */   generateCodeFrame: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   getBaseTransformPreset: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getBaseTransformPreset),
/* harmony export */   getConstantType: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getConstantType),
/* harmony export */   getMemoedVNodeCall: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getMemoedVNodeCall),
/* harmony export */   getVNodeBlockHelper: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeBlockHelper),
/* harmony export */   getVNodeHelper: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeHelper),
/* harmony export */   hasDynamicKeyVBind: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind),
/* harmony export */   hasScopeRef: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasScopeRef),
/* harmony export */   helperNameMap: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.helperNameMap),
/* harmony export */   injectProp: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.injectProp),
/* harmony export */   isAllWhitespace: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isAllWhitespace),
/* harmony export */   isCommentOrWhitespace: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isCommentOrWhitespace),
/* harmony export */   isCoreComponent: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isCoreComponent),
/* harmony export */   isFnExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isFnExpression),
/* harmony export */   isFnExpressionBrowser: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isFnExpressionBrowser),
/* harmony export */   isFnExpressionNode: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isFnExpressionNode),
/* harmony export */   isFunctionType: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isFunctionType),
/* harmony export */   isInDestructureAssignment: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isInDestructureAssignment),
/* harmony export */   isInNewExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isInNewExpression),
/* harmony export */   isMemberExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpression),
/* harmony export */   isMemberExpressionBrowser: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionBrowser),
/* harmony export */   isMemberExpressionNode: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionNode),
/* harmony export */   isReferencedIdentifier: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isReferencedIdentifier),
/* harmony export */   isSimpleIdentifier: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSimpleIdentifier),
/* harmony export */   isSlotOutlet: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSlotOutlet),
/* harmony export */   isStaticArgOf: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticArgOf),
/* harmony export */   isStaticExp: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp),
/* harmony export */   isStaticProperty: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticProperty),
/* harmony export */   isStaticPropertyKey: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticPropertyKey),
/* harmony export */   isTemplateNode: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isTemplateNode),
/* harmony export */   isText: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isText),
/* harmony export */   isVPre: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isVPre),
/* harmony export */   isVSlot: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isVSlot),
/* harmony export */   isWhitespaceText: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isWhitespaceText),
/* harmony export */   locStub: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.locStub),
/* harmony export */   noopDirectiveTransform: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform),
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   parserOptions: () => (/* binding */ parserOptions),
/* harmony export */   processExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processExpression),
/* harmony export */   processFor: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processFor),
/* harmony export */   processIf: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processIf),
/* harmony export */   processSlotOutlet: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processSlotOutlet),
/* harmony export */   registerRuntimeHelpers: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers),
/* harmony export */   resolveComponentType: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponentType),
/* harmony export */   stringifyExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.stringifyExpression),
/* harmony export */   toValidAssetId: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.toValidAssetId),
/* harmony export */   trackSlotScopes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackSlotScopes),
/* harmony export */   trackVForSlotScopes: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackVForSlotScopes),
/* harmony export */   transform: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transform),
/* harmony export */   transformBind: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformBind),
/* harmony export */   transformElement: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformElement),
/* harmony export */   transformExpression: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformExpression),
/* harmony export */   transformModel: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel),
/* harmony export */   transformOn: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn),
/* harmony export */   transformStyle: () => (/* binding */ transformStyle),
/* harmony export */   transformVBindShorthand: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformVBindShorthand),
/* harmony export */   traverseNode: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.traverseNode),
/* harmony export */   unwrapTSNode: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.unwrapTSNode),
/* harmony export */   validFirstIdentCharRE: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.validFirstIdentCharRE),
/* harmony export */   walkBlockDeclarations: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkBlockDeclarations),
/* harmony export */   walkFunctionParams: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkFunctionParams),
/* harmony export */   walkIdentifiers: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkIdentifiers),
/* harmony export */   warnDeprecation: () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation)
/* harmony export */ });
/* harmony import */ var _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/compiler-core */ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/**
* @vue/compiler-dom v3.5.26
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/




const V_MODEL_RADIO = /* @__PURE__ */ Symbol( true ? `vModelRadio` : 0);
const V_MODEL_CHECKBOX = /* @__PURE__ */ Symbol(
   true ? `vModelCheckbox` : 0
);
const V_MODEL_TEXT = /* @__PURE__ */ Symbol( true ? `vModelText` : 0);
const V_MODEL_SELECT = /* @__PURE__ */ Symbol(
   true ? `vModelSelect` : 0
);
const V_MODEL_DYNAMIC = /* @__PURE__ */ Symbol(
   true ? `vModelDynamic` : 0
);
const V_ON_WITH_MODIFIERS = /* @__PURE__ */ Symbol(
   true ? `vOnModifiersGuard` : 0
);
const V_ON_WITH_KEYS = /* @__PURE__ */ Symbol(
   true ? `vOnKeysGuard` : 0
);
const V_SHOW = /* @__PURE__ */ Symbol( true ? `vShow` : 0);
const TRANSITION = /* @__PURE__ */ Symbol( true ? `Transition` : 0);
const TRANSITION_GROUP = /* @__PURE__ */ Symbol(
   true ? `TransitionGroup` : 0
);
(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers)({
  [V_MODEL_RADIO]: `vModelRadio`,
  [V_MODEL_CHECKBOX]: `vModelCheckbox`,
  [V_MODEL_TEXT]: `vModelText`,
  [V_MODEL_SELECT]: `vModelSelect`,
  [V_MODEL_DYNAMIC]: `vModelDynamic`,
  [V_ON_WITH_MODIFIERS]: `withModifiers`,
  [V_ON_WITH_KEYS]: `withKeys`,
  [V_SHOW]: `vShow`,
  [TRANSITION]: `Transition`,
  [TRANSITION_GROUP]: `TransitionGroup`
});

let decoder;
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}

const parserOptions = {
  parseMode: "html",
  isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isVoidTag,
  isNativeTag: (tag) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMathMLTag)(tag),
  isPreTag: (tag) => tag === "pre",
  isIgnoreNewlineTag: (tag) => tag === "pre" || tag === "textarea",
  decodeEntities: decodeHtmlBrowser ,
  isBuiltInComponent: (tag) => {
    if (tag === "Transition" || tag === "transition") {
      return TRANSITION;
    } else if (tag === "TransitionGroup" || tag === "transition-group") {
      return TRANSITION_GROUP;
    }
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(tag, parent, rootNamespace) {
    let ns = parent ? parent.ns : rootNamespace;
    if (parent && ns === 2) {
      if (parent.tag === "annotation-xml") {
        if (tag === "svg") {
          return 1;
        }
        if (parent.props.some(
          (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
        )) {
          ns = 0;
        }
      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
        ns = 0;
      }
    } else if (parent && ns === 1) {
      if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
        ns = 0;
      }
    }
    if (ns === 0) {
      if (tag === "svg") {
        return 1;
      }
      if (tag === "math") {
        return 2;
      }
    }
    return ns;
  }
};

const transformStyle = (node) => {
  if (node.type === 1) {
    node.props.forEach((p, i) => {
      if (p.type === 6 && p.name === "style" && p.value) {
        node.props[i] = {
          type: 7,
          name: `bind`,
          arg: (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`style`, true, p.loc),
          exp: parseInlineCSS(p.value.content, p.loc),
          modifiers: [],
          loc: p.loc
        };
      }
    });
  }
};
const parseInlineCSS = (cssText, loc) => {
  const normalized = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.parseStringStyle)(cssText);
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(
    JSON.stringify(normalized),
    false,
    loc,
    3
  );
};

function createDOMCompilerError(code, loc) {
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError)(
    code,
    loc,
     true ? DOMErrorMessages : 0
  );
}
const DOMErrorCodes = {
  "X_V_HTML_NO_EXPRESSION": 54,
  "54": "X_V_HTML_NO_EXPRESSION",
  "X_V_HTML_WITH_CHILDREN": 55,
  "55": "X_V_HTML_WITH_CHILDREN",
  "X_V_TEXT_NO_EXPRESSION": 56,
  "56": "X_V_TEXT_NO_EXPRESSION",
  "X_V_TEXT_WITH_CHILDREN": 57,
  "57": "X_V_TEXT_WITH_CHILDREN",
  "X_V_MODEL_ON_INVALID_ELEMENT": 58,
  "58": "X_V_MODEL_ON_INVALID_ELEMENT",
  "X_V_MODEL_ARG_ON_ELEMENT": 59,
  "59": "X_V_MODEL_ARG_ON_ELEMENT",
  "X_V_MODEL_ON_FILE_INPUT_ELEMENT": 60,
  "60": "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
  "X_V_MODEL_UNNECESSARY_VALUE": 61,
  "61": "X_V_MODEL_UNNECESSARY_VALUE",
  "X_V_SHOW_NO_EXPRESSION": 62,
  "62": "X_V_SHOW_NO_EXPRESSION",
  "X_TRANSITION_INVALID_CHILDREN": 63,
  "63": "X_TRANSITION_INVALID_CHILDREN",
  "X_IGNORED_SIDE_EFFECT_TAG": 64,
  "64": "X_IGNORED_SIDE_EFFECT_TAG",
  "__EXTEND_POINT__": 65,
  "65": "__EXTEND_POINT__"
};
const DOMErrorMessages = {
  [54]: `v-html is missing expression.`,
  [55]: `v-html will override element children.`,
  [56]: `v-text is missing expression.`,
  [57]: `v-text will override element children.`,
  [58]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
  [59]: `v-model argument is not supported on plain elements.`,
  [60]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
  [61]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
  [62]: `v-show is missing expression.`,
  [63]: `<Transition> expects exactly one child element or component.`,
  [64]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
};

const transformVHtml = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(54, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(55, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(
        (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`innerHTML`, true, loc),
        exp || (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("", true)
      )
    ]
  };
};

const transformVText = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(56, loc)
    );
  }
  if (node.children.length) {
    context.onError(
      createDOMCompilerError(57, loc)
    );
    node.children.length = 0;
  }
  return {
    props: [
      (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(
        (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`textContent`, true),
        exp ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getConstantType)(exp, context) > 0 ? exp : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(
          context.helperString(_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING),
          [exp],
          loc
        ) : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("", true)
      )
    ]
  };
};

const transformModel = (dir, node, context) => {
  const baseResult = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel)(dir, node, context);
  if (!baseResult.props.length || node.tagType === 1) {
    return baseResult;
  }
  if (dir.arg) {
    context.onError(
      createDOMCompilerError(
        59,
        dir.arg.loc
      )
    );
  }
  function checkDuplicatedValue() {
    const value = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findDir)(node, "bind");
    if (value && (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticArgOf)(value.arg, "value")) {
      context.onError(
        createDOMCompilerError(
          61,
          value.loc
        )
      );
    }
  }
  const { tag } = node;
  const isCustomElement = context.isCustomElement(tag);
  if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
    let directiveToUse = V_MODEL_TEXT;
    let isInvalidType = false;
    if (tag === "input" || isCustomElement) {
      const type = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, `type`);
      if (type) {
        if (type.type === 7) {
          directiveToUse = V_MODEL_DYNAMIC;
        } else if (type.value) {
          switch (type.value.content) {
            case "radio":
              directiveToUse = V_MODEL_RADIO;
              break;
            case "checkbox":
              directiveToUse = V_MODEL_CHECKBOX;
              break;
            case "file":
              isInvalidType = true;
              context.onError(
                createDOMCompilerError(
                  60,
                  dir.loc
                )
              );
              break;
            default:
               true && checkDuplicatedValue();
              break;
          }
        }
      } else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind)(node)) {
        directiveToUse = V_MODEL_DYNAMIC;
      } else {
         true && checkDuplicatedValue();
      }
    } else if (tag === "select") {
      directiveToUse = V_MODEL_SELECT;
    } else {
       true && checkDuplicatedValue();
    }
    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse);
    }
  } else {
    context.onError(
      createDOMCompilerError(
        58,
        dir.loc
      )
    );
  }
  baseResult.props = baseResult.props.filter(
    (p) => !(p.key.type === 4 && p.key.content === "modelValue")
  );
  return baseResult;
};

const isEventOptionModifier = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`passive,once,capture`);
const isNonKeyModifier = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(
  // event propagation management
  `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
);
const maybeKeyModifier = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)("left,right");
const isKeyboardEvent = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`onkeyup,onkeydown,onkeypress`);
const resolveModifiers = (key, modifiers, context, loc) => {
  const keyModifiers = [];
  const nonKeyModifiers = [];
  const eventOptionModifiers = [];
  for (let i = 0; i < modifiers.length; i++) {
    const modifier = modifiers[i].content;
    if (modifier === "native" && (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled)(
      "COMPILER_V_ON_NATIVE",
      context,
      loc
    )) {
      eventOptionModifiers.push(modifier);
    } else if (isEventOptionModifier(modifier)) {
      eventOptionModifiers.push(modifier);
    } else {
      if (maybeKeyModifier(modifier)) {
        if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)) {
          if (isKeyboardEvent(key.content.toLowerCase())) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }
  return {
    keyModifiers,
    nonKeyModifiers,
    eventOptionModifiers
  };
};
const transformClick = (key, event) => {
  const isStaticClick = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) && key.content.toLowerCase() === "onclick";
  return isStaticClick ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(event, true) : key.type !== 4 ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([
    `(`,
    key,
    `) === "onClick" ? "${event}" : (`,
    key,
    `)`
  ]) : key;
};
const transformOn = (dir, node, context) => {
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn)(dir, node, context, (baseResult) => {
    const { modifiers } = dir;
    if (!modifiers.length) return baseResult;
    let { key, value: handlerExp } = baseResult.props[0];
    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
    if (nonKeyModifiers.includes("right")) {
      key = transformClick(key, `onContextmenu`);
    }
    if (nonKeyModifiers.includes("middle")) {
      key = transformClick(key, `onMouseup`);
    }
    if (nonKeyModifiers.length) {
      handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_MODIFIERS), [
        handlerExp,
        JSON.stringify(nonKeyModifiers)
      ]);
    }
    if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
    (!(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) || isKeyboardEvent(key.content.toLowerCase()))) {
      handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_KEYS), [
        handlerExp,
        JSON.stringify(keyModifiers)
      ]);
    }
    if (eventOptionModifiers.length) {
      const modifierPostfix = eventOptionModifiers.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join("");
      key = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`${key.content}${modifierPostfix}`, true) : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([`(`, key, `) + "${modifierPostfix}"`]);
    }
    return {
      props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(key, handlerExp)]
    };
  });
};

const transformShow = (dir, node, context) => {
  const { exp, loc } = dir;
  if (!exp) {
    context.onError(
      createDOMCompilerError(62, loc)
    );
  }
  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  };
};

const transformTransition = (node, context) => {
  if (node.type === 1 && node.tagType === 1) {
    const component = context.isBuiltInComponent(node.tag);
    if (component === TRANSITION) {
      return () => {
        if (!node.children.length) {
          return;
        }
        if (hasMultipleChildren(node)) {
          context.onError(
            createDOMCompilerError(
              63,
              {
                start: node.children[0].loc.start,
                end: node.children[node.children.length - 1].loc.end,
                source: ""
              }
            )
          );
        }
        const child = node.children[0];
        if (child.type === 1) {
          for (const p of child.props) {
            if (p.type === 7 && p.name === "show") {
              node.props.push({
                type: 6,
                name: "persisted",
                nameLoc: node.loc,
                value: void 0,
                loc: node.loc
              });
            }
          }
        }
      };
    }
  }
};
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter(
    (c) => !(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isCommentOrWhitespace)(c)
  );
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}

const ignoreSideEffectTags = (node, context) => {
  if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
     true && context.onError(
      createDOMCompilerError(
        64,
        node.loc
      )
    );
    context.removeNode();
  }
};

function isValidHTMLNesting(parent, child) {
  if (parent === "template") {
    return true;
  }
  if (parent in onlyValidChildren) {
    return onlyValidChildren[parent].has(child);
  }
  if (child in onlyValidParents) {
    return onlyValidParents[child].has(parent);
  }
  if (parent in knownInvalidChildren) {
    if (knownInvalidChildren[parent].has(child)) return false;
  }
  if (child in knownInvalidParents) {
    if (knownInvalidParents[child].has(parent)) return false;
  }
  return true;
}
const headings = /* @__PURE__ */ new Set(["h1", "h2", "h3", "h4", "h5", "h6"]);
const emptySet = /* @__PURE__ */ new Set([]);
const onlyValidChildren = {
  head: /* @__PURE__ */ new Set([
    "base",
    "basefront",
    "bgsound",
    "link",
    "meta",
    "title",
    "noscript",
    "noframes",
    "style",
    "script",
    "template"
  ]),
  optgroup: /* @__PURE__ */ new Set(["option"]),
  select: /* @__PURE__ */ new Set(["optgroup", "option", "hr"]),
  // table
  table: /* @__PURE__ */ new Set(["caption", "colgroup", "tbody", "tfoot", "thead"]),
  tr: /* @__PURE__ */ new Set(["td", "th"]),
  colgroup: /* @__PURE__ */ new Set(["col"]),
  tbody: /* @__PURE__ */ new Set(["tr"]),
  thead: /* @__PURE__ */ new Set(["tr"]),
  tfoot: /* @__PURE__ */ new Set(["tr"]),
  // these elements can not have any children elements
  script: emptySet,
  iframe: emptySet,
  option: emptySet,
  textarea: emptySet,
  style: emptySet,
  title: emptySet
};
const onlyValidParents = {
  // sections
  html: emptySet,
  body: /* @__PURE__ */ new Set(["html"]),
  head: /* @__PURE__ */ new Set(["html"]),
  // table
  td: /* @__PURE__ */ new Set(["tr"]),
  colgroup: /* @__PURE__ */ new Set(["table"]),
  caption: /* @__PURE__ */ new Set(["table"]),
  tbody: /* @__PURE__ */ new Set(["table"]),
  tfoot: /* @__PURE__ */ new Set(["table"]),
  col: /* @__PURE__ */ new Set(["colgroup"]),
  th: /* @__PURE__ */ new Set(["tr"]),
  thead: /* @__PURE__ */ new Set(["table"]),
  tr: /* @__PURE__ */ new Set(["tbody", "thead", "tfoot"]),
  // data list
  dd: /* @__PURE__ */ new Set(["dl", "div"]),
  dt: /* @__PURE__ */ new Set(["dl", "div"]),
  // other
  figcaption: /* @__PURE__ */ new Set(["figure"]),
  // li: new Set(["ul", "ol"]),
  summary: /* @__PURE__ */ new Set(["details"]),
  area: /* @__PURE__ */ new Set(["map"])
};
const knownInvalidChildren = {
  p: /* @__PURE__ */ new Set([
    "address",
    "article",
    "aside",
    "blockquote",
    "center",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "fieldset",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "hgroup",
    "hr",
    "li",
    "main",
    "nav",
    "menu",
    "ol",
    "p",
    "pre",
    "section",
    "table",
    "ul"
  ]),
  svg: /* @__PURE__ */ new Set([
    "b",
    "blockquote",
    "br",
    "code",
    "dd",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hr",
    "i",
    "img",
    "li",
    "menu",
    "meta",
    "ol",
    "p",
    "pre",
    "ruby",
    "s",
    "small",
    "span",
    "strong",
    "sub",
    "sup",
    "table",
    "u",
    "ul",
    "var"
  ])
};
const knownInvalidParents = {
  a: /* @__PURE__ */ new Set(["a"]),
  button: /* @__PURE__ */ new Set(["button"]),
  dd: /* @__PURE__ */ new Set(["dd", "dt"]),
  dt: /* @__PURE__ */ new Set(["dd", "dt"]),
  form: /* @__PURE__ */ new Set(["form"]),
  li: /* @__PURE__ */ new Set(["li"]),
  h1: headings,
  h2: headings,
  h3: headings,
  h4: headings,
  h5: headings,
  h6: headings
};

const validateHtmlNesting = (node, context) => {
  if (node.type === 1 && node.tagType === 0 && context.parent && context.parent.type === 1 && context.parent.tagType === 0 && !isValidHTMLNesting(context.parent.tag, node.tag)) {
    const error = new SyntaxError(
      `<${node.tag}> cannot be child of <${context.parent.tag}>, according to HTML specifications. This can cause hydration errors or potentially disrupt future functionality.`
    );
    error.loc = node.loc;
    context.onWarn(error);
  }
};

const DOMNodeTransforms = [
  transformStyle,
  ... true ? [transformTransition, validateHtmlNesting] : 0
];
const DOMDirectiveTransforms = {
  cloak: _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel,
  // override compiler-core
  on: transformOn,
  // override compiler-core
  show: transformShow
};
function compile(src, options = {}) {
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile)(
    src,
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: null 
    })
  );
}
function parse(template, options = {}) {
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options));
}




/***/ },

/***/ "./node_modules/@vue/devtools-kit/dist/index.js"
/*!******************************************************!*\
  !*** ./node_modules/@vue/devtools-kit/dist/index.js ***!
  \******************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DevToolsContextHookKeys: () => (/* binding */ DevToolsContextHookKeys),
/* harmony export */   DevToolsMessagingHookKeys: () => (/* binding */ DevToolsMessagingHookKeys),
/* harmony export */   DevToolsV6PluginAPIHookKeys: () => (/* binding */ DevToolsV6PluginAPIHookKeys),
/* harmony export */   INFINITY: () => (/* binding */ INFINITY),
/* harmony export */   NAN: () => (/* binding */ NAN),
/* harmony export */   NEGATIVE_INFINITY: () => (/* binding */ NEGATIVE_INFINITY),
/* harmony export */   ROUTER_INFO_KEY: () => (/* binding */ ROUTER_INFO_KEY),
/* harmony export */   ROUTER_KEY: () => (/* binding */ ROUTER_KEY),
/* harmony export */   UNDEFINED: () => (/* binding */ UNDEFINED),
/* harmony export */   activeAppRecord: () => (/* binding */ activeAppRecord),
/* harmony export */   addCustomCommand: () => (/* binding */ addCustomCommand),
/* harmony export */   addCustomTab: () => (/* binding */ addCustomTab),
/* harmony export */   addDevToolsAppRecord: () => (/* binding */ addDevToolsAppRecord),
/* harmony export */   addDevToolsPluginToBuffer: () => (/* binding */ addDevToolsPluginToBuffer),
/* harmony export */   addInspector: () => (/* binding */ addInspector),
/* harmony export */   callConnectedUpdatedHook: () => (/* binding */ callConnectedUpdatedHook),
/* harmony export */   callDevToolsPluginSetupFn: () => (/* binding */ callDevToolsPluginSetupFn),
/* harmony export */   callInspectorUpdatedHook: () => (/* binding */ callInspectorUpdatedHook),
/* harmony export */   callStateUpdatedHook: () => (/* binding */ callStateUpdatedHook),
/* harmony export */   createComponentsDevToolsPlugin: () => (/* binding */ createComponentsDevToolsPlugin),
/* harmony export */   createDevToolsApi: () => (/* binding */ createDevToolsApi),
/* harmony export */   createDevToolsCtxHooks: () => (/* binding */ createDevToolsCtxHooks),
/* harmony export */   createRpcClient: () => (/* binding */ createRpcClient),
/* harmony export */   createRpcProxy: () => (/* binding */ createRpcProxy),
/* harmony export */   createRpcServer: () => (/* binding */ createRpcServer),
/* harmony export */   devtools: () => (/* binding */ devtools),
/* harmony export */   devtoolsAppRecords: () => (/* binding */ devtoolsAppRecords),
/* harmony export */   devtoolsContext: () => (/* binding */ devtoolsContext),
/* harmony export */   devtoolsInspector: () => (/* binding */ devtoolsInspector),
/* harmony export */   devtoolsPluginBuffer: () => (/* binding */ devtoolsPluginBuffer),
/* harmony export */   devtoolsRouter: () => (/* binding */ devtoolsRouter),
/* harmony export */   devtoolsRouterInfo: () => (/* binding */ devtoolsRouterInfo),
/* harmony export */   devtoolsState: () => (/* binding */ devtoolsState),
/* harmony export */   escape: () => (/* binding */ escape),
/* harmony export */   formatInspectorStateValue: () => (/* binding */ formatInspectorStateValue),
/* harmony export */   getActiveInspectors: () => (/* binding */ getActiveInspectors),
/* harmony export */   getDevToolsEnv: () => (/* binding */ getDevToolsEnv),
/* harmony export */   getExtensionClientContext: () => (/* binding */ getExtensionClientContext),
/* harmony export */   getInspector: () => (/* binding */ getInspector),
/* harmony export */   getInspectorActions: () => (/* binding */ getInspectorActions),
/* harmony export */   getInspectorInfo: () => (/* binding */ getInspectorInfo),
/* harmony export */   getInspectorNodeActions: () => (/* binding */ getInspectorNodeActions),
/* harmony export */   getInspectorStateValueType: () => (/* binding */ getInspectorStateValueType),
/* harmony export */   getRaw: () => (/* binding */ getRaw),
/* harmony export */   getRpcClient: () => (/* binding */ getRpcClient),
/* harmony export */   getRpcServer: () => (/* binding */ getRpcServer),
/* harmony export */   getViteRpcClient: () => (/* binding */ getViteRpcClient),
/* harmony export */   getViteRpcServer: () => (/* binding */ getViteRpcServer),
/* harmony export */   initDevTools: () => (/* binding */ initDevTools),
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),
/* harmony export */   onDevToolsClientConnected: () => (/* binding */ onDevToolsClientConnected),
/* harmony export */   onDevToolsConnected: () => (/* binding */ onDevToolsConnected),
/* harmony export */   parse: () => (/* binding */ parse2),
/* harmony export */   registerDevToolsPlugin: () => (/* binding */ registerDevToolsPlugin),
/* harmony export */   removeCustomCommand: () => (/* binding */ removeCustomCommand),
/* harmony export */   removeDevToolsAppRecord: () => (/* binding */ removeDevToolsAppRecord),
/* harmony export */   removeRegisteredPluginApp: () => (/* binding */ removeRegisteredPluginApp),
/* harmony export */   resetDevToolsState: () => (/* binding */ resetDevToolsState),
/* harmony export */   setActiveAppRecord: () => (/* binding */ setActiveAppRecord),
/* harmony export */   setActiveAppRecordId: () => (/* binding */ setActiveAppRecordId),
/* harmony export */   setDevToolsEnv: () => (/* binding */ setDevToolsEnv),
/* harmony export */   setElectronClientContext: () => (/* binding */ setElectronClientContext),
/* harmony export */   setElectronProxyContext: () => (/* binding */ setElectronProxyContext),
/* harmony export */   setElectronServerContext: () => (/* binding */ setElectronServerContext),
/* harmony export */   setExtensionClientContext: () => (/* binding */ setExtensionClientContext),
/* harmony export */   setIframeServerContext: () => (/* binding */ setIframeServerContext),
/* harmony export */   setOpenInEditorBaseUrl: () => (/* binding */ setOpenInEditorBaseUrl),
/* harmony export */   setRpcServerToGlobal: () => (/* binding */ setRpcServerToGlobal),
/* harmony export */   setViteClientContext: () => (/* binding */ setViteClientContext),
/* harmony export */   setViteRpcClientToGlobal: () => (/* binding */ setViteRpcClientToGlobal),
/* harmony export */   setViteRpcServerToGlobal: () => (/* binding */ setViteRpcServerToGlobal),
/* harmony export */   setViteServerContext: () => (/* binding */ setViteServerContext),
/* harmony export */   setupDevToolsPlugin: () => (/* binding */ setupDevToolsPlugin),
/* harmony export */   stringify: () => (/* binding */ stringify2),
/* harmony export */   toEdit: () => (/* binding */ toEdit),
/* harmony export */   toSubmit: () => (/* binding */ toSubmit),
/* harmony export */   toggleClientConnected: () => (/* binding */ toggleClientConnected),
/* harmony export */   toggleComponentInspectorEnabled: () => (/* binding */ toggleComponentInspectorEnabled),
/* harmony export */   toggleHighPerfMode: () => (/* binding */ toggleHighPerfMode),
/* harmony export */   updateDevToolsClientDetected: () => (/* binding */ updateDevToolsClientDetected),
/* harmony export */   updateDevToolsState: () => (/* binding */ updateDevToolsState),
/* harmony export */   updateTimelineLayersState: () => (/* binding */ updateTimelineLayersState)
/* harmony export */ });
/* harmony import */ var _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/devtools-shared */ "./node_modules/@vue/devtools-shared/dist/index.js");
/* harmony import */ var perfect_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! perfect-debounce */ "./node_modules/perfect-debounce/dist/index.mjs");
/* harmony import */ var hookable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hookable */ "./node_modules/hookable/dist/index.mjs");
/* harmony import */ var birpc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! birpc */ "./node_modules/birpc/dist/index.mjs");
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target22) => (target22 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target22, "default", { value: mod, enumerable: true }) : target22,
  mod
));

// ../../node_modules/.pnpm/tsup@8.4.0_@microsoft+api-extractor@7.51.1_@types+node@22.13.14__jiti@2.4.2_postcss@8.5_96eb05a9d65343021e53791dd83f3773/node_modules/tsup/assets/esm_shims.js
var init_esm_shims = __esm({
  "../../node_modules/.pnpm/tsup@8.4.0_@microsoft+api-extractor@7.51.1_@types+node@22.13.14__jiti@2.4.2_postcss@8.5_96eb05a9d65343021e53791dd83f3773/node_modules/tsup/assets/esm_shims.js"() {
    "use strict";
  }
});

// ../../node_modules/.pnpm/speakingurl@14.0.1/node_modules/speakingurl/lib/speakingurl.js
var require_speakingurl = __commonJS({
  "../../node_modules/.pnpm/speakingurl@14.0.1/node_modules/speakingurl/lib/speakingurl.js"(exports, module) {
    "use strict";
    init_esm_shims();
    (function(root) {
      "use strict";
      var charMap = {
        // latin
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "Ae",
        "\xC5": "A",
        "\xC6": "AE",
        "\xC7": "C",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xD0": "D",
        "\xD1": "N",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "Oe",
        "\u0150": "O",
        "\xD8": "O",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "Ue",
        "\u0170": "U",
        "\xDD": "Y",
        "\xDE": "TH",
        "\xDF": "ss",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "ae",
        "\xE5": "a",
        "\xE6": "ae",
        "\xE7": "c",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xF0": "d",
        "\xF1": "n",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "oe",
        "\u0151": "o",
        "\xF8": "o",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "ue",
        "\u0171": "u",
        "\xFD": "y",
        "\xFE": "th",
        "\xFF": "y",
        "\u1E9E": "SS",
        // language specific
        // Arabic
        "\u0627": "a",
        "\u0623": "a",
        "\u0625": "i",
        "\u0622": "aa",
        "\u0624": "u",
        "\u0626": "e",
        "\u0621": "a",
        "\u0628": "b",
        "\u062A": "t",
        "\u062B": "th",
        "\u062C": "j",
        "\u062D": "h",
        "\u062E": "kh",
        "\u062F": "d",
        "\u0630": "th",
        "\u0631": "r",
        "\u0632": "z",
        "\u0633": "s",
        "\u0634": "sh",
        "\u0635": "s",
        "\u0636": "dh",
        "\u0637": "t",
        "\u0638": "z",
        "\u0639": "a",
        "\u063A": "gh",
        "\u0641": "f",
        "\u0642": "q",
        "\u0643": "k",
        "\u0644": "l",
        "\u0645": "m",
        "\u0646": "n",
        "\u0647": "h",
        "\u0648": "w",
        "\u064A": "y",
        "\u0649": "a",
        "\u0629": "h",
        "\uFEFB": "la",
        "\uFEF7": "laa",
        "\uFEF9": "lai",
        "\uFEF5": "laa",
        // Persian additional characters than Arabic
        "\u06AF": "g",
        "\u0686": "ch",
        "\u067E": "p",
        "\u0698": "zh",
        "\u06A9": "k",
        "\u06CC": "y",
        // Arabic diactrics
        "\u064E": "a",
        "\u064B": "an",
        "\u0650": "e",
        "\u064D": "en",
        "\u064F": "u",
        "\u064C": "on",
        "\u0652": "",
        // Arabic numbers
        "\u0660": "0",
        "\u0661": "1",
        "\u0662": "2",
        "\u0663": "3",
        "\u0664": "4",
        "\u0665": "5",
        "\u0666": "6",
        "\u0667": "7",
        "\u0668": "8",
        "\u0669": "9",
        // Persian numbers
        "\u06F0": "0",
        "\u06F1": "1",
        "\u06F2": "2",
        "\u06F3": "3",
        "\u06F4": "4",
        "\u06F5": "5",
        "\u06F6": "6",
        "\u06F7": "7",
        "\u06F8": "8",
        "\u06F9": "9",
        // Burmese consonants
        "\u1000": "k",
        "\u1001": "kh",
        "\u1002": "g",
        "\u1003": "ga",
        "\u1004": "ng",
        "\u1005": "s",
        "\u1006": "sa",
        "\u1007": "z",
        "\u1005\u103B": "za",
        "\u100A": "ny",
        "\u100B": "t",
        "\u100C": "ta",
        "\u100D": "d",
        "\u100E": "da",
        "\u100F": "na",
        "\u1010": "t",
        "\u1011": "ta",
        "\u1012": "d",
        "\u1013": "da",
        "\u1014": "n",
        "\u1015": "p",
        "\u1016": "pa",
        "\u1017": "b",
        "\u1018": "ba",
        "\u1019": "m",
        "\u101A": "y",
        "\u101B": "ya",
        "\u101C": "l",
        "\u101D": "w",
        "\u101E": "th",
        "\u101F": "h",
        "\u1020": "la",
        "\u1021": "a",
        // consonant character combos
        "\u103C": "y",
        "\u103B": "ya",
        "\u103D": "w",
        "\u103C\u103D": "yw",
        "\u103B\u103D": "ywa",
        "\u103E": "h",
        // independent vowels
        "\u1027": "e",
        "\u104F": "-e",
        "\u1023": "i",
        "\u1024": "-i",
        "\u1009": "u",
        "\u1026": "-u",
        "\u1029": "aw",
        "\u101E\u103C\u1031\u102C": "aw",
        "\u102A": "aw",
        // numbers
        "\u1040": "0",
        "\u1041": "1",
        "\u1042": "2",
        "\u1043": "3",
        "\u1044": "4",
        "\u1045": "5",
        "\u1046": "6",
        "\u1047": "7",
        "\u1048": "8",
        "\u1049": "9",
        // virama and tone marks which are silent in transliteration
        "\u1039": "",
        "\u1037": "",
        "\u1038": "",
        // Czech
        "\u010D": "c",
        "\u010F": "d",
        "\u011B": "e",
        "\u0148": "n",
        "\u0159": "r",
        "\u0161": "s",
        "\u0165": "t",
        "\u016F": "u",
        "\u017E": "z",
        "\u010C": "C",
        "\u010E": "D",
        "\u011A": "E",
        "\u0147": "N",
        "\u0158": "R",
        "\u0160": "S",
        "\u0164": "T",
        "\u016E": "U",
        "\u017D": "Z",
        // Dhivehi
        "\u0780": "h",
        "\u0781": "sh",
        "\u0782": "n",
        "\u0783": "r",
        "\u0784": "b",
        "\u0785": "lh",
        "\u0786": "k",
        "\u0787": "a",
        "\u0788": "v",
        "\u0789": "m",
        "\u078A": "f",
        "\u078B": "dh",
        "\u078C": "th",
        "\u078D": "l",
        "\u078E": "g",
        "\u078F": "gn",
        "\u0790": "s",
        "\u0791": "d",
        "\u0792": "z",
        "\u0793": "t",
        "\u0794": "y",
        "\u0795": "p",
        "\u0796": "j",
        "\u0797": "ch",
        "\u0798": "tt",
        "\u0799": "hh",
        "\u079A": "kh",
        "\u079B": "th",
        "\u079C": "z",
        "\u079D": "sh",
        "\u079E": "s",
        "\u079F": "d",
        "\u07A0": "t",
        "\u07A1": "z",
        "\u07A2": "a",
        "\u07A3": "gh",
        "\u07A4": "q",
        "\u07A5": "w",
        "\u07A6": "a",
        "\u07A7": "aa",
        "\u07A8": "i",
        "\u07A9": "ee",
        "\u07AA": "u",
        "\u07AB": "oo",
        "\u07AC": "e",
        "\u07AD": "ey",
        "\u07AE": "o",
        "\u07AF": "oa",
        "\u07B0": "",
        // Georgian https://en.wikipedia.org/wiki/Romanization_of_Georgian
        // National system (2002)
        "\u10D0": "a",
        "\u10D1": "b",
        "\u10D2": "g",
        "\u10D3": "d",
        "\u10D4": "e",
        "\u10D5": "v",
        "\u10D6": "z",
        "\u10D7": "t",
        "\u10D8": "i",
        "\u10D9": "k",
        "\u10DA": "l",
        "\u10DB": "m",
        "\u10DC": "n",
        "\u10DD": "o",
        "\u10DE": "p",
        "\u10DF": "zh",
        "\u10E0": "r",
        "\u10E1": "s",
        "\u10E2": "t",
        "\u10E3": "u",
        "\u10E4": "p",
        "\u10E5": "k",
        "\u10E6": "gh",
        "\u10E7": "q",
        "\u10E8": "sh",
        "\u10E9": "ch",
        "\u10EA": "ts",
        "\u10EB": "dz",
        "\u10EC": "ts",
        "\u10ED": "ch",
        "\u10EE": "kh",
        "\u10EF": "j",
        "\u10F0": "h",
        // Greek
        "\u03B1": "a",
        "\u03B2": "v",
        "\u03B3": "g",
        "\u03B4": "d",
        "\u03B5": "e",
        "\u03B6": "z",
        "\u03B7": "i",
        "\u03B8": "th",
        "\u03B9": "i",
        "\u03BA": "k",
        "\u03BB": "l",
        "\u03BC": "m",
        "\u03BD": "n",
        "\u03BE": "ks",
        "\u03BF": "o",
        "\u03C0": "p",
        "\u03C1": "r",
        "\u03C3": "s",
        "\u03C4": "t",
        "\u03C5": "y",
        "\u03C6": "f",
        "\u03C7": "x",
        "\u03C8": "ps",
        "\u03C9": "o",
        "\u03AC": "a",
        "\u03AD": "e",
        "\u03AF": "i",
        "\u03CC": "o",
        "\u03CD": "y",
        "\u03AE": "i",
        "\u03CE": "o",
        "\u03C2": "s",
        "\u03CA": "i",
        "\u03B0": "y",
        "\u03CB": "y",
        "\u0390": "i",
        "\u0391": "A",
        "\u0392": "B",
        "\u0393": "G",
        "\u0394": "D",
        "\u0395": "E",
        "\u0396": "Z",
        "\u0397": "I",
        "\u0398": "TH",
        "\u0399": "I",
        "\u039A": "K",
        "\u039B": "L",
        "\u039C": "M",
        "\u039D": "N",
        "\u039E": "KS",
        "\u039F": "O",
        "\u03A0": "P",
        "\u03A1": "R",
        "\u03A3": "S",
        "\u03A4": "T",
        "\u03A5": "Y",
        "\u03A6": "F",
        "\u03A7": "X",
        "\u03A8": "PS",
        "\u03A9": "O",
        "\u0386": "A",
        "\u0388": "E",
        "\u038A": "I",
        "\u038C": "O",
        "\u038E": "Y",
        "\u0389": "I",
        "\u038F": "O",
        "\u03AA": "I",
        "\u03AB": "Y",
        // Latvian
        "\u0101": "a",
        // '': 'c', // duplicate
        "\u0113": "e",
        "\u0123": "g",
        "\u012B": "i",
        "\u0137": "k",
        "\u013C": "l",
        "\u0146": "n",
        // '': 's', // duplicate
        "\u016B": "u",
        // '': 'z', // duplicate
        "\u0100": "A",
        // '': 'C', // duplicate
        "\u0112": "E",
        "\u0122": "G",
        "\u012A": "I",
        "\u0136": "k",
        "\u013B": "L",
        "\u0145": "N",
        // '': 'S', // duplicate
        "\u016A": "U",
        // '': 'Z', // duplicate
        // Macedonian
        "\u040C": "Kj",
        "\u045C": "kj",
        "\u0409": "Lj",
        "\u0459": "lj",
        "\u040A": "Nj",
        "\u045A": "nj",
        "\u0422\u0441": "Ts",
        "\u0442\u0441": "ts",
        // Polish
        "\u0105": "a",
        "\u0107": "c",
        "\u0119": "e",
        "\u0142": "l",
        "\u0144": "n",
        // '': 'o', // duplicate
        "\u015B": "s",
        "\u017A": "z",
        "\u017C": "z",
        "\u0104": "A",
        "\u0106": "C",
        "\u0118": "E",
        "\u0141": "L",
        "\u0143": "N",
        "\u015A": "S",
        "\u0179": "Z",
        "\u017B": "Z",
        // Ukranian
        "\u0404": "Ye",
        "\u0406": "I",
        "\u0407": "Yi",
        "\u0490": "G",
        "\u0454": "ye",
        "\u0456": "i",
        "\u0457": "yi",
        "\u0491": "g",
        // Romanian
        "\u0103": "a",
        "\u0102": "A",
        "\u0219": "s",
        "\u0218": "S",
        // '': 's', // duplicate
        // '': 'S', // duplicate
        "\u021B": "t",
        "\u021A": "T",
        "\u0163": "t",
        "\u0162": "T",
        // Russian https://en.wikipedia.org/wiki/Romanization_of_Russian
        // ICAO
        "\u0430": "a",
        "\u0431": "b",
        "\u0432": "v",
        "\u0433": "g",
        "\u0434": "d",
        "\u0435": "e",
        "\u0451": "yo",
        "\u0436": "zh",
        "\u0437": "z",
        "\u0438": "i",
        "\u0439": "i",
        "\u043A": "k",
        "\u043B": "l",
        "\u043C": "m",
        "\u043D": "n",
        "\u043E": "o",
        "\u043F": "p",
        "\u0440": "r",
        "\u0441": "s",
        "\u0442": "t",
        "\u0443": "u",
        "\u0444": "f",
        "\u0445": "kh",
        "\u0446": "c",
        "\u0447": "ch",
        "\u0448": "sh",
        "\u0449": "sh",
        "\u044A": "",
        "\u044B": "y",
        "\u044C": "",
        "\u044D": "e",
        "\u044E": "yu",
        "\u044F": "ya",
        "\u0410": "A",
        "\u0411": "B",
        "\u0412": "V",
        "\u0413": "G",
        "\u0414": "D",
        "\u0415": "E",
        "\u0401": "Yo",
        "\u0416": "Zh",
        "\u0417": "Z",
        "\u0418": "I",
        "\u0419": "I",
        "\u041A": "K",
        "\u041B": "L",
        "\u041C": "M",
        "\u041D": "N",
        "\u041E": "O",
        "\u041F": "P",
        "\u0420": "R",
        "\u0421": "S",
        "\u0422": "T",
        "\u0423": "U",
        "\u0424": "F",
        "\u0425": "Kh",
        "\u0426": "C",
        "\u0427": "Ch",
        "\u0428": "Sh",
        "\u0429": "Sh",
        "\u042A": "",
        "\u042B": "Y",
        "\u042C": "",
        "\u042D": "E",
        "\u042E": "Yu",
        "\u042F": "Ya",
        // Serbian
        "\u0452": "dj",
        "\u0458": "j",
        // '': 'lj',  // duplicate
        // '': 'nj', // duplicate
        "\u045B": "c",
        "\u045F": "dz",
        "\u0402": "Dj",
        "\u0408": "j",
        // '': 'Lj', // duplicate
        // '': 'Nj', // duplicate
        "\u040B": "C",
        "\u040F": "Dz",
        // Slovak
        "\u013E": "l",
        "\u013A": "l",
        "\u0155": "r",
        "\u013D": "L",
        "\u0139": "L",
        "\u0154": "R",
        // Turkish
        "\u015F": "s",
        "\u015E": "S",
        "\u0131": "i",
        "\u0130": "I",
        // '': 'c', // duplicate
        // '': 'C', // duplicate
        // '': 'u', // duplicate, see langCharMap
        // '': 'U', // duplicate, see langCharMap
        // '': 'o', // duplicate, see langCharMap
        // '': 'O', // duplicate, see langCharMap
        "\u011F": "g",
        "\u011E": "G",
        // Vietnamese
        "\u1EA3": "a",
        "\u1EA2": "A",
        "\u1EB3": "a",
        "\u1EB2": "A",
        "\u1EA9": "a",
        "\u1EA8": "A",
        "\u0111": "d",
        "\u0110": "D",
        "\u1EB9": "e",
        "\u1EB8": "E",
        "\u1EBD": "e",
        "\u1EBC": "E",
        "\u1EBB": "e",
        "\u1EBA": "E",
        "\u1EBF": "e",
        "\u1EBE": "E",
        "\u1EC1": "e",
        "\u1EC0": "E",
        "\u1EC7": "e",
        "\u1EC6": "E",
        "\u1EC5": "e",
        "\u1EC4": "E",
        "\u1EC3": "e",
        "\u1EC2": "E",
        "\u1ECF": "o",
        "\u1ECD": "o",
        "\u1ECC": "o",
        "\u1ED1": "o",
        "\u1ED0": "O",
        "\u1ED3": "o",
        "\u1ED2": "O",
        "\u1ED5": "o",
        "\u1ED4": "O",
        "\u1ED9": "o",
        "\u1ED8": "O",
        "\u1ED7": "o",
        "\u1ED6": "O",
        "\u01A1": "o",
        "\u01A0": "O",
        "\u1EDB": "o",
        "\u1EDA": "O",
        "\u1EDD": "o",
        "\u1EDC": "O",
        "\u1EE3": "o",
        "\u1EE2": "O",
        "\u1EE1": "o",
        "\u1EE0": "O",
        "\u1EDE": "o",
        "\u1EDF": "o",
        "\u1ECB": "i",
        "\u1ECA": "I",
        "\u0129": "i",
        "\u0128": "I",
        "\u1EC9": "i",
        "\u1EC8": "i",
        "\u1EE7": "u",
        "\u1EE6": "U",
        "\u1EE5": "u",
        "\u1EE4": "U",
        "\u0169": "u",
        "\u0168": "U",
        "\u01B0": "u",
        "\u01AF": "U",
        "\u1EE9": "u",
        "\u1EE8": "U",
        "\u1EEB": "u",
        "\u1EEA": "U",
        "\u1EF1": "u",
        "\u1EF0": "U",
        "\u1EEF": "u",
        "\u1EEE": "U",
        "\u1EED": "u",
        "\u1EEC": "\u01B0",
        "\u1EF7": "y",
        "\u1EF6": "y",
        "\u1EF3": "y",
        "\u1EF2": "Y",
        "\u1EF5": "y",
        "\u1EF4": "Y",
        "\u1EF9": "y",
        "\u1EF8": "Y",
        "\u1EA1": "a",
        "\u1EA0": "A",
        "\u1EA5": "a",
        "\u1EA4": "A",
        "\u1EA7": "a",
        "\u1EA6": "A",
        "\u1EAD": "a",
        "\u1EAC": "A",
        "\u1EAB": "a",
        "\u1EAA": "A",
        // '': 'a', // duplicate
        // '': 'A', // duplicate
        "\u1EAF": "a",
        "\u1EAE": "A",
        "\u1EB1": "a",
        "\u1EB0": "A",
        "\u1EB7": "a",
        "\u1EB6": "A",
        "\u1EB5": "a",
        "\u1EB4": "A",
        "\u24EA": "0",
        "\u2460": "1",
        "\u2461": "2",
        "\u2462": "3",
        "\u2463": "4",
        "\u2464": "5",
        "\u2465": "6",
        "\u2466": "7",
        "\u2467": "8",
        "\u2468": "9",
        "\u2469": "10",
        "\u246A": "11",
        "\u246B": "12",
        "\u246C": "13",
        "\u246D": "14",
        "\u246E": "15",
        "\u246F": "16",
        "\u2470": "17",
        "\u2471": "18",
        "\u2472": "18",
        "\u2473": "18",
        "\u24F5": "1",
        "\u24F6": "2",
        "\u24F7": "3",
        "\u24F8": "4",
        "\u24F9": "5",
        "\u24FA": "6",
        "\u24FB": "7",
        "\u24FC": "8",
        "\u24FD": "9",
        "\u24FE": "10",
        "\u24FF": "0",
        "\u24EB": "11",
        "\u24EC": "12",
        "\u24ED": "13",
        "\u24EE": "14",
        "\u24EF": "15",
        "\u24F0": "16",
        "\u24F1": "17",
        "\u24F2": "18",
        "\u24F3": "19",
        "\u24F4": "20",
        "\u24B6": "A",
        "\u24B7": "B",
        "\u24B8": "C",
        "\u24B9": "D",
        "\u24BA": "E",
        "\u24BB": "F",
        "\u24BC": "G",
        "\u24BD": "H",
        "\u24BE": "I",
        "\u24BF": "J",
        "\u24C0": "K",
        "\u24C1": "L",
        "\u24C2": "M",
        "\u24C3": "N",
        "\u24C4": "O",
        "\u24C5": "P",
        "\u24C6": "Q",
        "\u24C7": "R",
        "\u24C8": "S",
        "\u24C9": "T",
        "\u24CA": "U",
        "\u24CB": "V",
        "\u24CC": "W",
        "\u24CD": "X",
        "\u24CE": "Y",
        "\u24CF": "Z",
        "\u24D0": "a",
        "\u24D1": "b",
        "\u24D2": "c",
        "\u24D3": "d",
        "\u24D4": "e",
        "\u24D5": "f",
        "\u24D6": "g",
        "\u24D7": "h",
        "\u24D8": "i",
        "\u24D9": "j",
        "\u24DA": "k",
        "\u24DB": "l",
        "\u24DC": "m",
        "\u24DD": "n",
        "\u24DE": "o",
        "\u24DF": "p",
        "\u24E0": "q",
        "\u24E1": "r",
        "\u24E2": "s",
        "\u24E3": "t",
        "\u24E4": "u",
        "\u24E6": "v",
        "\u24E5": "w",
        "\u24E7": "x",
        "\u24E8": "y",
        "\u24E9": "z",
        // symbols
        "\u201C": '"',
        "\u201D": '"',
        "\u2018": "'",
        "\u2019": "'",
        "\u2202": "d",
        "\u0192": "f",
        "\u2122": "(TM)",
        "\xA9": "(C)",
        "\u0153": "oe",
        "\u0152": "OE",
        "\xAE": "(R)",
        "\u2020": "+",
        "\u2120": "(SM)",
        "\u2026": "...",
        "\u02DA": "o",
        "\xBA": "o",
        "\xAA": "a",
        "\u2022": "*",
        "\u104A": ",",
        "\u104B": ".",
        // currency
        "$": "USD",
        "\u20AC": "EUR",
        "\u20A2": "BRN",
        "\u20A3": "FRF",
        "\xA3": "GBP",
        "\u20A4": "ITL",
        "\u20A6": "NGN",
        "\u20A7": "ESP",
        "\u20A9": "KRW",
        "\u20AA": "ILS",
        "\u20AB": "VND",
        "\u20AD": "LAK",
        "\u20AE": "MNT",
        "\u20AF": "GRD",
        "\u20B1": "ARS",
        "\u20B2": "PYG",
        "\u20B3": "ARA",
        "\u20B4": "UAH",
        "\u20B5": "GHS",
        "\xA2": "cent",
        "\xA5": "CNY",
        "\u5143": "CNY",
        "\u5186": "YEN",
        "\uFDFC": "IRR",
        "\u20A0": "EWE",
        "\u0E3F": "THB",
        "\u20A8": "INR",
        "\u20B9": "INR",
        "\u20B0": "PF",
        "\u20BA": "TRY",
        "\u060B": "AFN",
        "\u20BC": "AZN",
        "\u043B\u0432": "BGN",
        "\u17DB": "KHR",
        "\u20A1": "CRC",
        "\u20B8": "KZT",
        "\u0434\u0435\u043D": "MKD",
        "z\u0142": "PLN",
        "\u20BD": "RUB",
        "\u20BE": "GEL"
      };
      var lookAheadCharArray = [
        // burmese
        "\u103A",
        // Dhivehi
        "\u07B0"
      ];
      var diatricMap = {
        // Burmese
        // dependent vowels
        "\u102C": "a",
        "\u102B": "a",
        "\u1031": "e",
        "\u1032": "e",
        "\u102D": "i",
        "\u102E": "i",
        "\u102D\u102F": "o",
        "\u102F": "u",
        "\u1030": "u",
        "\u1031\u102B\u1004\u103A": "aung",
        "\u1031\u102C": "aw",
        "\u1031\u102C\u103A": "aw",
        "\u1031\u102B": "aw",
        "\u1031\u102B\u103A": "aw",
        "\u103A": "\u103A",
        // this is special case but the character will be converted to latin in the code
        "\u1000\u103A": "et",
        "\u102D\u102F\u1000\u103A": "aik",
        "\u1031\u102C\u1000\u103A": "auk",
        "\u1004\u103A": "in",
        "\u102D\u102F\u1004\u103A": "aing",
        "\u1031\u102C\u1004\u103A": "aung",
        "\u1005\u103A": "it",
        "\u100A\u103A": "i",
        "\u1010\u103A": "at",
        "\u102D\u1010\u103A": "eik",
        "\u102F\u1010\u103A": "ok",
        "\u103D\u1010\u103A": "ut",
        "\u1031\u1010\u103A": "it",
        "\u1012\u103A": "d",
        "\u102D\u102F\u1012\u103A": "ok",
        "\u102F\u1012\u103A": "ait",
        "\u1014\u103A": "an",
        "\u102C\u1014\u103A": "an",
        "\u102D\u1014\u103A": "ein",
        "\u102F\u1014\u103A": "on",
        "\u103D\u1014\u103A": "un",
        "\u1015\u103A": "at",
        "\u102D\u1015\u103A": "eik",
        "\u102F\u1015\u103A": "ok",
        "\u103D\u1015\u103A": "ut",
        "\u1014\u103A\u102F\u1015\u103A": "nub",
        "\u1019\u103A": "an",
        "\u102D\u1019\u103A": "ein",
        "\u102F\u1019\u103A": "on",
        "\u103D\u1019\u103A": "un",
        "\u101A\u103A": "e",
        "\u102D\u102F\u101C\u103A": "ol",
        "\u1009\u103A": "in",
        "\u1036": "an",
        "\u102D\u1036": "ein",
        "\u102F\u1036": "on",
        // Dhivehi
        "\u07A6\u0787\u07B0": "ah",
        "\u07A6\u0781\u07B0": "ah"
      };
      var langCharMap = {
        "en": {},
        // default language
        "az": {
          // Azerbaijani
          "\xE7": "c",
          "\u0259": "e",
          "\u011F": "g",
          "\u0131": "i",
          "\xF6": "o",
          "\u015F": "s",
          "\xFC": "u",
          "\xC7": "C",
          "\u018F": "E",
          "\u011E": "G",
          "\u0130": "I",
          "\xD6": "O",
          "\u015E": "S",
          "\xDC": "U"
        },
        "cs": {
          // Czech
          "\u010D": "c",
          "\u010F": "d",
          "\u011B": "e",
          "\u0148": "n",
          "\u0159": "r",
          "\u0161": "s",
          "\u0165": "t",
          "\u016F": "u",
          "\u017E": "z",
          "\u010C": "C",
          "\u010E": "D",
          "\u011A": "E",
          "\u0147": "N",
          "\u0158": "R",
          "\u0160": "S",
          "\u0164": "T",
          "\u016E": "U",
          "\u017D": "Z"
        },
        "fi": {
          // Finnish
          // '': 'a', duplicate see charMap/latin
          // '': 'A', duplicate see charMap/latin
          "\xE4": "a",
          // ok
          "\xC4": "A",
          // ok
          "\xF6": "o",
          // ok
          "\xD6": "O"
          // ok
        },
        "hu": {
          // Hungarian
          "\xE4": "a",
          // ok
          "\xC4": "A",
          // ok
          // '': 'a', duplicate see charMap/latin
          // '': 'A', duplicate see charMap/latin
          "\xF6": "o",
          // ok
          "\xD6": "O",
          // ok
          // '': 'o', duplicate see charMap/latin
          // '': 'O', duplicate see charMap/latin
          "\xFC": "u",
          "\xDC": "U",
          "\u0171": "u",
          "\u0170": "U"
        },
        "lt": {
          // Lithuanian
          "\u0105": "a",
          "\u010D": "c",
          "\u0119": "e",
          "\u0117": "e",
          "\u012F": "i",
          "\u0161": "s",
          "\u0173": "u",
          "\u016B": "u",
          "\u017E": "z",
          "\u0104": "A",
          "\u010C": "C",
          "\u0118": "E",
          "\u0116": "E",
          "\u012E": "I",
          "\u0160": "S",
          "\u0172": "U",
          "\u016A": "U"
        },
        "lv": {
          // Latvian
          "\u0101": "a",
          "\u010D": "c",
          "\u0113": "e",
          "\u0123": "g",
          "\u012B": "i",
          "\u0137": "k",
          "\u013C": "l",
          "\u0146": "n",
          "\u0161": "s",
          "\u016B": "u",
          "\u017E": "z",
          "\u0100": "A",
          "\u010C": "C",
          "\u0112": "E",
          "\u0122": "G",
          "\u012A": "i",
          "\u0136": "k",
          "\u013B": "L",
          "\u0145": "N",
          "\u0160": "S",
          "\u016A": "u",
          "\u017D": "Z"
        },
        "pl": {
          // Polish
          "\u0105": "a",
          "\u0107": "c",
          "\u0119": "e",
          "\u0142": "l",
          "\u0144": "n",
          "\xF3": "o",
          "\u015B": "s",
          "\u017A": "z",
          "\u017C": "z",
          "\u0104": "A",
          "\u0106": "C",
          "\u0118": "e",
          "\u0141": "L",
          "\u0143": "N",
          "\xD3": "O",
          "\u015A": "S",
          "\u0179": "Z",
          "\u017B": "Z"
        },
        "sv": {
          // Swedish
          // '': 'a', duplicate see charMap/latin
          // '': 'A', duplicate see charMap/latin
          "\xE4": "a",
          // ok
          "\xC4": "A",
          // ok
          "\xF6": "o",
          // ok
          "\xD6": "O"
          // ok
        },
        "sk": {
          // Slovak
          "\xE4": "a",
          "\xC4": "A"
        },
        "sr": {
          // Serbian
          "\u0459": "lj",
          "\u045A": "nj",
          "\u0409": "Lj",
          "\u040A": "Nj",
          "\u0111": "dj",
          "\u0110": "Dj"
        },
        "tr": {
          // Turkish
          "\xDC": "U",
          "\xD6": "O",
          "\xFC": "u",
          "\xF6": "o"
        }
      };
      var symbolMap = {
        "ar": {
          "\u2206": "delta",
          "\u221E": "la-nihaya",
          "\u2665": "hob",
          "&": "wa",
          "|": "aw",
          "<": "aqal-men",
          ">": "akbar-men",
          "\u2211": "majmou",
          "\xA4": "omla"
        },
        "az": {},
        "ca": {
          "\u2206": "delta",
          "\u221E": "infinit",
          "\u2665": "amor",
          "&": "i",
          "|": "o",
          "<": "menys que",
          ">": "mes que",
          "\u2211": "suma dels",
          "\xA4": "moneda"
        },
        "cs": {
          "\u2206": "delta",
          "\u221E": "nekonecno",
          "\u2665": "laska",
          "&": "a",
          "|": "nebo",
          "<": "mensi nez",
          ">": "vetsi nez",
          "\u2211": "soucet",
          "\xA4": "mena"
        },
        "de": {
          "\u2206": "delta",
          "\u221E": "unendlich",
          "\u2665": "Liebe",
          "&": "und",
          "|": "oder",
          "<": "kleiner als",
          ">": "groesser als",
          "\u2211": "Summe von",
          "\xA4": "Waehrung"
        },
        "dv": {
          "\u2206": "delta",
          "\u221E": "kolunulaa",
          "\u2665": "loabi",
          "&": "aai",
          "|": "noonee",
          "<": "ah vure kuda",
          ">": "ah vure bodu",
          "\u2211": "jumula",
          "\xA4": "faisaa"
        },
        "en": {
          "\u2206": "delta",
          "\u221E": "infinity",
          "\u2665": "love",
          "&": "and",
          "|": "or",
          "<": "less than",
          ">": "greater than",
          "\u2211": "sum",
          "\xA4": "currency"
        },
        "es": {
          "\u2206": "delta",
          "\u221E": "infinito",
          "\u2665": "amor",
          "&": "y",
          "|": "u",
          "<": "menos que",
          ">": "mas que",
          "\u2211": "suma de los",
          "\xA4": "moneda"
        },
        "fa": {
          "\u2206": "delta",
          "\u221E": "bi-nahayat",
          "\u2665": "eshgh",
          "&": "va",
          "|": "ya",
          "<": "kamtar-az",
          ">": "bishtar-az",
          "\u2211": "majmooe",
          "\xA4": "vahed"
        },
        "fi": {
          "\u2206": "delta",
          "\u221E": "aarettomyys",
          "\u2665": "rakkaus",
          "&": "ja",
          "|": "tai",
          "<": "pienempi kuin",
          ">": "suurempi kuin",
          "\u2211": "summa",
          "\xA4": "valuutta"
        },
        "fr": {
          "\u2206": "delta",
          "\u221E": "infiniment",
          "\u2665": "Amour",
          "&": "et",
          "|": "ou",
          "<": "moins que",
          ">": "superieure a",
          "\u2211": "somme des",
          "\xA4": "monnaie"
        },
        "ge": {
          "\u2206": "delta",
          "\u221E": "usasruloba",
          "\u2665": "siqvaruli",
          "&": "da",
          "|": "an",
          "<": "naklebi",
          ">": "meti",
          "\u2211": "jami",
          "\xA4": "valuta"
        },
        "gr": {},
        "hu": {
          "\u2206": "delta",
          "\u221E": "vegtelen",
          "\u2665": "szerelem",
          "&": "es",
          "|": "vagy",
          "<": "kisebb mint",
          ">": "nagyobb mint",
          "\u2211": "szumma",
          "\xA4": "penznem"
        },
        "it": {
          "\u2206": "delta",
          "\u221E": "infinito",
          "\u2665": "amore",
          "&": "e",
          "|": "o",
          "<": "minore di",
          ">": "maggiore di",
          "\u2211": "somma",
          "\xA4": "moneta"
        },
        "lt": {
          "\u2206": "delta",
          "\u221E": "begalybe",
          "\u2665": "meile",
          "&": "ir",
          "|": "ar",
          "<": "maziau nei",
          ">": "daugiau nei",
          "\u2211": "suma",
          "\xA4": "valiuta"
        },
        "lv": {
          "\u2206": "delta",
          "\u221E": "bezgaliba",
          "\u2665": "milestiba",
          "&": "un",
          "|": "vai",
          "<": "mazak neka",
          ">": "lielaks neka",
          "\u2211": "summa",
          "\xA4": "valuta"
        },
        "my": {
          "\u2206": "kwahkhyaet",
          "\u221E": "asaonasme",
          "\u2665": "akhyait",
          "&": "nhin",
          "|": "tho",
          "<": "ngethaw",
          ">": "kyithaw",
          "\u2211": "paungld",
          "\xA4": "ngwekye"
        },
        "mk": {},
        "nl": {
          "\u2206": "delta",
          "\u221E": "oneindig",
          "\u2665": "liefde",
          "&": "en",
          "|": "of",
          "<": "kleiner dan",
          ">": "groter dan",
          "\u2211": "som",
          "\xA4": "valuta"
        },
        "pl": {
          "\u2206": "delta",
          "\u221E": "nieskonczonosc",
          "\u2665": "milosc",
          "&": "i",
          "|": "lub",
          "<": "mniejsze niz",
          ">": "wieksze niz",
          "\u2211": "suma",
          "\xA4": "waluta"
        },
        "pt": {
          "\u2206": "delta",
          "\u221E": "infinito",
          "\u2665": "amor",
          "&": "e",
          "|": "ou",
          "<": "menor que",
          ">": "maior que",
          "\u2211": "soma",
          "\xA4": "moeda"
        },
        "ro": {
          "\u2206": "delta",
          "\u221E": "infinit",
          "\u2665": "dragoste",
          "&": "si",
          "|": "sau",
          "<": "mai mic ca",
          ">": "mai mare ca",
          "\u2211": "suma",
          "\xA4": "valuta"
        },
        "ru": {
          "\u2206": "delta",
          "\u221E": "beskonechno",
          "\u2665": "lubov",
          "&": "i",
          "|": "ili",
          "<": "menshe",
          ">": "bolshe",
          "\u2211": "summa",
          "\xA4": "valjuta"
        },
        "sk": {
          "\u2206": "delta",
          "\u221E": "nekonecno",
          "\u2665": "laska",
          "&": "a",
          "|": "alebo",
          "<": "menej ako",
          ">": "viac ako",
          "\u2211": "sucet",
          "\xA4": "mena"
        },
        "sr": {},
        "tr": {
          "\u2206": "delta",
          "\u221E": "sonsuzluk",
          "\u2665": "ask",
          "&": "ve",
          "|": "veya",
          "<": "kucuktur",
          ">": "buyuktur",
          "\u2211": "toplam",
          "\xA4": "para birimi"
        },
        "uk": {
          "\u2206": "delta",
          "\u221E": "bezkinechnist",
          "\u2665": "lubov",
          "&": "i",
          "|": "abo",
          "<": "menshe",
          ">": "bilshe",
          "\u2211": "suma",
          "\xA4": "valjuta"
        },
        "vn": {
          "\u2206": "delta",
          "\u221E": "vo cuc",
          "\u2665": "yeu",
          "&": "va",
          "|": "hoac",
          "<": "nho hon",
          ">": "lon hon",
          "\u2211": "tong",
          "\xA4": "tien te"
        }
      };
      var uricChars = [";", "?", ":", "@", "&", "=", "+", "$", ",", "/"].join("");
      var uricNoSlashChars = [";", "?", ":", "@", "&", "=", "+", "$", ","].join("");
      var markChars = [".", "!", "~", "*", "'", "(", ")"].join("");
      var getSlug = function getSlug2(input, opts) {
        var separator = "-";
        var result = "";
        var diatricString = "";
        var convertSymbols = true;
        var customReplacements = {};
        var maintainCase;
        var titleCase;
        var truncate;
        var uricFlag;
        var uricNoSlashFlag;
        var markFlag;
        var symbol;
        var langChar;
        var lucky;
        var i;
        var ch;
        var l;
        var lastCharWasSymbol;
        var lastCharWasDiatric;
        var allowedChars = "";
        if (typeof input !== "string") {
          return "";
        }
        if (typeof opts === "string") {
          separator = opts;
        }
        symbol = symbolMap.en;
        langChar = langCharMap.en;
        if (typeof opts === "object") {
          maintainCase = opts.maintainCase || false;
          customReplacements = opts.custom && typeof opts.custom === "object" ? opts.custom : customReplacements;
          truncate = +opts.truncate > 1 && opts.truncate || false;
          uricFlag = opts.uric || false;
          uricNoSlashFlag = opts.uricNoSlash || false;
          markFlag = opts.mark || false;
          convertSymbols = opts.symbols === false || opts.lang === false ? false : true;
          separator = opts.separator || separator;
          if (uricFlag) {
            allowedChars += uricChars;
          }
          if (uricNoSlashFlag) {
            allowedChars += uricNoSlashChars;
          }
          if (markFlag) {
            allowedChars += markChars;
          }
          symbol = opts.lang && symbolMap[opts.lang] && convertSymbols ? symbolMap[opts.lang] : convertSymbols ? symbolMap.en : {};
          langChar = opts.lang && langCharMap[opts.lang] ? langCharMap[opts.lang] : opts.lang === false || opts.lang === true ? {} : langCharMap.en;
          if (opts.titleCase && typeof opts.titleCase.length === "number" && Array.prototype.toString.call(opts.titleCase)) {
            opts.titleCase.forEach(function(v) {
              customReplacements[v + ""] = v + "";
            });
            titleCase = true;
          } else {
            titleCase = !!opts.titleCase;
          }
          if (opts.custom && typeof opts.custom.length === "number" && Array.prototype.toString.call(opts.custom)) {
            opts.custom.forEach(function(v) {
              customReplacements[v + ""] = v + "";
            });
          }
          Object.keys(customReplacements).forEach(function(v) {
            var r;
            if (v.length > 1) {
              r = new RegExp("\\b" + escapeChars(v) + "\\b", "gi");
            } else {
              r = new RegExp(escapeChars(v), "gi");
            }
            input = input.replace(r, customReplacements[v]);
          });
          for (ch in customReplacements) {
            allowedChars += ch;
          }
        }
        allowedChars += separator;
        allowedChars = escapeChars(allowedChars);
        input = input.replace(/(^\s+|\s+$)/g, "");
        lastCharWasSymbol = false;
        lastCharWasDiatric = false;
        for (i = 0, l = input.length; i < l; i++) {
          ch = input[i];
          if (isReplacedCustomChar(ch, customReplacements)) {
            lastCharWasSymbol = false;
          } else if (langChar[ch]) {
            ch = lastCharWasSymbol && langChar[ch].match(/[A-Za-z0-9]/) ? " " + langChar[ch] : langChar[ch];
            lastCharWasSymbol = false;
          } else if (ch in charMap) {
            if (i + 1 < l && lookAheadCharArray.indexOf(input[i + 1]) >= 0) {
              diatricString += ch;
              ch = "";
            } else if (lastCharWasDiatric === true) {
              ch = diatricMap[diatricString] + charMap[ch];
              diatricString = "";
            } else {
              ch = lastCharWasSymbol && charMap[ch].match(/[A-Za-z0-9]/) ? " " + charMap[ch] : charMap[ch];
            }
            lastCharWasSymbol = false;
            lastCharWasDiatric = false;
          } else if (ch in diatricMap) {
            diatricString += ch;
            ch = "";
            if (i === l - 1) {
              ch = diatricMap[diatricString];
            }
            lastCharWasDiatric = true;
          } else if (
            // process symbol chars
            symbol[ch] && !(uricFlag && uricChars.indexOf(ch) !== -1) && !(uricNoSlashFlag && uricNoSlashChars.indexOf(ch) !== -1)
          ) {
            ch = lastCharWasSymbol || result.substr(-1).match(/[A-Za-z0-9]/) ? separator + symbol[ch] : symbol[ch];
            ch += input[i + 1] !== void 0 && input[i + 1].match(/[A-Za-z0-9]/) ? separator : "";
            lastCharWasSymbol = true;
          } else {
            if (lastCharWasDiatric === true) {
              ch = diatricMap[diatricString] + ch;
              diatricString = "";
              lastCharWasDiatric = false;
            } else if (lastCharWasSymbol && (/[A-Za-z0-9]/.test(ch) || result.substr(-1).match(/A-Za-z0-9]/))) {
              ch = " " + ch;
            }
            lastCharWasSymbol = false;
          }
          result += ch.replace(new RegExp("[^\\w\\s" + allowedChars + "_-]", "g"), separator);
        }
        if (titleCase) {
          result = result.replace(/(\w)(\S*)/g, function(_, i2, r) {
            var j = i2.toUpperCase() + (r !== null ? r : "");
            return Object.keys(customReplacements).indexOf(j.toLowerCase()) < 0 ? j : j.toLowerCase();
          });
        }
        result = result.replace(/\s+/g, separator).replace(new RegExp("\\" + separator + "+", "g"), separator).replace(new RegExp("(^\\" + separator + "+|\\" + separator + "+$)", "g"), "");
        if (truncate && result.length > truncate) {
          lucky = result.charAt(truncate) === separator;
          result = result.slice(0, truncate);
          if (!lucky) {
            result = result.slice(0, result.lastIndexOf(separator));
          }
        }
        if (!maintainCase && !titleCase) {
          result = result.toLowerCase();
        }
        return result;
      };
      var createSlug = function createSlug2(opts) {
        return function getSlugWithConfig(input) {
          return getSlug(input, opts);
        };
      };
      var escapeChars = function escapeChars2(input) {
        return input.replace(/[-\\^$*+?.()|[\]{}\/]/g, "\\$&");
      };
      var isReplacedCustomChar = function(ch, customReplacements) {
        for (var c in customReplacements) {
          if (customReplacements[c] === ch) {
            return true;
          }
        }
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = getSlug;
        module.exports.createSlug = createSlug;
      } else if (typeof define !== "undefined" && define.amd) {
        define([], function() {
          return getSlug;
        });
      } else {
        try {
          if (root.getSlug || root.createSlug) {
            throw "speakingurl: globals exists /(getSlug|createSlug)/";
          } else {
            root.getSlug = getSlug;
            root.createSlug = createSlug;
          }
        } catch (e) {
        }
      }
    })(exports);
  }
});

// ../../node_modules/.pnpm/speakingurl@14.0.1/node_modules/speakingurl/index.js
var require_speakingurl2 = __commonJS({
  "../../node_modules/.pnpm/speakingurl@14.0.1/node_modules/speakingurl/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    module.exports = require_speakingurl();
  }
});

// src/index.ts
init_esm_shims();

// src/core/index.ts
init_esm_shims();


// src/compat/index.ts
init_esm_shims();

function onLegacyDevToolsPluginApiAvailable(cb) {
  if (_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__) {
    cb();
    return;
  }
  Object.defineProperty(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target, "__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__", {
    set(value) {
      if (value)
        cb();
    },
    configurable: true
  });
}

// src/ctx/index.ts
init_esm_shims();


// src/ctx/api.ts
init_esm_shims();


// src/core/component-highlighter/index.ts
init_esm_shims();

// src/core/component/state/bounding-rect.ts
init_esm_shims();

// src/core/component/utils/index.ts
init_esm_shims();

function getComponentTypeName(options) {
  var _a25;
  const name = options.name || options._componentTag || options.__VUE_DEVTOOLS_COMPONENT_GUSSED_NAME__ || options.__name;
  if (name === "index" && ((_a25 = options.__file) == null ? void 0 : _a25.endsWith("index.vue"))) {
    return "";
  }
  return name;
}
function getComponentFileName(options) {
  const file = options.__file;
  if (file)
    return (0,_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.classify)((0,_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.basename)(file, ".vue"));
}
function getComponentName(options) {
  const name = options.displayName || options.name || options._componentTag;
  if (name)
    return name;
  return getComponentFileName(options);
}
function saveComponentGussedName(instance, name) {
  instance.type.__VUE_DEVTOOLS_COMPONENT_GUSSED_NAME__ = name;
  return name;
}
function getAppRecord(instance) {
  if (instance.__VUE_DEVTOOLS_NEXT_APP_RECORD__)
    return instance.__VUE_DEVTOOLS_NEXT_APP_RECORD__;
  else if (instance.root)
    return instance.appContext.app.__VUE_DEVTOOLS_NEXT_APP_RECORD__;
}
async function getComponentId(options) {
  const { app, uid, instance } = options;
  try {
    if (instance.__VUE_DEVTOOLS_NEXT_UID__)
      return instance.__VUE_DEVTOOLS_NEXT_UID__;
    const appRecord = await getAppRecord(app);
    if (!appRecord)
      return null;
    const isRoot = appRecord.rootInstance === instance;
    return `${appRecord.id}:${isRoot ? "root" : uid}`;
  } catch (e) {
  }
}
function isFragment(instance) {
  var _a25, _b25;
  const subTreeType = (_a25 = instance.subTree) == null ? void 0 : _a25.type;
  const appRecord = getAppRecord(instance);
  if (appRecord) {
    return ((_b25 = appRecord == null ? void 0 : appRecord.types) == null ? void 0 : _b25.Fragment) === subTreeType;
  }
  return false;
}
function isBeingDestroyed(instance) {
  return instance._isBeingDestroyed || instance.isUnmounted;
}
function getInstanceName(instance) {
  var _a25, _b25, _c;
  const name = getComponentTypeName((instance == null ? void 0 : instance.type) || {});
  if (name)
    return name;
  if ((instance == null ? void 0 : instance.root) === instance)
    return "Root";
  for (const key in (_b25 = (_a25 = instance.parent) == null ? void 0 : _a25.type) == null ? void 0 : _b25.components) {
    if (instance.parent.type.components[key] === (instance == null ? void 0 : instance.type))
      return saveComponentGussedName(instance, key);
  }
  for (const key in (_c = instance.appContext) == null ? void 0 : _c.components) {
    if (instance.appContext.components[key] === (instance == null ? void 0 : instance.type))
      return saveComponentGussedName(instance, key);
  }
  const fileName = getComponentFileName((instance == null ? void 0 : instance.type) || {});
  if (fileName)
    return fileName;
  return "Anonymous Component";
}
function getUniqueComponentId(instance) {
  var _a25, _b25, _c;
  const appId = (_c = (_b25 = (_a25 = instance == null ? void 0 : instance.appContext) == null ? void 0 : _a25.app) == null ? void 0 : _b25.__VUE_DEVTOOLS_NEXT_APP_RECORD_ID__) != null ? _c : 0;
  const instanceId = instance === (instance == null ? void 0 : instance.root) ? "root" : instance.uid;
  return `${appId}:${instanceId}`;
}
function getRenderKey(value) {
  if (value == null)
    return "";
  if (typeof value === "number")
    return value;
  else if (typeof value === "string")
    return `'${value}'`;
  else if (Array.isArray(value))
    return "Array";
  else
    return "Object";
}
function returnError(cb) {
  try {
    return cb();
  } catch (e) {
    return e;
  }
}
function getComponentInstance(appRecord, instanceId) {
  instanceId = instanceId || `${appRecord.id}:root`;
  const instance = appRecord.instanceMap.get(instanceId);
  return instance || appRecord.instanceMap.get(":root");
}
function ensurePropertyExists(obj, key, skipObjCheck = false) {
  return skipObjCheck ? key in obj : typeof obj === "object" && obj !== null ? key in obj : false;
}

// src/core/component/state/bounding-rect.ts
function createRect() {
  const rect = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    get width() {
      return rect.right - rect.left;
    },
    get height() {
      return rect.bottom - rect.top;
    }
  };
  return rect;
}
var range;
function getTextRect(node) {
  if (!range)
    range = document.createRange();
  range.selectNode(node);
  return range.getBoundingClientRect();
}
function getFragmentRect(vnode) {
  const rect = createRect();
  if (!vnode.children)
    return rect;
  for (let i = 0, l = vnode.children.length; i < l; i++) {
    const childVnode = vnode.children[i];
    let childRect;
    if (childVnode.component) {
      childRect = getComponentBoundingRect(childVnode.component);
    } else if (childVnode.el) {
      const el = childVnode.el;
      if (el.nodeType === 1 || el.getBoundingClientRect)
        childRect = el.getBoundingClientRect();
      else if (el.nodeType === 3 && el.data.trim())
        childRect = getTextRect(el);
    }
    if (childRect)
      mergeRects(rect, childRect);
  }
  return rect;
}
function mergeRects(a, b) {
  if (!a.top || b.top < a.top)
    a.top = b.top;
  if (!a.bottom || b.bottom > a.bottom)
    a.bottom = b.bottom;
  if (!a.left || b.left < a.left)
    a.left = b.left;
  if (!a.right || b.right > a.right)
    a.right = b.right;
  return a;
}
var DEFAULT_RECT = {
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  width: 0,
  height: 0
};
function getComponentBoundingRect(instance) {
  const el = instance.subTree.el;
  if (typeof window === "undefined") {
    return DEFAULT_RECT;
  }
  if (isFragment(instance))
    return getFragmentRect(instance.subTree);
  else if ((el == null ? void 0 : el.nodeType) === 1)
    return el == null ? void 0 : el.getBoundingClientRect();
  else if (instance.subTree.component)
    return getComponentBoundingRect(instance.subTree.component);
  else
    return DEFAULT_RECT;
}

// src/core/component/tree/el.ts
init_esm_shims();
function getRootElementsFromComponentInstance(instance) {
  if (isFragment(instance))
    return getFragmentRootElements(instance.subTree);
  if (!instance.subTree)
    return [];
  return [instance.subTree.el];
}
function getFragmentRootElements(vnode) {
  if (!vnode.children)
    return [];
  const list = [];
  vnode.children.forEach((childVnode) => {
    if (childVnode.component)
      list.push(...getRootElementsFromComponentInstance(childVnode.component));
    else if (childVnode == null ? void 0 : childVnode.el)
      list.push(childVnode.el);
  });
  return list;
}

// src/core/component-highlighter/index.ts
var CONTAINER_ELEMENT_ID = "__vue-devtools-component-inspector__";
var CARD_ELEMENT_ID = "__vue-devtools-component-inspector__card__";
var COMPONENT_NAME_ELEMENT_ID = "__vue-devtools-component-inspector__name__";
var INDICATOR_ELEMENT_ID = "__vue-devtools-component-inspector__indicator__";
var containerStyles = {
  display: "block",
  zIndex: 2147483640,
  position: "fixed",
  backgroundColor: "#42b88325",
  border: "1px solid #42b88350",
  borderRadius: "5px",
  transition: "all 0.1s ease-in",
  pointerEvents: "none"
};
var cardStyles = {
  fontFamily: "Arial, Helvetica, sans-serif",
  padding: "5px 8px",
  borderRadius: "4px",
  textAlign: "left",
  position: "absolute",
  left: 0,
  color: "#e9e9e9",
  fontSize: "14px",
  fontWeight: 600,
  lineHeight: "24px",
  backgroundColor: "#42b883",
  boxShadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1)"
};
var indicatorStyles = {
  display: "inline-block",
  fontWeight: 400,
  fontStyle: "normal",
  fontSize: "12px",
  opacity: 0.7
};
function getContainerElement() {
  return document.getElementById(CONTAINER_ELEMENT_ID);
}
function getCardElement() {
  return document.getElementById(CARD_ELEMENT_ID);
}
function getIndicatorElement() {
  return document.getElementById(INDICATOR_ELEMENT_ID);
}
function getNameElement() {
  return document.getElementById(COMPONENT_NAME_ELEMENT_ID);
}
function getStyles(bounds) {
  return {
    left: `${Math.round(bounds.left * 100) / 100}px`,
    top: `${Math.round(bounds.top * 100) / 100}px`,
    width: `${Math.round(bounds.width * 100) / 100}px`,
    height: `${Math.round(bounds.height * 100) / 100}px`
  };
}
function create(options) {
  var _a25;
  const containerEl = document.createElement("div");
  containerEl.id = (_a25 = options.elementId) != null ? _a25 : CONTAINER_ELEMENT_ID;
  Object.assign(containerEl.style, {
    ...containerStyles,
    ...getStyles(options.bounds),
    ...options.style
  });
  const cardEl = document.createElement("span");
  cardEl.id = CARD_ELEMENT_ID;
  Object.assign(cardEl.style, {
    ...cardStyles,
    top: options.bounds.top < 35 ? 0 : "-35px"
  });
  const nameEl = document.createElement("span");
  nameEl.id = COMPONENT_NAME_ELEMENT_ID;
  nameEl.innerHTML = `&lt;${options.name}&gt;&nbsp;&nbsp;`;
  const indicatorEl = document.createElement("i");
  indicatorEl.id = INDICATOR_ELEMENT_ID;
  indicatorEl.innerHTML = `${Math.round(options.bounds.width * 100) / 100} x ${Math.round(options.bounds.height * 100) / 100}`;
  Object.assign(indicatorEl.style, indicatorStyles);
  cardEl.appendChild(nameEl);
  cardEl.appendChild(indicatorEl);
  containerEl.appendChild(cardEl);
  document.body.appendChild(containerEl);
  return containerEl;
}
function update(options) {
  const containerEl = getContainerElement();
  const cardEl = getCardElement();
  const nameEl = getNameElement();
  const indicatorEl = getIndicatorElement();
  if (containerEl) {
    Object.assign(containerEl.style, {
      ...containerStyles,
      ...getStyles(options.bounds)
    });
    Object.assign(cardEl.style, {
      top: options.bounds.top < 35 ? 0 : "-35px"
    });
    nameEl.innerHTML = `&lt;${options.name}&gt;&nbsp;&nbsp;`;
    indicatorEl.innerHTML = `${Math.round(options.bounds.width * 100) / 100} x ${Math.round(options.bounds.height * 100) / 100}`;
  }
}
function highlight(instance) {
  const bounds = getComponentBoundingRect(instance);
  if (!bounds.width && !bounds.height)
    return;
  const name = getInstanceName(instance);
  const container = getContainerElement();
  container ? update({ bounds, name }) : create({ bounds, name });
}
function unhighlight() {
  const el = getContainerElement();
  if (el)
    el.style.display = "none";
}
var inspectInstance = null;
function inspectFn(e) {
  const target22 = e.target;
  if (target22) {
    const instance = target22.__vueParentComponent;
    if (instance) {
      inspectInstance = instance;
      const el = instance.vnode.el;
      if (el) {
        const bounds = getComponentBoundingRect(instance);
        const name = getInstanceName(instance);
        const container = getContainerElement();
        container ? update({ bounds, name }) : create({ bounds, name });
      }
    }
  }
}
function selectComponentFn(e, cb) {
  e.preventDefault();
  e.stopPropagation();
  if (inspectInstance) {
    const uniqueComponentId = getUniqueComponentId(inspectInstance);
    cb(uniqueComponentId);
  }
}
var inspectComponentHighLighterSelectFn = null;
function cancelInspectComponentHighLighter() {
  unhighlight();
  window.removeEventListener("mouseover", inspectFn);
  window.removeEventListener("click", inspectComponentHighLighterSelectFn, true);
  inspectComponentHighLighterSelectFn = null;
}
function inspectComponentHighLighter() {
  window.addEventListener("mouseover", inspectFn);
  return new Promise((resolve) => {
    function onSelect(e) {
      e.preventDefault();
      e.stopPropagation();
      selectComponentFn(e, (id) => {
        window.removeEventListener("click", onSelect, true);
        inspectComponentHighLighterSelectFn = null;
        window.removeEventListener("mouseover", inspectFn);
        const el = getContainerElement();
        if (el)
          el.style.display = "none";
        resolve(JSON.stringify({ id }));
      });
    }
    inspectComponentHighLighterSelectFn = onSelect;
    window.addEventListener("click", onSelect, true);
  });
}
function scrollToComponent(options) {
  const instance = getComponentInstance(activeAppRecord.value, options.id);
  if (instance) {
    const [el] = getRootElementsFromComponentInstance(instance);
    if (typeof el.scrollIntoView === "function") {
      el.scrollIntoView({
        behavior: "smooth"
      });
    } else {
      const bounds = getComponentBoundingRect(instance);
      const scrollTarget = document.createElement("div");
      const styles = {
        ...getStyles(bounds),
        position: "absolute"
      };
      Object.assign(scrollTarget.style, styles);
      document.body.appendChild(scrollTarget);
      scrollTarget.scrollIntoView({
        behavior: "smooth"
      });
      setTimeout(() => {
        document.body.removeChild(scrollTarget);
      }, 2e3);
    }
    setTimeout(() => {
      const bounds = getComponentBoundingRect(instance);
      if (bounds.width || bounds.height) {
        const name = getInstanceName(instance);
        const el2 = getContainerElement();
        el2 ? update({ ...options, name, bounds }) : create({ ...options, name, bounds });
        setTimeout(() => {
          if (el2)
            el2.style.display = "none";
        }, 1500);
      }
    }, 1200);
  }
}

// src/core/component-inspector/index.ts
init_esm_shims();

var _a, _b;
(_b = (_a = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_COMPONENT_INSPECTOR_ENABLED__) != null ? _b : _a.__VUE_DEVTOOLS_COMPONENT_INSPECTOR_ENABLED__ = true;
function toggleComponentInspectorEnabled(enabled) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_COMPONENT_INSPECTOR_ENABLED__ = enabled;
}
function waitForInspectorInit(cb) {
  let total = 0;
  const timer = setInterval(() => {
    if (_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_INSPECTOR__) {
      clearInterval(timer);
      total += 30;
      cb();
    }
    if (total >= /* 5s */
    5e3)
      clearInterval(timer);
  }, 30);
}
function setupInspector() {
  const inspector = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_INSPECTOR__;
  const _openInEditor = inspector.openInEditor;
  inspector.openInEditor = async (...params) => {
    inspector.disable();
    _openInEditor(...params);
  };
}
function getComponentInspector() {
  return new Promise((resolve) => {
    function setup() {
      setupInspector();
      resolve(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_INSPECTOR__);
    }
    if (!_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_INSPECTOR__) {
      waitForInspectorInit(() => {
        setup();
      });
    } else {
      setup();
    }
  });
}

// src/core/component/state/editor.ts
init_esm_shims();

// src/shared/stub-vue.ts
init_esm_shims();
function isReadonly(value) {
  return !!(value && value["__v_isReadonly" /* IS_READONLY */]);
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw" /* RAW */]);
  }
  return !!(value && value["__v_isReactive" /* IS_REACTIVE */]);
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw" /* RAW */];
  return raw ? toRaw(raw) : observed;
}
var Fragment = Symbol.for("v-fgt");

// src/core/component/state/editor.ts
var StateEditor = class {
  constructor() {
    this.refEditor = new RefStateEditor();
  }
  set(object, path, value, cb) {
    const sections = Array.isArray(path) ? path : path.split(".");
    const markRef = false;
    while (sections.length > 1) {
      const section = sections.shift();
      if (object instanceof Map)
        object = object.get(section);
      else if (object instanceof Set)
        object = Array.from(object.values())[section];
      else object = object[section];
      if (this.refEditor.isRef(object))
        object = this.refEditor.get(object);
    }
    const field = sections[0];
    const item = this.refEditor.get(object)[field];
    if (cb) {
      cb(object, field, value);
    } else {
      if (this.refEditor.isRef(item))
        this.refEditor.set(item, value);
      else if (markRef)
        object[field] = value;
      else
        object[field] = value;
    }
  }
  get(object, path) {
    const sections = Array.isArray(path) ? path : path.split(".");
    for (let i = 0; i < sections.length; i++) {
      if (object instanceof Map)
        object = object.get(sections[i]);
      else
        object = object[sections[i]];
      if (this.refEditor.isRef(object))
        object = this.refEditor.get(object);
      if (!object)
        return void 0;
    }
    return object;
  }
  has(object, path, parent = false) {
    if (typeof object === "undefined")
      return false;
    const sections = Array.isArray(path) ? path.slice() : path.split(".");
    const size = !parent ? 1 : 2;
    while (object && sections.length > size) {
      const section = sections.shift();
      object = object[section];
      if (this.refEditor.isRef(object))
        object = this.refEditor.get(object);
    }
    return object != null && Object.prototype.hasOwnProperty.call(object, sections[0]);
  }
  createDefaultSetCallback(state) {
    return (object, field, value) => {
      if (state.remove || state.newKey) {
        if (Array.isArray(object))
          object.splice(field, 1);
        else if (toRaw(object) instanceof Map)
          object.delete(field);
        else if (toRaw(object) instanceof Set)
          object.delete(Array.from(object.values())[field]);
        else Reflect.deleteProperty(object, field);
      }
      if (!state.remove) {
        const target22 = object[state.newKey || field];
        if (this.refEditor.isRef(target22))
          this.refEditor.set(target22, value);
        else if (toRaw(object) instanceof Map)
          object.set(state.newKey || field, value);
        else if (toRaw(object) instanceof Set)
          object.add(value);
        else
          object[state.newKey || field] = value;
      }
    };
  }
};
var RefStateEditor = class {
  set(ref, value) {
    if (isRef(ref)) {
      ref.value = value;
    } else {
      if (ref instanceof Set && Array.isArray(value)) {
        ref.clear();
        value.forEach((v) => ref.add(v));
        return;
      }
      const currentKeys = Object.keys(value);
      if (ref instanceof Map) {
        const previousKeysSet2 = new Set(ref.keys());
        currentKeys.forEach((key) => {
          ref.set(key, Reflect.get(value, key));
          previousKeysSet2.delete(key);
        });
        previousKeysSet2.forEach((key) => ref.delete(key));
        return;
      }
      const previousKeysSet = new Set(Object.keys(ref));
      currentKeys.forEach((key) => {
        Reflect.set(ref, key, Reflect.get(value, key));
        previousKeysSet.delete(key);
      });
      previousKeysSet.forEach((key) => Reflect.deleteProperty(ref, key));
    }
  }
  get(ref) {
    return isRef(ref) ? ref.value : ref;
  }
  isRef(ref) {
    return isRef(ref) || isReactive(ref);
  }
};
async function editComponentState(payload, stateEditor2) {
  const { path, nodeId, state, type } = payload;
  const instance = getComponentInstance(activeAppRecord.value, nodeId);
  if (!instance)
    return;
  const targetPath = path.slice();
  let target22;
  if (Object.keys(instance.props).includes(path[0])) {
    target22 = instance.props;
  } else if (instance.devtoolsRawSetupState && Object.keys(instance.devtoolsRawSetupState).includes(path[0])) {
    target22 = instance.devtoolsRawSetupState;
  } else if (instance.data && Object.keys(instance.data).includes(path[0])) {
    target22 = instance.data;
  } else {
    target22 = instance.proxy;
  }
  if (target22 && targetPath) {
    if (state.type === "object" && type === "reactive") {
    }
    stateEditor2.set(target22, targetPath, state.value, stateEditor2.createDefaultSetCallback(state));
  }
}
var stateEditor = new StateEditor();
async function editState(payload) {
  editComponentState(payload, stateEditor);
}

// src/core/open-in-editor/index.ts
init_esm_shims();


// src/ctx/state.ts
init_esm_shims();



// src/core/timeline/storage.ts
init_esm_shims();

var TIMELINE_LAYERS_STATE_STORAGE_ID = "__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS_STATE__";
function addTimelineLayersStateToStorage(state) {
  if (!_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.isBrowser || typeof localStorage === "undefined" || localStorage === null) {
    return;
  }
  localStorage.setItem(TIMELINE_LAYERS_STATE_STORAGE_ID, JSON.stringify(state));
}
function getTimelineLayersStateFromStorage() {
  if (typeof window === "undefined" || !_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.isBrowser || typeof localStorage === "undefined" || localStorage === null) {
    return {
      recordingState: false,
      mouseEventEnabled: false,
      keyboardEventEnabled: false,
      componentEventEnabled: false,
      performanceEventEnabled: false,
      selected: ""
    };
  }
  const state = typeof localStorage.getItem !== "undefined" ? localStorage.getItem(TIMELINE_LAYERS_STATE_STORAGE_ID) : null;
  return state ? JSON.parse(state) : {
    recordingState: false,
    mouseEventEnabled: false,
    keyboardEventEnabled: false,
    componentEventEnabled: false,
    performanceEventEnabled: false,
    selected: ""
  };
}

// src/ctx/hook.ts
init_esm_shims();



// src/ctx/inspector.ts
init_esm_shims();



// src/ctx/timeline.ts
init_esm_shims();

var _a2, _b2;
(_b2 = (_a2 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS) != null ? _b2 : _a2.__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS = [];
var devtoolsTimelineLayers = new Proxy(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS, {
  get(target22, prop, receiver) {
    return Reflect.get(target22, prop, receiver);
  }
});
function addTimelineLayer(options, descriptor) {
  devtoolsState.timelineLayersState[descriptor.id] = false;
  devtoolsTimelineLayers.push({
    ...options,
    descriptorId: descriptor.id,
    appRecord: getAppRecord(descriptor.app)
  });
}
function updateTimelineLayersState(state) {
  const updatedState = {
    ...devtoolsState.timelineLayersState,
    ...state
  };
  addTimelineLayersStateToStorage(updatedState);
  updateDevToolsState({
    timelineLayersState: updatedState
  });
}

// src/ctx/inspector.ts
var _a3, _b3;
(_b3 = (_a3 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT_INSPECTOR__) != null ? _b3 : _a3.__VUE_DEVTOOLS_KIT_INSPECTOR__ = [];
var devtoolsInspector = new Proxy(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_INSPECTOR__, {
  get(target22, prop, receiver) {
    return Reflect.get(target22, prop, receiver);
  }
});
var callInspectorUpdatedHook = (0,perfect_debounce__WEBPACK_IMPORTED_MODULE_1__.debounce)(() => {
  devtoolsContext.hooks.callHook("sendInspectorToClient" /* SEND_INSPECTOR_TO_CLIENT */, getActiveInspectors());
});
function addInspector(inspector, descriptor) {
  var _a25, _b25;
  devtoolsInspector.push({
    options: inspector,
    descriptor,
    treeFilterPlaceholder: (_a25 = inspector.treeFilterPlaceholder) != null ? _a25 : "Search tree...",
    stateFilterPlaceholder: (_b25 = inspector.stateFilterPlaceholder) != null ? _b25 : "Search state...",
    treeFilter: "",
    selectedNodeId: "",
    appRecord: getAppRecord(descriptor.app)
  });
  callInspectorUpdatedHook();
}
function getActiveInspectors() {
  return devtoolsInspector.filter((inspector) => inspector.descriptor.app === activeAppRecord.value.app).filter((inspector) => inspector.descriptor.id !== "components").map((inspector) => {
    var _a25;
    const descriptor = inspector.descriptor;
    const options = inspector.options;
    return {
      id: options.id,
      label: options.label,
      logo: descriptor.logo,
      icon: `custom-ic-baseline-${(_a25 = options == null ? void 0 : options.icon) == null ? void 0 : _a25.replace(/_/g, "-")}`,
      packageName: descriptor.packageName,
      homepage: descriptor.homepage,
      pluginId: descriptor.id
    };
  });
}
function getInspectorInfo(id) {
  const inspector = getInspector(id, activeAppRecord.value.app);
  if (!inspector)
    return;
  const descriptor = inspector.descriptor;
  const options = inspector.options;
  const timelineLayers = devtoolsTimelineLayers.filter((layer) => layer.descriptorId === descriptor.id).map((item) => ({
    id: item.id,
    label: item.label,
    color: item.color
  }));
  return {
    id: options.id,
    label: options.label,
    logo: descriptor.logo,
    packageName: descriptor.packageName,
    homepage: descriptor.homepage,
    timelineLayers,
    treeFilterPlaceholder: inspector.treeFilterPlaceholder,
    stateFilterPlaceholder: inspector.stateFilterPlaceholder
  };
}
function getInspector(id, app) {
  return devtoolsInspector.find((inspector) => inspector.options.id === id && (app ? inspector.descriptor.app === app : true));
}
function getInspectorActions(id) {
  const inspector = getInspector(id);
  return inspector == null ? void 0 : inspector.options.actions;
}
function getInspectorNodeActions(id) {
  const inspector = getInspector(id);
  return inspector == null ? void 0 : inspector.options.nodeActions;
}

// src/ctx/hook.ts
var DevToolsV6PluginAPIHookKeys = /* @__PURE__ */ ((DevToolsV6PluginAPIHookKeys2) => {
  DevToolsV6PluginAPIHookKeys2["VISIT_COMPONENT_TREE"] = "visitComponentTree";
  DevToolsV6PluginAPIHookKeys2["INSPECT_COMPONENT"] = "inspectComponent";
  DevToolsV6PluginAPIHookKeys2["EDIT_COMPONENT_STATE"] = "editComponentState";
  DevToolsV6PluginAPIHookKeys2["GET_INSPECTOR_TREE"] = "getInspectorTree";
  DevToolsV6PluginAPIHookKeys2["GET_INSPECTOR_STATE"] = "getInspectorState";
  DevToolsV6PluginAPIHookKeys2["EDIT_INSPECTOR_STATE"] = "editInspectorState";
  DevToolsV6PluginAPIHookKeys2["INSPECT_TIMELINE_EVENT"] = "inspectTimelineEvent";
  DevToolsV6PluginAPIHookKeys2["TIMELINE_CLEARED"] = "timelineCleared";
  DevToolsV6PluginAPIHookKeys2["SET_PLUGIN_SETTINGS"] = "setPluginSettings";
  return DevToolsV6PluginAPIHookKeys2;
})(DevToolsV6PluginAPIHookKeys || {});
var DevToolsContextHookKeys = /* @__PURE__ */ ((DevToolsContextHookKeys2) => {
  DevToolsContextHookKeys2["ADD_INSPECTOR"] = "addInspector";
  DevToolsContextHookKeys2["SEND_INSPECTOR_TREE"] = "sendInspectorTree";
  DevToolsContextHookKeys2["SEND_INSPECTOR_STATE"] = "sendInspectorState";
  DevToolsContextHookKeys2["CUSTOM_INSPECTOR_SELECT_NODE"] = "customInspectorSelectNode";
  DevToolsContextHookKeys2["TIMELINE_LAYER_ADDED"] = "timelineLayerAdded";
  DevToolsContextHookKeys2["TIMELINE_EVENT_ADDED"] = "timelineEventAdded";
  DevToolsContextHookKeys2["GET_COMPONENT_INSTANCES"] = "getComponentInstances";
  DevToolsContextHookKeys2["GET_COMPONENT_BOUNDS"] = "getComponentBounds";
  DevToolsContextHookKeys2["GET_COMPONENT_NAME"] = "getComponentName";
  DevToolsContextHookKeys2["COMPONENT_HIGHLIGHT"] = "componentHighlight";
  DevToolsContextHookKeys2["COMPONENT_UNHIGHLIGHT"] = "componentUnhighlight";
  return DevToolsContextHookKeys2;
})(DevToolsContextHookKeys || {});
var DevToolsMessagingHookKeys = /* @__PURE__ */ ((DevToolsMessagingHookKeys2) => {
  DevToolsMessagingHookKeys2["SEND_INSPECTOR_TREE_TO_CLIENT"] = "sendInspectorTreeToClient";
  DevToolsMessagingHookKeys2["SEND_INSPECTOR_STATE_TO_CLIENT"] = "sendInspectorStateToClient";
  DevToolsMessagingHookKeys2["SEND_TIMELINE_EVENT_TO_CLIENT"] = "sendTimelineEventToClient";
  DevToolsMessagingHookKeys2["SEND_INSPECTOR_TO_CLIENT"] = "sendInspectorToClient";
  DevToolsMessagingHookKeys2["SEND_ACTIVE_APP_UNMOUNTED_TO_CLIENT"] = "sendActiveAppUpdatedToClient";
  DevToolsMessagingHookKeys2["DEVTOOLS_STATE_UPDATED"] = "devtoolsStateUpdated";
  DevToolsMessagingHookKeys2["DEVTOOLS_CONNECTED_UPDATED"] = "devtoolsConnectedUpdated";
  DevToolsMessagingHookKeys2["ROUTER_INFO_UPDATED"] = "routerInfoUpdated";
  return DevToolsMessagingHookKeys2;
})(DevToolsMessagingHookKeys || {});
function createDevToolsCtxHooks() {
  const hooks2 = (0,hookable__WEBPACK_IMPORTED_MODULE_2__.createHooks)();
  hooks2.hook("addInspector" /* ADD_INSPECTOR */, ({ inspector, plugin }) => {
    addInspector(inspector, plugin.descriptor);
  });
  const debounceSendInspectorTree = (0,perfect_debounce__WEBPACK_IMPORTED_MODULE_1__.debounce)(async ({ inspectorId, plugin }) => {
    var _a25;
    if (!inspectorId || !((_a25 = plugin == null ? void 0 : plugin.descriptor) == null ? void 0 : _a25.app) || devtoolsState.highPerfModeEnabled)
      return;
    const inspector = getInspector(inspectorId, plugin.descriptor.app);
    const _payload = {
      app: plugin.descriptor.app,
      inspectorId,
      filter: (inspector == null ? void 0 : inspector.treeFilter) || "",
      rootNodes: []
    };
    await new Promise((resolve) => {
      hooks2.callHookWith(async (callbacks) => {
        await Promise.all(callbacks.map((cb) => cb(_payload)));
        resolve();
      }, "getInspectorTree" /* GET_INSPECTOR_TREE */);
    });
    hooks2.callHookWith(async (callbacks) => {
      await Promise.all(callbacks.map((cb) => cb({
        inspectorId,
        rootNodes: _payload.rootNodes
      })));
    }, "sendInspectorTreeToClient" /* SEND_INSPECTOR_TREE_TO_CLIENT */);
  }, 120);
  hooks2.hook("sendInspectorTree" /* SEND_INSPECTOR_TREE */, debounceSendInspectorTree);
  const debounceSendInspectorState = (0,perfect_debounce__WEBPACK_IMPORTED_MODULE_1__.debounce)(async ({ inspectorId, plugin }) => {
    var _a25;
    if (!inspectorId || !((_a25 = plugin == null ? void 0 : plugin.descriptor) == null ? void 0 : _a25.app) || devtoolsState.highPerfModeEnabled)
      return;
    const inspector = getInspector(inspectorId, plugin.descriptor.app);
    const _payload = {
      app: plugin.descriptor.app,
      inspectorId,
      nodeId: (inspector == null ? void 0 : inspector.selectedNodeId) || "",
      state: null
    };
    const ctx = {
      currentTab: `custom-inspector:${inspectorId}`
    };
    if (_payload.nodeId) {
      await new Promise((resolve) => {
        hooks2.callHookWith(async (callbacks) => {
          await Promise.all(callbacks.map((cb) => cb(_payload, ctx)));
          resolve();
        }, "getInspectorState" /* GET_INSPECTOR_STATE */);
      });
    }
    hooks2.callHookWith(async (callbacks) => {
      await Promise.all(callbacks.map((cb) => cb({
        inspectorId,
        nodeId: _payload.nodeId,
        state: _payload.state
      })));
    }, "sendInspectorStateToClient" /* SEND_INSPECTOR_STATE_TO_CLIENT */);
  }, 120);
  hooks2.hook("sendInspectorState" /* SEND_INSPECTOR_STATE */, debounceSendInspectorState);
  hooks2.hook("customInspectorSelectNode" /* CUSTOM_INSPECTOR_SELECT_NODE */, ({ inspectorId, nodeId, plugin }) => {
    const inspector = getInspector(inspectorId, plugin.descriptor.app);
    if (!inspector)
      return;
    inspector.selectedNodeId = nodeId;
  });
  hooks2.hook("timelineLayerAdded" /* TIMELINE_LAYER_ADDED */, ({ options, plugin }) => {
    addTimelineLayer(options, plugin.descriptor);
  });
  hooks2.hook("timelineEventAdded" /* TIMELINE_EVENT_ADDED */, ({ options, plugin }) => {
    var _a25;
    const internalLayerIds = ["performance", "component-event", "keyboard", "mouse"];
    if (devtoolsState.highPerfModeEnabled || !((_a25 = devtoolsState.timelineLayersState) == null ? void 0 : _a25[plugin.descriptor.id]) && !internalLayerIds.includes(options.layerId))
      return;
    hooks2.callHookWith(async (callbacks) => {
      await Promise.all(callbacks.map((cb) => cb(options)));
    }, "sendTimelineEventToClient" /* SEND_TIMELINE_EVENT_TO_CLIENT */);
  });
  hooks2.hook("getComponentInstances" /* GET_COMPONENT_INSTANCES */, async ({ app }) => {
    const appRecord = app.__VUE_DEVTOOLS_NEXT_APP_RECORD__;
    if (!appRecord)
      return null;
    const appId = appRecord.id.toString();
    const instances = [...appRecord.instanceMap].filter(([key]) => key.split(":")[0] === appId).map(([, instance]) => instance);
    return instances;
  });
  hooks2.hook("getComponentBounds" /* GET_COMPONENT_BOUNDS */, async ({ instance }) => {
    const bounds = getComponentBoundingRect(instance);
    return bounds;
  });
  hooks2.hook("getComponentName" /* GET_COMPONENT_NAME */, ({ instance }) => {
    const name = getInstanceName(instance);
    return name;
  });
  hooks2.hook("componentHighlight" /* COMPONENT_HIGHLIGHT */, ({ uid }) => {
    const instance = activeAppRecord.value.instanceMap.get(uid);
    if (instance) {
      highlight(instance);
    }
  });
  hooks2.hook("componentUnhighlight" /* COMPONENT_UNHIGHLIGHT */, () => {
    unhighlight();
  });
  return hooks2;
}

// src/ctx/state.ts
var _a4, _b4;
(_b4 = (_a4 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT_APP_RECORDS__) != null ? _b4 : _a4.__VUE_DEVTOOLS_KIT_APP_RECORDS__ = [];
var _a5, _b5;
(_b5 = (_a5 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__) != null ? _b5 : _a5.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__ = {};
var _a6, _b6;
(_b6 = (_a6 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__) != null ? _b6 : _a6.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__ = "";
var _a7, _b7;
(_b7 = (_a7 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT_CUSTOM_TABS__) != null ? _b7 : _a7.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__ = [];
var _a8, _b8;
(_b8 = (_a8 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__) != null ? _b8 : _a8.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__ = [];
var STATE_KEY = "__VUE_DEVTOOLS_KIT_GLOBAL_STATE__";
function initStateFactory() {
  return {
    connected: false,
    clientConnected: false,
    vitePluginDetected: true,
    appRecords: [],
    activeAppRecordId: "",
    tabs: [],
    commands: [],
    highPerfModeEnabled: true,
    devtoolsClientDetected: {},
    perfUniqueGroupId: 0,
    timelineLayersState: getTimelineLayersStateFromStorage()
  };
}
var _a9, _b9;
(_b9 = (_a9 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target)[STATE_KEY]) != null ? _b9 : _a9[STATE_KEY] = initStateFactory();
var callStateUpdatedHook = (0,perfect_debounce__WEBPACK_IMPORTED_MODULE_1__.debounce)((state) => {
  devtoolsContext.hooks.callHook("devtoolsStateUpdated" /* DEVTOOLS_STATE_UPDATED */, { state });
});
var callConnectedUpdatedHook = (0,perfect_debounce__WEBPACK_IMPORTED_MODULE_1__.debounce)((state, oldState) => {
  devtoolsContext.hooks.callHook("devtoolsConnectedUpdated" /* DEVTOOLS_CONNECTED_UPDATED */, { state, oldState });
});
var devtoolsAppRecords = new Proxy(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_APP_RECORDS__, {
  get(_target, prop, receiver) {
    if (prop === "value")
      return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_APP_RECORDS__;
    return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_APP_RECORDS__[prop];
  }
});
var addDevToolsAppRecord = (app) => {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_APP_RECORDS__ = [
    ..._vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_APP_RECORDS__,
    app
  ];
};
var removeDevToolsAppRecord = (app) => {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_APP_RECORDS__ = devtoolsAppRecords.value.filter((record) => record.app !== app);
};
var activeAppRecord = new Proxy(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__, {
  get(_target, prop, receiver) {
    if (prop === "value")
      return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__;
    else if (prop === "id")
      return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__;
    return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__[prop];
  }
});
function updateAllStates() {
  callStateUpdatedHook({
    ..._vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[STATE_KEY],
    appRecords: devtoolsAppRecords.value,
    activeAppRecordId: activeAppRecord.id,
    tabs: _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__,
    commands: _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__
  });
}
function setActiveAppRecord(app) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__ = app;
  updateAllStates();
}
function setActiveAppRecordId(id) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__ = id;
  updateAllStates();
}
var devtoolsState = new Proxy(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[STATE_KEY], {
  get(target22, property) {
    if (property === "appRecords") {
      return devtoolsAppRecords;
    } else if (property === "activeAppRecordId") {
      return activeAppRecord.id;
    } else if (property === "tabs") {
      return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__;
    } else if (property === "commands") {
      return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__;
    }
    return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[STATE_KEY][property];
  },
  deleteProperty(target22, property) {
    delete target22[property];
    return true;
  },
  set(target22, property, value) {
    const oldState = { ..._vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[STATE_KEY] };
    target22[property] = value;
    _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[STATE_KEY][property] = value;
    return true;
  }
});
function resetDevToolsState() {
  Object.assign(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[STATE_KEY], initStateFactory());
}
function updateDevToolsState(state) {
  const oldState = {
    ..._vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[STATE_KEY],
    appRecords: devtoolsAppRecords.value,
    activeAppRecordId: activeAppRecord.id
  };
  if (oldState.connected !== state.connected && state.connected || oldState.clientConnected !== state.clientConnected && state.clientConnected) {
    callConnectedUpdatedHook(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[STATE_KEY], oldState);
  }
  Object.assign(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[STATE_KEY], state);
  updateAllStates();
}
function onDevToolsConnected(fn) {
  return new Promise((resolve) => {
    if (devtoolsState.connected) {
      fn();
      resolve();
    }
    devtoolsContext.hooks.hook("devtoolsConnectedUpdated" /* DEVTOOLS_CONNECTED_UPDATED */, ({ state }) => {
      if (state.connected) {
        fn();
        resolve();
      }
    });
  });
}
var resolveIcon = (icon) => {
  if (!icon)
    return;
  if (icon.startsWith("baseline-")) {
    return `custom-ic-${icon}`;
  }
  if (icon.startsWith("i-") || (0,_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.isUrlString)(icon))
    return icon;
  return `custom-ic-baseline-${icon}`;
};
function addCustomTab(tab) {
  const tabs = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__;
  if (tabs.some((t) => t.name === tab.name))
    return;
  tabs.push({
    ...tab,
    icon: resolveIcon(tab.icon)
  });
  updateAllStates();
}
function addCustomCommand(action) {
  const commands = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__;
  if (commands.some((t) => t.id === action.id))
    return;
  commands.push({
    ...action,
    icon: resolveIcon(action.icon),
    children: action.children ? action.children.map((child) => ({
      ...child,
      icon: resolveIcon(child.icon)
    })) : void 0
  });
  updateAllStates();
}
function removeCustomCommand(actionId) {
  const commands = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__;
  const index = commands.findIndex((t) => t.id === actionId);
  if (index === -1)
    return;
  commands.splice(index, 1);
  updateAllStates();
}
function toggleClientConnected(state) {
  updateDevToolsState({ clientConnected: state });
}

// src/core/open-in-editor/index.ts
function setOpenInEditorBaseUrl(url) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_OPEN_IN_EDITOR_BASE_URL__ = url;
}
function openInEditor(options = {}) {
  var _a25, _b25, _c;
  const { file, host, baseUrl = window.location.origin, line = 0, column = 0 } = options;
  if (file) {
    if (host === "chrome-extension") {
      const fileName = file.replace(/\\/g, "\\\\");
      const _baseUrl = (_b25 = (_a25 = window.VUE_DEVTOOLS_CONFIG) == null ? void 0 : _a25.openInEditorHost) != null ? _b25 : "/";
      fetch(`${_baseUrl}__open-in-editor?file=${encodeURI(file)}`).then((response) => {
        if (!response.ok) {
          const msg = `Opening component ${fileName} failed`;
          console.log(`%c${msg}`, "color:red");
        }
      });
    } else if (devtoolsState.vitePluginDetected) {
      const _baseUrl = (_c = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_OPEN_IN_EDITOR_BASE_URL__) != null ? _c : baseUrl;
      _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_INSPECTOR__.openInEditor(_baseUrl, file, line, column);
    }
  }
}

// src/core/plugin/index.ts
init_esm_shims();


// src/api/index.ts
init_esm_shims();

// src/api/v6/index.ts
init_esm_shims();

// src/core/plugin/plugin-settings.ts
init_esm_shims();

// src/ctx/plugin.ts
init_esm_shims();

var _a10, _b10;
(_b10 = (_a10 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT_PLUGIN_BUFFER__) != null ? _b10 : _a10.__VUE_DEVTOOLS_KIT_PLUGIN_BUFFER__ = [];
var devtoolsPluginBuffer = new Proxy(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_PLUGIN_BUFFER__, {
  get(target22, prop, receiver) {
    return Reflect.get(target22, prop, receiver);
  }
});
function addDevToolsPluginToBuffer(pluginDescriptor, setupFn) {
  devtoolsPluginBuffer.push([pluginDescriptor, setupFn]);
}

// src/core/plugin/plugin-settings.ts
function _getSettings(settings) {
  const _settings = {};
  Object.keys(settings).forEach((key) => {
    _settings[key] = settings[key].defaultValue;
  });
  return _settings;
}
function getPluginLocalKey(pluginId) {
  return `__VUE_DEVTOOLS_NEXT_PLUGIN_SETTINGS__${pluginId}__`;
}
function getPluginSettingsOptions(pluginId) {
  var _a25, _b25, _c;
  const item = (_b25 = (_a25 = devtoolsPluginBuffer.find((item2) => {
    var _a26;
    return item2[0].id === pluginId && !!((_a26 = item2[0]) == null ? void 0 : _a26.settings);
  })) == null ? void 0 : _a25[0]) != null ? _b25 : null;
  return (_c = item == null ? void 0 : item.settings) != null ? _c : null;
}
function getPluginSettings(pluginId, fallbackValue) {
  var _a25, _b25, _c;
  const localKey = getPluginLocalKey(pluginId);
  if (localKey) {
    const localSettings = localStorage.getItem(localKey);
    if (localSettings) {
      return JSON.parse(localSettings);
    }
  }
  if (pluginId) {
    const item = (_b25 = (_a25 = devtoolsPluginBuffer.find((item2) => item2[0].id === pluginId)) == null ? void 0 : _a25[0]) != null ? _b25 : null;
    return _getSettings((_c = item == null ? void 0 : item.settings) != null ? _c : {});
  }
  return _getSettings(fallbackValue);
}
function initPluginSettings(pluginId, settings) {
  const localKey = getPluginLocalKey(pluginId);
  const localSettings = localStorage.getItem(localKey);
  if (!localSettings) {
    localStorage.setItem(localKey, JSON.stringify(_getSettings(settings)));
  }
}
function setPluginSettings(pluginId, key, value) {
  const localKey = getPluginLocalKey(pluginId);
  const localSettings = localStorage.getItem(localKey);
  const parsedLocalSettings = JSON.parse(localSettings || "{}");
  const updated = {
    ...parsedLocalSettings,
    [key]: value
  };
  localStorage.setItem(localKey, JSON.stringify(updated));
  devtoolsContext.hooks.callHookWith((callbacks) => {
    callbacks.forEach((cb) => cb({
      pluginId,
      key,
      oldValue: parsedLocalSettings[key],
      newValue: value,
      settings: updated
    }));
  }, "setPluginSettings" /* SET_PLUGIN_SETTINGS */);
}

// src/hook/index.ts
init_esm_shims();



// src/types/index.ts
init_esm_shims();

// src/types/app.ts
init_esm_shims();

// src/types/command.ts
init_esm_shims();

// src/types/component.ts
init_esm_shims();

// src/types/hook.ts
init_esm_shims();

// src/types/inspector.ts
init_esm_shims();

// src/types/plugin.ts
init_esm_shims();

// src/types/router.ts
init_esm_shims();

// src/types/tab.ts
init_esm_shims();

// src/types/timeline.ts
init_esm_shims();

// src/hook/index.ts
var _a11, _b11;
var devtoolsHooks = (_b11 = (_a11 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_HOOK) != null ? _b11 : _a11.__VUE_DEVTOOLS_HOOK = (0,hookable__WEBPACK_IMPORTED_MODULE_2__.createHooks)();
var on = {
  vueAppInit(fn) {
    devtoolsHooks.hook("app:init" /* APP_INIT */, fn);
  },
  vueAppUnmount(fn) {
    devtoolsHooks.hook("app:unmount" /* APP_UNMOUNT */, fn);
  },
  vueAppConnected(fn) {
    devtoolsHooks.hook("app:connected" /* APP_CONNECTED */, fn);
  },
  componentAdded(fn) {
    return devtoolsHooks.hook("component:added" /* COMPONENT_ADDED */, fn);
  },
  componentEmit(fn) {
    return devtoolsHooks.hook("component:emit" /* COMPONENT_EMIT */, fn);
  },
  componentUpdated(fn) {
    return devtoolsHooks.hook("component:updated" /* COMPONENT_UPDATED */, fn);
  },
  componentRemoved(fn) {
    return devtoolsHooks.hook("component:removed" /* COMPONENT_REMOVED */, fn);
  },
  setupDevtoolsPlugin(fn) {
    devtoolsHooks.hook("devtools-plugin:setup" /* SETUP_DEVTOOLS_PLUGIN */, fn);
  },
  perfStart(fn) {
    return devtoolsHooks.hook("perf:start" /* PERFORMANCE_START */, fn);
  },
  perfEnd(fn) {
    return devtoolsHooks.hook("perf:end" /* PERFORMANCE_END */, fn);
  }
};
function createDevToolsHook() {
  return {
    id: "vue-devtools-next",
    devtoolsVersion: "7.0",
    enabled: false,
    appRecords: [],
    apps: [],
    events: /* @__PURE__ */ new Map(),
    on(event, fn) {
      var _a25;
      if (!this.events.has(event))
        this.events.set(event, []);
      (_a25 = this.events.get(event)) == null ? void 0 : _a25.push(fn);
      return () => this.off(event, fn);
    },
    once(event, fn) {
      const onceFn = (...args) => {
        this.off(event, onceFn);
        fn(...args);
      };
      this.on(event, onceFn);
      return [event, onceFn];
    },
    off(event, fn) {
      if (this.events.has(event)) {
        const eventCallbacks = this.events.get(event);
        const index = eventCallbacks.indexOf(fn);
        if (index !== -1)
          eventCallbacks.splice(index, 1);
      }
    },
    emit(event, ...payload) {
      if (this.events.has(event))
        this.events.get(event).forEach((fn) => fn(...payload));
    }
  };
}
function subscribeDevToolsHook(hook2) {
  hook2.on("app:init" /* APP_INIT */, (app, version, types) => {
    var _a25, _b25, _c;
    if ((_c = (_b25 = (_a25 = app == null ? void 0 : app._instance) == null ? void 0 : _a25.type) == null ? void 0 : _b25.devtools) == null ? void 0 : _c.hide)
      return;
    devtoolsHooks.callHook("app:init" /* APP_INIT */, app, version, types);
  });
  hook2.on("app:unmount" /* APP_UNMOUNT */, (app) => {
    devtoolsHooks.callHook("app:unmount" /* APP_UNMOUNT */, app);
  });
  hook2.on("component:added" /* COMPONENT_ADDED */, async (app, uid, parentUid, component) => {
    var _a25, _b25, _c;
    if (((_c = (_b25 = (_a25 = app == null ? void 0 : app._instance) == null ? void 0 : _a25.type) == null ? void 0 : _b25.devtools) == null ? void 0 : _c.hide) || devtoolsState.highPerfModeEnabled)
      return;
    if (!app || typeof uid !== "number" && !uid || !component)
      return;
    devtoolsHooks.callHook("component:added" /* COMPONENT_ADDED */, app, uid, parentUid, component);
  });
  hook2.on("component:updated" /* COMPONENT_UPDATED */, (app, uid, parentUid, component) => {
    if (!app || typeof uid !== "number" && !uid || !component || devtoolsState.highPerfModeEnabled)
      return;
    devtoolsHooks.callHook("component:updated" /* COMPONENT_UPDATED */, app, uid, parentUid, component);
  });
  hook2.on("component:removed" /* COMPONENT_REMOVED */, async (app, uid, parentUid, component) => {
    if (!app || typeof uid !== "number" && !uid || !component || devtoolsState.highPerfModeEnabled)
      return;
    devtoolsHooks.callHook("component:removed" /* COMPONENT_REMOVED */, app, uid, parentUid, component);
  });
  hook2.on("component:emit" /* COMPONENT_EMIT */, async (app, instance, event, params) => {
    if (!app || !instance || devtoolsState.highPerfModeEnabled)
      return;
    devtoolsHooks.callHook("component:emit" /* COMPONENT_EMIT */, app, instance, event, params);
  });
  hook2.on("perf:start" /* PERFORMANCE_START */, (app, uid, vm, type, time) => {
    if (!app || devtoolsState.highPerfModeEnabled)
      return;
    devtoolsHooks.callHook("perf:start" /* PERFORMANCE_START */, app, uid, vm, type, time);
  });
  hook2.on("perf:end" /* PERFORMANCE_END */, (app, uid, vm, type, time) => {
    if (!app || devtoolsState.highPerfModeEnabled)
      return;
    devtoolsHooks.callHook("perf:end" /* PERFORMANCE_END */, app, uid, vm, type, time);
  });
  hook2.on("devtools-plugin:setup" /* SETUP_DEVTOOLS_PLUGIN */, (pluginDescriptor, setupFn, options) => {
    if ((options == null ? void 0 : options.target) === "legacy")
      return;
    devtoolsHooks.callHook("devtools-plugin:setup" /* SETUP_DEVTOOLS_PLUGIN */, pluginDescriptor, setupFn);
  });
}
var hook = {
  on,
  setupDevToolsPlugin(pluginDescriptor, setupFn) {
    return devtoolsHooks.callHook("devtools-plugin:setup" /* SETUP_DEVTOOLS_PLUGIN */, pluginDescriptor, setupFn);
  }
};

// src/api/v6/index.ts
var DevToolsV6PluginAPI = class {
  constructor({ plugin, ctx }) {
    this.hooks = ctx.hooks;
    this.plugin = plugin;
  }
  get on() {
    return {
      // component inspector
      visitComponentTree: (handler) => {
        this.hooks.hook("visitComponentTree" /* VISIT_COMPONENT_TREE */, handler);
      },
      inspectComponent: (handler) => {
        this.hooks.hook("inspectComponent" /* INSPECT_COMPONENT */, handler);
      },
      editComponentState: (handler) => {
        this.hooks.hook("editComponentState" /* EDIT_COMPONENT_STATE */, handler);
      },
      // custom inspector
      getInspectorTree: (handler) => {
        this.hooks.hook("getInspectorTree" /* GET_INSPECTOR_TREE */, handler);
      },
      getInspectorState: (handler) => {
        this.hooks.hook("getInspectorState" /* GET_INSPECTOR_STATE */, handler);
      },
      editInspectorState: (handler) => {
        this.hooks.hook("editInspectorState" /* EDIT_INSPECTOR_STATE */, handler);
      },
      // timeline
      inspectTimelineEvent: (handler) => {
        this.hooks.hook("inspectTimelineEvent" /* INSPECT_TIMELINE_EVENT */, handler);
      },
      timelineCleared: (handler) => {
        this.hooks.hook("timelineCleared" /* TIMELINE_CLEARED */, handler);
      },
      // settings
      setPluginSettings: (handler) => {
        this.hooks.hook("setPluginSettings" /* SET_PLUGIN_SETTINGS */, handler);
      }
    };
  }
  // component inspector
  notifyComponentUpdate(instance) {
    var _a25;
    if (devtoolsState.highPerfModeEnabled) {
      return;
    }
    const inspector = getActiveInspectors().find((i) => i.packageName === this.plugin.descriptor.packageName);
    if (inspector == null ? void 0 : inspector.id) {
      if (instance) {
        const args = [
          instance.appContext.app,
          instance.uid,
          (_a25 = instance.parent) == null ? void 0 : _a25.uid,
          instance
        ];
        devtoolsHooks.callHook("component:updated" /* COMPONENT_UPDATED */, ...args);
      } else {
        devtoolsHooks.callHook("component:updated" /* COMPONENT_UPDATED */);
      }
      this.hooks.callHook("sendInspectorState" /* SEND_INSPECTOR_STATE */, { inspectorId: inspector.id, plugin: this.plugin });
    }
  }
  // custom inspector
  addInspector(options) {
    this.hooks.callHook("addInspector" /* ADD_INSPECTOR */, { inspector: options, plugin: this.plugin });
    if (this.plugin.descriptor.settings) {
      initPluginSettings(options.id, this.plugin.descriptor.settings);
    }
  }
  sendInspectorTree(inspectorId) {
    if (devtoolsState.highPerfModeEnabled) {
      return;
    }
    this.hooks.callHook("sendInspectorTree" /* SEND_INSPECTOR_TREE */, { inspectorId, plugin: this.plugin });
  }
  sendInspectorState(inspectorId) {
    if (devtoolsState.highPerfModeEnabled) {
      return;
    }
    this.hooks.callHook("sendInspectorState" /* SEND_INSPECTOR_STATE */, { inspectorId, plugin: this.plugin });
  }
  selectInspectorNode(inspectorId, nodeId) {
    this.hooks.callHook("customInspectorSelectNode" /* CUSTOM_INSPECTOR_SELECT_NODE */, { inspectorId, nodeId, plugin: this.plugin });
  }
  visitComponentTree(payload) {
    return this.hooks.callHook("visitComponentTree" /* VISIT_COMPONENT_TREE */, payload);
  }
  // timeline
  now() {
    if (devtoolsState.highPerfModeEnabled) {
      return 0;
    }
    return Date.now();
  }
  addTimelineLayer(options) {
    this.hooks.callHook("timelineLayerAdded" /* TIMELINE_LAYER_ADDED */, { options, plugin: this.plugin });
  }
  addTimelineEvent(options) {
    if (devtoolsState.highPerfModeEnabled) {
      return;
    }
    this.hooks.callHook("timelineEventAdded" /* TIMELINE_EVENT_ADDED */, { options, plugin: this.plugin });
  }
  // settings
  getSettings(pluginId) {
    return getPluginSettings(pluginId != null ? pluginId : this.plugin.descriptor.id, this.plugin.descriptor.settings);
  }
  // utilities
  getComponentInstances(app) {
    return this.hooks.callHook("getComponentInstances" /* GET_COMPONENT_INSTANCES */, { app });
  }
  getComponentBounds(instance) {
    return this.hooks.callHook("getComponentBounds" /* GET_COMPONENT_BOUNDS */, { instance });
  }
  getComponentName(instance) {
    return this.hooks.callHook("getComponentName" /* GET_COMPONENT_NAME */, { instance });
  }
  highlightElement(instance) {
    const uid = instance.__VUE_DEVTOOLS_NEXT_UID__;
    return this.hooks.callHook("componentHighlight" /* COMPONENT_HIGHLIGHT */, { uid });
  }
  unhighlightElement() {
    return this.hooks.callHook("componentUnhighlight" /* COMPONENT_UNHIGHLIGHT */);
  }
};

// src/api/index.ts
var DevToolsPluginAPI = DevToolsV6PluginAPI;

// src/core/plugin/components.ts
init_esm_shims();


// src/core/component/state/index.ts
init_esm_shims();

// src/core/component/state/process.ts
init_esm_shims();


// src/core/component/state/constants.ts
init_esm_shims();
var vueBuiltins = /* @__PURE__ */ new Set([
  "nextTick",
  "defineComponent",
  "defineAsyncComponent",
  "defineCustomElement",
  "ref",
  "computed",
  "reactive",
  "readonly",
  "watchEffect",
  "watchPostEffect",
  "watchSyncEffect",
  "watch",
  "isRef",
  "unref",
  "toRef",
  "toRefs",
  "isProxy",
  "isReactive",
  "isReadonly",
  "shallowRef",
  "triggerRef",
  "customRef",
  "shallowReactive",
  "shallowReadonly",
  "toRaw",
  "markRaw",
  "effectScope",
  "getCurrentScope",
  "onScopeDispose",
  "onMounted",
  "onUpdated",
  "onUnmounted",
  "onBeforeMount",
  "onBeforeUpdate",
  "onBeforeUnmount",
  "onErrorCaptured",
  "onRenderTracked",
  "onRenderTriggered",
  "onActivated",
  "onDeactivated",
  "onServerPrefetch",
  "provide",
  "inject",
  "h",
  "mergeProps",
  "cloneVNode",
  "isVNode",
  "resolveComponent",
  "resolveDirective",
  "withDirectives",
  "withModifiers"
]);
var symbolRE = /^\[native Symbol Symbol\((.*)\)\]$/;
var rawTypeRE = /^\[object (\w+)\]$/;
var specialTypeRE = /^\[native (\w+) (.*?)(<>(([\s\S])*))?\]$/;
var fnTypeRE = /^(?:function|class) (\w+)/;
var MAX_STRING_SIZE = 1e4;
var MAX_ARRAY_SIZE = 5e3;
var UNDEFINED = "__vue_devtool_undefined__";
var INFINITY = "__vue_devtool_infinity__";
var NEGATIVE_INFINITY = "__vue_devtool_negative_infinity__";
var NAN = "__vue_devtool_nan__";
var ESC = {
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "&": "&amp;"
};

// src/core/component/state/util.ts
init_esm_shims();

// src/core/component/state/is.ts
init_esm_shims();
function isVueInstance(value) {
  if (!ensurePropertyExists(value, "_")) {
    return false;
  }
  if (!isPlainObject(value._)) {
    return false;
  }
  return Object.keys(value._).includes("vnode");
}
function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function isPrimitive(data) {
  if (data == null)
    return true;
  const type = typeof data;
  return type === "string" || type === "number" || type === "boolean";
}
function isRef2(raw) {
  return !!raw.__v_isRef;
}
function isComputed(raw) {
  return isRef2(raw) && !!raw.effect;
}
function isReactive2(raw) {
  return !!raw.__v_isReactive;
}
function isReadOnly(raw) {
  return !!raw.__v_isReadonly;
}

// src/core/component/state/util.ts
var tokenMap = {
  [UNDEFINED]: "undefined",
  [NAN]: "NaN",
  [INFINITY]: "Infinity",
  [NEGATIVE_INFINITY]: "-Infinity"
};
var reversedTokenMap = Object.entries(tokenMap).reduce((acc, [key, value]) => {
  acc[value] = key;
  return acc;
}, {});
function internalStateTokenToString(value) {
  if (value === null)
    return "null";
  return typeof value === "string" && tokenMap[value] || false;
}
function replaceTokenToString(value) {
  const replaceRegex = new RegExp(`"(${Object.keys(tokenMap).join("|")})"`, "g");
  return value.replace(replaceRegex, (_, g1) => tokenMap[g1]);
}
function replaceStringToToken(value) {
  const literalValue = reversedTokenMap[value.trim()];
  if (literalValue)
    return `"${literalValue}"`;
  const replaceRegex = new RegExp(`:\\s*(${Object.keys(reversedTokenMap).join("|")})`, "g");
  return value.replace(replaceRegex, (_, g1) => `:"${reversedTokenMap[g1]}"`);
}
function getPropType(type) {
  if (Array.isArray(type))
    return type.map((t) => getPropType(t)).join(" or ");
  if (type == null)
    return "null";
  const match = type.toString().match(fnTypeRE);
  return typeof type === "function" ? match && match[1] || "any" : "any";
}
function sanitize(data) {
  if (!isPrimitive(data) && !Array.isArray(data) && !isPlainObject(data)) {
    return Object.prototype.toString.call(data);
  } else {
    return data;
  }
}
function getSetupStateType(raw) {
  try {
    return {
      ref: isRef2(raw),
      computed: isComputed(raw),
      reactive: isReactive2(raw),
      readonly: isReadOnly(raw)
    };
  } catch (e) {
    return {
      ref: false,
      computed: false,
      reactive: false,
      readonly: false
    };
  }
}
function toRaw2(value) {
  if (value == null ? void 0 : value.__v_raw)
    return value.__v_raw;
  return value;
}
function escape(s) {
  return s.replace(/[<>"&]/g, (s2) => {
    return ESC[s2] || s2;
  });
}

// src/core/component/state/process.ts
function mergeOptions(to, from, instance) {
  if (typeof from === "function")
    from = from.options;
  if (!from)
    return to;
  const { mixins, extends: extendsOptions } = from;
  extendsOptions && mergeOptions(to, extendsOptions, instance);
  mixins && mixins.forEach(
    (m) => mergeOptions(to, m, instance)
  );
  for (const key of ["computed", "inject"]) {
    if (Object.prototype.hasOwnProperty.call(from, key)) {
      if (!to[key])
        to[key] = from[key];
      else
        Object.assign(to[key], from[key]);
    }
  }
  return to;
}
function resolveMergedOptions(instance) {
  const raw = instance == null ? void 0 : instance.type;
  if (!raw)
    return {};
  const { mixins, extends: extendsOptions } = raw;
  const globalMixins = instance.appContext.mixins;
  if (!globalMixins.length && !mixins && !extendsOptions)
    return raw;
  const options = {};
  globalMixins.forEach((m) => mergeOptions(options, m, instance));
  mergeOptions(options, raw, instance);
  return options;
}
function processProps(instance) {
  var _a25;
  const props = [];
  const propDefinitions = (_a25 = instance == null ? void 0 : instance.type) == null ? void 0 : _a25.props;
  for (const key in instance == null ? void 0 : instance.props) {
    const propDefinition = propDefinitions ? propDefinitions[key] : null;
    const camelizeKey = (0,_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(key);
    props.push({
      type: "props",
      key: camelizeKey,
      value: returnError(() => instance.props[key]),
      editable: true,
      meta: propDefinition ? {
        type: propDefinition.type ? getPropType(propDefinition.type) : "any",
        required: !!propDefinition.required,
        ...propDefinition.default ? {
          default: propDefinition.default.toString()
        } : {}
      } : { type: "invalid" }
    });
  }
  return props;
}
function processState(instance) {
  const type = instance.type;
  const props = type == null ? void 0 : type.props;
  const getters = type.vuex && type.vuex.getters;
  const computedDefs = type.computed;
  const data = {
    ...instance.data,
    ...instance.renderContext
  };
  return Object.keys(data).filter((key) => !(props && key in props) && !(getters && key in getters) && !(computedDefs && key in computedDefs)).map((key) => ({
    key,
    type: "data",
    value: returnError(() => data[key]),
    editable: true
  }));
}
function getStateTypeAndName(info) {
  const stateType = info.computed ? "computed" : info.ref ? "ref" : info.reactive ? "reactive" : null;
  const stateTypeName = stateType ? `${stateType.charAt(0).toUpperCase()}${stateType.slice(1)}` : null;
  return {
    stateType,
    stateTypeName
  };
}
function processSetupState(instance) {
  const raw = instance.devtoolsRawSetupState || {};
  return Object.keys(instance.setupState).filter((key) => !vueBuiltins.has(key) && key.split(/(?=[A-Z])/)[0] !== "use").map((key) => {
    var _a25, _b25, _c, _d;
    const value = returnError(() => toRaw2(instance.setupState[key]));
    const accessError = value instanceof Error;
    const rawData = raw[key];
    let result;
    let isOtherType = accessError || typeof value === "function" || ensurePropertyExists(value, "render") && typeof value.render === "function" || ensurePropertyExists(value, "__asyncLoader") && typeof value.__asyncLoader === "function" || typeof value === "object" && value && ("setup" in value || "props" in value) || /^v[A-Z]/.test(key);
    if (rawData && !accessError) {
      const info = getSetupStateType(rawData);
      const { stateType, stateTypeName } = getStateTypeAndName(info);
      const isState = info.ref || info.computed || info.reactive;
      const raw2 = ensurePropertyExists(rawData, "effect") ? ((_b25 = (_a25 = rawData.effect) == null ? void 0 : _a25.raw) == null ? void 0 : _b25.toString()) || ((_d = (_c = rawData.effect) == null ? void 0 : _c.fn) == null ? void 0 : _d.toString()) : null;
      if (stateType)
        isOtherType = false;
      result = {
        ...stateType ? { stateType, stateTypeName } : {},
        ...raw2 ? { raw: raw2 } : {},
        editable: isState && !info.readonly
      };
    }
    const type = isOtherType ? "setup (other)" : "setup";
    return {
      key,
      value,
      type,
      // @ts-expect-error ignore
      ...result
    };
  });
}
function processComputed(instance, mergedType) {
  const type = mergedType;
  const computed = [];
  const defs = type.computed || {};
  for (const key in defs) {
    const def = defs[key];
    const type2 = typeof def === "function" && def.vuex ? "vuex bindings" : "computed";
    computed.push({
      type: type2,
      key,
      value: returnError(() => {
        var _a25;
        return (_a25 = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a25[key];
      }),
      editable: typeof def.set === "function"
    });
  }
  return computed;
}
function processAttrs(instance) {
  return Object.keys(instance.attrs).map((key) => ({
    type: "attrs",
    key,
    value: returnError(() => instance.attrs[key])
  }));
}
function processProvide(instance) {
  return Reflect.ownKeys(instance.provides).map((key) => ({
    type: "provided",
    key: key.toString(),
    value: returnError(() => instance.provides[key])
  }));
}
function processInject(instance, mergedType) {
  if (!(mergedType == null ? void 0 : mergedType.inject))
    return [];
  let keys = [];
  let defaultValue;
  if (Array.isArray(mergedType.inject)) {
    keys = mergedType.inject.map((key) => ({
      key,
      originalKey: key
    }));
  } else {
    keys = Reflect.ownKeys(mergedType.inject).map((key) => {
      const value = mergedType.inject[key];
      let originalKey;
      if (typeof value === "string" || typeof value === "symbol") {
        originalKey = value;
      } else {
        originalKey = value.from;
        defaultValue = value.default;
      }
      return {
        key,
        originalKey
      };
    });
  }
  return keys.map(({ key, originalKey }) => ({
    type: "injected",
    key: originalKey && key !== originalKey ? `${originalKey.toString()} \u279E ${key.toString()}` : key.toString(),
    // eslint-disable-next-line no-prototype-builtins
    value: returnError(() => instance.ctx.hasOwnProperty(key) ? instance.ctx[key] : instance.provides.hasOwnProperty(originalKey) ? instance.provides[originalKey] : defaultValue)
  }));
}
function processRefs(instance) {
  return Object.keys(instance.refs).map((key) => ({
    type: "template refs",
    key,
    value: returnError(() => instance.refs[key])
  }));
}
function processEventListeners(instance) {
  var _a25, _b25;
  const emitsDefinition = instance.type.emits;
  const declaredEmits = Array.isArray(emitsDefinition) ? emitsDefinition : Object.keys(emitsDefinition != null ? emitsDefinition : {});
  const keys = Object.keys((_b25 = (_a25 = instance == null ? void 0 : instance.vnode) == null ? void 0 : _a25.props) != null ? _b25 : {});
  const result = [];
  for (const key of keys) {
    const [prefix, ...eventNameParts] = key.split(/(?=[A-Z])/);
    if (prefix === "on") {
      const eventName = eventNameParts.join("-").toLowerCase();
      const isDeclared = declaredEmits.includes(eventName);
      result.push({
        type: "event listeners",
        key: eventName,
        value: {
          _custom: {
            displayText: isDeclared ? "\u2705 Declared" : "\u26A0\uFE0F Not declared",
            key: isDeclared ? "\u2705 Declared" : "\u26A0\uFE0F Not declared",
            value: isDeclared ? "\u2705 Declared" : "\u26A0\uFE0F Not declared",
            tooltipText: !isDeclared ? `The event <code>${eventName}</code> is not declared in the <code>emits</code> option. It will leak into the component's attributes (<code>$attrs</code>).` : null
          }
        }
      });
    }
  }
  return result;
}
function processInstanceState(instance) {
  const mergedType = resolveMergedOptions(instance);
  return processProps(instance).concat(
    processState(instance),
    processSetupState(instance),
    processComputed(instance, mergedType),
    processAttrs(instance),
    processProvide(instance),
    processInject(instance, mergedType),
    processRefs(instance),
    processEventListeners(instance)
  );
}

// src/core/component/state/index.ts
function getInstanceState(params) {
  var _a25;
  const instance = getComponentInstance(activeAppRecord.value, params.instanceId);
  const id = getUniqueComponentId(instance);
  const name = getInstanceName(instance);
  const file = (_a25 = instance == null ? void 0 : instance.type) == null ? void 0 : _a25.__file;
  const state = processInstanceState(instance);
  return {
    id,
    name,
    file,
    state,
    instance
  };
}

// src/core/component/tree/walker.ts
init_esm_shims();

// src/core/component/tree/filter.ts
init_esm_shims();

var ComponentFilter = class {
  constructor(filter) {
    this.filter = filter || "";
  }
  /**
   * Check if an instance is qualified.
   *
   * @param {Vue|Vnode} instance
   * @return {boolean}
   */
  isQualified(instance) {
    const name = getInstanceName(instance);
    return (0,_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.classify)(name).toLowerCase().includes(this.filter) || (0,_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.kebabize)(name).toLowerCase().includes(this.filter);
  }
};
function createComponentFilter(filterText) {
  return new ComponentFilter(filterText);
}

// src/core/component/tree/walker.ts
var ComponentWalker = class {
  constructor(options) {
    // Dedupe instances (Some instances may be both on a component and on a child abstract/functional component)
    this.captureIds = /* @__PURE__ */ new Map();
    const { filterText = "", maxDepth, recursively, api } = options;
    this.componentFilter = createComponentFilter(filterText);
    this.maxDepth = maxDepth;
    this.recursively = recursively;
    this.api = api;
  }
  getComponentTree(instance) {
    this.captureIds = /* @__PURE__ */ new Map();
    return this.findQualifiedChildren(instance, 0);
  }
  getComponentParents(instance) {
    this.captureIds = /* @__PURE__ */ new Map();
    const parents = [];
    this.captureId(instance);
    let parent = instance;
    while (parent = parent.parent) {
      this.captureId(parent);
      parents.push(parent);
    }
    return parents;
  }
  captureId(instance) {
    if (!instance)
      return null;
    const id = instance.__VUE_DEVTOOLS_NEXT_UID__ != null ? instance.__VUE_DEVTOOLS_NEXT_UID__ : getUniqueComponentId(instance);
    instance.__VUE_DEVTOOLS_NEXT_UID__ = id;
    if (this.captureIds.has(id))
      return null;
    else
      this.captureIds.set(id, void 0);
    this.mark(instance);
    return id;
  }
  /**
   * Capture the meta information of an instance. (recursive)
   *
   * @param {Vue} instance
   * @return {object}
   */
  async capture(instance, depth) {
    var _a25;
    if (!instance)
      return null;
    const id = this.captureId(instance);
    const name = getInstanceName(instance);
    const children = this.getInternalInstanceChildren(instance.subTree).filter((child) => !isBeingDestroyed(child));
    const parents = this.getComponentParents(instance) || [];
    const inactive = !!instance.isDeactivated || parents.some((parent) => parent.isDeactivated);
    const treeNode = {
      uid: instance.uid,
      id,
      name,
      renderKey: getRenderKey(instance.vnode ? instance.vnode.key : null),
      inactive,
      children: [],
      isFragment: isFragment(instance),
      tags: typeof instance.type !== "function" ? [] : [
        {
          label: "functional",
          textColor: 5592405,
          backgroundColor: 15658734
        }
      ],
      autoOpen: this.recursively,
      file: instance.type.__file || ""
    };
    if (depth < this.maxDepth || instance.type.__isKeepAlive || parents.some((parent) => parent.type.__isKeepAlive)) {
      treeNode.children = await Promise.all(children.map((child) => this.capture(child, depth + 1)).filter(Boolean));
    }
    if (this.isKeepAlive(instance)) {
      const cachedComponents = this.getKeepAliveCachedInstances(instance);
      const childrenIds = children.map((child) => child.__VUE_DEVTOOLS_NEXT_UID__);
      for (const cachedChild of cachedComponents) {
        if (!childrenIds.includes(cachedChild.__VUE_DEVTOOLS_NEXT_UID__)) {
          const node = await this.capture({ ...cachedChild, isDeactivated: true }, depth + 1);
          if (node)
            treeNode.children.push(node);
        }
      }
    }
    const rootElements = getRootElementsFromComponentInstance(instance);
    const firstElement = rootElements[0];
    if (firstElement == null ? void 0 : firstElement.parentElement) {
      const parentInstance = instance.parent;
      const parentRootElements = parentInstance ? getRootElementsFromComponentInstance(parentInstance) : [];
      let el = firstElement;
      const indexList = [];
      do {
        indexList.push(Array.from(el.parentElement.childNodes).indexOf(el));
        el = el.parentElement;
      } while (el.parentElement && parentRootElements.length && !parentRootElements.includes(el));
      treeNode.domOrder = indexList.reverse();
    } else {
      treeNode.domOrder = [-1];
    }
    if ((_a25 = instance.suspense) == null ? void 0 : _a25.suspenseKey) {
      treeNode.tags.push({
        label: instance.suspense.suspenseKey,
        backgroundColor: 14979812,
        textColor: 16777215
      });
      this.mark(instance, true);
    }
    this.api.visitComponentTree({
      treeNode,
      componentInstance: instance,
      app: instance.appContext.app,
      filter: this.componentFilter.filter
    });
    return treeNode;
  }
  /**
   * Find qualified children from a single instance.
   * If the instance itself is qualified, just return itself.
   * This is ok because [].concat works in both cases.
   *
   * @param {Vue|Vnode} instance
   * @return {Vue|Array}
   */
  async findQualifiedChildren(instance, depth) {
    var _a25;
    if (this.componentFilter.isQualified(instance) && !((_a25 = instance.type.devtools) == null ? void 0 : _a25.hide)) {
      return [await this.capture(instance, depth)];
    } else if (instance.subTree) {
      const list = this.isKeepAlive(instance) ? this.getKeepAliveCachedInstances(instance) : this.getInternalInstanceChildren(instance.subTree);
      return this.findQualifiedChildrenFromList(list, depth);
    } else {
      return [];
    }
  }
  /**
   * Iterate through an array of instances and flatten it into
   * an array of qualified instances. This is a depth-first
   * traversal - e.g. if an instance is not matched, we will
   * recursively go deeper until a qualified child is found.
   *
   * @param {Array} instances
   * @return {Array}
   */
  async findQualifiedChildrenFromList(instances, depth) {
    instances = instances.filter((child) => {
      var _a25;
      return !isBeingDestroyed(child) && !((_a25 = child.type.devtools) == null ? void 0 : _a25.hide);
    });
    if (!this.componentFilter.filter)
      return Promise.all(instances.map((child) => this.capture(child, depth)));
    else
      return Array.prototype.concat.apply([], await Promise.all(instances.map((i) => this.findQualifiedChildren(i, depth))));
  }
  /**
   * Get children from a component instance.
   */
  getInternalInstanceChildren(subTree, suspense = null) {
    const list = [];
    if (subTree) {
      if (subTree.component) {
        !suspense ? list.push(subTree.component) : list.push({ ...subTree.component, suspense });
      } else if (subTree.suspense) {
        const suspenseKey = !subTree.suspense.isInFallback ? "suspense default" : "suspense fallback";
        list.push(...this.getInternalInstanceChildren(subTree.suspense.activeBranch, { ...subTree.suspense, suspenseKey }));
      } else if (Array.isArray(subTree.children)) {
        subTree.children.forEach((childSubTree) => {
          if (childSubTree.component)
            !suspense ? list.push(childSubTree.component) : list.push({ ...childSubTree.component, suspense });
          else
            list.push(...this.getInternalInstanceChildren(childSubTree, suspense));
        });
      }
    }
    return list.filter((child) => {
      var _a25;
      return !isBeingDestroyed(child) && !((_a25 = child.type.devtools) == null ? void 0 : _a25.hide);
    });
  }
  /**
   * Mark an instance as captured and store it in the instance map.
   *
   * @param {Vue} instance
   */
  mark(instance, force = false) {
    const instanceMap = getAppRecord(instance).instanceMap;
    if (force || !instanceMap.has(instance.__VUE_DEVTOOLS_NEXT_UID__)) {
      instanceMap.set(instance.__VUE_DEVTOOLS_NEXT_UID__, instance);
      activeAppRecord.value.instanceMap = instanceMap;
    }
  }
  isKeepAlive(instance) {
    return instance.type.__isKeepAlive && instance.__v_cache;
  }
  getKeepAliveCachedInstances(instance) {
    return Array.from(instance.__v_cache.values()).map((vnode) => vnode.component).filter(Boolean);
  }
};

// src/core/timeline/index.ts
init_esm_shims();


// src/core/timeline/perf.ts
init_esm_shims();
var markEndQueue = /* @__PURE__ */ new Map();
var PERFORMANCE_EVENT_LAYER_ID = "performance";
async function performanceMarkStart(api, app, uid, vm, type, time) {
  const appRecord = await getAppRecord(app);
  if (!appRecord) {
    return;
  }
  const componentName = getInstanceName(vm) || "Unknown Component";
  const groupId = devtoolsState.perfUniqueGroupId++;
  const groupKey = `${uid}-${type}`;
  appRecord.perfGroupIds.set(groupKey, { groupId, time });
  await api.addTimelineEvent({
    layerId: PERFORMANCE_EVENT_LAYER_ID,
    event: {
      time: Date.now(),
      data: {
        component: componentName,
        type,
        measure: "start"
      },
      title: componentName,
      subtitle: type,
      groupId
    }
  });
  if (markEndQueue.has(groupKey)) {
    const {
      app: app2,
      uid: uid2,
      instance,
      type: type2,
      time: time2
    } = markEndQueue.get(groupKey);
    markEndQueue.delete(groupKey);
    await performanceMarkEnd(
      api,
      app2,
      uid2,
      instance,
      type2,
      time2
    );
  }
}
function performanceMarkEnd(api, app, uid, vm, type, time) {
  const appRecord = getAppRecord(app);
  if (!appRecord)
    return;
  const componentName = getInstanceName(vm) || "Unknown Component";
  const groupKey = `${uid}-${type}`;
  const groupInfo = appRecord.perfGroupIds.get(groupKey);
  if (groupInfo) {
    const groupId = groupInfo.groupId;
    const startTime = groupInfo.time;
    const duration = time - startTime;
    api.addTimelineEvent({
      layerId: PERFORMANCE_EVENT_LAYER_ID,
      event: {
        time: Date.now(),
        data: {
          component: componentName,
          type,
          measure: "end",
          duration: {
            _custom: {
              type: "Duration",
              value: duration,
              display: `${duration} ms`
            }
          }
        },
        title: componentName,
        subtitle: type,
        groupId
      }
    });
  } else {
    markEndQueue.set(groupKey, { app, uid, instance: vm, type, time });
  }
}

// src/core/timeline/index.ts
var COMPONENT_EVENT_LAYER_ID = "component-event";
function setupBuiltinTimelineLayers(api) {
  if (!_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.isBrowser)
    return;
  api.addTimelineLayer({
    id: "mouse",
    label: "Mouse",
    color: 10768815
  });
  ["mousedown", "mouseup", "click", "dblclick"].forEach((eventType) => {
    if (!devtoolsState.timelineLayersState.recordingState || !devtoolsState.timelineLayersState.mouseEventEnabled)
      return;
    window.addEventListener(eventType, async (event) => {
      await api.addTimelineEvent({
        layerId: "mouse",
        event: {
          time: Date.now(),
          data: {
            type: eventType,
            x: event.clientX,
            y: event.clientY
          },
          title: eventType
        }
      });
    }, {
      capture: true,
      passive: true
    });
  });
  api.addTimelineLayer({
    id: "keyboard",
    label: "Keyboard",
    color: 8475055
  });
  ["keyup", "keydown", "keypress"].forEach((eventType) => {
    window.addEventListener(eventType, async (event) => {
      if (!devtoolsState.timelineLayersState.recordingState || !devtoolsState.timelineLayersState.keyboardEventEnabled)
        return;
      await api.addTimelineEvent({
        layerId: "keyboard",
        event: {
          time: Date.now(),
          data: {
            type: eventType,
            key: event.key,
            ctrlKey: event.ctrlKey,
            shiftKey: event.shiftKey,
            altKey: event.altKey,
            metaKey: event.metaKey
          },
          title: event.key
        }
      });
    }, {
      capture: true,
      passive: true
    });
  });
  api.addTimelineLayer({
    id: COMPONENT_EVENT_LAYER_ID,
    label: "Component events",
    color: 5226637
  });
  hook.on.componentEmit(async (app, instance, event, params) => {
    if (!devtoolsState.timelineLayersState.recordingState || !devtoolsState.timelineLayersState.componentEventEnabled)
      return;
    const appRecord = await getAppRecord(app);
    if (!appRecord)
      return;
    const componentId = `${appRecord.id}:${instance.uid}`;
    const componentName = getInstanceName(instance) || "Unknown Component";
    api.addTimelineEvent({
      layerId: COMPONENT_EVENT_LAYER_ID,
      event: {
        time: Date.now(),
        data: {
          component: {
            _custom: {
              type: "component-definition",
              display: componentName
            }
          },
          event,
          params
        },
        title: event,
        subtitle: `by ${componentName}`,
        meta: {
          componentId
        }
      }
    });
  });
  api.addTimelineLayer({
    id: "performance",
    label: PERFORMANCE_EVENT_LAYER_ID,
    color: 4307050
  });
  hook.on.perfStart((app, uid, vm, type, time) => {
    if (!devtoolsState.timelineLayersState.recordingState || !devtoolsState.timelineLayersState.performanceEventEnabled)
      return;
    performanceMarkStart(api, app, uid, vm, type, time);
  });
  hook.on.perfEnd((app, uid, vm, type, time) => {
    if (!devtoolsState.timelineLayersState.recordingState || !devtoolsState.timelineLayersState.performanceEventEnabled)
      return;
    performanceMarkEnd(api, app, uid, vm, type, time);
  });
}

// src/core/vm/index.ts
init_esm_shims();
var MAX_$VM = 10;
var $vmQueue = [];
function exposeInstanceToWindow(componentInstance) {
  if (typeof window === "undefined")
    return;
  const win = window;
  if (!componentInstance)
    return;
  win.$vm = componentInstance;
  if ($vmQueue[0] !== componentInstance) {
    if ($vmQueue.length >= MAX_$VM) {
      $vmQueue.pop();
    }
    for (let i = $vmQueue.length; i > 0; i--) {
      win[`$vm${i}`] = $vmQueue[i] = $vmQueue[i - 1];
    }
    win.$vm0 = $vmQueue[0] = componentInstance;
  }
}

// src/core/plugin/components.ts
var INSPECTOR_ID = "components";
function createComponentsDevToolsPlugin(app) {
  const descriptor = {
    id: INSPECTOR_ID,
    label: "Components",
    app
  };
  const setupFn = (api) => {
    api.addInspector({
      id: INSPECTOR_ID,
      label: "Components",
      treeFilterPlaceholder: "Search components"
    });
    setupBuiltinTimelineLayers(api);
    api.on.getInspectorTree(async (payload) => {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        const instance = getComponentInstance(activeAppRecord.value, payload.instanceId);
        if (instance) {
          const walker2 = new ComponentWalker({
            filterText: payload.filter,
            // @TODO: should make this configurable?
            maxDepth: 100,
            recursively: false,
            api
          });
          payload.rootNodes = await walker2.getComponentTree(instance);
        }
      }
    });
    api.on.getInspectorState(async (payload) => {
      var _a25;
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        const result = getInstanceState({
          instanceId: payload.nodeId
        });
        const componentInstance = result.instance;
        const app2 = (_a25 = result.instance) == null ? void 0 : _a25.appContext.app;
        const _payload = {
          componentInstance,
          app: app2,
          instanceData: result
        };
        devtoolsContext.hooks.callHookWith((callbacks) => {
          callbacks.forEach((cb) => cb(_payload));
        }, "inspectComponent" /* INSPECT_COMPONENT */);
        payload.state = result;
        exposeInstanceToWindow(componentInstance);
      }
    });
    api.on.editInspectorState(async (payload) => {
      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
        editState(payload);
        await api.sendInspectorState("components");
      }
    });
    const debounceSendInspectorTree = (0,perfect_debounce__WEBPACK_IMPORTED_MODULE_1__.debounce)(() => {
      api.sendInspectorTree(INSPECTOR_ID);
    }, 120);
    const debounceSendInspectorState = (0,perfect_debounce__WEBPACK_IMPORTED_MODULE_1__.debounce)(() => {
      api.sendInspectorState(INSPECTOR_ID);
    }, 120);
    const componentAddedCleanup = hook.on.componentAdded(async (app2, uid, parentUid, component) => {
      var _a25, _b25, _c;
      if (devtoolsState.highPerfModeEnabled)
        return;
      if ((_c = (_b25 = (_a25 = app2 == null ? void 0 : app2._instance) == null ? void 0 : _a25.type) == null ? void 0 : _b25.devtools) == null ? void 0 : _c.hide)
        return;
      if (!app2 || typeof uid !== "number" && !uid || !component)
        return;
      const id = await getComponentId({
        app: app2,
        uid,
        instance: component
      });
      const appRecord = await getAppRecord(app2);
      if (component) {
        if (component.__VUE_DEVTOOLS_NEXT_UID__ == null)
          component.__VUE_DEVTOOLS_NEXT_UID__ = id;
        if (!(appRecord == null ? void 0 : appRecord.instanceMap.has(id))) {
          appRecord == null ? void 0 : appRecord.instanceMap.set(id, component);
          if (activeAppRecord.value.id === (appRecord == null ? void 0 : appRecord.id))
            activeAppRecord.value.instanceMap = appRecord.instanceMap;
        }
      }
      if (!appRecord)
        return;
      debounceSendInspectorTree();
    });
    const componentUpdatedCleanup = hook.on.componentUpdated(async (app2, uid, parentUid, component) => {
      var _a25, _b25, _c;
      if (devtoolsState.highPerfModeEnabled)
        return;
      if ((_c = (_b25 = (_a25 = app2 == null ? void 0 : app2._instance) == null ? void 0 : _a25.type) == null ? void 0 : _b25.devtools) == null ? void 0 : _c.hide)
        return;
      if (!app2 || typeof uid !== "number" && !uid || !component)
        return;
      const id = await getComponentId({
        app: app2,
        uid,
        instance: component
      });
      const appRecord = await getAppRecord(app2);
      if (component) {
        if (component.__VUE_DEVTOOLS_NEXT_UID__ == null)
          component.__VUE_DEVTOOLS_NEXT_UID__ = id;
        if (!(appRecord == null ? void 0 : appRecord.instanceMap.has(id))) {
          appRecord == null ? void 0 : appRecord.instanceMap.set(id, component);
          if (activeAppRecord.value.id === (appRecord == null ? void 0 : appRecord.id))
            activeAppRecord.value.instanceMap = appRecord.instanceMap;
        }
      }
      if (!appRecord)
        return;
      debounceSendInspectorTree();
      debounceSendInspectorState();
    });
    const componentRemovedCleanup = hook.on.componentRemoved(async (app2, uid, parentUid, component) => {
      var _a25, _b25, _c;
      if (devtoolsState.highPerfModeEnabled)
        return;
      if ((_c = (_b25 = (_a25 = app2 == null ? void 0 : app2._instance) == null ? void 0 : _a25.type) == null ? void 0 : _b25.devtools) == null ? void 0 : _c.hide)
        return;
      if (!app2 || typeof uid !== "number" && !uid || !component)
        return;
      const appRecord = await getAppRecord(app2);
      if (!appRecord)
        return;
      const id = await getComponentId({
        app: app2,
        uid,
        instance: component
      });
      appRecord == null ? void 0 : appRecord.instanceMap.delete(id);
      if (activeAppRecord.value.id === (appRecord == null ? void 0 : appRecord.id))
        activeAppRecord.value.instanceMap = appRecord.instanceMap;
      debounceSendInspectorTree();
    });
  };
  return [descriptor, setupFn];
}

// src/core/plugin/index.ts
var _a12, _b12;
(_b12 = (_a12 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__) != null ? _b12 : _a12.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__ = /* @__PURE__ */ new Set();
function setupDevToolsPlugin(pluginDescriptor, setupFn) {
  return hook.setupDevToolsPlugin(pluginDescriptor, setupFn);
}
function callDevToolsPluginSetupFn(plugin, app) {
  const [pluginDescriptor, setupFn] = plugin;
  if (pluginDescriptor.app !== app)
    return;
  const api = new DevToolsPluginAPI({
    plugin: {
      setupFn,
      descriptor: pluginDescriptor
    },
    ctx: devtoolsContext
  });
  if (pluginDescriptor.packageName === "vuex") {
    api.on.editInspectorState((payload) => {
      api.sendInspectorState(payload.inspectorId);
    });
  }
  setupFn(api);
}
function removeRegisteredPluginApp(app) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__.delete(app);
}
function registerDevToolsPlugin(app, options) {
  if (_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__.has(app)) {
    return;
  }
  if (devtoolsState.highPerfModeEnabled && !(options == null ? void 0 : options.inspectingComponent)) {
    return;
  }
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__.add(app);
  devtoolsPluginBuffer.forEach((plugin) => {
    callDevToolsPluginSetupFn(plugin, app);
  });
}

// src/core/router/index.ts
init_esm_shims();



// src/ctx/router.ts
init_esm_shims();

var ROUTER_KEY = "__VUE_DEVTOOLS_ROUTER__";
var ROUTER_INFO_KEY = "__VUE_DEVTOOLS_ROUTER_INFO__";
var _a13, _b13;
(_b13 = (_a13 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target)[ROUTER_INFO_KEY]) != null ? _b13 : _a13[ROUTER_INFO_KEY] = {
  currentRoute: null,
  routes: []
};
var _a14, _b14;
(_b14 = (_a14 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target)[ROUTER_KEY]) != null ? _b14 : _a14[ROUTER_KEY] = {};
var devtoolsRouterInfo = new Proxy(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[ROUTER_INFO_KEY], {
  get(target22, property) {
    return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[ROUTER_INFO_KEY][property];
  }
});
var devtoolsRouter = new Proxy(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[ROUTER_KEY], {
  get(target22, property) {
    if (property === "value") {
      return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[ROUTER_KEY];
    }
  }
});

// src/core/router/index.ts
function getRoutes(router) {
  const routesMap = /* @__PURE__ */ new Map();
  return ((router == null ? void 0 : router.getRoutes()) || []).filter((i) => !routesMap.has(i.path) && routesMap.set(i.path, 1));
}
function filterRoutes(routes) {
  return routes.map((item) => {
    let { path, name, children, meta } = item;
    if (children == null ? void 0 : children.length)
      children = filterRoutes(children);
    return {
      path,
      name,
      children,
      meta
    };
  });
}
function filterCurrentRoute(route) {
  if (route) {
    const { fullPath, hash, href, path, name, matched, params, query } = route;
    return {
      fullPath,
      hash,
      href,
      path,
      name,
      params,
      query,
      matched: filterRoutes(matched)
    };
  }
  return route;
}
function normalizeRouterInfo(appRecord, activeAppRecord2) {
  function init() {
    var _a25;
    const router = (_a25 = appRecord.app) == null ? void 0 : _a25.config.globalProperties.$router;
    const currentRoute = filterCurrentRoute(router == null ? void 0 : router.currentRoute.value);
    const routes = filterRoutes(getRoutes(router));
    const c = console.warn;
    console.warn = () => {
    };
    _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[ROUTER_INFO_KEY] = {
      currentRoute: currentRoute ? (0,_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.deepClone)(currentRoute) : {},
      routes: (0,_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.deepClone)(routes)
    };
    _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[ROUTER_KEY] = router;
    console.warn = c;
  }
  init();
  hook.on.componentUpdated((0,perfect_debounce__WEBPACK_IMPORTED_MODULE_1__.debounce)(() => {
    var _a25;
    if (((_a25 = activeAppRecord2.value) == null ? void 0 : _a25.app) !== appRecord.app)
      return;
    init();
    if (devtoolsState.highPerfModeEnabled)
      return;
    devtoolsContext.hooks.callHook("routerInfoUpdated" /* ROUTER_INFO_UPDATED */, { state: _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[ROUTER_INFO_KEY] });
  }, 200));
}

// src/ctx/api.ts
function createDevToolsApi(hooks2) {
  return {
    // get inspector tree
    async getInspectorTree(payload) {
      const _payload = {
        ...payload,
        app: activeAppRecord.value.app,
        rootNodes: []
      };
      await new Promise((resolve) => {
        hooks2.callHookWith(async (callbacks) => {
          await Promise.all(callbacks.map((cb) => cb(_payload)));
          resolve();
        }, "getInspectorTree" /* GET_INSPECTOR_TREE */);
      });
      return _payload.rootNodes;
    },
    // get inspector state
    async getInspectorState(payload) {
      const _payload = {
        ...payload,
        app: activeAppRecord.value.app,
        state: null
      };
      const ctx = {
        currentTab: `custom-inspector:${payload.inspectorId}`
      };
      await new Promise((resolve) => {
        hooks2.callHookWith(async (callbacks) => {
          await Promise.all(callbacks.map((cb) => cb(_payload, ctx)));
          resolve();
        }, "getInspectorState" /* GET_INSPECTOR_STATE */);
      });
      return _payload.state;
    },
    // edit inspector state
    editInspectorState(payload) {
      const stateEditor2 = new StateEditor();
      const _payload = {
        ...payload,
        app: activeAppRecord.value.app,
        set: (obj, path = payload.path, value = payload.state.value, cb) => {
          stateEditor2.set(obj, path, value, cb || stateEditor2.createDefaultSetCallback(payload.state));
        }
      };
      hooks2.callHookWith((callbacks) => {
        callbacks.forEach((cb) => cb(_payload));
      }, "editInspectorState" /* EDIT_INSPECTOR_STATE */);
    },
    // send inspector state
    sendInspectorState(inspectorId) {
      const inspector = getInspector(inspectorId);
      hooks2.callHook("sendInspectorState" /* SEND_INSPECTOR_STATE */, { inspectorId, plugin: {
        descriptor: inspector.descriptor,
        setupFn: () => ({})
      } });
    },
    // inspect component inspector
    inspectComponentInspector() {
      return inspectComponentHighLighter();
    },
    // cancel inspect component inspector
    cancelInspectComponentInspector() {
      return cancelInspectComponentHighLighter();
    },
    // get component render code
    getComponentRenderCode(id) {
      const instance = getComponentInstance(activeAppRecord.value, id);
      if (instance)
        return !(typeof (instance == null ? void 0 : instance.type) === "function") ? instance.render.toString() : instance.type.toString();
    },
    // scroll to component
    scrollToComponent(id) {
      return scrollToComponent({ id });
    },
    // open in editor
    openInEditor,
    // get vue inspector
    getVueInspector: getComponentInspector,
    // toggle app
    toggleApp(id, options) {
      const appRecord = devtoolsAppRecords.value.find((record) => record.id === id);
      if (appRecord) {
        setActiveAppRecordId(id);
        setActiveAppRecord(appRecord);
        normalizeRouterInfo(appRecord, activeAppRecord);
        callInspectorUpdatedHook();
        registerDevToolsPlugin(appRecord.app, options);
      }
    },
    // inspect dom
    inspectDOM(instanceId) {
      const instance = getComponentInstance(activeAppRecord.value, instanceId);
      if (instance) {
        const [el] = getRootElementsFromComponentInstance(instance);
        if (el) {
          _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_INSPECT_DOM_TARGET__ = el;
        }
      }
    },
    updatePluginSettings(pluginId, key, value) {
      setPluginSettings(pluginId, key, value);
    },
    getPluginSettings(pluginId) {
      return {
        options: getPluginSettingsOptions(pluginId),
        values: getPluginSettings(pluginId)
      };
    }
  };
}

// src/ctx/env.ts
init_esm_shims();

var _a15, _b15;
(_b15 = (_a15 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_ENV__) != null ? _b15 : _a15.__VUE_DEVTOOLS_ENV__ = {
  vitePluginDetected: false
};
function getDevToolsEnv() {
  return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_ENV__;
}
function setDevToolsEnv(env) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_ENV__ = {
    ..._vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_ENV__,
    ...env
  };
}

// src/ctx/index.ts
var hooks = createDevToolsCtxHooks();
var _a16, _b16;
(_b16 = (_a16 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT_CONTEXT__) != null ? _b16 : _a16.__VUE_DEVTOOLS_KIT_CONTEXT__ = {
  hooks,
  get state() {
    return {
      ...devtoolsState,
      activeAppRecordId: activeAppRecord.id,
      activeAppRecord: activeAppRecord.value,
      appRecords: devtoolsAppRecords.value
    };
  },
  api: createDevToolsApi(hooks)
};
var devtoolsContext = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_CONTEXT__;

// src/core/app/index.ts
init_esm_shims();
var import_speakingurl = __toESM(require_speakingurl2(), 1);

var _a17, _b17;
var appRecordInfo = (_b17 = (_a17 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_NEXT_APP_RECORD_INFO__) != null ? _b17 : _a17.__VUE_DEVTOOLS_NEXT_APP_RECORD_INFO__ = {
  id: 0,
  appIds: /* @__PURE__ */ new Set()
};
function getAppRecordName(app, fallbackName) {
  var _a25;
  return ((_a25 = app == null ? void 0 : app._component) == null ? void 0 : _a25.name) || `App ${fallbackName}`;
}
function getAppRootInstance(app) {
  var _a25, _b25, _c, _d;
  if (app._instance)
    return app._instance;
  else if ((_b25 = (_a25 = app._container) == null ? void 0 : _a25._vnode) == null ? void 0 : _b25.component)
    return (_d = (_c = app._container) == null ? void 0 : _c._vnode) == null ? void 0 : _d.component;
}
function removeAppRecordId(app) {
  const id = app.__VUE_DEVTOOLS_NEXT_APP_RECORD_ID__;
  if (id != null) {
    appRecordInfo.appIds.delete(id);
    appRecordInfo.id--;
  }
}
function getAppRecordId(app, defaultId) {
  if (app.__VUE_DEVTOOLS_NEXT_APP_RECORD_ID__ != null)
    return app.__VUE_DEVTOOLS_NEXT_APP_RECORD_ID__;
  let id = defaultId != null ? defaultId : (appRecordInfo.id++).toString();
  if (defaultId && appRecordInfo.appIds.has(id)) {
    let count = 1;
    while (appRecordInfo.appIds.has(`${defaultId}_${count}`))
      count++;
    id = `${defaultId}_${count}`;
  }
  appRecordInfo.appIds.add(id);
  app.__VUE_DEVTOOLS_NEXT_APP_RECORD_ID__ = id;
  return id;
}
function createAppRecord(app, types) {
  var _a25, _b25;
  const rootInstance = getAppRootInstance(app);
  if (rootInstance) {
    appRecordInfo.id++;
    const name = getAppRecordName(app, appRecordInfo.id.toString());
    const id = getAppRecordId(app, (0, import_speakingurl.default)(name));
    const [el] = getRootElementsFromComponentInstance(rootInstance);
    const record = {
      id,
      name,
      types,
      instanceMap: /* @__PURE__ */ new Map(),
      perfGroupIds: /* @__PURE__ */ new Map(),
      rootInstance,
      iframe: _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.isBrowser && document !== (el == null ? void 0 : el.ownerDocument) ? (_b25 = (_a25 = el == null ? void 0 : el.ownerDocument) == null ? void 0 : _a25.location) == null ? void 0 : _b25.pathname : void 0
    };
    app.__VUE_DEVTOOLS_NEXT_APP_RECORD__ = record;
    const rootId = `${record.id}:root`;
    record.instanceMap.set(rootId, record.rootInstance);
    record.rootInstance.__VUE_DEVTOOLS_NEXT_UID__ = rootId;
    return record;
  } else {
    return {};
  }
}

// src/core/iframe/index.ts
init_esm_shims();
function detectIframeApp(target22, inIframe = false) {
  if (inIframe) {
    let sendEventToParent2 = function(cb) {
      try {
        const hook3 = window.parent.__VUE_DEVTOOLS_GLOBAL_HOOK__;
        if (hook3) {
          cb(hook3);
        }
      } catch (e) {
      }
    };
    var sendEventToParent = sendEventToParent2;
    const hook2 = {
      id: "vue-devtools-next",
      devtoolsVersion: "7.0",
      on: (event, cb) => {
        sendEventToParent2((hook3) => {
          hook3.on(event, cb);
        });
      },
      once: (event, cb) => {
        sendEventToParent2((hook3) => {
          hook3.once(event, cb);
        });
      },
      off: (event, cb) => {
        sendEventToParent2((hook3) => {
          hook3.off(event, cb);
        });
      },
      emit: (event, ...payload) => {
        sendEventToParent2((hook3) => {
          hook3.emit(event, ...payload);
        });
      }
    };
    Object.defineProperty(target22, "__VUE_DEVTOOLS_GLOBAL_HOOK__", {
      get() {
        return hook2;
      },
      configurable: true
    });
  }
  function injectVueHookToIframe(iframe) {
    if (iframe.__vdevtools__injected) {
      return;
    }
    try {
      iframe.__vdevtools__injected = true;
      const inject = () => {
        try {
          iframe.contentWindow.__VUE_DEVTOOLS_IFRAME__ = iframe;
          const script = iframe.contentDocument.createElement("script");
          script.textContent = `;(${detectIframeApp.toString()})(window, true)`;
          iframe.contentDocument.documentElement.appendChild(script);
          script.parentNode.removeChild(script);
        } catch (e) {
        }
      };
      inject();
      iframe.addEventListener("load", () => inject());
    } catch (e) {
    }
  }
  function injectVueHookToIframes() {
    if (typeof window === "undefined") {
      return;
    }
    const iframes = Array.from(document.querySelectorAll("iframe:not([data-vue-devtools-ignore])"));
    for (const iframe of iframes) {
      injectVueHookToIframe(iframe);
    }
  }
  injectVueHookToIframes();
  let iframeAppChecks = 0;
  const iframeAppCheckTimer = setInterval(() => {
    injectVueHookToIframes();
    iframeAppChecks++;
    if (iframeAppChecks >= 5) {
      clearInterval(iframeAppCheckTimer);
    }
  }, 1e3);
}

// src/core/index.ts
function initDevTools() {
  var _a25;
  detectIframeApp(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target);
  updateDevToolsState({
    vitePluginDetected: getDevToolsEnv().vitePluginDetected
  });
  const isDevToolsNext = ((_a25 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_GLOBAL_HOOK__) == null ? void 0 : _a25.id) === "vue-devtools-next";
  if (_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_GLOBAL_HOOK__ && isDevToolsNext)
    return;
  const _devtoolsHook = createDevToolsHook();
  if (_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_HOOK_REPLAY__) {
    try {
      _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_HOOK_REPLAY__.forEach((cb) => cb(_devtoolsHook));
      _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_HOOK_REPLAY__ = [];
    } catch (e) {
      console.error("[vue-devtools] Error during hook replay", e);
    }
  }
  _devtoolsHook.once("init", (Vue) => {
    _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_VUE2_APP_DETECTED__ = true;
    console.log("%c[_____Vue DevTools v7 log_____]", "color: red; font-bold: 600; font-size: 16px;");
    console.log("%cVue DevTools v7 detected in your Vue2 project. v7 only supports Vue3 and will not work.", "font-bold: 500; font-size: 14px;");
    const legacyChromeUrl = "https://chromewebstore.google.com/detail/vuejs-devtools/iaajmlceplecbljialhhkmedjlpdblhp";
    const legacyFirefoxUrl = "https://addons.mozilla.org/firefox/addon/vue-js-devtools-v6-legacy";
    console.log(`%cThe legacy version of chrome extension that supports both Vue 2 and Vue 3 has been moved to %c ${legacyChromeUrl}`, "font-size: 14px;", "text-decoration: underline; cursor: pointer;font-size: 14px;");
    console.log(`%cThe legacy version of firefox extension that supports both Vue 2 and Vue 3 has been moved to %c ${legacyFirefoxUrl}`, "font-size: 14px;", "text-decoration: underline; cursor: pointer;font-size: 14px;");
    console.log("%cPlease install and enable only the legacy version for your Vue2 app.", "font-bold: 500; font-size: 14px;");
    console.log("%c[_____Vue DevTools v7 log_____]", "color: red; font-bold: 600; font-size: 16px;");
  });
  hook.on.setupDevtoolsPlugin((pluginDescriptor, setupFn) => {
    var _a26;
    addDevToolsPluginToBuffer(pluginDescriptor, setupFn);
    const { app } = (_a26 = activeAppRecord) != null ? _a26 : {};
    if (pluginDescriptor.settings) {
      initPluginSettings(pluginDescriptor.id, pluginDescriptor.settings);
    }
    if (!app)
      return;
    callDevToolsPluginSetupFn([pluginDescriptor, setupFn], app);
  });
  onLegacyDevToolsPluginApiAvailable(() => {
    const normalizedPluginBuffer = devtoolsPluginBuffer.filter(([item]) => item.id !== "components");
    normalizedPluginBuffer.forEach(([pluginDescriptor, setupFn]) => {
      _devtoolsHook.emit("devtools-plugin:setup" /* SETUP_DEVTOOLS_PLUGIN */, pluginDescriptor, setupFn, { target: "legacy" });
    });
  });
  hook.on.vueAppInit(async (app, version, types) => {
    const appRecord = createAppRecord(app, types);
    const normalizedAppRecord = {
      ...appRecord,
      app,
      version
    };
    addDevToolsAppRecord(normalizedAppRecord);
    if (devtoolsAppRecords.value.length === 1) {
      setActiveAppRecord(normalizedAppRecord);
      setActiveAppRecordId(normalizedAppRecord.id);
      normalizeRouterInfo(normalizedAppRecord, activeAppRecord);
      registerDevToolsPlugin(normalizedAppRecord.app);
    }
    setupDevToolsPlugin(...createComponentsDevToolsPlugin(normalizedAppRecord.app));
    updateDevToolsState({
      connected: true
    });
    _devtoolsHook.apps.push(app);
  });
  hook.on.vueAppUnmount(async (app) => {
    const activeRecords = devtoolsAppRecords.value.filter((appRecord) => appRecord.app !== app);
    if (activeRecords.length === 0) {
      updateDevToolsState({
        connected: false
      });
    }
    removeDevToolsAppRecord(app);
    removeAppRecordId(app);
    if (activeAppRecord.value.app === app) {
      setActiveAppRecord(activeRecords[0]);
      devtoolsContext.hooks.callHook("sendActiveAppUpdatedToClient" /* SEND_ACTIVE_APP_UNMOUNTED_TO_CLIENT */);
    }
    _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_GLOBAL_HOOK__.apps.splice(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_GLOBAL_HOOK__.apps.indexOf(app), 1);
    removeRegisteredPluginApp(app);
  });
  subscribeDevToolsHook(_devtoolsHook);
  if (!_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_GLOBAL_HOOK__) {
    Object.defineProperty(_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target, "__VUE_DEVTOOLS_GLOBAL_HOOK__", {
      get() {
        return _devtoolsHook;
      },
      configurable: true
    });
  } else {
    if (!_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.isNuxtApp) {
      Object.assign(__VUE_DEVTOOLS_GLOBAL_HOOK__, _devtoolsHook);
    }
  }
}
function onDevToolsClientConnected(fn) {
  return new Promise((resolve) => {
    if (devtoolsState.connected && devtoolsState.clientConnected) {
      fn();
      resolve();
      return;
    }
    devtoolsContext.hooks.hook("devtoolsConnectedUpdated" /* DEVTOOLS_CONNECTED_UPDATED */, ({ state }) => {
      if (state.connected && state.clientConnected) {
        fn();
        resolve();
      }
    });
  });
}

// src/core/high-perf-mode/index.ts
init_esm_shims();
function toggleHighPerfMode(state) {
  devtoolsState.highPerfModeEnabled = state != null ? state : !devtoolsState.highPerfModeEnabled;
  if (!state && activeAppRecord.value) {
    registerDevToolsPlugin(activeAppRecord.value.app);
  }
}

// src/core/component/state/format.ts
init_esm_shims();

// src/core/component/state/reviver.ts
init_esm_shims();

function reviveSet(val) {
  const result = /* @__PURE__ */ new Set();
  const list = val._custom.value;
  for (let i = 0; i < list.length; i++) {
    const value = list[i];
    result.add(revive(value));
  }
  return result;
}
function reviveMap(val) {
  const result = /* @__PURE__ */ new Map();
  const list = val._custom.value;
  for (let i = 0; i < list.length; i++) {
    const { key, value } = list[i];
    result.set(key, revive(value));
  }
  return result;
}
function revive(val) {
  if (val === UNDEFINED) {
    return void 0;
  } else if (val === INFINITY) {
    return Number.POSITIVE_INFINITY;
  } else if (val === NEGATIVE_INFINITY) {
    return Number.NEGATIVE_INFINITY;
  } else if (val === NAN) {
    return Number.NaN;
  } else if (val && val._custom) {
    const { _custom: custom } = val;
    if (custom.type === "component")
      return activeAppRecord.value.instanceMap.get(custom.id);
    else if (custom.type === "map")
      return reviveMap(val);
    else if (custom.type === "set")
      return reviveSet(val);
    else if (custom.type === "bigint")
      return BigInt(custom.value);
    else
      return revive(custom.value);
  } else if (symbolRE.test(val)) {
    const [, string] = symbolRE.exec(val);
    return Symbol.for(string);
  } else if (specialTypeRE.test(val)) {
    const [, type, string, , details] = specialTypeRE.exec(val);
    const result = new _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[type](string);
    if (type === "Error" && details)
      result.stack = details;
    return result;
  } else {
    return val;
  }
}
function reviver(key, value) {
  return revive(value);
}

// src/core/component/state/format.ts
function getInspectorStateValueType(value, raw = true) {
  const type = typeof value;
  if (value == null || value === UNDEFINED || value === "undefined") {
    return "null";
  } else if (type === "boolean" || type === "number" || value === INFINITY || value === NEGATIVE_INFINITY || value === NAN) {
    return "literal";
  } else if (value == null ? void 0 : value._custom) {
    if (raw || value._custom.display != null || value._custom.displayText != null)
      return "custom";
    else
      return getInspectorStateValueType(value._custom.value);
  } else if (typeof value === "string") {
    const typeMatch = specialTypeRE.exec(value);
    if (typeMatch) {
      const [, type2] = typeMatch;
      return `native ${type2}`;
    } else {
      return "string";
    }
  } else if (Array.isArray(value) || (value == null ? void 0 : value._isArray)) {
    return "array";
  } else if (isPlainObject(value)) {
    return "plain-object";
  } else {
    return "unknown";
  }
}
function formatInspectorStateValue(value, quotes = false, options) {
  var _a25, _b25, _c;
  const { customClass } = options != null ? options : {};
  let result;
  const type = getInspectorStateValueType(value, false);
  if (type !== "custom" && (value == null ? void 0 : value._custom))
    value = value._custom.value;
  if (result = internalStateTokenToString(value)) {
    return result;
  } else if (type === "custom") {
    const nestedName = ((_a25 = value._custom.value) == null ? void 0 : _a25._custom) && formatInspectorStateValue(value._custom.value, quotes, options);
    return nestedName || value._custom.displayText || value._custom.display;
  } else if (type === "array") {
    return `Array[${value.length}]`;
  } else if (type === "plain-object") {
    return `Object${Object.keys(value).length ? "" : " (empty)"}`;
  } else if (type == null ? void 0 : type.includes("native")) {
    return escape((_b25 = specialTypeRE.exec(value)) == null ? void 0 : _b25[2]);
  } else if (typeof value === "string") {
    const typeMatch = value.match(rawTypeRE);
    if (typeMatch) {
      value = escapeString(typeMatch[1]);
    } else if (quotes) {
      value = `<span>"</span>${(customClass == null ? void 0 : customClass.string) ? `<span class=${customClass.string}>${escapeString(value)}</span>` : escapeString(value)}<span>"</span>`;
    } else {
      value = (customClass == null ? void 0 : customClass.string) ? `<span class="${(_c = customClass == null ? void 0 : customClass.string) != null ? _c : ""}">${escapeString(value)}</span>` : escapeString(value);
    }
  }
  return value;
}
function escapeString(value) {
  return escape(value).replace(/ /g, "&nbsp;").replace(/\n/g, "<span>\\n</span>");
}
function getRaw(value) {
  var _a25, _b25, _c;
  let customType;
  const isCustom = getInspectorStateValueType(value) === "custom";
  let inherit = {};
  if (isCustom) {
    const data = value;
    const customValue = (_a25 = data._custom) == null ? void 0 : _a25.value;
    const currentCustomType = (_b25 = data._custom) == null ? void 0 : _b25.type;
    const nestedCustom = typeof customValue === "object" && customValue !== null && "_custom" in customValue ? getRaw(customValue) : { inherit: void 0, value: void 0, customType: void 0 };
    inherit = nestedCustom.inherit || ((_c = data._custom) == null ? void 0 : _c.fields) || {};
    value = nestedCustom.value || customValue;
    customType = nestedCustom.customType || currentCustomType;
  }
  if (value && value._isArray)
    value = value.items;
  return { value, inherit, customType };
}
function toEdit(value, customType) {
  if (customType === "bigint")
    return value;
  if (customType === "date")
    return value;
  return replaceTokenToString(JSON.stringify(value));
}
function toSubmit(value, customType) {
  if (customType === "bigint")
    return BigInt(value);
  if (customType === "date")
    return new Date(value);
  return JSON.parse(replaceStringToToken(value), reviver);
}

// src/core/devtools-client/detected.ts
init_esm_shims();

function updateDevToolsClientDetected(params) {
  devtoolsState.devtoolsClientDetected = {
    ...devtoolsState.devtoolsClientDetected,
    ...params
  };
  const devtoolsClientVisible = Object.values(devtoolsState.devtoolsClientDetected).some(Boolean);
  toggleHighPerfMode(!devtoolsClientVisible);
}
var _a18, _b18;
(_b18 = (_a18 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_UPDATE_CLIENT_DETECTED__) != null ? _b18 : _a18.__VUE_DEVTOOLS_UPDATE_CLIENT_DETECTED__ = updateDevToolsClientDetected;

// src/messaging/index.ts
init_esm_shims();



// src/messaging/presets/index.ts
init_esm_shims();

// src/messaging/presets/broadcast-channel/index.ts
init_esm_shims();

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/index.js
init_esm_shims();

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/class-registry.js
init_esm_shims();

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/registry.js
init_esm_shims();

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/double-indexed-kv.js
init_esm_shims();
var DoubleIndexedKV = class {
  constructor() {
    this.keyToValue = /* @__PURE__ */ new Map();
    this.valueToKey = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    this.keyToValue.set(key, value);
    this.valueToKey.set(value, key);
  }
  getByKey(key) {
    return this.keyToValue.get(key);
  }
  getByValue(value) {
    return this.valueToKey.get(value);
  }
  clear() {
    this.keyToValue.clear();
    this.valueToKey.clear();
  }
};

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/registry.js
var Registry = class {
  constructor(generateIdentifier) {
    this.generateIdentifier = generateIdentifier;
    this.kv = new DoubleIndexedKV();
  }
  register(value, identifier) {
    if (this.kv.getByValue(value)) {
      return;
    }
    if (!identifier) {
      identifier = this.generateIdentifier(value);
    }
    this.kv.set(identifier, value);
  }
  clear() {
    this.kv.clear();
  }
  getIdentifier(value) {
    return this.kv.getByValue(value);
  }
  getValue(identifier) {
    return this.kv.getByKey(identifier);
  }
};

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/class-registry.js
var ClassRegistry = class extends Registry {
  constructor() {
    super((c) => c.name);
    this.classToAllowedProps = /* @__PURE__ */ new Map();
  }
  register(value, options) {
    if (typeof options === "object") {
      if (options.allowProps) {
        this.classToAllowedProps.set(value, options.allowProps);
      }
      super.register(value, options.identifier);
    } else {
      super.register(value, options);
    }
  }
  getAllowedProps(value) {
    return this.classToAllowedProps.get(value);
  }
};

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/custom-transformer-registry.js
init_esm_shims();

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/util.js
init_esm_shims();
function valuesOfObj(record) {
  if ("values" in Object) {
    return Object.values(record);
  }
  const values = [];
  for (const key in record) {
    if (record.hasOwnProperty(key)) {
      values.push(record[key]);
    }
  }
  return values;
}
function find(record, predicate) {
  const values = valuesOfObj(record);
  if ("find" in values) {
    return values.find(predicate);
  }
  const valuesNotNever = values;
  for (let i = 0; i < valuesNotNever.length; i++) {
    const value = valuesNotNever[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
function forEach(record, run) {
  Object.entries(record).forEach(([key, value]) => run(value, key));
}
function includes(arr, value) {
  return arr.indexOf(value) !== -1;
}
function findArr(record, predicate) {
  for (let i = 0; i < record.length; i++) {
    const value = record[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/custom-transformer-registry.js
var CustomTransformerRegistry = class {
  constructor() {
    this.transfomers = {};
  }
  register(transformer) {
    this.transfomers[transformer.name] = transformer;
  }
  findApplicable(v) {
    return find(this.transfomers, (transformer) => transformer.isApplicable(v));
  }
  findByName(name) {
    return this.transfomers[name];
  }
};

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/plainer.js
init_esm_shims();

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/is.js
init_esm_shims();
var getType = (payload) => Object.prototype.toString.call(payload).slice(8, -1);
var isUndefined = (payload) => typeof payload === "undefined";
var isNull = (payload) => payload === null;
var isPlainObject2 = (payload) => {
  if (typeof payload !== "object" || payload === null)
    return false;
  if (payload === Object.prototype)
    return false;
  if (Object.getPrototypeOf(payload) === null)
    return true;
  return Object.getPrototypeOf(payload) === Object.prototype;
};
var isEmptyObject = (payload) => isPlainObject2(payload) && Object.keys(payload).length === 0;
var isArray = (payload) => Array.isArray(payload);
var isString = (payload) => typeof payload === "string";
var isNumber = (payload) => typeof payload === "number" && !isNaN(payload);
var isBoolean = (payload) => typeof payload === "boolean";
var isRegExp = (payload) => payload instanceof RegExp;
var isMap = (payload) => payload instanceof Map;
var isSet = (payload) => payload instanceof Set;
var isSymbol = (payload) => getType(payload) === "Symbol";
var isDate = (payload) => payload instanceof Date && !isNaN(payload.valueOf());
var isError = (payload) => payload instanceof Error;
var isNaNValue = (payload) => typeof payload === "number" && isNaN(payload);
var isPrimitive2 = (payload) => isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);
var isBigint = (payload) => typeof payload === "bigint";
var isInfinite = (payload) => payload === Infinity || payload === -Infinity;
var isTypedArray = (payload) => ArrayBuffer.isView(payload) && !(payload instanceof DataView);
var isURL = (payload) => payload instanceof URL;

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/pathstringifier.js
init_esm_shims();
var escapeKey = (key) => key.replace(/\./g, "\\.");
var stringifyPath = (path) => path.map(String).map(escapeKey).join(".");
var parsePath = (string) => {
  const result = [];
  let segment = "";
  for (let i = 0; i < string.length; i++) {
    let char = string.charAt(i);
    const isEscapedDot = char === "\\" && string.charAt(i + 1) === ".";
    if (isEscapedDot) {
      segment += ".";
      i++;
      continue;
    }
    const isEndOfSegment = char === ".";
    if (isEndOfSegment) {
      result.push(segment);
      segment = "";
      continue;
    }
    segment += char;
  }
  const lastSegment = segment;
  result.push(lastSegment);
  return result;
};

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/transformer.js
init_esm_shims();
function simpleTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
var simpleRules = [
  simpleTransformation(isUndefined, "undefined", () => null, () => void 0),
  simpleTransformation(isBigint, "bigint", (v) => v.toString(), (v) => {
    if (typeof BigInt !== "undefined") {
      return BigInt(v);
    }
    console.error("Please add a BigInt polyfill.");
    return v;
  }),
  simpleTransformation(isDate, "Date", (v) => v.toISOString(), (v) => new Date(v)),
  simpleTransformation(isError, "Error", (v, superJson) => {
    const baseError = {
      name: v.name,
      message: v.message
    };
    superJson.allowedErrorProps.forEach((prop) => {
      baseError[prop] = v[prop];
    });
    return baseError;
  }, (v, superJson) => {
    const e = new Error(v.message);
    e.name = v.name;
    e.stack = v.stack;
    superJson.allowedErrorProps.forEach((prop) => {
      e[prop] = v[prop];
    });
    return e;
  }),
  simpleTransformation(isRegExp, "regexp", (v) => "" + v, (regex) => {
    const body = regex.slice(1, regex.lastIndexOf("/"));
    const flags = regex.slice(regex.lastIndexOf("/") + 1);
    return new RegExp(body, flags);
  }),
  simpleTransformation(
    isSet,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    (v) => [...v.values()],
    (v) => new Set(v)
  ),
  simpleTransformation(isMap, "map", (v) => [...v.entries()], (v) => new Map(v)),
  simpleTransformation((v) => isNaNValue(v) || isInfinite(v), "number", (v) => {
    if (isNaNValue(v)) {
      return "NaN";
    }
    if (v > 0) {
      return "Infinity";
    } else {
      return "-Infinity";
    }
  }, Number),
  simpleTransformation((v) => v === 0 && 1 / v === -Infinity, "number", () => {
    return "-0";
  }, Number),
  simpleTransformation(isURL, "URL", (v) => v.toString(), (v) => new URL(v))
];
function compositeTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
var symbolRule = compositeTransformation((s, superJson) => {
  if (isSymbol(s)) {
    const isRegistered = !!superJson.symbolRegistry.getIdentifier(s);
    return isRegistered;
  }
  return false;
}, (s, superJson) => {
  const identifier = superJson.symbolRegistry.getIdentifier(s);
  return ["symbol", identifier];
}, (v) => v.description, (_, a, superJson) => {
  const value = superJson.symbolRegistry.getValue(a[1]);
  if (!value) {
    throw new Error("Trying to deserialize unknown symbol");
  }
  return value;
});
var constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce((obj, ctor) => {
  obj[ctor.name] = ctor;
  return obj;
}, {});
var typedArrayRule = compositeTransformation(isTypedArray, (v) => ["typed-array", v.constructor.name], (v) => [...v], (v, a) => {
  const ctor = constructorToName[a[1]];
  if (!ctor) {
    throw new Error("Trying to deserialize unknown typed array");
  }
  return new ctor(v);
});
function isInstanceOfRegisteredClass(potentialClass, superJson) {
  if (potentialClass == null ? void 0 : potentialClass.constructor) {
    const isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
    return isRegistered;
  }
  return false;
}
var classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson) => {
  const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
  return ["class", identifier];
}, (clazz, superJson) => {
  const allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
  if (!allowedProps) {
    return { ...clazz };
  }
  const result = {};
  allowedProps.forEach((prop) => {
    result[prop] = clazz[prop];
  });
  return result;
}, (v, a, superJson) => {
  const clazz = superJson.classRegistry.getValue(a[1]);
  if (!clazz) {
    throw new Error(`Trying to deserialize unknown class '${a[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);
  }
  return Object.assign(Object.create(clazz.prototype), v);
});
var customRule = compositeTransformation((value, superJson) => {
  return !!superJson.customTransformerRegistry.findApplicable(value);
}, (value, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value);
  return ["custom", transformer.name];
}, (value, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value);
  return transformer.serialize(value);
}, (v, a, superJson) => {
  const transformer = superJson.customTransformerRegistry.findByName(a[1]);
  if (!transformer) {
    throw new Error("Trying to deserialize unknown custom value");
  }
  return transformer.deserialize(v);
});
var compositeRules = [classRule, symbolRule, customRule, typedArrayRule];
var transformValue = (value, superJson) => {
  const applicableCompositeRule = findArr(compositeRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableCompositeRule) {
    return {
      value: applicableCompositeRule.transform(value, superJson),
      type: applicableCompositeRule.annotation(value, superJson)
    };
  }
  const applicableSimpleRule = findArr(simpleRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableSimpleRule) {
    return {
      value: applicableSimpleRule.transform(value, superJson),
      type: applicableSimpleRule.annotation
    };
  }
  return void 0;
};
var simpleRulesByAnnotation = {};
simpleRules.forEach((rule) => {
  simpleRulesByAnnotation[rule.annotation] = rule;
});
var untransformValue = (json, type, superJson) => {
  if (isArray(type)) {
    switch (type[0]) {
      case "symbol":
        return symbolRule.untransform(json, type, superJson);
      case "class":
        return classRule.untransform(json, type, superJson);
      case "custom":
        return customRule.untransform(json, type, superJson);
      case "typed-array":
        return typedArrayRule.untransform(json, type, superJson);
      default:
        throw new Error("Unknown transformation: " + type);
    }
  } else {
    const transformation = simpleRulesByAnnotation[type];
    if (!transformation) {
      throw new Error("Unknown transformation: " + type);
    }
    return transformation.untransform(json, superJson);
  }
};

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/accessDeep.js
init_esm_shims();
var getNthKey = (value, n) => {
  if (n > value.size)
    throw new Error("index out of bounds");
  const keys = value.keys();
  while (n > 0) {
    keys.next();
    n--;
  }
  return keys.next().value;
};
function validatePath(path) {
  if (includes(path, "__proto__")) {
    throw new Error("__proto__ is not allowed as a property");
  }
  if (includes(path, "prototype")) {
    throw new Error("prototype is not allowed as a property");
  }
  if (includes(path, "constructor")) {
    throw new Error("constructor is not allowed as a property");
  }
}
var getDeep = (object, path) => {
  validatePath(path);
  for (let i = 0; i < path.length; i++) {
    const key = path[i];
    if (isSet(object)) {
      object = getNthKey(object, +key);
    } else if (isMap(object)) {
      const row = +key;
      const type = +path[++i] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(object, row);
      switch (type) {
        case "key":
          object = keyOfRow;
          break;
        case "value":
          object = object.get(keyOfRow);
          break;
      }
    } else {
      object = object[key];
    }
  }
  return object;
};
var setDeep = (object, path, mapper) => {
  validatePath(path);
  if (path.length === 0) {
    return mapper(object);
  }
  let parent = object;
  for (let i = 0; i < path.length - 1; i++) {
    const key = path[i];
    if (isArray(parent)) {
      const index = +key;
      parent = parent[index];
    } else if (isPlainObject2(parent)) {
      parent = parent[key];
    } else if (isSet(parent)) {
      const row = +key;
      parent = getNthKey(parent, row);
    } else if (isMap(parent)) {
      const isEnd = i === path.length - 2;
      if (isEnd) {
        break;
      }
      const row = +key;
      const type = +path[++i] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(parent, row);
      switch (type) {
        case "key":
          parent = keyOfRow;
          break;
        case "value":
          parent = parent.get(keyOfRow);
          break;
      }
    }
  }
  const lastKey = path[path.length - 1];
  if (isArray(parent)) {
    parent[+lastKey] = mapper(parent[+lastKey]);
  } else if (isPlainObject2(parent)) {
    parent[lastKey] = mapper(parent[lastKey]);
  }
  if (isSet(parent)) {
    const oldValue = getNthKey(parent, +lastKey);
    const newValue = mapper(oldValue);
    if (oldValue !== newValue) {
      parent.delete(oldValue);
      parent.add(newValue);
    }
  }
  if (isMap(parent)) {
    const row = +path[path.length - 2];
    const keyToRow = getNthKey(parent, row);
    const type = +lastKey === 0 ? "key" : "value";
    switch (type) {
      case "key": {
        const newKey = mapper(keyToRow);
        parent.set(newKey, parent.get(keyToRow));
        if (newKey !== keyToRow) {
          parent.delete(keyToRow);
        }
        break;
      }
      case "value": {
        parent.set(keyToRow, mapper(parent.get(keyToRow)));
        break;
      }
    }
  }
  return object;
};

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/plainer.js
function traverse(tree, walker2, origin = []) {
  if (!tree) {
    return;
  }
  if (!isArray(tree)) {
    forEach(tree, (subtree, key) => traverse(subtree, walker2, [...origin, ...parsePath(key)]));
    return;
  }
  const [nodeValue, children] = tree;
  if (children) {
    forEach(children, (child, key) => {
      traverse(child, walker2, [...origin, ...parsePath(key)]);
    });
  }
  walker2(nodeValue, origin);
}
function applyValueAnnotations(plain, annotations, superJson) {
  traverse(annotations, (type, path) => {
    plain = setDeep(plain, path, (v) => untransformValue(v, type, superJson));
  });
  return plain;
}
function applyReferentialEqualityAnnotations(plain, annotations) {
  function apply(identicalPaths, path) {
    const object = getDeep(plain, parsePath(path));
    identicalPaths.map(parsePath).forEach((identicalObjectPath) => {
      plain = setDeep(plain, identicalObjectPath, () => object);
    });
  }
  if (isArray(annotations)) {
    const [root, other] = annotations;
    root.forEach((identicalPath) => {
      plain = setDeep(plain, parsePath(identicalPath), () => plain);
    });
    if (other) {
      forEach(other, apply);
    }
  } else {
    forEach(annotations, apply);
  }
  return plain;
}
var isDeep = (object, superJson) => isPlainObject2(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);
function addIdentity(object, path, identities) {
  const existingSet = identities.get(object);
  if (existingSet) {
    existingSet.push(path);
  } else {
    identities.set(object, [path]);
  }
}
function generateReferentialEqualityAnnotations(identitites, dedupe) {
  const result = {};
  let rootEqualityPaths = void 0;
  identitites.forEach((paths) => {
    if (paths.length <= 1) {
      return;
    }
    if (!dedupe) {
      paths = paths.map((path) => path.map(String)).sort((a, b) => a.length - b.length);
    }
    const [representativePath, ...identicalPaths] = paths;
    if (representativePath.length === 0) {
      rootEqualityPaths = identicalPaths.map(stringifyPath);
    } else {
      result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);
    }
  });
  if (rootEqualityPaths) {
    if (isEmptyObject(result)) {
      return [rootEqualityPaths];
    } else {
      return [rootEqualityPaths, result];
    }
  } else {
    return isEmptyObject(result) ? void 0 : result;
  }
}
var walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = /* @__PURE__ */ new Map()) => {
  var _a25;
  const primitive = isPrimitive2(object);
  if (!primitive) {
    addIdentity(object, path, identities);
    const seen = seenObjects.get(object);
    if (seen) {
      return dedupe ? {
        transformedValue: null
      } : seen;
    }
  }
  if (!isDeep(object, superJson)) {
    const transformed2 = transformValue(object, superJson);
    const result2 = transformed2 ? {
      transformedValue: transformed2.value,
      annotations: [transformed2.type]
    } : {
      transformedValue: object
    };
    if (!primitive) {
      seenObjects.set(object, result2);
    }
    return result2;
  }
  if (includes(objectsInThisPath, object)) {
    return {
      transformedValue: null
    };
  }
  const transformationResult = transformValue(object, superJson);
  const transformed = (_a25 = transformationResult == null ? void 0 : transformationResult.value) != null ? _a25 : object;
  const transformedValue = isArray(transformed) ? [] : {};
  const innerAnnotations = {};
  forEach(transformed, (value, index) => {
    if (index === "__proto__" || index === "constructor" || index === "prototype") {
      throw new Error(`Detected property ${index}. This is a prototype pollution risk, please remove it from your object.`);
    }
    const recursiveResult = walker(value, identities, superJson, dedupe, [...path, index], [...objectsInThisPath, object], seenObjects);
    transformedValue[index] = recursiveResult.transformedValue;
    if (isArray(recursiveResult.annotations)) {
      innerAnnotations[index] = recursiveResult.annotations;
    } else if (isPlainObject2(recursiveResult.annotations)) {
      forEach(recursiveResult.annotations, (tree, key) => {
        innerAnnotations[escapeKey(index) + "." + key] = tree;
      });
    }
  });
  const result = isEmptyObject(innerAnnotations) ? {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type] : void 0
  } : {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations
  };
  if (!primitive) {
    seenObjects.set(object, result);
  }
  return result;
};

// ../../node_modules/.pnpm/copy-anything@3.0.5/node_modules/copy-anything/dist/index.js
init_esm_shims();

// ../../node_modules/.pnpm/is-what@4.1.16/node_modules/is-what/dist/index.js
init_esm_shims();
function getType2(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
function isArray2(payload) {
  return getType2(payload) === "Array";
}
function isPlainObject3(payload) {
  if (getType2(payload) !== "Object")
    return false;
  const prototype = Object.getPrototypeOf(payload);
  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
}
function isNull2(payload) {
  return getType2(payload) === "Null";
}
function isOneOf(a, b, c, d, e) {
  return (value) => a(value) || b(value) || !!c && c(value) || !!d && d(value) || !!e && e(value);
}
function isUndefined2(payload) {
  return getType2(payload) === "Undefined";
}
var isNullOrUndefined = isOneOf(isNull2, isUndefined2);

// ../../node_modules/.pnpm/copy-anything@3.0.5/node_modules/copy-anything/dist/index.js
function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  if (propType === "enumerable")
    carry[key] = newVal;
  if (includeNonenumerable && propType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
function copy(target22, options = {}) {
  if (isArray2(target22)) {
    return target22.map((item) => copy(item, options));
  }
  if (!isPlainObject3(target22)) {
    return target22;
  }
  const props = Object.getOwnPropertyNames(target22);
  const symbols = Object.getOwnPropertySymbols(target22);
  return [...props, ...symbols].reduce((carry, key) => {
    if (isArray2(options.props) && !options.props.includes(key)) {
      return carry;
    }
    const val = target22[key];
    const newVal = copy(val, options);
    assignProp(carry, key, newVal, target22, options.nonenumerable);
    return carry;
  }, {});
}

// ../../node_modules/.pnpm/superjson@2.2.2/node_modules/superjson/dist/index.js
var SuperJSON = class {
  /**
   * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.
   */
  constructor({ dedupe = false } = {}) {
    this.classRegistry = new ClassRegistry();
    this.symbolRegistry = new Registry((s) => {
      var _a25;
      return (_a25 = s.description) != null ? _a25 : "";
    });
    this.customTransformerRegistry = new CustomTransformerRegistry();
    this.allowedErrorProps = [];
    this.dedupe = dedupe;
  }
  serialize(object) {
    const identities = /* @__PURE__ */ new Map();
    const output = walker(object, identities, this, this.dedupe);
    const res = {
      json: output.transformedValue
    };
    if (output.annotations) {
      res.meta = {
        ...res.meta,
        values: output.annotations
      };
    }
    const equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);
    if (equalityAnnotations) {
      res.meta = {
        ...res.meta,
        referentialEqualities: equalityAnnotations
      };
    }
    return res;
  }
  deserialize(payload) {
    const { json, meta } = payload;
    let result = copy(json);
    if (meta == null ? void 0 : meta.values) {
      result = applyValueAnnotations(result, meta.values, this);
    }
    if (meta == null ? void 0 : meta.referentialEqualities) {
      result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);
    }
    return result;
  }
  stringify(object) {
    return JSON.stringify(this.serialize(object));
  }
  parse(string) {
    return this.deserialize(JSON.parse(string));
  }
  registerClass(v, options) {
    this.classRegistry.register(v, options);
  }
  registerSymbol(v, identifier) {
    this.symbolRegistry.register(v, identifier);
  }
  registerCustom(transformer, name) {
    this.customTransformerRegistry.register({
      name,
      ...transformer
    });
  }
  allowErrorProps(...props) {
    this.allowedErrorProps.push(...props);
  }
};
SuperJSON.defaultInstance = new SuperJSON();
SuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);
SuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);
SuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);
SuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);
SuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);
SuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);
SuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);
SuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);
var serialize = SuperJSON.serialize;
var deserialize = SuperJSON.deserialize;
var stringify = SuperJSON.stringify;
var parse = SuperJSON.parse;
var registerClass = SuperJSON.registerClass;
var registerCustom = SuperJSON.registerCustom;
var registerSymbol = SuperJSON.registerSymbol;
var allowErrorProps = SuperJSON.allowErrorProps;

// src/messaging/presets/broadcast-channel/context.ts
init_esm_shims();
var __DEVTOOLS_KIT_BROADCAST_MESSAGING_EVENT_KEY = "__devtools-kit-broadcast-messaging-event-key__";

// src/messaging/presets/broadcast-channel/index.ts
var BROADCAST_CHANNEL_NAME = "__devtools-kit:broadcast-channel__";
function createBroadcastChannel() {
  const channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
  return {
    post: (data) => {
      channel.postMessage(SuperJSON.stringify({
        event: __DEVTOOLS_KIT_BROADCAST_MESSAGING_EVENT_KEY,
        data
      }));
    },
    on: (handler) => {
      channel.onmessage = (event) => {
        const parsed = SuperJSON.parse(event.data);
        if (parsed.event === __DEVTOOLS_KIT_BROADCAST_MESSAGING_EVENT_KEY) {
          handler(parsed.data);
        }
      };
    }
  };
}

// src/messaging/presets/electron/index.ts
init_esm_shims();

// src/messaging/presets/electron/client.ts
init_esm_shims();

// src/messaging/presets/electron/context.ts
init_esm_shims();

var __ELECTRON_CLIENT_CONTEXT__ = "electron:client-context";
var __ELECTRON_RPOXY_CONTEXT__ = "electron:proxy-context";
var __ELECTRON_SERVER_CONTEXT__ = "electron:server-context";
var __DEVTOOLS_KIT_ELECTRON_MESSAGING_EVENT_KEY__ = {
  // client
  CLIENT_TO_PROXY: "client->proxy",
  // on: proxy->client
  // proxy
  PROXY_TO_CLIENT: "proxy->client",
  // on: server->proxy
  PROXY_TO_SERVER: "proxy->server",
  // on: client->proxy
  // server
  SERVER_TO_PROXY: "server->proxy"
  // on: proxy->server
};
function getElectronClientContext() {
  return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[__ELECTRON_CLIENT_CONTEXT__];
}
function setElectronClientContext(context) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[__ELECTRON_CLIENT_CONTEXT__] = context;
}
function getElectronProxyContext() {
  return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[__ELECTRON_RPOXY_CONTEXT__];
}
function setElectronProxyContext(context) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[__ELECTRON_RPOXY_CONTEXT__] = context;
}
function getElectronServerContext() {
  return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[__ELECTRON_SERVER_CONTEXT__];
}
function setElectronServerContext(context) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[__ELECTRON_SERVER_CONTEXT__] = context;
}

// src/messaging/presets/electron/client.ts
function createElectronClientChannel() {
  const socket = getElectronClientContext();
  return {
    post: (data) => {
      socket.emit(__DEVTOOLS_KIT_ELECTRON_MESSAGING_EVENT_KEY__.CLIENT_TO_PROXY, SuperJSON.stringify(data));
    },
    on: (handler) => {
      socket.on(__DEVTOOLS_KIT_ELECTRON_MESSAGING_EVENT_KEY__.PROXY_TO_CLIENT, (e) => {
        handler(SuperJSON.parse(e));
      });
    }
  };
}

// src/messaging/presets/electron/proxy.ts
init_esm_shims();
function createElectronProxyChannel() {
  const socket = getElectronProxyContext();
  return {
    post: (data) => {
    },
    on: (handler) => {
      socket.on(__DEVTOOLS_KIT_ELECTRON_MESSAGING_EVENT_KEY__.SERVER_TO_PROXY, (data) => {
        socket.broadcast.emit(__DEVTOOLS_KIT_ELECTRON_MESSAGING_EVENT_KEY__.PROXY_TO_CLIENT, data);
      });
      socket.on(__DEVTOOLS_KIT_ELECTRON_MESSAGING_EVENT_KEY__.CLIENT_TO_PROXY, (data) => {
        socket.broadcast.emit(__DEVTOOLS_KIT_ELECTRON_MESSAGING_EVENT_KEY__.PROXY_TO_SERVER, data);
      });
    }
  };
}

// src/messaging/presets/electron/server.ts
init_esm_shims();
function createElectronServerChannel() {
  const socket = getElectronServerContext();
  return {
    post: (data) => {
      socket.emit(__DEVTOOLS_KIT_ELECTRON_MESSAGING_EVENT_KEY__.SERVER_TO_PROXY, SuperJSON.stringify(data));
    },
    on: (handler) => {
      socket.on(__DEVTOOLS_KIT_ELECTRON_MESSAGING_EVENT_KEY__.PROXY_TO_SERVER, (data) => {
        handler(SuperJSON.parse(data));
      });
    }
  };
}

// src/messaging/presets/extension/index.ts
init_esm_shims();

// src/messaging/presets/extension/client.ts
init_esm_shims();

// src/messaging/presets/extension/context.ts
init_esm_shims();

var __EXTENSION_CLIENT_CONTEXT__ = "electron:client-context";
var __DEVTOOLS_KIT_EXTENSION_MESSAGING_EVENT_KEY__ = {
  // client
  CLIENT_TO_PROXY: "client->proxy",
  // on: proxy->client
  // proxy
  PROXY_TO_CLIENT: "proxy->client",
  // on: server->proxy
  PROXY_TO_SERVER: "proxy->server",
  // on: client->proxy
  // server
  SERVER_TO_PROXY: "server->proxy"
  // on: proxy->server
};
function getExtensionClientContext() {
  return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[__EXTENSION_CLIENT_CONTEXT__];
}
function setExtensionClientContext(context) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[__EXTENSION_CLIENT_CONTEXT__] = context;
}

// src/messaging/presets/extension/client.ts
function createExtensionClientChannel() {
  let disconnected = false;
  let port = null;
  let reconnectTimer = null;
  let onMessageHandler = null;
  function connect() {
    try {
      clearTimeout(reconnectTimer);
      port = chrome.runtime.connect({
        name: `${chrome.devtools.inspectedWindow.tabId}`
      });
      setExtensionClientContext(port);
      disconnected = false;
      port == null ? void 0 : port.onMessage.addListener(onMessageHandler);
      port.onDisconnect.addListener(() => {
        disconnected = true;
        port == null ? void 0 : port.onMessage.removeListener(onMessageHandler);
        reconnectTimer = setTimeout(connect, 1e3);
      });
    } catch (e) {
      disconnected = true;
    }
  }
  connect();
  return {
    post: (data) => {
      if (disconnected) {
        return;
      }
      port == null ? void 0 : port.postMessage(SuperJSON.stringify(data));
    },
    on: (handler) => {
      onMessageHandler = (data) => {
        if (disconnected) {
          return;
        }
        handler(SuperJSON.parse(data));
      };
      port == null ? void 0 : port.onMessage.addListener(onMessageHandler);
    }
  };
}

// src/messaging/presets/extension/proxy.ts
init_esm_shims();
function createExtensionProxyChannel() {
  const port = chrome.runtime.connect({
    name: "content-script"
  });
  function sendMessageToUserApp(payload) {
    window.postMessage({
      source: __DEVTOOLS_KIT_EXTENSION_MESSAGING_EVENT_KEY__.PROXY_TO_SERVER,
      payload
    }, "*");
  }
  function sendMessageToDevToolsClient(e) {
    if (e.data && e.data.source === __DEVTOOLS_KIT_EXTENSION_MESSAGING_EVENT_KEY__.SERVER_TO_PROXY) {
      try {
        port.postMessage(e.data.payload);
      } catch (e2) {
      }
    }
  }
  port.onMessage.addListener(sendMessageToUserApp);
  window.addEventListener("message", sendMessageToDevToolsClient);
  port.onDisconnect.addListener(() => {
    window.removeEventListener("message", sendMessageToDevToolsClient);
    sendMessageToUserApp(SuperJSON.stringify({
      event: "shutdown"
    }));
  });
  sendMessageToUserApp(SuperJSON.stringify({
    event: "init"
  }));
  return {
    post: (data) => {
    },
    on: (handler) => {
    }
  };
}

// src/messaging/presets/extension/server.ts
init_esm_shims();
function createExtensionServerChannel() {
  return {
    post: (data) => {
      window.postMessage({
        source: __DEVTOOLS_KIT_EXTENSION_MESSAGING_EVENT_KEY__.SERVER_TO_PROXY,
        payload: SuperJSON.stringify(data)
      }, "*");
    },
    on: (handler) => {
      const listener = (event) => {
        if (event.data.source === __DEVTOOLS_KIT_EXTENSION_MESSAGING_EVENT_KEY__.PROXY_TO_SERVER && event.data.payload) {
          handler(SuperJSON.parse(event.data.payload));
        }
      };
      window.addEventListener("message", listener);
      return () => {
        window.removeEventListener("message", listener);
      };
    }
  };
}

// src/messaging/presets/iframe/index.ts
init_esm_shims();

// src/messaging/presets/iframe/client.ts
init_esm_shims();


// src/messaging/presets/iframe/context.ts
init_esm_shims();

var __DEVTOOLS_KIT_IFRAME_MESSAGING_EVENT_KEY = "__devtools-kit-iframe-messaging-event-key__";
var __IFRAME_SERVER_CONTEXT__ = "iframe:server-context";
function getIframeServerContext() {
  return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[__IFRAME_SERVER_CONTEXT__];
}
function setIframeServerContext(context) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[__IFRAME_SERVER_CONTEXT__] = context;
}

// src/messaging/presets/iframe/client.ts
function createIframeClientChannel() {
  if (!_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.isBrowser) {
    return {
      post: (data) => {
      },
      on: (handler) => {
      }
    };
  }
  return {
    post: (data) => window.parent.postMessage(SuperJSON.stringify({
      event: __DEVTOOLS_KIT_IFRAME_MESSAGING_EVENT_KEY,
      data
    }), "*"),
    on: (handler) => window.addEventListener("message", (event) => {
      try {
        const parsed = SuperJSON.parse(event.data);
        if (event.source === window.parent && parsed.event === __DEVTOOLS_KIT_IFRAME_MESSAGING_EVENT_KEY) {
          handler(parsed.data);
        }
      } catch (e) {
      }
    })
  };
}

// src/messaging/presets/iframe/server.ts
init_esm_shims();

function createIframeServerChannel() {
  if (!_vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.isBrowser) {
    return {
      post: (data) => {
      },
      on: (handler) => {
      }
    };
  }
  return {
    post: (data) => {
      var _a25;
      const iframe = getIframeServerContext();
      (_a25 = iframe == null ? void 0 : iframe.contentWindow) == null ? void 0 : _a25.postMessage(SuperJSON.stringify({
        event: __DEVTOOLS_KIT_IFRAME_MESSAGING_EVENT_KEY,
        data
      }), "*");
    },
    on: (handler) => {
      window.addEventListener("message", (event) => {
        const iframe = getIframeServerContext();
        try {
          const parsed = SuperJSON.parse(event.data);
          if (event.source === (iframe == null ? void 0 : iframe.contentWindow) && parsed.event === __DEVTOOLS_KIT_IFRAME_MESSAGING_EVENT_KEY) {
            handler(parsed.data);
          }
        } catch (e) {
        }
      });
    }
  };
}

// src/messaging/presets/vite/index.ts
init_esm_shims();

// src/messaging/presets/vite/client.ts
init_esm_shims();

// src/messaging/presets/vite/context.ts
init_esm_shims();

var __DEVTOOLS_KIT_VITE_MESSAGING_EVENT_KEY = "__devtools-kit-vite-messaging-event-key__";
var __VITE_CLIENT_CONTEXT__ = "vite:client-context";
var __VITE_SERVER_CONTEXT__ = "vite:server-context";
function getViteClientContext() {
  return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[__VITE_CLIENT_CONTEXT__];
}
function setViteClientContext(context) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[__VITE_CLIENT_CONTEXT__] = context;
}
function getViteServerContext() {
  return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[__VITE_SERVER_CONTEXT__];
}
function setViteServerContext(context) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target[__VITE_SERVER_CONTEXT__] = context;
}

// src/messaging/presets/vite/client.ts
function createViteClientChannel() {
  const client = getViteClientContext();
  return {
    post: (data) => {
      client == null ? void 0 : client.send(__DEVTOOLS_KIT_VITE_MESSAGING_EVENT_KEY, SuperJSON.stringify(data));
    },
    on: (handler) => {
      client == null ? void 0 : client.on(__DEVTOOLS_KIT_VITE_MESSAGING_EVENT_KEY, (event) => {
        handler(SuperJSON.parse(event));
      });
    }
  };
}

// src/messaging/presets/vite/server.ts
init_esm_shims();
function createViteServerChannel() {
  var _a25;
  const viteServer = getViteServerContext();
  const ws = (_a25 = viteServer.hot) != null ? _a25 : viteServer.ws;
  return {
    post: (data) => ws == null ? void 0 : ws.send(__DEVTOOLS_KIT_VITE_MESSAGING_EVENT_KEY, SuperJSON.stringify(data)),
    on: (handler) => ws == null ? void 0 : ws.on(__DEVTOOLS_KIT_VITE_MESSAGING_EVENT_KEY, (event) => {
      handler(SuperJSON.parse(event));
    })
  };
}

// src/messaging/presets/ws/index.ts
init_esm_shims();

// src/messaging/presets/ws/client.ts
init_esm_shims();

// src/messaging/presets/ws/context.ts
init_esm_shims();


// src/messaging/presets/ws/server.ts
init_esm_shims();

// src/messaging/index.ts
var _a19, _b19;
(_b19 = (_a19 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT_MESSAGE_CHANNELS__) != null ? _b19 : _a19.__VUE_DEVTOOLS_KIT_MESSAGE_CHANNELS__ = [];
var _a20, _b20;
(_b20 = (_a20 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT_RPC_CLIENT__) != null ? _b20 : _a20.__VUE_DEVTOOLS_KIT_RPC_CLIENT__ = null;
var _a21, _b21;
(_b21 = (_a21 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT_RPC_SERVER__) != null ? _b21 : _a21.__VUE_DEVTOOLS_KIT_RPC_SERVER__ = null;
var _a22, _b22;
(_b22 = (_a22 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT_VITE_RPC_CLIENT__) != null ? _b22 : _a22.__VUE_DEVTOOLS_KIT_VITE_RPC_CLIENT__ = null;
var _a23, _b23;
(_b23 = (_a23 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT_VITE_RPC_SERVER__) != null ? _b23 : _a23.__VUE_DEVTOOLS_KIT_VITE_RPC_SERVER__ = null;
var _a24, _b24;
(_b24 = (_a24 = _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target).__VUE_DEVTOOLS_KIT_BROADCAST_RPC_SERVER__) != null ? _b24 : _a24.__VUE_DEVTOOLS_KIT_BROADCAST_RPC_SERVER__ = null;
function setRpcClientToGlobal(rpc) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_RPC_CLIENT__ = rpc;
}
function setRpcServerToGlobal(rpc) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_RPC_SERVER__ = rpc;
}
function getRpcClient() {
  return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_RPC_CLIENT__;
}
function getRpcServer() {
  return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_RPC_SERVER__;
}
function setViteRpcClientToGlobal(rpc) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_VITE_RPC_CLIENT__ = rpc;
}
function setViteRpcServerToGlobal(rpc) {
  _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_VITE_RPC_SERVER__ = rpc;
}
function getViteRpcClient() {
  return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_VITE_RPC_CLIENT__;
}
function getViteRpcServer() {
  return _vue_devtools_shared__WEBPACK_IMPORTED_MODULE_0__.target.__VUE_DEVTOOLS_KIT_VITE_RPC_SERVER__;
}
function getChannel(preset, host = "client") {
  const channel = {
    iframe: {
      client: createIframeClientChannel,
      server: createIframeServerChannel
    }[host],
    electron: {
      client: createElectronClientChannel,
      proxy: createElectronProxyChannel,
      server: createElectronServerChannel
    }[host],
    vite: {
      client: createViteClientChannel,
      server: createViteServerChannel
    }[host],
    broadcast: {
      client: createBroadcastChannel,
      server: createBroadcastChannel
    }[host],
    extension: {
      client: createExtensionClientChannel,
      proxy: createExtensionProxyChannel,
      server: createExtensionServerChannel
    }[host]
  }[preset];
  return channel();
}
function createRpcClient(functions, options = {}) {
  const { channel: _channel, options: _options, preset } = options;
  const channel = preset ? getChannel(preset) : _channel;
  const rpc = (0,birpc__WEBPACK_IMPORTED_MODULE_3__.createBirpc)(functions, {
    ..._options,
    ...channel,
    timeout: -1
  });
  if (preset === "vite") {
    setViteRpcClientToGlobal(rpc);
    return;
  }
  setRpcClientToGlobal(rpc);
  return rpc;
}
function createRpcServer(functions, options = {}) {
  const { channel: _channel, options: _options, preset } = options;
  const channel = preset ? getChannel(preset, "server") : _channel;
  const rpcServer = getRpcServer();
  if (!rpcServer) {
    const group = (0,birpc__WEBPACK_IMPORTED_MODULE_3__.createBirpcGroup)(functions, [channel], {
      ..._options,
      timeout: -1
    });
    if (preset === "vite") {
      setViteRpcServerToGlobal(group);
      return;
    }
    setRpcServerToGlobal(group);
  } else {
    rpcServer.updateChannels((channels) => {
      channels.push(channel);
    });
  }
}
function createRpcProxy(options = {}) {
  const { channel: _channel, options: _options, preset } = options;
  const channel = preset ? getChannel(preset, "proxy") : _channel;
  return (0,birpc__WEBPACK_IMPORTED_MODULE_3__.createBirpc)({}, {
    ..._options,
    ...channel,
    timeout: -1
  });
}

// src/shared/index.ts
init_esm_shims();

// src/shared/env.ts
init_esm_shims();

// src/shared/time.ts
init_esm_shims();

// src/shared/util.ts
init_esm_shims();

// src/core/component/state/replacer.ts
init_esm_shims();

// src/core/component/state/custom.ts
init_esm_shims();
function getFunctionDetails(func) {
  let string = "";
  let matches = null;
  try {
    string = Function.prototype.toString.call(func);
    matches = String.prototype.match.call(string, /\([\s\S]*?\)/);
  } catch (e) {
  }
  const match = matches && matches[0];
  const args = typeof match === "string" ? match : "(?)";
  const name = typeof func.name === "string" ? func.name : "";
  return {
    _custom: {
      type: "function",
      displayText: `<span style="opacity:.8;margin-right:5px;">function</span> <span style="white-space:nowrap;">${escape(name)}${args}</span>`,
      tooltipText: string.trim() ? `<pre>${string}</pre>` : null
    }
  };
}
function getBigIntDetails(val) {
  const stringifiedBigInt = BigInt.prototype.toString.call(val);
  return {
    _custom: {
      type: "bigint",
      displayText: `BigInt(${stringifiedBigInt})`,
      value: stringifiedBigInt
    }
  };
}
function getDateDetails(val) {
  const date = new Date(val.getTime());
  date.setMinutes(date.getMinutes() - date.getTimezoneOffset());
  return {
    _custom: {
      type: "date",
      displayText: Date.prototype.toString.call(val),
      value: date.toISOString().slice(0, -1)
    }
  };
}
function getMapDetails(val) {
  const list = Object.fromEntries(val);
  return {
    _custom: {
      type: "map",
      displayText: "Map",
      value: list,
      readOnly: true,
      fields: {
        abstract: true
      }
    }
  };
}
function getSetDetails(val) {
  const list = Array.from(val);
  return {
    _custom: {
      type: "set",
      displayText: `Set[${list.length}]`,
      value: list,
      readOnly: true
    }
  };
}
function getCaughtGetters(store) {
  const getters = {};
  const origGetters = store.getters || {};
  const keys = Object.keys(origGetters);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    Object.defineProperty(getters, key, {
      enumerable: true,
      get: () => {
        try {
          return origGetters[key];
        } catch (e) {
          return e;
        }
      }
    });
  }
  return getters;
}
function reduceStateList(list) {
  if (!list.length)
    return void 0;
  return list.reduce((map, item) => {
    const key = item.type || "data";
    const obj = map[key] = map[key] || {};
    obj[item.key] = item.value;
    return map;
  }, {});
}
function namedNodeMapToObject(map) {
  const result = {};
  const l = map.length;
  for (let i = 0; i < l; i++) {
    const node = map.item(i);
    result[node.name] = node.value;
  }
  return result;
}
function getStoreDetails(store) {
  return {
    _custom: {
      type: "store",
      displayText: "Store",
      value: {
        state: store.state,
        getters: getCaughtGetters(store)
      },
      fields: {
        abstract: true
      }
    }
  };
}
function getRouterDetails(router) {
  return {
    _custom: {
      type: "router",
      displayText: "VueRouter",
      value: {
        options: router.options,
        currentRoute: router.currentRoute
      },
      fields: {
        abstract: true
      }
    }
  };
}
function getInstanceDetails(instance) {
  if (instance._)
    instance = instance._;
  const state = processInstanceState(instance);
  return {
    _custom: {
      type: "component",
      id: instance.__VUE_DEVTOOLS_NEXT_UID__,
      displayText: getInstanceName(instance),
      tooltipText: "Component instance",
      value: reduceStateList(state),
      fields: {
        abstract: true
      }
    }
  };
}
function getComponentDefinitionDetails(definition) {
  let display = getComponentName(definition);
  if (display) {
    if (definition.name && definition.__file)
      display += ` <span>(${definition.__file})</span>`;
  } else {
    display = "<i>Unknown Component</i>";
  }
  return {
    _custom: {
      type: "component-definition",
      displayText: display,
      tooltipText: "Component definition",
      ...definition.__file ? {
        file: definition.__file
      } : {}
    }
  };
}
function getHTMLElementDetails(value) {
  try {
    return {
      _custom: {
        type: "HTMLElement",
        displayText: `<span class="opacity-30">&lt;</span><span class="text-blue-500">${value.tagName.toLowerCase()}</span><span class="opacity-30">&gt;</span>`,
        value: namedNodeMapToObject(value.attributes)
      }
    };
  } catch (e) {
    return {
      _custom: {
        type: "HTMLElement",
        displayText: `<span class="text-blue-500">${String(value)}</span>`
      }
    };
  }
}
function tryGetRefValue(ref) {
  if (ensurePropertyExists(ref, "_value", true)) {
    return ref._value;
  }
  if (ensurePropertyExists(ref, "value", true)) {
    return ref.value;
  }
}
function getObjectDetails(object) {
  var _a25, _b25, _c, _d;
  const info = getSetupStateType(object);
  const isState = info.ref || info.computed || info.reactive;
  if (isState) {
    const stateTypeName = info.computed ? "Computed" : info.ref ? "Ref" : info.reactive ? "Reactive" : null;
    const value = toRaw2(info.reactive ? object : tryGetRefValue(object));
    const raw = ensurePropertyExists(object, "effect") ? ((_b25 = (_a25 = object.effect) == null ? void 0 : _a25.raw) == null ? void 0 : _b25.toString()) || ((_d = (_c = object.effect) == null ? void 0 : _c.fn) == null ? void 0 : _d.toString()) : null;
    return {
      _custom: {
        type: stateTypeName == null ? void 0 : stateTypeName.toLowerCase(),
        stateTypeName,
        value,
        ...raw ? { tooltipText: `<span class="font-mono">${raw}</span>` } : {}
      }
    };
  }
  if (ensurePropertyExists(object, "__asyncLoader") && typeof object.__asyncLoader === "function") {
    return {
      _custom: {
        type: "component-definition",
        display: "Async component definition"
      }
    };
  }
}

// src/core/component/state/replacer.ts
function stringifyReplacer(key, _value, depth, seenInstance) {
  var _a25;
  if (key === "compilerOptions")
    return;
  const val = this[key];
  const type = typeof val;
  if (Array.isArray(val)) {
    const l = val.length;
    if (l > MAX_ARRAY_SIZE) {
      return {
        _isArray: true,
        length: l,
        items: val.slice(0, MAX_ARRAY_SIZE)
      };
    }
    return val;
  } else if (typeof val === "string") {
    if (val.length > MAX_STRING_SIZE)
      return `${val.substring(0, MAX_STRING_SIZE)}... (${val.length} total length)`;
    else
      return val;
  } else if (type === "undefined") {
    return UNDEFINED;
  } else if (val === Number.POSITIVE_INFINITY) {
    return INFINITY;
  } else if (val === Number.NEGATIVE_INFINITY) {
    return NEGATIVE_INFINITY;
  } else if (typeof val === "function") {
    return getFunctionDetails(val);
  } else if (type === "symbol") {
    return `[native Symbol ${Symbol.prototype.toString.call(val)}]`;
  } else if (typeof val === "bigint") {
    return getBigIntDetails(val);
  } else if (val !== null && typeof val === "object") {
    const proto = Object.prototype.toString.call(val);
    if (proto === "[object Map]") {
      return getMapDetails(val);
    } else if (proto === "[object Set]") {
      return getSetDetails(val);
    } else if (proto === "[object RegExp]") {
      return `[native RegExp ${RegExp.prototype.toString.call(val)}]`;
    } else if (proto === "[object Date]") {
      return getDateDetails(val);
    } else if (proto === "[object Error]") {
      return `[native Error ${val.message}<>${val.stack}]`;
    } else if (ensurePropertyExists(val, "state", true) && ensurePropertyExists(val, "_vm", true)) {
      return getStoreDetails(val);
    } else if (val.constructor && val.constructor.name === "VueRouter") {
      return getRouterDetails(val);
    } else if (isVueInstance(val)) {
      const componentVal = getInstanceDetails(val);
      const parentInstanceDepth = seenInstance == null ? void 0 : seenInstance.get(val);
      if (parentInstanceDepth && parentInstanceDepth < depth) {
        return `[[CircularRef]] <${componentVal._custom.displayText}>`;
      }
      seenInstance == null ? void 0 : seenInstance.set(val, depth);
      return componentVal;
    } else if (ensurePropertyExists(val, "render", true) && typeof val.render === "function") {
      return getComponentDefinitionDetails(val);
    } else if (val.constructor && val.constructor.name === "VNode") {
      return `[native VNode <${val.tag}>]`;
    } else if (typeof HTMLElement !== "undefined" && val instanceof HTMLElement) {
      return getHTMLElementDetails(val);
    } else if (((_a25 = val.constructor) == null ? void 0 : _a25.name) === "Store" && "_wrappedGetters" in val) {
      return "[object Store]";
    } else if (ensurePropertyExists(val, "currentRoute", true)) {
      return "[object Router]";
    }
    const customDetails = getObjectDetails(val);
    if (customDetails != null)
      return customDetails;
  } else if (Number.isNaN(val)) {
    return NAN;
  }
  return sanitize(val);
}

// src/shared/transfer.ts
init_esm_shims();
var MAX_SERIALIZED_SIZE = 2 * 1024 * 1024;
function isObject(_data, proto) {
  return proto === "[object Object]";
}
function isArray3(_data, proto) {
  return proto === "[object Array]";
}
function isVueReactiveLinkNode(node) {
  var _a25;
  const constructorName = (_a25 = node == null ? void 0 : node.constructor) == null ? void 0 : _a25.name;
  return constructorName === "Dep" && "activeLink" in node || constructorName === "Link" && "dep" in node;
}
function encode(data, replacer, list, seen, depth = 0, seenVueInstance = /* @__PURE__ */ new Map()) {
  let stored;
  let key;
  let value;
  let i;
  let l;
  const seenIndex = seen.get(data);
  if (seenIndex != null)
    return seenIndex;
  const index = list.length;
  const proto = Object.prototype.toString.call(data);
  if (isObject(data, proto)) {
    if (isVueReactiveLinkNode(data)) {
      return index;
    }
    stored = {};
    seen.set(data, index);
    list.push(stored);
    const keys = Object.keys(data);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      if (key === "compilerOptions")
        return index;
      value = data[key];
      const isVm = value != null && isObject(value, Object.prototype.toString.call(data)) && isVueInstance(value);
      try {
        if (replacer) {
          value = replacer.call(data, key, value, depth, seenVueInstance);
        }
      } catch (e) {
        value = e;
      }
      stored[key] = encode(value, replacer, list, seen, depth + 1, seenVueInstance);
      if (isVm) {
        seenVueInstance.delete(value);
      }
    }
  } else if (isArray3(data, proto)) {
    stored = [];
    seen.set(data, index);
    list.push(stored);
    for (i = 0, l = data.length; i < l; i++) {
      try {
        value = data[i];
        if (replacer)
          value = replacer.call(data, i, value, depth, seenVueInstance);
      } catch (e) {
        value = e;
      }
      stored[i] = encode(value, replacer, list, seen, depth + 1, seenVueInstance);
    }
  } else {
    list.push(data);
  }
  return index;
}
function decode(list, reviver2 = null) {
  let i = list.length;
  let j, k, data, key, value, proto;
  while (i--) {
    data = list[i];
    proto = Object.prototype.toString.call(data);
    if (proto === "[object Object]") {
      const keys = Object.keys(data);
      for (j = 0, k = keys.length; j < k; j++) {
        key = keys[j];
        value = list[data[key]];
        if (reviver2)
          value = reviver2.call(data, key, value);
        data[key] = value;
      }
    } else if (proto === "[object Array]") {
      for (j = 0, k = data.length; j < k; j++) {
        value = list[data[j]];
        if (reviver2)
          value = reviver2.call(data, j, value);
        data[j] = value;
      }
    }
  }
}
function stringifyCircularAutoChunks(data, replacer = null, space = null) {
  let result;
  try {
    result = arguments.length === 1 ? JSON.stringify(data) : JSON.stringify(data, (k, v) => {
      var _a25;
      return (_a25 = replacer == null ? void 0 : replacer(k, v)) == null ? void 0 : _a25.call(this);
    }, space);
  } catch (e) {
    result = stringifyStrictCircularAutoChunks(data, replacer, space);
  }
  if (result.length > MAX_SERIALIZED_SIZE) {
    const chunkCount = Math.ceil(result.length / MAX_SERIALIZED_SIZE);
    const chunks = [];
    for (let i = 0; i < chunkCount; i++)
      chunks.push(result.slice(i * MAX_SERIALIZED_SIZE, (i + 1) * MAX_SERIALIZED_SIZE));
    return chunks;
  }
  return result;
}
function stringifyStrictCircularAutoChunks(data, replacer = null, space = null) {
  const list = [];
  encode(data, replacer, list, /* @__PURE__ */ new Map());
  return space ? ` ${JSON.stringify(list, null, space)}` : ` ${JSON.stringify(list)}`;
}
function parseCircularAutoChunks(data, reviver2 = null) {
  if (Array.isArray(data))
    data = data.join("");
  const hasCircular = /^\s/.test(data);
  if (!hasCircular) {
    return arguments.length === 1 ? JSON.parse(data) : JSON.parse(data, reviver2);
  } else {
    const list = JSON.parse(data);
    decode(list, reviver2);
    return list[0];
  }
}

// src/shared/util.ts
function stringify2(data) {
  return stringifyCircularAutoChunks(data, stringifyReplacer);
}
function parse2(data, revive2 = false) {
  if (data == void 0)
    return {};
  return revive2 ? parseCircularAutoChunks(data, reviver) : parseCircularAutoChunks(data);
}

// src/index.ts
var devtools = {
  hook,
  init: () => {
    initDevTools();
  },
  get ctx() {
    return devtoolsContext;
  },
  get api() {
    return devtoolsContext.api;
  }
};



/***/ },

/***/ "./node_modules/@vue/devtools-shared/dist/index.js"
/*!*********************************************************!*\
  !*** ./node_modules/@vue/devtools-shared/dist/index.js ***!
  \*********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BROADCAST_CHANNEL_NAME: () => (/* binding */ BROADCAST_CHANNEL_NAME),
/* harmony export */   NOOP: () => (/* binding */ NOOP),
/* harmony export */   VIEW_MODE_STORAGE_KEY: () => (/* binding */ VIEW_MODE_STORAGE_KEY),
/* harmony export */   VITE_PLUGIN_CLIENT_URL_STORAGE_KEY: () => (/* binding */ VITE_PLUGIN_CLIENT_URL_STORAGE_KEY),
/* harmony export */   VITE_PLUGIN_DETECTED_STORAGE_KEY: () => (/* binding */ VITE_PLUGIN_DETECTED_STORAGE_KEY),
/* harmony export */   basename: () => (/* binding */ basename),
/* harmony export */   camelize: () => (/* binding */ camelize),
/* harmony export */   classify: () => (/* binding */ classify),
/* harmony export */   deepClone: () => (/* binding */ deepClone),
/* harmony export */   isArray: () => (/* binding */ isArray),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser),
/* harmony export */   isInChromePanel: () => (/* binding */ isInChromePanel),
/* harmony export */   isInElectron: () => (/* binding */ isInElectron),
/* harmony export */   isInIframe: () => (/* binding */ isInIframe),
/* harmony export */   isInSeparateWindow: () => (/* binding */ isInSeparateWindow),
/* harmony export */   isMacOS: () => (/* binding */ isMacOS),
/* harmony export */   isMap: () => (/* binding */ isMap),
/* harmony export */   isNumeric: () => (/* binding */ isNumeric),
/* harmony export */   isNuxtApp: () => (/* binding */ isNuxtApp),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isSet: () => (/* binding */ isSet),
/* harmony export */   isUrlString: () => (/* binding */ isUrlString),
/* harmony export */   kebabize: () => (/* binding */ kebabize),
/* harmony export */   randomStr: () => (/* binding */ randomStr),
/* harmony export */   sortByKey: () => (/* binding */ sortByKey),
/* harmony export */   target: () => (/* binding */ target)
/* harmony export */ });
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target2) => (target2 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target2, "default", { value: mod, enumerable: true }) : target2,
  mod
));

// ../../node_modules/.pnpm/tsup@8.4.0_@microsoft+api-extractor@7.51.1_@types+node@22.13.14__jiti@2.4.2_postcss@8.5_96eb05a9d65343021e53791dd83f3773/node_modules/tsup/assets/esm_shims.js
var init_esm_shims = __esm({
  "../../node_modules/.pnpm/tsup@8.4.0_@microsoft+api-extractor@7.51.1_@types+node@22.13.14__jiti@2.4.2_postcss@8.5_96eb05a9d65343021e53791dd83f3773/node_modules/tsup/assets/esm_shims.js"() {
    "use strict";
  }
});

// ../../node_modules/.pnpm/rfdc@1.4.1/node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "../../node_modules/.pnpm/rfdc@1.4.1/node_modules/rfdc/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    module.exports = rfdc2;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc2(opts) {
      opts = opts || {};
      if (opts.circles) return rfdcCircles(opts);
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false) continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      const refs = [];
      const refsNew = [];
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            const index = refs.indexOf(cur);
            if (index !== -1) {
              a2[k] = refsNew[index];
            } else {
              a2[k] = fn(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false) continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// src/index.ts
init_esm_shims();

// src/constants.ts
init_esm_shims();
var VIEW_MODE_STORAGE_KEY = "__vue-devtools-view-mode__";
var VITE_PLUGIN_DETECTED_STORAGE_KEY = "__vue-devtools-vite-plugin-detected__";
var VITE_PLUGIN_CLIENT_URL_STORAGE_KEY = "__vue-devtools-vite-plugin-client-url__";
var BROADCAST_CHANNEL_NAME = "__vue-devtools-broadcast-channel__";

// src/env.ts
init_esm_shims();
var isBrowser = typeof navigator !== "undefined";
var target = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : {};
var isInChromePanel = typeof target.chrome !== "undefined" && !!target.chrome.devtools;
var isInIframe = isBrowser && target.self !== target.top;
var _a;
var isInElectron = typeof navigator !== "undefined" && ((_a = navigator.userAgent) == null ? void 0 : _a.toLowerCase().includes("electron"));
var isNuxtApp = typeof window !== "undefined" && !!window.__NUXT__;
var isInSeparateWindow = !isInIframe && !isInChromePanel && !isInElectron;

// src/general.ts
init_esm_shims();
var import_rfdc = __toESM(require_rfdc(), 1);
function NOOP() {
}
var isNumeric = (str) => `${+str}` === str;
var isMacOS = () => (navigator == null ? void 0 : navigator.platform) ? navigator == null ? void 0 : navigator.platform.toLowerCase().includes("mac") : /Macintosh/.test(navigator.userAgent);
var classifyRE = /(?:^|[-_/])(\w)/g;
var camelizeRE = /-(\w)/g;
var kebabizeRE = /([a-z0-9])([A-Z])/g;
function toUpper(_, c) {
  return c ? c.toUpperCase() : "";
}
function classify(str) {
  return str && `${str}`.replace(classifyRE, toUpper);
}
function camelize(str) {
  return str && str.replace(camelizeRE, toUpper);
}
function kebabize(str) {
  return str && str.replace(kebabizeRE, (_, lowerCaseCharacter, upperCaseLetter) => {
    return `${lowerCaseCharacter}-${upperCaseLetter}`;
  }).toLowerCase();
}
function basename(filename, ext) {
  let normalizedFilename = filename.replace(/^[a-z]:/i, "").replace(/\\/g, "/");
  if (normalizedFilename.endsWith(`index${ext}`)) {
    normalizedFilename = normalizedFilename.replace(`/index${ext}`, ext);
  }
  const lastSlashIndex = normalizedFilename.lastIndexOf("/");
  const baseNameWithExt = normalizedFilename.substring(lastSlashIndex + 1);
  if (ext) {
    const extIndex = baseNameWithExt.lastIndexOf(ext);
    return baseNameWithExt.substring(0, extIndex);
  }
  return "";
}
function sortByKey(state) {
  return state && state.slice().sort((a, b) => {
    if (a.key < b.key)
      return -1;
    if (a.key > b.key)
      return 1;
    return 0;
  });
}
var HTTP_URL_RE = /^https?:\/\//;
function isUrlString(str) {
  return str.startsWith("/") || HTTP_URL_RE.test(str);
}
var deepClone = (0, import_rfdc.default)({ circles: true });
function randomStr() {
  return Math.random().toString(36).slice(2);
}
function isObject(value) {
  return typeof value === "object" && !Array.isArray(value) && value !== null;
}
function isArray(value) {
  return Array.isArray(value);
}
function isSet(value) {
  return value instanceof Set;
}
function isMap(value) {
  return value instanceof Map;
}



/***/ },

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js"
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ARRAY_ITERATE_KEY: () => (/* binding */ ARRAY_ITERATE_KEY),
/* harmony export */   EffectFlags: () => (/* binding */ EffectFlags),
/* harmony export */   EffectScope: () => (/* binding */ EffectScope),
/* harmony export */   ITERATE_KEY: () => (/* binding */ ITERATE_KEY),
/* harmony export */   MAP_KEY_ITERATE_KEY: () => (/* binding */ MAP_KEY_ITERATE_KEY),
/* harmony export */   ReactiveEffect: () => (/* binding */ ReactiveEffect),
/* harmony export */   ReactiveFlags: () => (/* binding */ ReactiveFlags),
/* harmony export */   TrackOpTypes: () => (/* binding */ TrackOpTypes),
/* harmony export */   TriggerOpTypes: () => (/* binding */ TriggerOpTypes),
/* harmony export */   WatchErrorCodes: () => (/* binding */ WatchErrorCodes),
/* harmony export */   computed: () => (/* binding */ computed),
/* harmony export */   customRef: () => (/* binding */ customRef),
/* harmony export */   effect: () => (/* binding */ effect),
/* harmony export */   effectScope: () => (/* binding */ effectScope),
/* harmony export */   enableTracking: () => (/* binding */ enableTracking),
/* harmony export */   getCurrentScope: () => (/* binding */ getCurrentScope),
/* harmony export */   getCurrentWatcher: () => (/* binding */ getCurrentWatcher),
/* harmony export */   isProxy: () => (/* binding */ isProxy),
/* harmony export */   isReactive: () => (/* binding */ isReactive),
/* harmony export */   isReadonly: () => (/* binding */ isReadonly),
/* harmony export */   isRef: () => (/* binding */ isRef),
/* harmony export */   isShallow: () => (/* binding */ isShallow),
/* harmony export */   markRaw: () => (/* binding */ markRaw),
/* harmony export */   onEffectCleanup: () => (/* binding */ onEffectCleanup),
/* harmony export */   onScopeDispose: () => (/* binding */ onScopeDispose),
/* harmony export */   onWatcherCleanup: () => (/* binding */ onWatcherCleanup),
/* harmony export */   pauseTracking: () => (/* binding */ pauseTracking),
/* harmony export */   proxyRefs: () => (/* binding */ proxyRefs),
/* harmony export */   reactive: () => (/* binding */ reactive),
/* harmony export */   reactiveReadArray: () => (/* binding */ reactiveReadArray),
/* harmony export */   readonly: () => (/* binding */ readonly),
/* harmony export */   ref: () => (/* binding */ ref),
/* harmony export */   resetTracking: () => (/* binding */ resetTracking),
/* harmony export */   shallowReactive: () => (/* binding */ shallowReactive),
/* harmony export */   shallowReadArray: () => (/* binding */ shallowReadArray),
/* harmony export */   shallowReadonly: () => (/* binding */ shallowReadonly),
/* harmony export */   shallowRef: () => (/* binding */ shallowRef),
/* harmony export */   stop: () => (/* binding */ stop),
/* harmony export */   toRaw: () => (/* binding */ toRaw),
/* harmony export */   toReactive: () => (/* binding */ toReactive),
/* harmony export */   toReadonly: () => (/* binding */ toReadonly),
/* harmony export */   toRef: () => (/* binding */ toRef),
/* harmony export */   toRefs: () => (/* binding */ toRefs),
/* harmony export */   toValue: () => (/* binding */ toValue),
/* harmony export */   track: () => (/* binding */ track),
/* harmony export */   traverse: () => (/* binding */ traverse),
/* harmony export */   trigger: () => (/* binding */ trigger),
/* harmony export */   triggerRef: () => (/* binding */ triggerRef),
/* harmony export */   unref: () => (/* binding */ unref),
/* harmony export */   watch: () => (/* binding */ watch)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/**
* @vue/reactivity v3.5.26
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/


function warn(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}

let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    /**
     * @internal
     */
    this._active = true;
    /**
     * @internal track `on` calls, allow `on` call multiple times
     */
    this._on = 0;
    /**
     * @internal
     */
    this.effects = [];
    /**
     * @internal
     */
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (true) {
      warn(`cannot run an inactive effect scope.`);
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    if (++this._on === 1) {
      this.prevScope = activeEffectScope;
      activeEffectScope = this;
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    if (this._on > 0 && --this._on === 0) {
      activeEffectScope = this.prevScope;
      this.prevScope = void 0;
    }
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      this.effects.length = 0;
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else if ( true && !failSilently) {
    warn(
      `onScopeDispose() is called when there is no active effect scope to be associated with.`
    );
  }
}

let activeSub;
const EffectFlags = {
  "ACTIVE": 1,
  "1": "ACTIVE",
  "RUNNING": 2,
  "2": "RUNNING",
  "TRACKING": 4,
  "4": "TRACKING",
  "NOTIFIED": 8,
  "8": "NOTIFIED",
  "DIRTY": 16,
  "16": "DIRTY",
  "ALLOW_RECURSE": 32,
  "32": "ALLOW_RECURSE",
  "PAUSED": 64,
  "64": "PAUSED",
  "EVALUATED": 128,
  "128": "EVALUATED"
};
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    /**
     * @internal
     */
    this.deps = void 0;
    /**
     * @internal
     */
    this.depsTail = void 0;
    /**
     * @internal
     */
    this.flags = 1 | 4;
    /**
     * @internal
     */
    this.next = void 0;
    /**
     * @internal
     */
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= -65;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      if ( true && activeSub !== this) {
        warn(
          "Active effect was not restored correctly - this is likely a Vue internal bug."
        );
      }
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= -2;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed) {
  if (computed.flags & 4 && !(computed.flags & 16)) {
    return;
  }
  computed.flags &= -17;
  if (computed.globalVersion === globalVersion) {
    return;
  }
  computed.globalVersion = globalVersion;
  if (!computed.isSSR && computed.flags & 128 && (!computed.deps && !computed._dirty || !isDirty(computed))) {
    return;
  }
  computed.flags |= 2;
  const dep = computed.dep;
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed;
  shouldTrack = true;
  try {
    prepareDeps(computed);
    const value = computed.fn(computed._value);
    if (dep.version === 0 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, computed._value)) {
      computed.flags |= 128;
      computed._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed);
    computed.flags &= -3;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if ( true && dep.subsHead === link) {
    dep.subsHead = nextSub;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= -5;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
function effect(fn, options) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const e = new ReactiveEffect(fn);
  if (options) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(e, options);
  }
  try {
    e.run();
  } catch (err) {
    e.stop();
    throw err;
  }
  const runner = e.run.bind(e);
  runner.effect = e;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function onEffectCleanup(fn, failSilently = false) {
  if (activeSub instanceof ReactiveEffect) {
    activeSub.cleanup = fn;
  } else if ( true && !failSilently) {
    warn(
      `onEffectCleanup() was called when there was no active effect to associate with.`
    );
  }
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}

let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  // TODO isolatedDeclarations "__v_skip"
  constructor(computed) {
    this.computed = computed;
    this.version = 0;
    /**
     * Link between this dep and the current active effect
     */
    this.activeLink = void 0;
    /**
     * Doubly linked list representing the subscribing effects (tail)
     */
    this.subs = void 0;
    /**
     * For object property deps cleanup
     */
    this.map = void 0;
    this.key = void 0;
    /**
     * Subscriber counter
     */
    this.sc = 0;
    /**
     * @internal
     */
    this.__v_skip = true;
    if (true) {
      this.subsHead = void 0;
    }
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    if ( true && activeSub.onTrack) {
      activeSub.onTrack(
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(
          {
            effect: activeSub
          },
          debugInfo
        )
      );
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (true) {
        for (let head = this.subsHead; head; head = head.nextSub) {
          if (head.sub.onTrigger && !(head.sub.flags & 8)) {
            head.sub.onTrigger(
              (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(
                {
                  effect: head.sub
                },
                debugInfo
              )
            );
          }
        }
      }
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed = link.dep.computed;
    if (computed && !link.dep.subs) {
      computed.flags |= 4 | 16;
      for (let l = computed.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    if ( true && link.dep.subsHead === void 0) {
      link.dep.subsHead = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = /* @__PURE__ */ Symbol(
   true ? "Object iterate" : 0
);
const MAP_KEY_ITERATE_KEY = /* @__PURE__ */ Symbol(
   true ? "Map keys iterate" : 0
);
const ARRAY_ITERATE_KEY = /* @__PURE__ */ Symbol(
   true ? "Array iterate" : 0
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    if (true) {
      dep.track({
        target,
        type,
        key
      });
    } else // removed by dead control flow
{}
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      if (true) {
        dep.trigger({
          target,
          type,
          key,
          newValue,
          oldValue,
          oldTarget
        });
      } else // removed by dead control flow
{}
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);
    const isArrayIndex = targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}

function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
function toWrapped(target, item) {
  if (isReadonly(target)) {
    return isReactive(target) ? toReadonly(toReactive(item)) : toReadonly(item);
  }
  return toReactive(item);
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, (item) => toWrapped(this, item));
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toWrapped(this, value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply(
      this,
      "filter",
      fn,
      thisArg,
      (v) => v.map((item) => toWrapped(this, item)),
      arguments
    );
  },
  find(fn, thisArg) {
    return apply(
      this,
      "find",
      fn,
      thisArg,
      (item) => toWrapped(this, item),
      arguments
    );
  },
  findIndex(fn, thisArg) {
    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply(
      this,
      "findLast",
      fn,
      thisArg,
      (item) => toWrapped(this, item),
      arguments
    );
  },
  findLastIndex(fn, thisArg) {
    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", (item) => toWrapped(this, item));
  }
};
function iterator(self, method, wrapValue) {
  const arr = shallowReadArray(self);
  const iter = arr[method]();
  if (arr !== self && !isShallow(self)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (!result.done) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply(self, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self);
  const needsWrap = arr !== self && !isShallow(self);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toWrapped(self, item), index, self);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self, method, fn, args) {
  const arr = shallowReadArray(self);
  let wrappedFn = fn;
  if (arr !== self) {
    if (!isShallow(self)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toWrapped(self, item), index, self);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self, method, args) {
  const arr = toRaw(self);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self)[method].apply(self, args);
  endBatch();
  resetTracking();
  return res;
}

const isNonTrackableKeys = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)
);
function hasOwnProperty(key) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      const value = targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key) ? res : res.value;
      return isReadonly2 && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    const isArrayWithIntegerKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key);
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArrayWithIntegerKey && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          if (true) {
            warn(
              `Set operation on key "${String(key)}" failed: target is readonly.`,
              target[key]
            );
          }
          return true;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArrayWithIntegerKey ? Number(key) < target.length : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    if (true) {
      warn(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
  deleteProperty(target, key) {
    if (true) {
      warn(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);

const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (true) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      warn(
        `${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type)} operation ${key}failed: target is readonly.`,
        toRaw(this)
      );
    }
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly && track(toRaw(target), "iterate", ITERATE_KEY);
      return target.size;
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
      !readonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(
    instrumentations,
    readonly ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        } else if (true) {
          checkIdentityKeys(target, has, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        } else if (true) {
          checkIdentityKeys(target, has, key);
        }
        const oldValue = get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0, oldValue);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const oldTarget =  true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target) ? new Map(target) : new Set(target) : 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0,
            oldTarget
          );
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has.call(target, rawKey)) {
    const type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);
    warn(
      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}

const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1 /* COMMON */;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2 /* COLLECTION */;
    default:
      return 0 /* INVALID */;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
    if (true) {
      warn(
        `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
          target
        )}`
      );
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const targetType = getTargetType(target);
  if (targetType === 0 /* INVALID */) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(value, "__v_skip") && Object.isExtensible(value)) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;
const toReadonly = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;

function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    if (true) {
      this.dep.track({
        target: this,
        type: "get",
        key: "value"
      });
    } else // removed by dead control flow
{}
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      if (true) {
        this.dep.trigger({
          target: this,
          type: "set",
          key: "value",
          newValue,
          oldValue
        });
      } else // removed by dead control flow
{}
    }
  }
}
function triggerRef(ref2) {
  if (ref2.dep) {
    if (true) {
      ref2.dep.trigger({
        target: ref2,
        type: "set",
        key: "value",
        newValue: ref2._value
      });
    } else // removed by dead control flow
{}
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this["__v_isRef"] = true;
    this._value = void 0;
    const dep = this.dep = new Dep();
    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
    this._get = get;
    this._set = set;
  }
  get value() {
    return this._value = this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  if ( true && !isProxy(object)) {
    warn(`toRefs() expects a reactive object but received a plain one.`);
  }
  const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
    this._raw = toRaw(_object);
    let shallow = true;
    let obj = _object;
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(_object) || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(String(_key))) {
      do {
        shallow = !isProxy(obj) || isShallow(obj);
      } while (shallow && (obj = obj["__v_raw"]));
    }
    this._shallow = shallow;
  }
  get value() {
    let val = this._object[this._key];
    if (this._shallow) {
      val = unref(val);
    }
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    if (this._shallow && isRef(this._raw[this._key])) {
      const nestedRef = this._object[this._key];
      if (isRef(nestedRef)) {
        nestedRef.value = newVal;
        return;
      }
    }
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(this._raw, this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this["__v_isRef"] = true;
    this["__v_isReadonly"] = true;
    this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source)) {
    return new GetterRefImpl(source);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  return new ObjectRefImpl(source, key, defaultValue);
}

class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    /**
     * @internal
     */
    this._value = void 0;
    /**
     * @internal
     */
    this.dep = new Dep(this);
    /**
     * @internal
     */
    this.__v_isRef = true;
    // TODO isolatedDeclarations "__v_isReadonly"
    // A computed is also a subscriber that tracks other deps
    /**
     * @internal
     */
    this.deps = void 0;
    /**
     * @internal
     */
    this.depsTail = void 0;
    /**
     * @internal
     */
    this.flags = 16;
    /**
     * @internal
     */
    this.globalVersion = globalVersion - 1;
    /**
     * @internal
     */
    this.next = void 0;
    // for backwards compat
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    } else if (true) ;
  }
  get value() {
    const link =  true ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : 0;
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    } else if (true) {
      warn("Write operation failed: computed value is readonly");
    }
  }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  if ( true && debugOptions && !isSSR) {
    cRef.onTrack = debugOptions.onTrack;
    cRef.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}

const TrackOpTypes = {
  "GET": "get",
  "HAS": "has",
  "ITERATE": "iterate"
};
const TriggerOpTypes = {
  "SET": "set",
  "ADD": "add",
  "DELETE": "delete",
  "CLEAR": "clear"
};
const ReactiveFlags = {
  "SKIP": "__v_skip",
  "IS_REACTIVE": "__v_isReactive",
  "IS_READONLY": "__v_isReadonly",
  "IS_SHALLOW": "__v_isShallow",
  "RAW": "__v_raw",
  "IS_REF": "__v_isRef"
};

const WatchErrorCodes = {
  "WATCH_GETTER": 2,
  "2": "WATCH_GETTER",
  "WATCH_CALLBACK": 3,
  "3": "WATCH_CALLBACK",
  "WATCH_CLEANUP": 4,
  "4": "WATCH_CLEANUP"
};
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function getCurrentWatcher() {
  return activeWatcher;
}
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  } else if ( true && !failSilently) {
    warn(
      `onWatcherCleanup() was called when there was no active watcher to associate with.`
    );
  }
}
function watch(source, cb, options = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const warnInvalidSource = (s) => {
    (options.onWarn || warn)(
      `Invalid watch source: `,
      s,
      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
    );
  };
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(s)) {
        return call ? call(s, 2) : s();
      } else {
         true && warnInvalidSource(s);
      }
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP;
     true && warnInvalidSource(source);
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect.stop();
    if (scope && scope.active) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.remove)(scope.effects, effect);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(v, oldValue[i])) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          oldValue = newValue;
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect = new ReactiveEffect(getter);
  effect.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);
  cleanup = effect.onStop = () => {
    const cleanups = cleanupMap.get(effect);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect);
    }
  };
  if (true) {
    effect.onTrack = options.onTrack;
    effect.onTrigger = options.onTrigger;
  }
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect.run();
  }
  watchHandle.pause = effect.pause.bind(effect);
  watchHandle.resume = effect.resume.bind(effect);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Map();
  if ((seen.get(value) || 0) >= depth) {
    return value;
  }
  seen.set(value, depth);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, seen);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(value)) {
    value.forEach((v) => {
      traverse(v, depth, seen);
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}




/***/ },

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js"
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTransition: () => (/* binding */ BaseTransition),
/* harmony export */   BaseTransitionPropsValidators: () => (/* binding */ BaseTransitionPropsValidators),
/* harmony export */   Comment: () => (/* binding */ Comment),
/* harmony export */   DeprecationTypes: () => (/* binding */ DeprecationTypes),
/* harmony export */   EffectScope: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   ErrorCodes: () => (/* binding */ ErrorCodes),
/* harmony export */   ErrorTypeStrings: () => (/* binding */ ErrorTypeStrings),
/* harmony export */   Fragment: () => (/* binding */ Fragment),
/* harmony export */   KeepAlive: () => (/* binding */ KeepAlive),
/* harmony export */   ReactiveEffect: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   Static: () => (/* binding */ Static),
/* harmony export */   Suspense: () => (/* binding */ Suspense),
/* harmony export */   Teleport: () => (/* binding */ Teleport),
/* harmony export */   Text: () => (/* binding */ Text),
/* harmony export */   TrackOpTypes: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.TrackOpTypes),
/* harmony export */   TriggerOpTypes: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.TriggerOpTypes),
/* harmony export */   assertNumber: () => (/* binding */ assertNumber),
/* harmony export */   callWithAsyncErrorHandling: () => (/* binding */ callWithAsyncErrorHandling),
/* harmony export */   callWithErrorHandling: () => (/* binding */ callWithErrorHandling),
/* harmony export */   camelize: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize),
/* harmony export */   capitalize: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize),
/* harmony export */   cloneVNode: () => (/* binding */ cloneVNode),
/* harmony export */   compatUtils: () => (/* binding */ compatUtils),
/* harmony export */   computed: () => (/* binding */ computed),
/* harmony export */   createBlock: () => (/* binding */ createBlock),
/* harmony export */   createCommentVNode: () => (/* binding */ createCommentVNode),
/* harmony export */   createElementBlock: () => (/* binding */ createElementBlock),
/* harmony export */   createElementVNode: () => (/* binding */ createBaseVNode),
/* harmony export */   createHydrationRenderer: () => (/* binding */ createHydrationRenderer),
/* harmony export */   createPropsRestProxy: () => (/* binding */ createPropsRestProxy),
/* harmony export */   createRenderer: () => (/* binding */ createRenderer),
/* harmony export */   createSlots: () => (/* binding */ createSlots),
/* harmony export */   createStaticVNode: () => (/* binding */ createStaticVNode),
/* harmony export */   createTextVNode: () => (/* binding */ createTextVNode),
/* harmony export */   createVNode: () => (/* binding */ createVNode),
/* harmony export */   customRef: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   defineAsyncComponent: () => (/* binding */ defineAsyncComponent),
/* harmony export */   defineComponent: () => (/* binding */ defineComponent),
/* harmony export */   defineEmits: () => (/* binding */ defineEmits),
/* harmony export */   defineExpose: () => (/* binding */ defineExpose),
/* harmony export */   defineModel: () => (/* binding */ defineModel),
/* harmony export */   defineOptions: () => (/* binding */ defineOptions),
/* harmony export */   defineProps: () => (/* binding */ defineProps),
/* harmony export */   defineSlots: () => (/* binding */ defineSlots),
/* harmony export */   devtools: () => (/* binding */ devtools),
/* harmony export */   effect: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   effectScope: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   getCurrentInstance: () => (/* binding */ getCurrentInstance),
/* harmony export */   getCurrentScope: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   getCurrentWatcher: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentWatcher),
/* harmony export */   getTransitionRawChildren: () => (/* binding */ getTransitionRawChildren),
/* harmony export */   guardReactiveProps: () => (/* binding */ guardReactiveProps),
/* harmony export */   h: () => (/* binding */ h),
/* harmony export */   handleError: () => (/* binding */ handleError),
/* harmony export */   hasInjectionContext: () => (/* binding */ hasInjectionContext),
/* harmony export */   hydrateOnIdle: () => (/* binding */ hydrateOnIdle),
/* harmony export */   hydrateOnInteraction: () => (/* binding */ hydrateOnInteraction),
/* harmony export */   hydrateOnMediaQuery: () => (/* binding */ hydrateOnMediaQuery),
/* harmony export */   hydrateOnVisible: () => (/* binding */ hydrateOnVisible),
/* harmony export */   initCustomFormatter: () => (/* binding */ initCustomFormatter),
/* harmony export */   inject: () => (/* binding */ inject),
/* harmony export */   isMemoSame: () => (/* binding */ isMemoSame),
/* harmony export */   isProxy: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   isReactive: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   isReadonly: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   isRef: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   isRuntimeOnly: () => (/* binding */ isRuntimeOnly),
/* harmony export */   isShallow: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   isVNode: () => (/* binding */ isVNode),
/* harmony export */   markRaw: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   mergeDefaults: () => (/* binding */ mergeDefaults),
/* harmony export */   mergeModels: () => (/* binding */ mergeModels),
/* harmony export */   mergeProps: () => (/* binding */ mergeProps),
/* harmony export */   nextTick: () => (/* binding */ nextTick),
/* harmony export */   normalizeClass: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass),
/* harmony export */   normalizeProps: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeProps),
/* harmony export */   normalizeStyle: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle),
/* harmony export */   onActivated: () => (/* binding */ onActivated),
/* harmony export */   onBeforeMount: () => (/* binding */ onBeforeMount),
/* harmony export */   onBeforeUnmount: () => (/* binding */ onBeforeUnmount),
/* harmony export */   onBeforeUpdate: () => (/* binding */ onBeforeUpdate),
/* harmony export */   onDeactivated: () => (/* binding */ onDeactivated),
/* harmony export */   onErrorCaptured: () => (/* binding */ onErrorCaptured),
/* harmony export */   onMounted: () => (/* binding */ onMounted),
/* harmony export */   onRenderTracked: () => (/* binding */ onRenderTracked),
/* harmony export */   onRenderTriggered: () => (/* binding */ onRenderTriggered),
/* harmony export */   onScopeDispose: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   onServerPrefetch: () => (/* binding */ onServerPrefetch),
/* harmony export */   onUnmounted: () => (/* binding */ onUnmounted),
/* harmony export */   onUpdated: () => (/* binding */ onUpdated),
/* harmony export */   onWatcherCleanup: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.onWatcherCleanup),
/* harmony export */   openBlock: () => (/* binding */ openBlock),
/* harmony export */   popScopeId: () => (/* binding */ popScopeId),
/* harmony export */   provide: () => (/* binding */ provide),
/* harmony export */   proxyRefs: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   pushScopeId: () => (/* binding */ pushScopeId),
/* harmony export */   queuePostFlushCb: () => (/* binding */ queuePostFlushCb),
/* harmony export */   reactive: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   readonly: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   ref: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   registerRuntimeCompiler: () => (/* binding */ registerRuntimeCompiler),
/* harmony export */   renderList: () => (/* binding */ renderList),
/* harmony export */   renderSlot: () => (/* binding */ renderSlot),
/* harmony export */   resolveComponent: () => (/* binding */ resolveComponent),
/* harmony export */   resolveDirective: () => (/* binding */ resolveDirective),
/* harmony export */   resolveDynamicComponent: () => (/* binding */ resolveDynamicComponent),
/* harmony export */   resolveFilter: () => (/* binding */ resolveFilter),
/* harmony export */   resolveTransitionHooks: () => (/* binding */ resolveTransitionHooks),
/* harmony export */   setBlockTracking: () => (/* binding */ setBlockTracking),
/* harmony export */   setDevtoolsHook: () => (/* binding */ setDevtoolsHook),
/* harmony export */   setTransitionHooks: () => (/* binding */ setTransitionHooks),
/* harmony export */   shallowReactive: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   shallowReadonly: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   shallowRef: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   ssrContextKey: () => (/* binding */ ssrContextKey),
/* harmony export */   ssrUtils: () => (/* binding */ ssrUtils),
/* harmony export */   stop: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   toDisplayString: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString),
/* harmony export */   toHandlerKey: () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey),
/* harmony export */   toHandlers: () => (/* binding */ toHandlers),
/* harmony export */   toRaw: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   toRef: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   toRefs: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   toValue: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toValue),
/* harmony export */   transformVNodeArgs: () => (/* binding */ transformVNodeArgs),
/* harmony export */   triggerRef: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   unref: () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   useAttrs: () => (/* binding */ useAttrs),
/* harmony export */   useId: () => (/* binding */ useId),
/* harmony export */   useModel: () => (/* binding */ useModel),
/* harmony export */   useSSRContext: () => (/* binding */ useSSRContext),
/* harmony export */   useSlots: () => (/* binding */ useSlots),
/* harmony export */   useTemplateRef: () => (/* binding */ useTemplateRef),
/* harmony export */   useTransitionState: () => (/* binding */ useTransitionState),
/* harmony export */   version: () => (/* binding */ version),
/* harmony export */   warn: () => (/* binding */ warn),
/* harmony export */   watch: () => (/* binding */ watch),
/* harmony export */   watchEffect: () => (/* binding */ watchEffect),
/* harmony export */   watchPostEffect: () => (/* binding */ watchPostEffect),
/* harmony export */   watchSyncEffect: () => (/* binding */ watchSyncEffect),
/* harmony export */   withAsyncContext: () => (/* binding */ withAsyncContext),
/* harmony export */   withCtx: () => (/* binding */ withCtx),
/* harmony export */   withDefaults: () => (/* binding */ withDefaults),
/* harmony export */   withDirectives: () => (/* binding */ withDirectives),
/* harmony export */   withMemo: () => (/* binding */ withMemo),
/* harmony export */   withScopeId: () => (/* binding */ withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/**
* @vue/runtime-core v3.5.26
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/





const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
    value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);
    return raw ? value : [`${key}=`, value];
  }
}
function assertNumber(val, type) {
  if (false) // removed by dead control flow
{}
  if (val === void 0) {
    return;
  } else if (typeof val !== "number") {
    warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
  } else if (isNaN(val)) {
    warn$1(`${type} is NaN - the duration expression might be incorrect.`);
  }
}

const ErrorCodes = {
  "SETUP_FUNCTION": 0,
  "0": "SETUP_FUNCTION",
  "RENDER_FUNCTION": 1,
  "1": "RENDER_FUNCTION",
  "NATIVE_EVENT_HANDLER": 5,
  "5": "NATIVE_EVENT_HANDLER",
  "COMPONENT_EVENT_HANDLER": 6,
  "6": "COMPONENT_EVENT_HANDLER",
  "VNODE_HOOK": 7,
  "7": "VNODE_HOOK",
  "DIRECTIVE_HOOK": 8,
  "8": "DIRECTIVE_HOOK",
  "TRANSITION_HOOK": 9,
  "9": "TRANSITION_HOOK",
  "APP_ERROR_HANDLER": 10,
  "10": "APP_ERROR_HANDLER",
  "APP_WARN_HANDLER": 11,
  "11": "APP_WARN_HANDLER",
  "FUNCTION_REF": 12,
  "12": "FUNCTION_REF",
  "ASYNC_COMPONENT_LOADER": 13,
  "13": "ASYNC_COMPONENT_LOADER",
  "SCHEDULER": 14,
  "14": "SCHEDULER",
  "COMPONENT_UPDATE": 15,
  "15": "COMPONENT_UPDATE",
  "APP_UNMOUNT_CLEANUP": 16,
  "16": "APP_UNMOUNT_CLEANUP"
};
const ErrorTypeStrings$1 = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush",
  [15]: "component update",
  [16]: "app unmount cleanup function"
};
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  } else if (true) {
    warn$1(
      `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`
    );
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo =  true ? ErrorTypeStrings$1[type] : 0;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (true) {
    const info = ErrorTypeStrings$1[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else // removed by dead control flow
{}
}

const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
  if (true) {
    seen = seen || /* @__PURE__ */ new Map();
  }
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      if ( true && checkRecursiveUpdates(seen, cb)) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= -2;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (true) {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if ( true && checkRecursiveUpdates(seen, cb)) {
        continue;
      }
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= -2;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  if (true) {
    seen = seen || /* @__PURE__ */ new Map();
  }
  const check =  true ? (job) => checkRecursiveUpdates(seen, job) : 0;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if ( true && check(job)) {
          continue;
        }
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= -2;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs(seen);
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  const count = seen.get(fn) || 0;
  if (count > RECURSION_LIMIT) {
    const instance = fn.i;
    const componentName = instance && getComponentName(instance.type);
    handleError(
      `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    );
    return true;
  }
  seen.set(fn, count + 1);
  return false;
}

let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Map();
if (true) {
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
const map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
  const id = instance.type.__hmrId;
  let record = map.get(id);
  if (!record) {
    createRecord(id, instance.type);
    record = map.get(id);
  }
  record.instances.add(instance);
}
function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
  if (map.has(id)) {
    return false;
  }
  map.set(id, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
  const record = map.get(id);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance) => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    isHmrUpdating = true;
    if (!(instance.job.flags & 8)) {
      instance.update();
    }
    isHmrUpdating = false;
  });
}
function reload(id, newComp) {
  const record = map.get(id);
  if (!record) return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (let i = 0; i < instances.length; i++) {
    const instance = instances[i];
    const oldComp = normalizeClassComponent(instance.type);
    let dirtyInstances = hmrDirtyComponents.get(oldComp);
    if (!dirtyInstances) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
    }
    dirtyInstances.add(instance);
    instance.appContext.propsCache.delete(instance.type);
    instance.appContext.emitsCache.delete(instance.type);
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      dirtyInstances.add(instance);
      instance.ceReload(newComp.styles);
      dirtyInstances.delete(instance);
    } else if (instance.parent) {
      queueJob(() => {
        if (!(instance.job.flags & 8)) {
          isHmrUpdating = true;
          instance.parent.update();
          isHmrUpdating = false;
          dirtyInstances.delete(instance);
        }
      });
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn(
        "[HMR] Root or manually mounted instance modified. Full reload required."
      );
    }
    if (instance.root.ce && instance !== instance.root) {
      instance.root.ce._removeChildStyle(oldComp);
    }
  }
  queuePostFlushCb(() => {
    hmrDirtyComponents.clear();
  });
}
function updateComponentDef(oldComp, newComp) {
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn) {
  return (id, arg) => {
    try {
      return fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn(
        `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
      );
    }
  };
}

let devtools$1;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
  if (devtools$1) {
    devtools$1.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event, args });
  }
}
function setDevtoolsHook$1(hook, target) {
  var _a, _b;
  devtools$1 = hook;
  if (devtools$1) {
    devtools$1.enabled = true;
    buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook$1(newHook, target);
    });
    setTimeout(() => {
      if (!devtools$1) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app, version) {
  emit$1("app:init" /* APP_INIT */, app, version, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
function devtoolsUnmountApp(app) {
  emit$1("app:unmount" /* APP_UNMOUNT */, app);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:removed" /* COMPONENT_REMOVED */
);
const devtoolsComponentRemoved = (component) => {
  if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
  !devtools$1.cleanupBuffer(component)) {
    _devtoolsComponentRemoved(component);
  }
};
// @__NO_SIDE_EFFECTS__
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit$1(
      hook,
      component.appContext.app,
      component.uid,
      component.parent ? component.parent.uid : void 0,
      component
    );
  };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */);
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */);
function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    emit$1(hook, component.appContext.app, component.uid, component, type, time);
  };
}
function devtoolsComponentEmit(component, event, params) {
  emit$1(
    "component:emit" /* COMPONENT_EMIT */,
    component.appContext.app,
    component,
    event,
    params
  );
}

let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if (true) {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}

function validateDirectiveName(name) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBuiltInDirective)(name)) {
    warn$1("Do not use built-in directive ids as custom directive id: " + name);
  }
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
     true && warn$1(`withDirectives can only be used inside render functions.`);
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ] = directives[i];
    if (dir) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.traverse)(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    }
  }
}

function provide(key, value) {
  if (true) {
    if (!currentInstance || currentInstance.isMounted) {
      warn$1(`provide() can only be used inside setup().`);
    }
  }
  if (currentInstance) {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = getCurrentInstance();
  if (instance || currentApp) {
    let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else if (true) {
      warn$1(`injection "${String(key)}" not found.`);
    }
  } else if (true) {
    warn$1(`inject() can only be used inside setup() or functional components.`);
  }
}
function hasInjectionContext() {
  return !!(getCurrentInstance() || currentApp);
}

const ssrContextKey = /* @__PURE__ */ Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
       true && warn$1(
        `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
      );
    }
    return ctx;
  }
};

function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
  return doWatch(
    effect,
    null,
     true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, options, { flush: "post" }) : 0
  );
}
function watchSyncEffect(effect, options) {
  return doWatch(
    effect,
    null,
     true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, options, { flush: "sync" }) : 0
  );
}
function watch(source, cb, options) {
  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {
    warn$1(
      `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
    );
  }
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  if ( true && !cb) {
    if (immediate !== void 0) {
      warn$1(
        `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (deep !== void 0) {
      warn$1(
        `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (once !== void 0) {
      warn$1(
        `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
  }
  const baseWatchOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, options);
  if (true) baseWatchOptions.onWarn = warn$1;
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
      watchStopHandle.resume = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
      watchStopHandle.pause = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.watch)(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}

const TeleportEndKey = /* @__PURE__ */ Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {
    if (!select) {
       true && warn$1(
        `Current renderer does not support string target for Teleports. (missing querySelector renderer option)`
      );
      return null;
    } else {
      const target = select(targetSelector);
      if ( true && !target && !isTeleportDisabled(props)) {
        warn$1(
          `Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
        );
      }
      return target;
    }
  } else {
    if ( true && !targetSelector && !isTeleportDisabled(props)) {
      warn$1(`Invalid Teleport target: ${targetSelector}`);
    }
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if ( true && isHmrUpdating) {
      optimized = false;
      dynamicChildren = null;
    }
    if (n1 == null) {
      const placeholder = n2.el =  true ? createComment("teleport start") : 0;
      const mainAnchor = n2.anchor =  true ? createComment("teleport end") : 0;
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target, n2, createText, insert);
        if (target) {
          if (namespace !== "svg" && isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace !== "mathml" && isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (parentComponent && parentComponent.isCE) {
            (parentComponent.ce._teleportTargets || (parentComponent.ce._teleportTargets = /* @__PURE__ */ new Set())).add(target);
          }
          if (!disabled) {
            mount(target, targetAnchor);
            updateCssVars(n2, false);
          }
        } else if ( true && !disabled) {
          warn$1(
            "Invalid Teleport target on mount:",
            target,
            `(${typeof target})`
          );
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
        updateCssVars(n2, true);
      }
      if (isTeleportDeferred(n2.props)) {
        n2.el.__isMounted = false;
        queuePostRenderEffect(() => {
          mountToTarget();
          delete n2.el.__isMounted;
        }, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
        queuePostRenderEffect(() => {
          TeleportImpl.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        }, parentSuspense);
        return;
      }
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, !!!("development" !== "production"));
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          } else if (true) {
            warn$1(
              "Invalid Teleport target on update:",
              target,
              `(${typeof target})`
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2, disabled);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  function hydrateDisabledTeleport(node2, vnode2, targetStart, targetAnchor) {
    vnode2.anchor = hydrateChildren(
      nextSibling(node2),
      vnode2,
      parentNode(node2),
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    vnode2.targetStart = targetStart;
    vnode2.targetAnchor = targetAnchor;
  }
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  const disabled = isTeleportDisabled(vnode.props);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (disabled) {
        hydrateDisabledTeleport(
          node,
          vnode,
          targetNode,
          targetNode && nextSibling(targetNode)
        );
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode, disabled);
  } else if (disabled) {
    if (vnode.shapeFlag & 16) {
      hydrateDisabledTeleport(node, vnode, node, nextSibling(node));
    }
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node, anchor;
    if (isDisabled) {
      node = vnode.el;
      anchor = vnode.anchor;
    } else {
      node = vnode.targetStart;
      anchor = vnode.targetAnchor;
    }
    while (node && node !== anchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target) {
    insert(targetStart, target);
    insert(targetAnchor, target);
  }
  return targetAnchor;
}

const leaveCbKey = /* @__PURE__ */ Symbol("_leaveCb");
const enterCbKey = /* @__PURE__ */ Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
      const { mode } = rawProps;
      if ( true && mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
        warn$1(`invalid <transition> mode: ${mode}`);
      }
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(oldInnerChild, innerChild) && recursiveGetSubtree(instance).type !== Comment) {
        let leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
            oldInnerChild = void 0;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
            enterHooks.delayedLeave = () => {
              delayedLeave();
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
          };
        } else {
          oldInnerChild = void 0;
        }
      } else if (oldInnerChild) {
        oldInnerChild = void 0;
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    let hasFound = false;
    for (const c of children) {
      if (c.type !== Comment) {
        if ( true && hasFound) {
          warn$1(
            "<transition> can only be used on a single element or component. Use <transition-group> for lists."
          );
          break;
        }
        child = c;
        hasFound = true;
        if (false) // removed by dead control flow
{}
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook(hook, args);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook(cancelHook, [el]);
        } else {
          callHook(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove) {
      const key2 = String(vnode.key);
      if (el[enterCbKey]) {
        el[enterCbKey](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove();
      }
      callHook(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove();
        if (cancelled) {
          callHook(onLeaveCancelled, [el]);
        } else {
          callHook(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  if (vnode.component) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}

// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}

function useId() {
  const i = getCurrentInstance();
  if (i) {
    return (i.appContext.config.idPrefix || "v") + "-" + i.ids[0] + i.ids[1]++;
  } else if (true) {
    warn$1(
      `useId() is called when there is no active component instance to be associated with.`
    );
  }
  return "";
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}

const knownTemplateRefs = /* @__PURE__ */ new WeakSet();
function useTemplateRef(key) {
  const i = getCurrentInstance();
  const r = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef)(null);
  if (i) {
    const refs = i.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? i.refs = {} : i.refs;
    let desc;
    if ( true && (desc = Object.getOwnPropertyDescriptor(refs, key)) && !desc.configurable) {
      warn$1(`useTemplateRef('${key}') already exists.`);
    } else {
      Object.defineProperty(refs, key, {
        enumerable: true,
        get: () => r.value,
        set: (val) => r.value = val
      });
    }
  } else if (true) {
    warn$1(
      `useTemplateRef() is called when there is no active component instance to be associated with.`
    );
  }
  const ret =  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly)(r) : 0;
  if (true) {
    knownTemplateRefs.add(ret);
  }
  return ret;
}

const pendingSetRefMap = /* @__PURE__ */ new WeakMap();
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref } = rawRef;
  if ( true && !owner) {
    warn$1(
      `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
    );
    return;
  }
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState);
  const canSetSetupRef = setupState === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO : (key) => {
    if (true) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawSetupState, key) && !(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(rawSetupState[key])) {
        warn$1(
          `Template ref "${key}" used on a non-ref value. It will not work in the production build.`
        );
      }
      if (knownTemplateRefs.has(rawSetupState[key])) {
        return false;
      }
    }
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawSetupState, key);
  };
  const canSetRef = (ref2) => {
    return  false || !knownTemplateRefs.has(ref2);
  };
  if (oldRef != null && oldRef !== ref) {
    invalidatePendingSetRef(oldRawRef);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {
      if (canSetRef(oldRef)) {
        oldRef.value = null;
      }
      const oldRawRefAtom = oldRawRef;
      if (oldRawRefAtom.k) refs[oldRawRefAtom.k] = null;
    }
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {
    callWithErrorHandling(ref, owner, 12, [value, refs]);
  } else {
    const _isString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref);
    const _isRef = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref) ? setupState[ref] : refs[ref] : canSetRef(ref) || !rawRef.k ? ref.value : refs[rawRef.k];
          if (isUnmount) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(existing, refValue);
          } else {
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing)) {
              if (_isString) {
                refs[ref] = [refValue];
                if (canSetSetupRef(ref)) {
                  setupState[ref] = refs[ref];
                }
              } else {
                const newVal = [refValue];
                if (canSetRef(ref)) {
                  ref.value = newVal;
                }
                if (rawRef.k) refs[rawRef.k] = newVal;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref] = value;
          if (canSetSetupRef(ref)) {
            setupState[ref] = value;
          }
        } else if (_isRef) {
          if (canSetRef(ref)) {
            ref.value = value;
          }
          if (rawRef.k) refs[rawRef.k] = value;
        } else if (true) {
          warn$1("Invalid template ref type:", ref, `(${typeof ref})`);
        }
      };
      if (value) {
        const job = () => {
          doSet();
          pendingSetRefMap.delete(rawRef);
        };
        job.id = -1;
        pendingSetRefMap.set(rawRef, job);
        queuePostRenderEffect(job, parentSuspense);
      } else {
        invalidatePendingSetRef(rawRef);
        doSet();
      }
    } else if (true) {
      warn$1("Invalid template ref type:", ref, `(${typeof ref})`);
    }
  }
}
function invalidatePendingSetRef(rawRef) {
  const pendingSetRef = pendingSetRefMap.get(rawRef);
  if (pendingSetRef) {
    pendingSetRef.flags |= 8;
    pendingSetRefMap.delete(rawRef);
  }
}

let hasLoggedMismatchError = false;
const logMismatchError = () => {
  if (hasLoggedMismatchError) {
    return;
  }
  console.error("Hydration completed but contains mismatches.");
  hasLoggedMismatchError = true;
};
const isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
const isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
const getContainerType = (container) => {
  if (container.nodeType !== 1) return void 0;
  if (isSVGContainer(container)) return "svg";
  if (isMathMLContainer(container)) return "mathml";
  return void 0;
};
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp,
      createText,
      nextSibling,
      parentNode,
      remove,
      insert,
      createComment
    }
  } = rendererInternals;
  const hydrate = (vnode, container) => {
    if (!container.hasChildNodes()) {
      ( true) && warn$1(
        `Attempting to hydrate existing markup but container is empty. Performing full mount instead.`
      );
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(
      node,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    );
    const { type, ref, shapeFlag, patchFlag } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if (true) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(node, "__vnode", vnode, true);
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(node, "__vueParentComponent", parentComponent, true);
    }
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            ( true) && warn$1(
              `Hydration text mismatch in`,
              node.parentNode,
              `
  - rendered on server: ${JSON.stringify(
                node.data
              )}
  - expected on client: ${JSON.stringify(vnode.children)}`
            );
            logMismatchError();
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (isTemplateNode(node)) {
          nextNode = nextSibling(node);
          replaceNode(
            vnode.el = node.content.firstChild,
            node,
            parentComponent
          );
        } else if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          if (isFragmentStart) {
            nextNode = locateClosingAnchor(node);
          } else if (isComment(node) && node.data === "teleport start") {
            nextNode = locateClosingAnchor(node, node.data, "teleport end");
          } else {
            nextNode = nextSibling(node);
          }
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            getContainerType(container),
            optimized
          );
          if (isAsyncWrapper(vnode) && !vnode.type.__asyncResolved) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            getContainerType(parentNode(node)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else if (true) {
          warn$1("Invalid HostVNode type:", type, `(${typeof type})`);
        }
    }
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
    const forcePatch = type === "input" || type === "option";
    if (true) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      let needCallTransitionHooks = false;
      if (isTemplateNode(el)) {
        needCallTransitionHooks = needTransition(
          null,
          // no need check parentSuspense in hydration
          transition
        ) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
        const content = el.content.firstChild;
        if (needCallTransitionHooks) {
          const cls = content.getAttribute("class");
          if (cls) content.$cls = cls;
          transition.beforeEnter(content);
        }
        replaceNode(content, el, parentComponent);
        vnode.el = el = content;
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        let hasWarned = false;
        while (next) {
          if (!isMismatchAllowed(el, 1 /* CHILDREN */)) {
            if (( true) && !hasWarned) {
              warn$1(
                `Hydration children mismatch on`,
                el,
                `
Server rendered element contains more child nodes than client vdom.`
              );
              hasWarned = true;
            }
            logMismatchError();
          }
          const cur = next;
          next = next.nextSibling;
          remove(cur);
        }
      } else if (shapeFlag & 8) {
        let clientText = vnode.children;
        if (clientText[0] === "\n" && (el.tagName === "PRE" || el.tagName === "TEXTAREA")) {
          clientText = clientText.slice(1);
        }
        const { textContent } = el;
        if (textContent !== clientText && // innerHTML normalize \r\n or \r into a single \n in the DOM
        textContent !== clientText.replace(/\r\n|\r/g, "\n")) {
          if (!isMismatchAllowed(el, 0 /* TEXT */)) {
            ( true) && warn$1(
              `Hydration text content mismatch on`,
              el,
              `
  - rendered on server: ${textContent}
  - expected on client: ${clientText}`
            );
            logMismatchError();
          }
          el.textContent = vnode.children;
        }
      }
      if (props) {
        if (true) {
          const isCustomElement = el.tagName.includes("-");
          for (const key in props) {
            if (( true) && // #11189 skip if this node has directives that have created hooks
            // as it could have mutated the DOM in any possible way
            !(dirs && dirs.some((d) => d.dir.created)) && propHasMismatch(el, key, props[key], vnode, parentComponent)) {
              logMismatchError();
            }
            if (forcePatch && (key.endsWith("value") || key === "indeterminate") || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) || // force hydrate v-bind with .prop modifiers
            key[0] === "." || isCustomElement) {
              patchProp(el, key, null, props[key], void 0, parentComponent);
            }
          }
        } else // removed by dead control flow
{}
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    let hasWarned = false;
    for (let i = 0; i < l; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
      const isText = vnode.type === Text;
      if (node) {
        if (isText && !optimized) {
          if (i + 1 < l && normalizeVNode(children[i + 1]).type === Text) {
            insert(
              createText(
                node.data.slice(vnode.children.length)
              ),
              container,
              nextSibling(node)
            );
            node.data = vnode.children;
          }
        }
        node = hydrateNode(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (isText && !vnode.children) {
        insert(vnode.el = createText(""), container);
      } else {
        if (!isMismatchAllowed(container, 1 /* CHILDREN */)) {
          if (( true) && !hasWarned) {
            warn$1(
              `Hydration children mismatch on`,
              container,
              `
Server rendered element contains fewer child nodes than client vdom.`
            );
            hasWarned = true;
          }
          logMismatchError();
        }
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          getContainerType(container),
          slotScopeIds
        );
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(
      nextSibling(node),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      logMismatchError();
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    if (!isMismatchAllowed(node.parentElement, 1 /* CHILDREN */)) {
      ( true) && warn$1(
        `Hydration node mismatch:
- rendered on server:`,
        node,
        node.nodeType === 3 ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``,
        `
- expected on client:`,
        vnode.type
      );
      logMismatchError();
    }
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove(node);
    patch(
      null,
      vnode,
      container,
      next,
      parentComponent,
      parentSuspense,
      getContainerType(container),
      slotScopeIds
    );
    if (parentComponent) {
      parentComponent.vnode.el = vnode.el;
      updateHOCHostEl(parentComponent, vnode.el);
    }
    return next;
  };
  const locateClosingAnchor = (node, open = "[", close = "]") => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === open) match++;
        if (node.data === close) {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  const replaceNode = (newNode, oldNode, parentComponent) => {
    const parentNode2 = oldNode.parentNode;
    if (parentNode2) {
      parentNode2.replaceChild(newNode, oldNode);
    }
    let parent = parentComponent;
    while (parent) {
      if (parent.vnode.el === oldNode) {
        parent.vnode.el = parent.subTree.el = newNode;
      }
      parent = parent.parent;
    }
  };
  const isTemplateNode = (node) => {
    return node.nodeType === 1 && node.tagName === "TEMPLATE";
  };
  return [hydrate, hydrateNode];
}
function propHasMismatch(el, key, clientValue, vnode, instance) {
  let mismatchType;
  let mismatchKey;
  let actual;
  let expected;
  if (key === "class") {
    if (el.$cls) {
      actual = el.$cls;
      delete el.$cls;
    } else {
      actual = el.getAttribute("class");
    }
    expected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(clientValue);
    if (!isSetEqual(toClassSet(actual || ""), toClassSet(expected))) {
      mismatchType = 2 /* CLASS */;
      mismatchKey = `class`;
    }
  } else if (key === "style") {
    actual = el.getAttribute("style") || "";
    expected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(clientValue) ? clientValue : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.stringifyStyle)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(clientValue));
    const actualMap = toStyleMap(actual);
    const expectedMap = toStyleMap(expected);
    if (vnode.dirs) {
      for (const { dir, value } of vnode.dirs) {
        if (dir.name === "show" && !value) {
          expectedMap.set("display", "none");
        }
      }
    }
    if (instance) {
      resolveCssVars(instance, vnode, expectedMap);
    }
    if (!isMapEqual(actualMap, expectedMap)) {
      mismatchType = 3 /* STYLE */;
      mismatchKey = "style";
    }
  } else if (el instanceof SVGElement && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isKnownSvgAttr)(key) || el instanceof HTMLElement && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBooleanAttr)(key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isKnownHtmlAttr)(key))) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBooleanAttr)(key)) {
      actual = el.hasAttribute(key);
      expected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(clientValue);
    } else if (clientValue == null) {
      actual = el.hasAttribute(key);
      expected = false;
    } else {
      if (el.hasAttribute(key)) {
        actual = el.getAttribute(key);
      } else if (key === "value" && el.tagName === "TEXTAREA") {
        actual = el.value;
      } else {
        actual = false;
      }
      expected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isRenderableAttrValue)(clientValue) ? String(clientValue) : false;
    }
    if (actual !== expected) {
      mismatchType = 4 /* ATTRIBUTE */;
      mismatchKey = key;
    }
  }
  if (mismatchType != null && !isMismatchAllowed(el, mismatchType)) {
    const format = (v) => v === false ? `(not rendered)` : `${mismatchKey}="${v}"`;
    const preSegment = `Hydration ${MismatchTypeString[mismatchType]} mismatch on`;
    const postSegment = `
  - rendered on server: ${format(actual)}
  - expected on client: ${format(expected)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`;
    {
      warn$1(preSegment, el, postSegment);
    }
    return true;
  }
  return false;
}
function toClassSet(str) {
  return new Set(str.trim().split(/\s+/));
}
function isSetEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const s of a) {
    if (!b.has(s)) {
      return false;
    }
  }
  return true;
}
function toStyleMap(str) {
  const styleMap = /* @__PURE__ */ new Map();
  for (const item of str.split(";")) {
    let [key, value] = item.split(":");
    key = key.trim();
    value = value && value.trim();
    if (key && value) {
      styleMap.set(key, value);
    }
  }
  return styleMap;
}
function isMapEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key, value] of a) {
    if (value !== b.get(key)) {
      return false;
    }
  }
  return true;
}
function resolveCssVars(instance, vnode, expectedMap) {
  const root = instance.subTree;
  if (instance.getCssVars && (vnode === root || root && root.type === Fragment && root.children.includes(vnode))) {
    const cssVars = instance.getCssVars();
    for (const key in cssVars) {
      const value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeCssVarValue)(cssVars[key]);
      expectedMap.set(`--${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getEscapedCssVarName)(key, false)}`, value);
    }
  }
  if (vnode === root && instance.parent) {
    resolveCssVars(instance.parent, instance.vnode, expectedMap);
  }
}
const allowMismatchAttr = "data-allow-mismatch";
const MismatchTypeString = {
  [0 /* TEXT */]: "text",
  [1 /* CHILDREN */]: "children",
  [2 /* CLASS */]: "class",
  [3 /* STYLE */]: "style",
  [4 /* ATTRIBUTE */]: "attribute"
};
function isMismatchAllowed(el, allowedType) {
  if (allowedType === 0 /* TEXT */ || allowedType === 1 /* CHILDREN */) {
    while (el && !el.hasAttribute(allowMismatchAttr)) {
      el = el.parentElement;
    }
  }
  const allowedAttr = el && el.getAttribute(allowMismatchAttr);
  if (allowedAttr == null) {
    return false;
  } else if (allowedAttr === "") {
    return true;
  } else {
    const list = allowedAttr.split(",");
    if (allowedType === 0 /* TEXT */ && list.includes("children")) {
      return true;
    }
    return list.includes(MismatchTypeString[allowedType]);
  }
}

const requestIdleCallback = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().requestIdleCallback || ((cb) => setTimeout(cb, 1));
const cancelIdleCallback = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().cancelIdleCallback || ((id) => clearTimeout(id));
const hydrateOnIdle = (timeout = 1e4) => (hydrate) => {
  const id = requestIdleCallback(hydrate, { timeout });
  return () => cancelIdleCallback(id);
};
function elementIsVisibleInViewport(el) {
  const { top, left, bottom, right } = el.getBoundingClientRect();
  const { innerHeight, innerWidth } = window;
  return (top > 0 && top < innerHeight || bottom > 0 && bottom < innerHeight) && (left > 0 && left < innerWidth || right > 0 && right < innerWidth);
}
const hydrateOnVisible = (opts) => (hydrate, forEach) => {
  const ob = new IntersectionObserver((entries) => {
    for (const e of entries) {
      if (!e.isIntersecting) continue;
      ob.disconnect();
      hydrate();
      break;
    }
  }, opts);
  forEach((el) => {
    if (!(el instanceof Element)) return;
    if (elementIsVisibleInViewport(el)) {
      hydrate();
      ob.disconnect();
      return false;
    }
    ob.observe(el);
  });
  return () => ob.disconnect();
};
const hydrateOnMediaQuery = (query) => (hydrate) => {
  if (query) {
    const mql = matchMedia(query);
    if (mql.matches) {
      hydrate();
    } else {
      mql.addEventListener("change", hydrate, { once: true });
      return () => mql.removeEventListener("change", hydrate);
    }
  }
};
const hydrateOnInteraction = (interactions = []) => (hydrate, forEach) => {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(interactions)) interactions = [interactions];
  let hasHydrated = false;
  const doHydrate = (e) => {
    if (!hasHydrated) {
      hasHydrated = true;
      teardown();
      hydrate();
      e.target.dispatchEvent(new e.constructor(e.type, e));
    }
  };
  const teardown = () => {
    forEach((el) => {
      for (const i of interactions) {
        el.removeEventListener(i, doHydrate);
      }
    });
  };
  forEach((el) => {
    for (const i of interactions) {
      el.addEventListener(i, doHydrate, { once: true });
    }
  });
  return teardown;
};
function forEachElement(node, cb) {
  if (isComment(node) && node.data === "[") {
    let depth = 1;
    let next = node.nextSibling;
    while (next) {
      if (next.nodeType === 1) {
        const result = cb(next);
        if (result === false) {
          break;
        }
      } else if (isComment(next)) {
        if (next.data === "]") {
          if (--depth === 0) break;
        } else if (next.data === "[") {
          depth++;
        }
      }
      next = next.nextSibling;
    }
  } else {
    cb(node);
  }
}

const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    hydrate: hydrateStrategy,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve, reject) => {
          const userRetry = () => resolve(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if ( true && !comp) {
        warn$1(
          `Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`
        );
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      if ( true && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        throw new Error(`Invalid async component load result: ${comp}`);
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    __asyncHydrate(el, instance, hydrate) {
      let patched = false;
      (instance.bu || (instance.bu = [])).push(() => patched = true);
      const performHydrate = () => {
        if (patched) {
          if (true) {
            warn$1(
              `Skipping lazy hydration for component '${getComponentName(resolvedComp) || resolvedComp.__file}': it was updated before lazy hydration performed.`
            );
          }
          return;
        }
        hydrate();
      };
      const doHydrate = hydrateStrategy ? () => {
        const teardown = hydrateStrategy(
          performHydrate,
          (cb) => forEachElement(el, cb)
        );
        if (teardown) {
          (instance.bum || (instance.bum = [])).push(teardown);
        }
      } : performHydrate;
      if (resolvedComp) {
        doHydrate();
      } else {
        load().then(() => !instance.isUnmounted && doHydrate());
      }
    },
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      markAsyncBoundary(instance);
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
      const error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
      const delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          instance.parent.update();
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createInnerComp(
            loadingComponent,
            instance
          );
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref2, props, children, ce } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    if (true) {
      instance.__v_cache = cache;
    }
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        namespace,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
      if (true) {
        devtoolsComponentAdded(instance2);
      }
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      invalidateMount(instance2.m);
      invalidateMount(instance2.a);
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
      if (true) {
        devtoolsComponentAdded(instance2);
      }
      if (true) {
        instance2.__keepAliveStorageContainer = storageContainer;
      }
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(
          isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : vnode.type
        );
        if (name && !filter(name)) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (cached && (!current || !isSameVNodeType(cached, current))) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys.delete(key);
    }
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches(include, name));
        exclude && pruneCache((name) => !matches(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        if (isSuspense(instance.subTree.type)) {
          queuePostRenderEffect(() => {
            cache.set(pendingCacheKey, getInnerChild(instance.subTree));
          }, instance.subTree.suspense);
        } else {
          cache.set(pendingCacheKey, getInnerChild(instance.subTree));
        }
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return current = null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        if (true) {
          warn$1(`KeepAlive should contain exactly one component child.`);
        }
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      if (vnode.type === Comment) {
        current = null;
        return vnode;
      }
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        vnode.shapeFlag &= -257;
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {
    return pattern.some((p) => matches(p, name));
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {
    return pattern.split(",").includes(name);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isRegExp)(pattern)) {
    pattern.lastIndex = 0;
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= -257;
  vnode.shapeFlag &= -513;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else if (true) {
    const apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings$1[type].replace(/ hook$/, ""));
    warn$1(
      `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().` + (` If you are using async setup(), make sure to register lifecycle hooks before the first await statement.` )
    );
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}

const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = /* @__PURE__ */ Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    if ( true && warnMissing && !res) {
      const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
      warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
    }
    return res;
  } else if (true) {
    warn$1(
      `resolve${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1))} can only be used in render() or setup().`
    );
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]);
}

function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  const sourceIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source);
  if (sourceIsArray || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {
    const sourceIsReactiveArray = sourceIsArray && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source);
    let needsWrap = false;
    let isReadonlySource = false;
    if (sourceIsReactiveArray) {
      needsWrap = !(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(source);
      isReadonlySource = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(source);
      source = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadArray)(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? isReadonlySource ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toReadonly)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toReactive)(source[i])) : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toReactive)(source[i]) : source[i],
        i,
        void 0,
        cached && cached[i]
      );
    }
  } else if (typeof source === "number") {
    if ( true && !Number.isInteger(source)) {
      warn$1(`The v-for range expect an integer value but got ${source}.`);
    }
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}

function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res) res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}

function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    const hasProps = Object.keys(props).length > 0;
    if (name !== "default") props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback && fallback())],
      hasProps ? -2 : 64
    );
  }
  let slot = slots[name];
  if ( true && slot && slot.length > 1) {
    warn$1(
      `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`
    );
    slot = () => [];
  }
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSymbol)(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}

function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
    warn$1(`v-on with no argument expects an object value.`);
    return ret;
  }
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];
  }
  return ret;
}

const getPublicInstance = (i) => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0,
    $attrs: (i) =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0,
    $slots: (i) =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0,
    $refs: (i) =>  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
  })
);
const isReservedPrefix = (key) => key === "_" || key === "$";
const hasSetupBinding = (state, key) => state !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && !state.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    if ( true && key === "__isVue") {
      return true;
    }
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1 /* SETUP */:
            return setupState[key];
          case 2 /* DATA */:
            return data[key];
          case 4 /* CONTEXT */:
            return ctx[key];
          case 3 /* PROPS */:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1 /* SETUP */;
        return setupState[key];
      } else if (__VUE_OPTIONS_API__ && data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
        accessCache[key] = 2 /* DATA */;
        return data[key];
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(props, key)) {
        accessCache[key] = 3 /* PROPS */;
        return props[key];
      } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
        accessCache[key] = 4 /* CONTEXT */;
        return ctx[key];
      } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
        accessCache[key] = 0 /* OTHER */;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance.attrs, "get", "");
         true && markAttrsAccessed();
      } else if ( true && key === "$slots") {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
      accessCache[key] = 4 /* CONTEXT */;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else if ( true && currentRenderingInstance && (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    key.indexOf("__v") !== 0)) {
      if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && isReservedPrefix(key[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
        warn$1(
          `Property ${JSON.stringify(
            key
          )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
        );
      } else if (instance === currentRenderingInstance) {
        warn$1(
          `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
        );
      }
    }
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if ( true && setupState.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
      warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
      return false;
    } else if (__VUE_OPTIONS_API__ && data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
      data[key] = value;
      return true;
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {
       true && warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
       true && warn$1(
        `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
      );
      return false;
    } else {
      if ( true && key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, props, type }
  }, key) {
    let cssModules;
    return !!(accessCache[key] || __VUE_OPTIONS_API__ && data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && key[0] !== "$" && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key) || hasSetupBinding(setupState, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(props, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key) || (cssModules = type.__cssModules) && cssModules[key]);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
if (true) {
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn$1(
      `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
    );
    return Reflect.ownKeys(target);
  };
}
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has(_, key) {
    const has = key[0] !== "_" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyAllowed)(key);
    if ( true && !has && PublicInstanceProxyHandlers.has(_, key)) {
      warn$1(
        `Property ${JSON.stringify(
          key
        )} should not start with _ which is a reserved prefix for Vue internals.`
      );
    }
    return has;
  }
});
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance) {
  const {
    ctx,
    propsOptions: [propsOptions]
  } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn$1(
          `setup() return property ${JSON.stringify(
            key
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
      });
    }
  });
}

const warnRuntimeUsage = (method) => warn$1(
  `${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
);
function defineProps() {
  if (true) {
    warnRuntimeUsage(`defineProps`);
  }
  return null;
}
function defineEmits() {
  if (true) {
    warnRuntimeUsage(`defineEmits`);
  }
  return null;
}
function defineExpose(exposed) {
  if (true) {
    warnRuntimeUsage(`defineExpose`);
  }
}
function defineOptions(options) {
  if (true) {
    warnRuntimeUsage(`defineOptions`);
  }
}
function defineSlots() {
  if (true) {
    warnRuntimeUsage(`defineSlots`);
  }
  return null;
}
function defineModel() {
  if (true) {
    warnRuntimeUsage("defineModel");
  }
}
function withDefaults(props, defaults) {
  if (true) {
    warnRuntimeUsage(`withDefaults`);
  }
  return null;
}
function useSlots() {
  return getContext("useSlots").slots;
}
function useAttrs() {
  return getContext("useAttrs").attrs;
}
function getContext(calledFunctionName) {
  const i = getCurrentInstance();
  if ( true && !i) {
    warn$1(`${calledFunctionName}() called without active instance.`);
  }
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props) ? props.reduce(
    (normalized, p) => (normalized[p] = null, normalized),
    {}
  ) : props;
}
function mergeDefaults(raw, defaults) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults) {
    if (key.startsWith("__skip")) continue;
    let opt = props[key];
    if (opt) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)) {
        opt = props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      opt = props[key] = { default: defaults[key] };
    } else if (true) {
      warn$1(`props default key "${key}" has no corresponding declaration.`);
    }
    if (opt && defaults[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
function mergeModels(a, b) {
  if (!a || !b) return a || b;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(a) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(b)) return a.concat(b);
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  if ( true && !ctx) {
    warn$1(
      `withAsyncContext called without active current instance. This is likely a bug.`
    );
  }
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}

function createDuplicateChecker() {
  const cache = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties =  true ? createDuplicateChecker() : 0;
  if (true) {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props" /* PROPS */, key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {
        if (true) {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else // removed by dead control flow
{}
        if (true) {
          checkDuplicateProperties("Methods" /* METHODS */, key);
        }
      } else if (true) {
        warn$1(
          `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
        );
      }
    }
  }
  if (dataOptions) {
    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataOptions)) {
      warn$1(
        `The data option must be a function. Plain object usage is no longer supported.`
      );
    }
    const data = dataOptions.call(publicThis, publicThis);
    if ( true && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {
      warn$1(
        `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
      );
    }
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {
       true && warn$1(`data() should return an object.`);
    } else {
      instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);
      if (true) {
        for (const key in data) {
          checkDuplicateProperties("Data" /* DATA */, key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data[key],
              set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
      if ( true && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
        warn$1(`Computed property "${key}" has no getter.`);
      }
      const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set) ? opt.set.bind(publicThis) :  true ? () => {
        warn$1(
          `Write operation failed: computed property "${key}" is readonly.`
        );
      } : 0;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
      if (true) {
        checkDuplicateProperties("Computed" /* COMPUTED */, key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val,
          enumerable: true
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
    if (true) {
      checkDuplicateProperties("Inject" /* INJECT */, key);
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {
    const handler = ctx[raw];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
      {
        watch(getter, handler);
      }
    } else if (true) {
      warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
        watch(getter, handler, raw);
      } else if (true) {
        warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else if (true) {
    warn$1(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
       true && warn$1(
        `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
      );
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend))(
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to) ? to.call(this, this) : to,
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(to) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}

function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp(rootComponent, rootProps = null) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(rootComponent)) {
      rootComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, rootComponent);
    }
    if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {
       true && warn$1(`root props passed to app.mount() must be an object.`);
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
        if (true) {
          warn$1(
            `app.config cannot be replaced. Modify individual options instead.`
          );
        }
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) {
           true && warn$1(`Plugin has already been applied to target app.`);
        } else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else if (true) {
          warn$1(
            `A plugin must either be a function or an object with an "install" function.`
          );
        }
        return app;
      },
      mixin(mixin) {
        if (__VUE_OPTIONS_API__) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (true) {
            warn$1(
              "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
            );
          }
        } else if (true) {
          warn$1("Mixins are only available in builds supporting Options API");
        }
        return app;
      },
      component(name, component) {
        if (true) {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if ( true && context.components[name]) {
          warn$1(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (true) {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if ( true && context.directives[name]) {
          warn$1(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          if ( true && rootContainer.__vue_app__) {
            warn$1(
              `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
            );
          }
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (true) {
            context.reload = () => {
              const cloned = cloneVNode(vnode);
              cloned.el = null;
              render(cloned, rootContainer, namespace);
            };
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          if (true) {
            app._instance = vnode.component;
            devtoolsInitApp(app, version);
          }
          return getComponentPublicInstance(vnode.component);
        } else if (true) {
          warn$1(
            `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
          );
        }
      },
      onUnmount(cleanupFn) {
        if ( true && typeof cleanupFn !== "function") {
          warn$1(
            `Expected function as first argument to app.onUnmount(), but got ${typeof cleanupFn}`
          );
        }
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render(null, app._container);
          if (true) {
            app._instance = null;
            devtoolsUnmountApp(app);
          }
          delete app._container.__vue_app__;
        } else if (true) {
          warn$1(`Cannot unmount an app that is not mounted.`);
        }
      },
      provide(key, value) {
        if ( true && key in context.provides) {
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(context.provides, key)) {
            warn$1(
              `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
            );
          } else {
            warn$1(
              `App already provides property with key "${String(key)}" inherited from its parent element. It will be overwritten with the new value.`
            );
          }
        }
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;

function useModel(props, name, options = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
  const i = getCurrentInstance();
  if ( true && !i) {
    warn$1(`useModel() called without active instance.`);
    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
  }
  const camelizedName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name);
  if ( true && !i.propsOptions[0][camelizedName]) {
    warn$1(`useModel() called with prop "${name}" which is not declared.`);
    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
  }
  const hyphenatedName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name);
  const modifiers = getModelModifiers(props, camelizedName);
  const res = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef)((track, trigger) => {
    let localValue;
    let prevSetValue = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    let prevEmittedValue;
    watchSyncEffect(() => {
      const propValue = props[camelizedName];
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(localValue, propValue)) {
        localValue = propValue;
        trigger();
      }
    });
    return {
      get() {
        track();
        return options.get ? options.get(localValue) : localValue;
      },
      set(value) {
        const emittedValue = options.set ? options.set(value) : value;
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(emittedValue, localValue) && !(prevSetValue !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(value, prevSetValue))) {
          return;
        }
        const rawProps = i.vnode.props;
        if (!(rawProps && // check if parent has passed v-model
        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps))) {
          localValue = value;
          trigger();
        }
        i.emit(`update:${name}`, emittedValue);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(value, emittedValue) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(value, prevSetValue) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(emittedValue, prevEmittedValue)) {
          trigger();
        }
        prevSetValue = value;
        prevEmittedValue = emittedValue;
      }
    };
  });
  res[Symbol.iterator] = () => {
    let i2 = 0;
    return {
      next() {
        if (i2 < 2) {
          return { value: i2++ ? modifiers || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ : res, done: false };
        } else {
          return { done: true };
        }
      }
    };
  };
  return res;
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(modelName)}Modifiers`] || props[`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(modelName)}Modifiers`];
};

function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
  if (true) {
    const {
      emitsOptions,
      propsOptions: [propsOptions]
    } = instance;
    if (emitsOptions) {
      if (!(event in emitsOptions) && true) {
        if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event)) in propsOptions)) {
          warn$1(
            `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event))}" prop.`
          );
        }
      } else {
        const validator = emitsOptions[event];
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {
          const isValid = validator(...rawArgs);
          if (!isValid) {
            warn$1(
              `Invalid event arguments: event validation failed for event "${event}".`
            );
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener = event.startsWith("update:");
  const modifiers = isModelListener && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber);
    }
  }
  if (true) {
    devtoolsComponentEmit(instance, event, args);
  }
  if (true) {
    const lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {
      warn$1(
        `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
          instance,
          instance.type
        )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(
          event
        )}" instead of "${event}".`
      );
    }
  }
  let handlerName;
  let handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)] || // also try camelCase event handler (#2249)
  props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event))];
  if (!handler && isModelListener) {
    handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
const mixinEmitsCache = /* @__PURE__ */ new WeakMap();
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = __VUE_OPTIONS_API__ && asMixin ? mixinEmitsCache : appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key);
}

let accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit,
    render,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  if (true) {
    accessedAttrs = false;
  }
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy =  true && setupState.__isScriptSetup ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
           true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(props) : 0,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if ( true && attrs === props) {
        markAttrsAccessed();
      }
      result = normalizeVNode(
        render2.length > 1 ? render2(
           true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(props) : 0,
           true ? {
            get attrs() {
              markAttrsAccessed();
              return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(attrs);
            },
            slots,
            emit
          } : 0
        ) : render2(
           true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(props) : 0,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  let setRoot = void 0;
  if ( true && result.patchFlag > 0 && result.patchFlag & 2048) {
    [root, setRoot] = getChildRoot(result);
  }
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      } else if ( true && !accessedAttrs && root.type !== Comment) {
        const allAttrs = Object.keys(attrs);
        const eventAttrs = [];
        const extraAttrs = [];
        for (let i = 0, l = allAttrs.length; i < l; i++) {
          const key = allAttrs[i];
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }
        if (extraAttrs.length) {
          warn$1(
            `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
          );
        }
        if (eventAttrs.length) {
          warn$1(
            `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
          );
        }
      }
    }
  }
  if (vnode.dirs) {
    if ( true && !isElementRoot(root)) {
      warn$1(
        `Runtime directive used on component with non-element root node. The directives will not function as intended.`
      );
    }
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if ( true && !isElementRoot(root)) {
      warn$1(
        `Component inside <Transition> renders non-element root node that cannot be animated.`
      );
    }
    setTransitionHooks(root, vnode.transition);
  }
  if ( true && setRoot) {
    setRoot(root);
  } else {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getChildRoot = (vnode) => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren, false);
  if (!childRoot) {
    return [vnode, void 0];
  } else if ( true && childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
    return getChildRoot(childRoot);
  }
  const index = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = (updatedRoot) => {
    rawChildren[index] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  };
  return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children, recurse = true) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
          if ( true && recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
            return filterSingleRoot(singleRoot.children);
          }
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
const isElementRoot = (vnode) => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if ( true && (prevChildren || nextChildren) && isHmrUpdating) {
    return true;
  }
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}

const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;

function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (true) {
    validateProps(rawProps || {}, props, instance);
  }
  if (isStateful) {
    instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function isInHmrContext(instance) {
  while (instance) {
    if (instance.type.__hmrId) return true;
    instance = instance.parent;
  }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !( true && isInHmrContext(instance)) && (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance.attrs, "set", "");
  }
  if (true) {
    validateProps(rawProps || {}, props, instance);
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    const castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[0 /* shouldCast */]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1 /* shouldCastTrue */] && (value === "" || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = __VUE_OPTIONS_API__ && asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (__VUE_OPTIONS_API__ && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
      cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);
    }
    return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {
        warn$1(`props must be strings when using array syntax.`, raw[i]);
      }
      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
      warn$1(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? { type: opt } : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(propType) && propType.name === "Boolean";
        }
        prop[0 /* shouldCast */] = shouldCast;
        prop[1 /* shouldCastTrue */] = shouldCastTrue;
        if (shouldCast || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
    return true;
  } else if (true) {
    warn$1(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType(ctor) {
  if (ctor === null) {
    return "null";
  }
  if (typeof ctor === "function") {
    return ctor.name || "";
  } else if (typeof ctor === "object") {
    const name = ctor.constructor && ctor.constructor.name;
    return name || "";
  }
  return "";
}
function validateProps(rawProps, props, instance) {
  const resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
  const options = instance.propsOptions[0];
  const camelizePropsKey = Object.keys(rawProps).map((key) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key));
  for (const key in options) {
    let opt = options[key];
    if (opt == null) continue;
    validateProp(
      key,
      resolvedValues[key],
      opt,
       true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(resolvedValues) : 0,
      !camelizePropsKey.includes(key)
    );
  }
}
function validateProp(name, value, prop, props, isAbsent) {
  const { type, required, validator, skipCheck } = prop;
  if (required && isAbsent) {
    warn$1('Missing required prop: "' + name + '"');
    return;
  }
  if (value == null && !required) {
    return;
  }
  if (type != null && type !== true && !skipCheck) {
    let isValid = false;
    const types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const { valid, expectedType } = assertType(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      warn$1(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  }
  if (validator && !validator(value, props)) {
    warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
const isSimpleType = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function assertType(value, type) {
  let valid;
  const expectedType = getType(type);
  if (expectedType === "null") {
    valid = value === null;
  } else if (isSimpleType(expectedType)) {
    const t = typeof value;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);
  } else if (expectedType === "Array") {
    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  if (expectedTypes.length === 0) {
    return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
  }
  let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}

const isInternalKey = (key) => key === "_" || key === "_ctx" || key === "$stable";
const normalizeSlotValue = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if ( true && currentInstance && !(ctx === null && currentRenderingInstance) && !(ctx && ctx.root !== currentInstance.root)) {
      warn$1(
        `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
      );
    }
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      if (true) {
        warn$1(
          `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
        );
      }
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  if ( true && !isKeepAlive(instance.vnode) && true) {
    warn$1(
      `Non-function value encountered for default slot. Prefer function slots for better performance.`
    );
  }
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || !isInternalKey(key)) {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if ( true && isHmrUpdating) {
        assignSlots(slots, children, optimized);
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, "set", "$slots");
      } else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};

let supported;
let perf;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark(`vue-${type}-${instance.uid}`);
  }
  if (true) {
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    const measureName = `<${formatComponentName(instance, instance.type)}> ${type}`;
    perf.mark(endTag);
    perf.measure(measureName, startTag, endTag);
    perf.clearMeasures(measureName);
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }
  if (true) {
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function isSupported() {
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  return supported;
}

function initFeatureFlags() {
  const needWarn = [];
  if (typeof __VUE_OPTIONS_API__ !== "boolean") {
     true && needWarn.push(`__VUE_OPTIONS_API__`);
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_OPTIONS_API__ = true;
  }
  if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
     true && needWarn.push(`__VUE_PROD_DEVTOOLS__`);
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;
  }
  if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== "boolean") {
     true && needWarn.push(`__VUE_PROD_HYDRATION_MISMATCH_DETAILS__`);
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
  }
  if ( true && needWarn.length) {
    const multi = needWarn.length > 1;
    console.warn(
      `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}

const queuePostRenderEffect = queueEffectWithSuspense ;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
  target.__VUE__ = true;
  if (true) {
    setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized =  true && isHmrUpdating ? false : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        } else if (true) {
          patchStaticNode(n1, n2, container, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (true) {
          warn$1("Invalid VNode type:", type, `(${typeof type})`);
        }
    }
    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    } else if (ref == null && n1 && n1.ref != null) {
      setRef(n1.ref, null, parentSuspense, n1, true);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        if ( true && isHmrUpdating && n2.patchFlag === -1 && "__elIndex" in n1) {
          const childNodes = container.childNodes;
          const newChild = hostCreateText(n2.children);
          const oldChild = childNodes[n2.__elIndex = n1.__elIndex];
          hostInsert(newChild, container, oldChild);
          hostRemove(oldChild);
        } else {
          hostSetText(el, n2.children);
        }
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const patchStaticNode = (n1, n2, container, namespace) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace
      );
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      const customElement = !!(n1.el && n1.el._isVueCE) ? n1.el : null;
      try {
        if (customElement) {
          customElement._beginPatch();
        }
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } finally {
        if (customElement) {
          customElement._endPatch();
        }
      }
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (true) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(el, "__vnode", vnode, true);
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(el, "__vueParentComponent", parentComponent, true);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if ( true && subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    if (true) {
      el.__vnode = n2;
    }
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if ( true && isHmrUpdating) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
      if (true) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if ( true && // #5523 dev root fragment may inherit directives
    (isHmrUpdating || patchFlag & 2048)) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren && n1.dynamicChildren.length === dynamicChildren.length) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (true) {
          traverseStaticChildren(n1, n2);
        } else // removed by dead control flow
{}
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = (initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    ));
    if ( true && instance.type.__hmrId) {
      registerHMR(instance);
    }
    if (true) {
      pushWarningContext(initialVNode);
      startMeasure(instance, `mount`);
    }
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      if (true) {
        startMeasure(instance, `init`);
      }
      setupComponent(instance, false, optimized);
      if (true) {
        endMeasure(instance, `init`);
      }
    }
    if ( true && isHmrUpdating) initialVNode.el = null;
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
        initialVNode.placeholder = placeholder.el;
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
    if (true) {
      popWarningContext();
      endMeasure(instance, `mount`);
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        if (true) {
          pushWarningContext(n2);
        }
        updateComponentPreRender(instance, n2, optimized);
        if (true) {
          popWarningContext();
        }
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            if (true) {
              startMeasure(instance, `render`);
            }
            instance.subTree = renderComponentRoot(instance);
            if (true) {
              endMeasure(instance, `render`);
            }
            if (true) {
              startMeasure(instance, `hydrate`);
            }
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
            if (true) {
              endMeasure(instance, `hydrate`);
            }
          };
          if (isAsyncWrapperVNode && type.__asyncHydrate) {
            type.__asyncHydrate(
              el,
              instance,
              hydrateSubTree
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (root.ce && // @ts-expect-error _def is private
          root.ce._def.shadowRoot !== false) {
            root.ce._injectChildStyle(type);
          }
          if (true) {
            startMeasure(instance, `render`);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          if (true) {
            endMeasure(instance, `render`);
          }
          if (true) {
            startMeasure(instance, `patch`);
          }
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          if (true) {
            endMeasure(instance, `patch`);
          }
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        if (true) {
          devtoolsComponentAdded(instance);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        if (true) {
          pushWarningContext(next || instance.vnode);
        }
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        if (true) {
          startMeasure(instance, `render`);
        }
        const nextTree = renderComponentRoot(instance);
        if (true) {
          endMeasure(instance, `render`);
        }
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        if (true) {
          startMeasure(instance, `patch`);
        }
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        if (true) {
          endMeasure(instance, `patch`);
        }
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
        if (true) {
          devtoolsComponentUpdated(instance);
        }
        if (true) {
          popWarningContext();
        }
      }
    };
    instance.scope.on();
    const effect = instance.effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect.run.bind(effect);
    const job = instance.job = effect.runIfDirty.bind(effect);
    job.i = instance;
    job.id = instance.uid;
    effect.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    if (true) {
      effect.onTrack = instance.rtc ? (e) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e) : void 0;
      effect.onTrigger = instance.rtg ? (e) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e) : void 0;
    }
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    flushPreFlushCbs(instance);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          if ( true && keyToNewIndexMap.has(nextChild.key)) {
            warn$1(
              `Duplicate keys found during update:`,
              JSON.stringify(nextChild.key),
              `Make sure keys are unique.`
            );
          }
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchorVNode = c2[nextIndex + 1];
        const anchor = nextIndex + 1 < l2 ? (
          // #13559, #14173 fallback to el placeholder for unresolved async component
          anchorVNode.el || resolveAsyncComponentPlaceholder(anchorVNode)
        ) : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove2 = () => {
          if (vnode.ctx.isUnmounted) {
            hostRemove(el);
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const performLeave = () => {
          if (el._isLeaving) {
            el[leaveCbKey](
              true
              /* cancelled */
            );
          }
          leave(el, () => {
            remove2();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove2, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref != null) {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
      setRef(ref, null, parentSuspense, vnode, true);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      if ( true && vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
        vnode.children.forEach((child) => {
          if (child.type === Comment) {
            hostRemove(child.el);
          } else {
            remove(child);
          }
        });
      } else {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    if ( true && instance.type.__hmrId) {
      unregisterHMR(instance);
    }
    const { bum, scope, job, subTree, um, m, a } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (true) {
      devtoolsComponentRemoved(instance);
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    let instance;
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
        instance = container._vnode.component;
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs(instance);
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect, job }, allowed) {
  if (allowed) {
    effect.flags |= 32;
    job.flags |= 4;
  } else {
    effect.flags &= -33;
    job.flags &= -5;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        if (c2.patchFlag !== -1) {
          c2.el = c1.el;
        } else {
          c2.__elIndex = i + // take fragment start anchor into account
          (n1.type === Fragment ? 1 : 0);
        }
      }
      if (c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
      if (true) {
        c2.el && (c2.el.__vnode = c2);
      }
    }
  }
}
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}
function resolveAsyncComponentPlaceholder(anchorVnode) {
  if (anchorVnode.placeholder) {
    return anchorVnode.placeholder;
  }
  const instance = anchorVnode.component;
  if (instance) {
    return resolveAsyncComponentPlaceholder(instance.subTree);
  }
  return null;
}

const isSuspense = (type) => type.__isSuspense;
let suspenseId = 0;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
        n2.suspense = n1.suspense;
        n2.suspense.vnode = n2;
        n2.el = n1.el;
        return;
      }
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl ;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    namespace,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      namespace,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(pendingBranch, newBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        if (!isHydrating) {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      }
    } else {
      suspense.pendingId = suspenseId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(activeBranch, newBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(activeBranch, newBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      if (newBranch.shapeFlag & 512) {
        suspense.pendingId = newBranch.component.suspenseId;
      } else {
        suspense.pendingId = suspenseId++;
      }
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  if ( true && !hasWarned) {
    hasWarned = true;
    console[console.info ? "info" : "log"](
      `<Suspense> is an experimental feature and its API will likely change.`
    );
  }
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense && parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props.timeout) : void 0;
  if (true) {
    assertNumber(timeout, `Suspense timeout`);
  }
  const initialAnchor = anchor;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    namespace,
    container,
    hiddenContainer,
    deps: 0,
    pendingId: suspenseId++,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !isHydrating,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      if (true) {
        if (!resume && !suspense.pendingBranch) {
          throw new Error(
            `suspense.resolve() is called without a pending branch.`
          );
        }
        if (suspense.isUnmounted) {
          throw new Error(
            `suspense.resolve() is called on an already unmounted suspense boundary.`
          );
        }
      }
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2,
        isInFallback
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(
                pendingBranch,
                container2,
                anchor === initialAnchor ? next(activeBranch) : anchor,
                0
              );
              queuePostFlushCb(effects);
              if (isInFallback && vnode2.ssFallback) {
                vnode2.ssFallback.el = null;
              }
            }
          };
        }
        if (activeBranch) {
          if (parentNode(activeBranch.el) === container2) {
            anchor = next(activeBranch);
          }
          unmount(activeBranch, parentComponent2, suspense, true);
          if (!delayEnter && isInFallback && vnode2.ssFallback) {
            queuePostRenderEffect(() => vnode2.ssFallback.el = null, suspense);
          }
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          namespace2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect, optimized2) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        if (true) {
          pushWarningContext(vnode2);
        }
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next(instance.subTree),
          suspense,
          namespace,
          optimized2
        );
        if (placeholder) {
          vnode2.placeholder = null;
          remove(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (true) {
          popWarningContext();
        }
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
  );
  const result = hydrateNode(
    node,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {
    const singleChild = filterSingleRoot(s);
    if ( true && !singleChild && s.filter((child) => child !== NULL_DYNAMIC_COMPONENT).length > 0) {
      warn$1(`<Suspense> slots expect a single root node.`);
    }
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  let el = branch.el;
  while (!el && branch.component) {
    branch = branch.component.subTree;
    el = branch.el;
  }
  vnode.el = el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  const suspensible = vnode.props && vnode.props.suspensible;
  return suspensible != null && suspensible !== false;
}

const Fragment = /* @__PURE__ */ Symbol.for("v-fgt");
const Text = /* @__PURE__ */ Symbol.for("v-txt");
const Comment = /* @__PURE__ */ Symbol.for("v-cmt");
const Static = /* @__PURE__ */ Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value, inVOnce = false) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  if ( true && n2.shapeFlag & 6 && n1.component) {
    const dirtyInstances = hmrDirtyComponents.get(n2.type);
    if (dirtyInstances && dirtyInstances.has(n1.component)) {
      n1.shapeFlag &= -257;
      n2.shapeFlag &= -513;
      return false;
    }
  }
  return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
  vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
  return _createVNode(
    ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args
  );
};
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref,
  ref_key,
  ref_for
}) => {
  if (typeof ref === "number") {
    ref = "" + ref;
  }
  return ref != null ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(children) ? 8 : 16;
  }
  if ( true && vnode.key !== vnode.key) {
    warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode =  true ? createVNodeWithArgsTransform : 0;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if ( true && !type) {
      warn$1(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {
      props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {
      if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {
        style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);
      }
      props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);
    }
  }
  const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type) ? 4 : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type) ? 2 : 0;
  if ( true && shapeFlag & 4 && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {
    type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);
    warn$1(
      `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
      `
Component that was made reactive: `,
      type
    );
  }
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || isInternalObject(props) ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children:  true && patchFlag === -1 && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children) ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    placeholder: vnode.placeholder,
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}

const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  if (true) {
    instance.ctx = createDevRenderContext(instance);
  } else // removed by dead control flow
{}
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1) setters.forEach((set) => set(v));
      else setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
const isBuiltInTag = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)("slot,component");
function validateComponentName(name, { isNativeTag }) {
  if (isBuiltInTag(name) || isNativeTag(name)) {
    warn$1(
      "Do not use built-in or reserved HTML elements as component id: " + name
    );
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized || isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  if (true) {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }
    if (Component.components) {
      const names = Object.keys(Component.components);
      for (let i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }
    if (Component.directives) {
      const names = Object.keys(Component.directives);
      for (let i = 0; i < names.length; i++) {
        validateDirectiveName(names[i]);
      }
    }
    if (Component.compilerOptions && isRuntimeOnly()) {
      warn$1(
        `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
      );
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  if (true) {
    exposePropsOnRenderContext(instance);
  }
  const { setup } = Component;
  if (setup) {
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
         true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0,
        setupContext
      ]
    );
    const isAsyncSetup = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
        if ( true && !instance.suspense) {
          const name = formatComponentName(instance, Component);
          warn$1(
            `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
          );
        }
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {
    if ( true && isVNode(setupResult)) {
      warn$1(
        `setup() should not return VNodes directly - return a render function instead.`
      );
    }
    if (true) {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);
    if (true) {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if ( true && setupResult !== void 0) {
    warn$1(
      `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
    );
  }
  finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile = _compile;
  installWithProxy = (i) => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || __VUE_OPTIONS_API__ && resolveMergedOptions(instance).template;
      if (template) {
        if (true) {
          startMeasure(instance, `compile`);
        }
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
        if (true) {
          endMeasure(instance, `compile`);
        }
      }
    }
    instance.render = Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  if (__VUE_OPTIONS_API__ && true) {
    const reset = setCurrentInstance(instance);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    try {
      applyOptions(instance);
    } finally {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
      reset();
    }
  }
  if ( true && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP && !isSSR) {
    if (!compile && Component.template) {
      warn$1(
        `Component provided template option but runtime compilation is not supported in this build of Vue.` + (` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".` )
      );
    } else {
      warn$1(`Component is missing template or render function: `, Component);
    }
  }
}
const attrsProxyHandlers =  true ? {
  get(target, key) {
    markAttrsAccessed();
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(target, "get", "");
    return target[key];
  },
  set() {
    warn$1(`setupContext.attrs is readonly.`);
    return false;
  },
  deleteProperty() {
    warn$1(`setupContext.attrs is readonly.`);
    return false;
  }
} : 0;
function getSlotsProxy(instance) {
  return new Proxy(instance.slots, {
    get(target, key) {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get", "$slots");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    if (true) {
      if (instance.exposed) {
        warn$1(`expose() should be called only once per setup().`);
      }
      if (exposed != null) {
        let exposedType = typeof exposed;
        if (exposedType === "object") {
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(exposed)) {
            exposedType = "array";
          } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(exposed)) {
            exposedType = "ref";
          }
        }
        if (exposedType !== "object") {
          warn$1(
            `expose() should be passed a plain object, received ${exposedType}.`
          );
        }
      }
    }
    instance.exposed = exposed || {};
  };
  if (true) {
    let attrsProxy;
    let slotsProxy;
    return Object.freeze({
      get attrs() {
        return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));
      },
      get slots() {
        return slotsProxy || (slotsProxy = getSlotsProxy(instance));
      },
      get emit() {
        return (event, ...args) => instance.emit(event, ...args);
      },
      expose
    });
  } else // removed by dead control flow
{}
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])\w/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(instance.components) || instance.parent && inferFromRegistry(
      instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && "__vccOpts" in value;
}

const computed = (getterOrOptions, debugOptions) => {
  const c = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);
  if (true) {
    const i = getCurrentInstance();
    if (i && i.appContext.config.warnRecursiveComputed) {
      c._warnRecursive = true;
    }
  }
  return c;
};

function h(type, propsOrChildren, children) {
  try {
    setBlockTracking(-1);
    const l = arguments.length;
    if (l === 2) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  } finally {
    setBlockTracking(1);
  }
}

function initCustomFormatter() {
  if ( false || typeof window === "undefined") {
    return;
  }
  const vueStyle = { style: "color:#3ba776" };
  const numberStyle = { style: "color:#1677ff" };
  const stringStyle = { style: "color:#f5222d" };
  const keywordStyle = { style: "color:#eb2f96" };
  const formatter = {
    __vue_custom_formatter: true,
    header(obj) {
      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
        const value = obj.value;
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
        return [
          "div",
          {},
          ["span", vueStyle, genRefFlag(obj)],
          "<",
          formatValue(value),
          `>`
        ];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(obj) ? "ShallowReactive" : "Reactive"],
          "<",
          formatValue(obj),
          `>${(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? ` (readonly)` : ``}`
        ];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(obj) ? "ShallowReadonly" : "Readonly"],
          "<",
          formatValue(obj),
          ">"
        ];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return [
          "div",
          {},
          ...formatInstance(obj.$)
        ];
      }
    }
  };
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));
    }
    if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      blocks.push(createInstanceBlock("data", (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));
    }
    const computed = extractKeys(instance, "computed");
    if (computed) {
      blocks.push(createInstanceBlock("computed", computed));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push([
      "div",
      {},
      [
        "span",
        {
          style: keywordStyle.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: instance }]
    ]);
    return blocks;
  }
  function createInstanceBlock(type, target) {
    target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);
    if (!Object.keys(target).length) {
      return ["span", {}];
    }
    return [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        type
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(target).map((key) => {
          return [
            "div",
            {},
            ["span", keywordStyle, key + ": "],
            formatValue(target[key], false)
          ];
        })
      ]
    ];
  }
  function formatValue(v, asRaw = true) {
    if (typeof v === "number") {
      return ["span", numberStyle, v];
    } else if (typeof v === "string") {
      return ["span", stringStyle, JSON.stringify(v)];
    } else if (typeof v === "boolean") {
      return ["span", keywordStyle, v];
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {
      return ["object", { object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v }];
    } else {
      return ["span", stringStyle, String(v)];
    }
  }
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  function genRefFlag(v) {
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(v)) {
      return `ShallowRef`;
    }
    if (v.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}

function withMemo(memo, render, cache, index) {
  const cached = cache[index];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render();
  ret.memo = memo.slice();
  ret.cacheIndex = index;
  return cache[index] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(prev[i], memo[i])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}

const version = "3.5.26";
const warn =  true ? warn$1 : 0;
const ErrorTypeStrings = ErrorTypeStrings$1 ;
const devtools =  true ? devtools$1 : 0;
const setDevtoolsHook =  true ? setDevtoolsHook$1 : 0;
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode: isVNode,
  normalizeVNode,
  getComponentPublicInstance,
  ensureValidVNode,
  pushWarningContext,
  popWarningContext
};
const ssrUtils = _ssrUtils ;
const resolveFilter = null;
const compatUtils = null;
const DeprecationTypes = null;




/***/ },

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js"
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTransition: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   BaseTransitionPropsValidators: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransitionPropsValidators),
/* harmony export */   Comment: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   DeprecationTypes: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.DeprecationTypes),
/* harmony export */   EffectScope: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   ErrorCodes: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ErrorCodes),
/* harmony export */   ErrorTypeStrings: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ErrorTypeStrings),
/* harmony export */   Fragment: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   KeepAlive: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   ReactiveEffect: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   Static: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   Suspense: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   Teleport: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   Text: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   TrackOpTypes: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.TrackOpTypes),
/* harmony export */   Transition: () => (/* binding */ Transition),
/* harmony export */   TransitionGroup: () => (/* binding */ TransitionGroup),
/* harmony export */   TriggerOpTypes: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.TriggerOpTypes),
/* harmony export */   VueElement: () => (/* binding */ VueElement),
/* harmony export */   assertNumber: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assertNumber),
/* harmony export */   callWithAsyncErrorHandling: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   callWithErrorHandling: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   camelize: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   capitalize: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   cloneVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   compatUtils: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   computed: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   createApp: () => (/* binding */ createApp),
/* harmony export */   createBlock: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   createCommentVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   createElementBlock: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   createElementVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   createHydrationRenderer: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   createPropsRestProxy: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   createRenderer: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   createSSRApp: () => (/* binding */ createSSRApp),
/* harmony export */   createSlots: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   createStaticVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   createTextVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   createVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   customRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   defineAsyncComponent: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   defineComponent: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement),
/* harmony export */   defineEmits: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   defineExpose: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   defineModel: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineModel),
/* harmony export */   defineOptions: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineOptions),
/* harmony export */   defineProps: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   defineSSRCustomElement: () => (/* binding */ defineSSRCustomElement),
/* harmony export */   defineSlots: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineSlots),
/* harmony export */   devtools: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   effect: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   effectScope: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   getCurrentInstance: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   getCurrentScope: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   getCurrentWatcher: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentWatcher),
/* harmony export */   getTransitionRawChildren: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   guardReactiveProps: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   h: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   handleError: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   hasInjectionContext: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.hasInjectionContext),
/* harmony export */   hydrate: () => (/* binding */ hydrate),
/* harmony export */   hydrateOnIdle: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.hydrateOnIdle),
/* harmony export */   hydrateOnInteraction: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.hydrateOnInteraction),
/* harmony export */   hydrateOnMediaQuery: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.hydrateOnMediaQuery),
/* harmony export */   hydrateOnVisible: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.hydrateOnVisible),
/* harmony export */   initCustomFormatter: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   initDirectivesForSSR: () => (/* binding */ initDirectivesForSSR),
/* harmony export */   inject: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   isMemoSame: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   isProxy: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   isReactive: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   isReadonly: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   isRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   isRuntimeOnly: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   isShallow: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   isVNode: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   markRaw: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   mergeDefaults: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   mergeModels: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeModels),
/* harmony export */   mergeProps: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   nextTick: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   nodeOps: () => (/* binding */ nodeOps),
/* harmony export */   normalizeClass: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   normalizeProps: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   normalizeStyle: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   onActivated: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   onBeforeMount: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   onBeforeUnmount: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   onBeforeUpdate: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   onDeactivated: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   onErrorCaptured: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   onMounted: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   onRenderTracked: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   onRenderTriggered: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   onScopeDispose: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   onServerPrefetch: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   onUnmounted: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   onUpdated: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   onWatcherCleanup: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onWatcherCleanup),
/* harmony export */   openBlock: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   patchProp: () => (/* binding */ patchProp),
/* harmony export */   popScopeId: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   provide: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   proxyRefs: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   pushScopeId: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   queuePostFlushCb: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   reactive: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   readonly: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   ref: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   registerRuntimeCompiler: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   render: () => (/* binding */ render),
/* harmony export */   renderList: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   renderSlot: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   resolveComponent: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   resolveDirective: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   resolveDynamicComponent: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   resolveFilter: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   resolveTransitionHooks: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   setBlockTracking: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   setDevtoolsHook: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   setTransitionHooks: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   shallowReactive: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   shallowReadonly: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   shallowRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   ssrContextKey: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   ssrUtils: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   stop: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   toDisplayString: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   toHandlerKey: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   toHandlers: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   toRaw: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   toRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   toRefs: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   toValue: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toValue),
/* harmony export */   transformVNodeArgs: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   triggerRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   unref: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   useAttrs: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   useCssModule: () => (/* binding */ useCssModule),
/* harmony export */   useCssVars: () => (/* binding */ useCssVars),
/* harmony export */   useHost: () => (/* binding */ useHost),
/* harmony export */   useId: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useId),
/* harmony export */   useModel: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useModel),
/* harmony export */   useSSRContext: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   useShadowRoot: () => (/* binding */ useShadowRoot),
/* harmony export */   useSlots: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   useTemplateRef: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTemplateRef),
/* harmony export */   useTransitionState: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   vModelCheckbox: () => (/* binding */ vModelCheckbox),
/* harmony export */   vModelDynamic: () => (/* binding */ vModelDynamic),
/* harmony export */   vModelRadio: () => (/* binding */ vModelRadio),
/* harmony export */   vModelSelect: () => (/* binding */ vModelSelect),
/* harmony export */   vModelText: () => (/* binding */ vModelText),
/* harmony export */   vShow: () => (/* binding */ vShow),
/* harmony export */   version: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   warn: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   watch: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   watchEffect: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   watchPostEffect: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   watchSyncEffect: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   withAsyncContext: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   withCtx: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   withDefaults: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   withDirectives: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   withKeys: () => (/* binding */ withKeys),
/* harmony export */   withMemo: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   withModifiers: () => (/* binding */ withModifiers),
/* harmony export */   withScopeId: () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/**
* @vue/runtime-dom v3.5.26
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/




let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Error creating trusted types policy: ${e}`);
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};

const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = /* @__PURE__ */ Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.extend)(
  {},
  _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t) => {
  t.displayName = "Transition";
  t.props = TransitionPropsValidators;
  return t;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isArray)(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isArray)(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done, isCancelled) => {
    el._enterCancelled = isCancelled;
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };
  return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.extend)(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      if (!el._enterCancelled) {
        forceReflow(el);
        addTransitionClass(el, leaveActiveClass);
      } else {
        addTransitionClass(el, leaveActiveClass);
        forceReflow(el);
      }
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(onLeave, [el, resolve]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false, void 0, true);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true, void 0, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isObject)(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toNumber)(val);
  if (true) {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assertNumber)(res, "<transition> explicit duration");
  }
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(?:transform|all)(?:,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow(el) {
  const targetDocument = el ? el.ownerDocument : document;
  return targetDocument.body.offsetHeight;
}

function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}

const vShowOriginalDisplay = /* @__PURE__ */ Symbol("_vod");
const vShowHidden = /* @__PURE__ */ Symbol("_vsh");
const vShow = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue) return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}

const CSS_VAR_TEXT = /* @__PURE__ */ Symbol( true ? "CSS_VAR_TEXT" : 0);
function useCssVars(getter) {
  const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
  if (!instance) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssVars is called without current active component instance.`);
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  if (true) {
    instance.getCssVars = () => getter(instance.proxy);
  }
  const setVars = () => {
    const vars = getter(instance.proxy);
    if (instance.ce) {
      setVarsOnNode(instance.ce, vars);
    } else {
      setVarsOnVNode(instance.subTree, vars);
    }
    updateTeleports(vars);
  };
  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate)(() => {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb)(setVars);
  });
  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch)(setVars, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.NOOP, { flush: "post" });
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor) break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    let cssText = "";
    for (const key in vars) {
      const value = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.normalizeCssVarValue)(vars[key]);
      style.setProperty(`--${key}`, value);
      cssText += `--${key}: ${value};`;
    }
    style[CSS_VAR_TEXT] = cssText;
  }
}

const displayRE = /(?:^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isString)(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!(0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isString)(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isArray)(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null) val = "";
    if (true) {
      if (semicolonRE.test(val)) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
          `Unexpected semicolon at the end of '${name}' style value: '${val}'`
        );
      }
    }
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.camelize)(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.capitalize)(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}

const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance, isBoolean = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isSpecialBooleanAttr)(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean && !(0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.includeBooleanAttr)(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean ? "" : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isSymbol)(value) ? String(value) : value
      );
    }
  }
}

function patchDOMProp(el, key, value, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.includeBooleanAttr)(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
    if ( true && !needRemove) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
        `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
        e
      );
    }
  }
  needRemove && el.removeAttribute(attrName || key);
}

function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = /* @__PURE__ */ Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value =  true ? sanitizeEventValue(nextValue, rawName) : 0;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
         true ? sanitizeEventValue(nextValue, rawName) : 0,
        instance
      );
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function sanitizeEventValue(value, propName) {
  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isFunction)(value) || (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isArray)(value)) {
    return value;
  }
  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
    `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value}.`
  );
  return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.NOOP;
}
function patchStopImmediatePropagation(e, value) {
  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isArray)(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value;
  }
}

const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isOn)(key)) {
    if (!(0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isModelListener)(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !(0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isString)(nextValue))
  ) {
    patchDOMProp(el, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.camelize)(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isFunction)(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
    return false;
  }
  if (key === "sandbox" && el.tagName === "IFRAME") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isString)(value)) {
    return false;
  }
  return key in el;
}

const REMOVAL = {};
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options, extraOptions, _createApp) {
  let Comp = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent)(options, extraOptions);
  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(Comp)) Comp = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.extend)({}, Comp, extraOptions);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, _createApp);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
const defineSSRCustomElement = (/* @__NO_SIDE_EFFECTS__ */ (options, extraOptions) => {
  return /* @__PURE__ */ defineCustomElement(options, extraOptions, createSSRApp);
});
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, _createApp = createApp) {
    super();
    this._def = _def;
    this._props = _props;
    this._createApp = _createApp;
    this._isVueCE = true;
    /**
     * @internal
     */
    this._instance = null;
    /**
     * @internal
     */
    this._app = null;
    /**
     * @internal
     */
    this._nonce = this._def.nonce;
    this._connected = false;
    this._resolved = false;
    this._patching = false;
    this._dirty = false;
    this._numberProps = null;
    this._styleChildren = /* @__PURE__ */ new WeakSet();
    this._ob = null;
    if (this.shadowRoot && _createApp !== createApp) {
      this._root = this.shadowRoot;
    } else {
      if ( true && this.shadowRoot) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
          `Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`
        );
      }
      if (_def.shadowRoot !== false) {
        this.attachShadow(
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.extend)({}, _def.shadowRootOptions, {
            mode: "open"
          })
        );
        this._root = this.shadowRoot;
      } else {
        this._root = this;
      }
    }
  }
  connectedCallback() {
    if (!this.isConnected) return;
    if (!this.shadowRoot && !this._resolved) {
      this._parseSlots();
    }
    this._connected = true;
    let parent = this;
    while (parent = parent && (parent.parentNode || parent.host)) {
      if (parent instanceof VueElement) {
        this._parent = parent;
        break;
      }
    }
    if (!this._instance) {
      if (this._resolved) {
        this._mount(this._def);
      } else {
        if (parent && parent._pendingResolve) {
          this._pendingResolve = parent._pendingResolve.then(() => {
            this._pendingResolve = void 0;
            this._resolveDef();
          });
        } else {
          this._resolveDef();
        }
      }
    }
  }
  _setParent(parent = this._parent) {
    if (parent) {
      this._instance.parent = parent._instance;
      this._inheritParentContext(parent);
    }
  }
  _inheritParentContext(parent = this._parent) {
    if (parent && this._app) {
      Object.setPrototypeOf(
        this._app._context.provides,
        parent._instance.provides
      );
    }
  }
  disconnectedCallback() {
    this._connected = false;
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
      if (!this._connected) {
        if (this._ob) {
          this._ob.disconnect();
          this._ob = null;
        }
        this._app && this._app.unmount();
        if (this._instance) this._instance.ce = void 0;
        this._app = this._instance = null;
        if (this._teleportTargets) {
          this._teleportTargets.clear();
          this._teleportTargets = void 0;
        }
      }
    });
  }
  _processMutations(mutations) {
    for (const m of mutations) {
      this._setAttr(m.attributeName);
    }
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    if (this._pendingResolve) {
      return;
    }
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    this._ob = new MutationObserver(this._processMutations.bind(this));
    this._ob.observe(this, { attributes: true });
    const resolve = (def, isAsync = false) => {
      this._resolved = true;
      this._pendingResolve = void 0;
      const { props, styles } = def;
      let numberProps;
      if (props && !(0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isArray)(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toNumber)(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[(0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.camelize)(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      this._resolveProps(def);
      if (this.shadowRoot) {
        this._applyStyles(styles);
      } else if ( true && styles) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
          "Custom element style injection is not supported when using shadowRoot: false"
        );
      }
      this._mount(def);
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      this._pendingResolve = asyncDef().then((def) => {
        def.configureApp = this._def.configureApp;
        resolve(this._def = def, true);
      });
    } else {
      resolve(this._def);
    }
  }
  _mount(def) {
    if (( true) && !def.name) {
      def.name = "VueElement";
    }
    this._app = this._createApp(def);
    this._inheritParentContext();
    if (def.configureApp) {
      def.configureApp(this._app);
    }
    this._app._ceVNode = this._createVNode();
    this._app.mount(this._root);
    const exposed = this._instance && this._instance.exposed;
    if (!exposed) return;
    for (const key in exposed) {
      if (!(0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.hasOwn)(this, key)) {
        Object.defineProperty(this, key, {
          // unwrap ref to be consistent with public instance behavior
          get: () => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.unref)(exposed[key])
        });
      } else if (true) {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Exposed property "${key}" already exists on custom element.`);
      }
    }
  }
  _resolveProps(def) {
    const { props } = def;
    const declaredPropKeys = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isArray)(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key]);
      }
    }
    for (const key of declaredPropKeys.map(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.camelize)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val, true, !this._patching);
        }
      });
    }
  }
  _setAttr(key) {
    if (key.startsWith("data-v-")) return;
    const has = this.hasAttribute(key);
    let value = has ? this.getAttribute(key) : REMOVAL;
    const camelKey = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.camelize)(key);
    if (has && this._numberProps && this._numberProps[camelKey]) {
      value = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toNumber)(value);
    }
    this._setProp(camelKey, value, false, true);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = false) {
    if (val !== this._props[key]) {
      this._dirty = true;
      if (val === REMOVAL) {
        delete this._props[key];
      } else {
        this._props[key] = val;
        if (key === "key" && this._app) {
          this._app._ceVNode.key = val;
        }
      }
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        const ob = this._ob;
        if (ob) {
          this._processMutations(ob.takeRecords());
          ob.disconnect();
        }
        if (val === true) {
          this.setAttribute((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(key), val + "");
        } else if (!val) {
          this.removeAttribute((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(key));
        }
        ob && ob.observe(this, { attributes: true });
      }
    }
  }
  _update() {
    const vnode = this._createVNode();
    if (this._app) vnode.appContext = this._app._context;
    render(vnode, this._root);
  }
  _createVNode() {
    const baseProps = {};
    if (!this.shadowRoot) {
      baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
    }
    const vnode = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(this._def, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.extend)(baseProps, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.ce = this;
        instance.isCE = true;
        if (true) {
          instance.ceReload = (newStyles) => {
            if (this._styles) {
              this._styles.forEach((s) => this._root.removeChild(s));
              this._styles.length = 0;
            }
            this._applyStyles(newStyles);
            this._instance = null;
            this._update();
          };
        }
        const dispatch = (event, args) => {
          this.dispatchEvent(
            new CustomEvent(
              event,
              (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(args[0]) ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.extend)({ detail: args }, args[0]) : { detail: args }
            )
          );
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(event) !== event) {
            dispatch((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(event), args);
          }
        };
        this._setParent();
      };
    }
    return vnode;
  }
  _applyStyles(styles, owner) {
    if (!styles) return;
    if (owner) {
      if (owner === this._def || this._styleChildren.has(owner)) {
        return;
      }
      this._styleChildren.add(owner);
    }
    const nonce = this._nonce;
    for (let i = styles.length - 1; i >= 0; i--) {
      const s = document.createElement("style");
      if (nonce) s.setAttribute("nonce", nonce);
      s.textContent = styles[i];
      this.shadowRoot.prepend(s);
      if (true) {
        if (owner) {
          if (owner.__hmrId) {
            if (!this._childStyles) this._childStyles = /* @__PURE__ */ new Map();
            let entry = this._childStyles.get(owner.__hmrId);
            if (!entry) {
              this._childStyles.set(owner.__hmrId, entry = []);
            }
            entry.push(s);
          }
        } else {
          (this._styles || (this._styles = [])).push(s);
        }
      }
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _parseSlots() {
    const slots = this._slots = {};
    let n;
    while (n = this.firstChild) {
      const slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
      (slots[slotName] || (slots[slotName] = [])).push(n);
      this.removeChild(n);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _renderSlots() {
    const outlets = this._getSlots();
    const scopeId = this._instance.type.__scopeId;
    for (let i = 0; i < outlets.length; i++) {
      const o = outlets[i];
      const slotName = o.getAttribute("name") || "default";
      const content = this._slots[slotName];
      const parent = o.parentNode;
      if (content) {
        for (const n of content) {
          if (scopeId && n.nodeType === 1) {
            const id = scopeId + "-s";
            const walker = document.createTreeWalker(n, 1);
            n.setAttribute(id, "");
            let child;
            while (child = walker.nextNode()) {
              child.setAttribute(id, "");
            }
          }
          parent.insertBefore(n, o);
        }
      } else {
        while (o.firstChild) parent.insertBefore(o.firstChild, o);
      }
      parent.removeChild(o);
    }
  }
  /**
   * @internal
   */
  _getSlots() {
    const roots = [this];
    if (this._teleportTargets) {
      roots.push(...this._teleportTargets);
    }
    const slots = /* @__PURE__ */ new Set();
    for (const root of roots) {
      const found = root.querySelectorAll("slot");
      for (let i = 0; i < found.length; i++) {
        slots.add(found[i]);
      }
    }
    return Array.from(slots);
  }
  /**
   * @internal
   */
  _injectChildStyle(comp) {
    this._applyStyles(comp.styles, comp);
  }
  /**
   * @internal
   */
  _beginPatch() {
    this._patching = true;
    this._dirty = false;
  }
  /**
   * @internal
   */
  _endPatch() {
    this._patching = false;
    if (this._dirty && this._instance) {
      this._update();
    }
  }
  /**
   * @internal
   */
  _removeChildStyle(comp) {
    if (true) {
      this._styleChildren.delete(comp);
      if (this._childStyles && comp.__hmrId) {
        const oldStyles = this._childStyles.get(comp.__hmrId);
        if (oldStyles) {
          oldStyles.forEach((s) => this._root.removeChild(s));
          oldStyles.length = 0;
        }
      }
    }
  }
}
function useHost(caller) {
  const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
  const el = instance && instance.ce;
  if (el) {
    return el;
  } else if (true) {
    if (!instance) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
        `${caller || "useHost"} called without an active component instance.`
      );
    } else {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
        `${caller || "useHost"} can only be used in components defined via defineCustomElement.`
      );
    }
  }
  return null;
}
function useShadowRoot() {
  const el =  true ? useHost("useShadowRoot") : 0;
  return el && el.shadowRoot;
}

function useCssModule(name = "$style") {
  {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    if (!instance) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssModule must be called inside setup()`);
      return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS modules injected.`);
      return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS module named "${name}".`);
      return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.EMPTY_OBJ;
    }
    return mod;
  }
}

const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = /* @__PURE__ */ Symbol("_moveCb");
const enterCbKey = /* @__PURE__ */ Symbol("_enterCb");
const decorate = (t) => {
  delete t.props.mode;
  return t;
};
const TransitionGroupImpl = /* @__PURE__ */ decorate({
  name: "TransitionGroup",
  props: /* @__PURE__ */ (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.extend)({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();
    let prevChildren;
    let children;
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        prevChildren = [];
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow(instance.vnode.el);
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || e.propertyName.endsWith("transform")) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
      prevChildren = [];
    });
    return () => {
      const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_1__.toRaw)(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;
      prevChildren = [];
      if (children) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(
              child,
              (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(
                child,
                cssTransitionProps,
                state,
                instance
              )
            );
            positionMap.set(child, {
              left: child.el.offsetLeft,
              top: child.el.offsetTop
            });
          }
        }
      }
      children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(
            child,
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance)
          );
        } else if ( true && child.type !== _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text) {
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<TransitionGroup> children must be keyed.`);
        }
      }
      return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);
    };
  }
});
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, {
    left: c.el.offsetLeft,
    top: c.el.offsetTop
  });
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}

const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isArray)(fn) ? (value) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.invokeArrayFns)(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = /* @__PURE__ */ Symbol("_assign");
function castValue(value, trim, number) {
  if (trim) value = value.trim();
  if (number) value = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.looseToNumber)(value);
  return value;
}
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing) return;
      el[assignKey](castValue(el.value, trim, castToNumber));
    });
    if (trim || castToNumber) {
      addEventListener(el, "change", () => {
        el.value = castValue(el.value, trim, castToNumber);
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing) return;
    const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.looseToNumber)(el.value) : el.value;
    const newValue = value == null ? "" : value;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value === oldValue) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el[assignKey];
      if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isArray)(modelValue)) {
        const index = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.looseIndexOf)(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isSet)(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  let checked;
  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isArray)(value)) {
    checked = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.looseIndexOf)(value, vnode.props.value) > -1;
  } else if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isSet)(value)) {
    checked = value.has(vnode.props.value);
  } else {
    if (value === oldValue) return;
    checked = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.looseEqual)(value, getCheckboxValue(el, true));
  }
  if (el.checked !== checked) {
    el.checked = checked;
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.looseEqual)(value, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.looseEqual)(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isSet)(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.looseToNumber)(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    if (!el._assigning) {
      setSelected(el, value);
    }
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  const isArrayValue = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isArray)(value);
  if (isMultiple && !isArrayValue && !(0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isSet)(value)) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`
    );
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option.selected = value.some((v) => String(v) === String(optionValue));
        } else {
          option.selected = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.looseIndexOf)(value, optionValue) > -1;
        }
      } else {
        option.selected = value.has(optionValue);
      }
    } else if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.looseEqual)(getValue(option), value)) {
      if (el.selectedIndex !== i) el.selectedIndex = i;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el.tagName,
    vnode.props && vnode.props.type
  );
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.looseEqual)(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isArray)(value)) {
      if (vnode.props && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.looseIndexOf)(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isSet)(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}

const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = ((event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  }));
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  const cache = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = ((event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.hyphenate)(event.key);
    if (modifiers.some(
      (k) => k === eventKey || keyNames[k] === eventKey
    )) {
      return fn(event);
    }
  }));
};

const rendererOptions = /* @__PURE__ */ (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.extend)({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render = ((...args) => {
  ensureRenderer().render(...args);
});
const hydrate = ((...args) => {
  ensureHydrationRenderer().hydrate(...args);
});
const createApp = ((...args) => {
  const app = ensureRenderer().createApp(...args);
  if (true) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app._component;
    if (!(0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isFunction)(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
});
const createSSRApp = ((...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  if (true) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, resolveRootNamespace(container));
    }
  };
  return app;
});
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function injectNativeTagCheck(app) {
  Object.defineProperty(app.config, "isNativeTag", {
    value: (tag) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isHTMLTag)(tag) || (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isSVGTag)(tag) || (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isMathMLTag)(tag),
    writable: false
  });
}
function injectCompilerOptionsCheck(app) {
  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {
    const isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
          `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
        );
      }
    });
    const compilerOptions = app.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
    Object.defineProperty(app.config, "compilerOptions", {
      get() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
        return compilerOptions;
      },
      set() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
      }
    });
  }
}
function normalizeContainer(container) {
  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.isString)(container)) {
    const res = document.querySelector(container);
    if ( true && !res) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
        `Failed to mount app: mount target selector "${container}" returned null.`
      );
    }
    return res;
  }
  if ( true && window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(
      `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
    );
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
} ;




/***/ },

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js"
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_ARR: () => (/* binding */ EMPTY_ARR),
/* harmony export */   EMPTY_OBJ: () => (/* binding */ EMPTY_OBJ),
/* harmony export */   NO: () => (/* binding */ NO),
/* harmony export */   NOOP: () => (/* binding */ NOOP),
/* harmony export */   PatchFlagNames: () => (/* binding */ PatchFlagNames),
/* harmony export */   PatchFlags: () => (/* binding */ PatchFlags),
/* harmony export */   ShapeFlags: () => (/* binding */ ShapeFlags),
/* harmony export */   SlotFlags: () => (/* binding */ SlotFlags),
/* harmony export */   camelize: () => (/* binding */ camelize),
/* harmony export */   capitalize: () => (/* binding */ capitalize),
/* harmony export */   cssVarNameEscapeSymbolsRE: () => (/* binding */ cssVarNameEscapeSymbolsRE),
/* harmony export */   def: () => (/* binding */ def),
/* harmony export */   escapeHtml: () => (/* binding */ escapeHtml),
/* harmony export */   escapeHtmlComment: () => (/* binding */ escapeHtmlComment),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   genCacheKey: () => (/* binding */ genCacheKey),
/* harmony export */   genPropsAccessExp: () => (/* binding */ genPropsAccessExp),
/* harmony export */   generateCodeFrame: () => (/* binding */ generateCodeFrame),
/* harmony export */   getEscapedCssVarName: () => (/* binding */ getEscapedCssVarName),
/* harmony export */   getGlobalThis: () => (/* binding */ getGlobalThis),
/* harmony export */   hasChanged: () => (/* binding */ hasChanged),
/* harmony export */   hasOwn: () => (/* binding */ hasOwn),
/* harmony export */   hyphenate: () => (/* binding */ hyphenate),
/* harmony export */   includeBooleanAttr: () => (/* binding */ includeBooleanAttr),
/* harmony export */   invokeArrayFns: () => (/* binding */ invokeArrayFns),
/* harmony export */   isArray: () => (/* binding */ isArray),
/* harmony export */   isBooleanAttr: () => (/* binding */ isBooleanAttr),
/* harmony export */   isBuiltInDirective: () => (/* binding */ isBuiltInDirective),
/* harmony export */   isDate: () => (/* binding */ isDate),
/* harmony export */   isFunction: () => (/* binding */ isFunction),
/* harmony export */   isGloballyAllowed: () => (/* binding */ isGloballyAllowed),
/* harmony export */   isGloballyWhitelisted: () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   isHTMLTag: () => (/* binding */ isHTMLTag),
/* harmony export */   isIntegerKey: () => (/* binding */ isIntegerKey),
/* harmony export */   isKnownHtmlAttr: () => (/* binding */ isKnownHtmlAttr),
/* harmony export */   isKnownMathMLAttr: () => (/* binding */ isKnownMathMLAttr),
/* harmony export */   isKnownSvgAttr: () => (/* binding */ isKnownSvgAttr),
/* harmony export */   isMap: () => (/* binding */ isMap),
/* harmony export */   isMathMLTag: () => (/* binding */ isMathMLTag),
/* harmony export */   isModelListener: () => (/* binding */ isModelListener),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isOn: () => (/* binding */ isOn),
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),
/* harmony export */   isPromise: () => (/* binding */ isPromise),
/* harmony export */   isRegExp: () => (/* binding */ isRegExp),
/* harmony export */   isRenderableAttrValue: () => (/* binding */ isRenderableAttrValue),
/* harmony export */   isReservedProp: () => (/* binding */ isReservedProp),
/* harmony export */   isSSRSafeAttrName: () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   isSVGTag: () => (/* binding */ isSVGTag),
/* harmony export */   isSet: () => (/* binding */ isSet),
/* harmony export */   isSpecialBooleanAttr: () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   isSymbol: () => (/* binding */ isSymbol),
/* harmony export */   isVoidTag: () => (/* binding */ isVoidTag),
/* harmony export */   looseEqual: () => (/* binding */ looseEqual),
/* harmony export */   looseIndexOf: () => (/* binding */ looseIndexOf),
/* harmony export */   looseToNumber: () => (/* binding */ looseToNumber),
/* harmony export */   makeMap: () => (/* binding */ makeMap),
/* harmony export */   normalizeClass: () => (/* binding */ normalizeClass),
/* harmony export */   normalizeCssVarValue: () => (/* binding */ normalizeCssVarValue),
/* harmony export */   normalizeProps: () => (/* binding */ normalizeProps),
/* harmony export */   normalizeStyle: () => (/* binding */ normalizeStyle),
/* harmony export */   objectToString: () => (/* binding */ objectToString),
/* harmony export */   parseStringStyle: () => (/* binding */ parseStringStyle),
/* harmony export */   propsToAttrMap: () => (/* binding */ propsToAttrMap),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   slotFlagsText: () => (/* binding */ slotFlagsText),
/* harmony export */   stringifyStyle: () => (/* binding */ stringifyStyle),
/* harmony export */   toDisplayString: () => (/* binding */ toDisplayString),
/* harmony export */   toHandlerKey: () => (/* binding */ toHandlerKey),
/* harmony export */   toNumber: () => (/* binding */ toNumber),
/* harmony export */   toRawType: () => (/* binding */ toRawType),
/* harmony export */   toTypeString: () => (/* binding */ toTypeString)
/* harmony export */ });
/**
* @vue/shared v3.5.26
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}

const EMPTY_OBJ =  true ? Object.freeze({}) : 0;
const EMPTY_ARR =  true ? Object.freeze([]) : 0;
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return ((str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  });
};
const camelizeRE = /-\w/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (c) => c.slice(1).toUpperCase());
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
function genCacheKey(source, options) {
  return source + JSON.stringify(
    options,
    (_, val) => typeof val === "function" ? val.toString() : val
  );
}

const PatchFlags = {
  "TEXT": 1,
  "1": "TEXT",
  "CLASS": 2,
  "2": "CLASS",
  "STYLE": 4,
  "4": "STYLE",
  "PROPS": 8,
  "8": "PROPS",
  "FULL_PROPS": 16,
  "16": "FULL_PROPS",
  "NEED_HYDRATION": 32,
  "32": "NEED_HYDRATION",
  "STABLE_FRAGMENT": 64,
  "64": "STABLE_FRAGMENT",
  "KEYED_FRAGMENT": 128,
  "128": "KEYED_FRAGMENT",
  "UNKEYED_FRAGMENT": 256,
  "256": "UNKEYED_FRAGMENT",
  "NEED_PATCH": 512,
  "512": "NEED_PATCH",
  "DYNAMIC_SLOTS": 1024,
  "1024": "DYNAMIC_SLOTS",
  "DEV_ROOT_FRAGMENT": 2048,
  "2048": "DEV_ROOT_FRAGMENT",
  "CACHED": -1,
  "-1": "CACHED",
  "BAIL": -2,
  "-2": "BAIL"
};
const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `NEED_HYDRATION`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `CACHED`,
  [-2]: `BAIL`
};

const ShapeFlags = {
  "ELEMENT": 1,
  "1": "ELEMENT",
  "FUNCTIONAL_COMPONENT": 2,
  "2": "FUNCTIONAL_COMPONENT",
  "STATEFUL_COMPONENT": 4,
  "4": "STATEFUL_COMPONENT",
  "TEXT_CHILDREN": 8,
  "8": "TEXT_CHILDREN",
  "ARRAY_CHILDREN": 16,
  "16": "ARRAY_CHILDREN",
  "SLOTS_CHILDREN": 32,
  "32": "SLOTS_CHILDREN",
  "TELEPORT": 64,
  "64": "TELEPORT",
  "SUSPENSE": 128,
  "128": "SUSPENSE",
  "COMPONENT_SHOULD_KEEP_ALIVE": 256,
  "256": "COMPONENT_SHOULD_KEEP_ALIVE",
  "COMPONENT_KEPT_ALIVE": 512,
  "512": "COMPONENT_KEPT_ALIVE",
  "COMPONENT": 6,
  "6": "COMPONENT"
};

const SlotFlags = {
  "STABLE": 1,
  "1": "STABLE",
  "DYNAMIC": 2,
  "2": "DYNAMIC",
  "FORWARDED": 3,
  "3": "FORWARDED"
};
const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};

const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
const isGloballyWhitelisted = isGloballyAllowed;

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
  start = Math.max(0, Math.min(start, source.length));
  end = Math.max(0, Math.min(end, source.length));
  if (start > end) return "";
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(
          `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
        );
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i) {
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(
            1,
            end > count ? lineLength - pad : end - start
          );
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}

function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  if (!styles) return "";
  if (isString(styles)) return styles;
  let ret = "";
  for (const key in styles) {
    const value = styles[key];
    if (isString(value) || typeof value === "number") {
      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props) return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}

const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);

const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
);
const isKnownSvgAttr = /* @__PURE__ */ makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
);
const isKnownMathMLAttr = /* @__PURE__ */ makeMap(
  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`
);
function isRenderableAttrValue(value) {
  if (value == null) {
    return false;
  }
  const type = typeof value;
  return type === "string" || type === "number" || type === "boolean";
}

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
  const str = "" + string;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index;
  let lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.slice(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escaped;
  }
  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
  return src.replace(commentStripRE, "");
}
const cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function getEscapedCssVarName(key, doubleEscape) {
  return key.replace(
    cssVarNameEscapeSymbolsRE,
    (s) => doubleEscape ? s === '"' ? '\\\\\\"' : `\\\\${s}` : `\\${s}`
  );
}

function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}

const isRef = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
  );
};

function normalizeCssVarValue(value) {
  if (value == null) {
    return "initial";
  }
  if (typeof value === "string") {
    return value === "" ? " " : value;
  }
  if (typeof value !== "number" || !Number.isFinite(value)) {
    if (true) {
      console.warn(
        "[Vue warn] Invalid value used for CSS binding. Expected a string or a finite number but received:",
        value
      );
    }
  }
  return String(value);
}




/***/ },

/***/ "./node_modules/birpc/dist/index.mjs"
/*!*******************************************!*\
  !*** ./node_modules/birpc/dist/index.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_TIMEOUT: () => (/* binding */ DEFAULT_TIMEOUT),
/* harmony export */   cachedMap: () => (/* binding */ cachedMap),
/* harmony export */   createBirpc: () => (/* binding */ createBirpc),
/* harmony export */   createBirpcGroup: () => (/* binding */ createBirpcGroup)
/* harmony export */ });
const TYPE_REQUEST = "q";
const TYPE_RESPONSE = "s";
const DEFAULT_TIMEOUT = 6e4;
function defaultSerialize(i) {
  return i;
}
const defaultDeserialize = defaultSerialize;
const { clearTimeout, setTimeout } = globalThis;
const random = Math.random.bind(Math);
function createBirpc($functions, options) {
  const {
    post,
    on,
    off = () => {
    },
    eventNames = [],
    serialize = defaultSerialize,
    deserialize = defaultDeserialize,
    resolver,
    bind = "rpc",
    timeout = DEFAULT_TIMEOUT
  } = options;
  let $closed = false;
  const _rpcPromiseMap = /* @__PURE__ */ new Map();
  let _promiseInit;
  let rpc;
  async function _call(method, args, event, optional) {
    if ($closed)
      throw new Error(`[birpc] rpc is closed, cannot call "${method}"`);
    const req = { m: method, a: args, t: TYPE_REQUEST };
    if (optional)
      req.o = true;
    const send = async (_req) => post(serialize(_req));
    if (event) {
      await send(req);
      return;
    }
    if (_promiseInit) {
      try {
        await _promiseInit;
      } finally {
        _promiseInit = void 0;
      }
    }
    let { promise, resolve, reject } = createPromiseWithResolvers();
    const id = nanoid();
    req.i = id;
    let timeoutId;
    async function handler(newReq = req) {
      if (timeout >= 0) {
        timeoutId = setTimeout(() => {
          try {
            const handleResult = options.onTimeoutError?.call(rpc, method, args);
            if (handleResult !== true)
              throw new Error(`[birpc] timeout on calling "${method}"`);
          } catch (e) {
            reject(e);
          }
          _rpcPromiseMap.delete(id);
        }, timeout);
        if (typeof timeoutId === "object")
          timeoutId = timeoutId.unref?.();
      }
      _rpcPromiseMap.set(id, { resolve, reject, timeoutId, method });
      await send(newReq);
      return promise;
    }
    try {
      if (options.onRequest)
        await options.onRequest.call(rpc, req, handler, resolve);
      else
        await handler();
    } catch (e) {
      if (options.onGeneralError?.call(rpc, e) !== true)
        throw e;
      return;
    } finally {
      clearTimeout(timeoutId);
      _rpcPromiseMap.delete(id);
    }
    return promise;
  }
  const $call = (method, ...args) => _call(method, args, false);
  const $callOptional = (method, ...args) => _call(method, args, false, true);
  const $callEvent = (method, ...args) => _call(method, args, true);
  const $callRaw = (options2) => _call(options2.method, options2.args, options2.event, options2.optional);
  const builtinMethods = {
    $call,
    $callOptional,
    $callEvent,
    $callRaw,
    $rejectPendingCalls,
    get $closed() {
      return $closed;
    },
    get $meta() {
      return options.meta;
    },
    $close,
    $functions
  };
  rpc = new Proxy({}, {
    get(_, method) {
      if (Object.prototype.hasOwnProperty.call(builtinMethods, method))
        return builtinMethods[method];
      if (method === "then" && !eventNames.includes("then") && !("then" in $functions))
        return void 0;
      const sendEvent = (...args) => _call(method, args, true);
      if (eventNames.includes(method)) {
        sendEvent.asEvent = sendEvent;
        return sendEvent;
      }
      const sendCall = (...args) => _call(method, args, false);
      sendCall.asEvent = sendEvent;
      return sendCall;
    }
  });
  function $close(customError) {
    $closed = true;
    _rpcPromiseMap.forEach(({ reject, method }) => {
      const error = new Error(`[birpc] rpc is closed, cannot call "${method}"`);
      if (customError) {
        customError.cause ??= error;
        return reject(customError);
      }
      reject(error);
    });
    _rpcPromiseMap.clear();
    off(onMessage);
  }
  function $rejectPendingCalls(handler) {
    const entries = Array.from(_rpcPromiseMap.values());
    const handlerResults = entries.map(({ method, reject }) => {
      if (!handler) {
        return reject(new Error(`[birpc]: rejected pending call "${method}".`));
      }
      return handler({ method, reject });
    });
    _rpcPromiseMap.clear();
    return handlerResults;
  }
  async function onMessage(data, ...extra) {
    let msg;
    try {
      msg = deserialize(data);
    } catch (e) {
      if (options.onGeneralError?.call(rpc, e) !== true)
        throw e;
      return;
    }
    if (msg.t === TYPE_REQUEST) {
      const { m: method, a: args, o: optional } = msg;
      let result, error;
      let fn = await (resolver ? resolver.call(rpc, method, $functions[method]) : $functions[method]);
      if (optional)
        fn ||= () => void 0;
      if (!fn) {
        error = new Error(`[birpc] function "${method}" not found`);
      } else {
        try {
          result = await fn.apply(bind === "rpc" ? rpc : $functions, args);
        } catch (e) {
          error = e;
        }
      }
      if (msg.i) {
        if (error && options.onError)
          options.onError.call(rpc, error, method, args);
        if (error && options.onFunctionError) {
          if (options.onFunctionError.call(rpc, error, method, args) === true)
            return;
        }
        if (!error) {
          try {
            await post(serialize({ t: TYPE_RESPONSE, i: msg.i, r: result }), ...extra);
            return;
          } catch (e) {
            error = e;
            if (options.onGeneralError?.call(rpc, e, method, args) !== true)
              throw e;
          }
        }
        try {
          await post(serialize({ t: TYPE_RESPONSE, i: msg.i, e: error }), ...extra);
        } catch (e) {
          if (options.onGeneralError?.call(rpc, e, method, args) !== true)
            throw e;
        }
      }
    } else {
      const { i: ack, r: result, e: error } = msg;
      const promise = _rpcPromiseMap.get(ack);
      if (promise) {
        clearTimeout(promise.timeoutId);
        if (error)
          promise.reject(error);
        else
          promise.resolve(result);
      }
      _rpcPromiseMap.delete(ack);
    }
  }
  _promiseInit = on(onMessage);
  return rpc;
}
const cacheMap = /* @__PURE__ */ new WeakMap();
function cachedMap(items, fn) {
  return items.map((i) => {
    let r = cacheMap.get(i);
    if (!r) {
      r = fn(i);
      cacheMap.set(i, r);
    }
    return r;
  });
}
function createBirpcGroup(functions, channels, options = {}) {
  const getChannels = () => typeof channels === "function" ? channels() : channels;
  const getClients = (channels2 = getChannels()) => cachedMap(channels2, (s) => createBirpc(functions, { ...options, ...s }));
  function _boardcast(method, args, event, optional) {
    const clients = getClients();
    return Promise.all(clients.map((c) => c.$callRaw({ method, args, event, optional })));
  }
  function $call(method, ...args) {
    return _boardcast(method, args, false);
  }
  function $callOptional(method, ...args) {
    return _boardcast(method, args, false, true);
  }
  function $callEvent(method, ...args) {
    return _boardcast(method, args, true);
  }
  const broadcastBuiltin = {
    $call,
    $callOptional,
    $callEvent
  };
  const broadcastProxy = new Proxy({}, {
    get(_, method) {
      if (Object.prototype.hasOwnProperty.call(broadcastBuiltin, method))
        return broadcastBuiltin[method];
      const client = getClients();
      const callbacks = client.map((c) => c[method]);
      const sendCall = (...args) => {
        return Promise.all(callbacks.map((i) => i(...args)));
      };
      sendCall.asEvent = async (...args) => {
        await Promise.all(callbacks.map((i) => i.asEvent(...args)));
      };
      return sendCall;
    }
  });
  function updateChannels(fn) {
    const channels2 = getChannels();
    fn?.(channels2);
    return getClients(channels2);
  }
  getClients();
  return {
    get clients() {
      return getClients();
    },
    functions,
    updateChannels,
    broadcast: broadcastProxy,
    /**
     * @deprecated use `broadcast`
     */
    // @ts-expect-error deprecated
    boardcast: broadcastProxy
  };
}
function createPromiseWithResolvers() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
function nanoid(size = 21) {
  let id = "";
  let i = size;
  while (i--)
    id += urlAlphabet[random() * 64 | 0];
  return id;
}




/***/ },

/***/ "./node_modules/core-js/internals/a-callable.js"
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-callable.js ***!
  \******************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ },

/***/ "./node_modules/core-js/internals/add-to-unscopables.js"
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
  \**************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] === undefined) {
  defineProperty(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ },

/***/ "./node_modules/core-js/internals/an-instance.js"
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/an-instance.js ***!
  \*******************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw new $TypeError('Incorrect invocation');
};


/***/ },

/***/ "./node_modules/core-js/internals/an-object.js"
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ },

/***/ "./node_modules/core-js/internals/array-includes.js"
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ },

/***/ "./node_modules/core-js/internals/array-iteration.js"
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/array-iteration.js ***!
  \***********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE === 1;
  var IS_FILTER = TYPE === 2;
  var IS_SOME = TYPE === 3;
  var IS_EVERY = TYPE === 4;
  var IS_FIND_INDEX = TYPE === 6;
  var IS_FILTER_REJECT = TYPE === 7;
  var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var length = lengthOfArrayLike(self);
    var boundFunction = bind(callbackfn, that);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ },

/***/ "./node_modules/core-js/internals/array-method-has-species-support.js"
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/array-method-has-species-support.js ***!
  \****************************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var V8_VERSION = __webpack_require__(/*! ../internals/environment-v8-version */ "./node_modules/core-js/internals/environment-v8-version.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ },

/***/ "./node_modules/core-js/internals/array-method-is-strict.js"
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/array-method-is-strict.js ***!
  \******************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () { return 1; }, 1);
  });
};


/***/ },

/***/ "./node_modules/core-js/internals/array-species-constructor.js"
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-constructor.js ***!
  \*********************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');
var $Array = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? $Array : C;
};


/***/ },

/***/ "./node_modules/core-js/internals/array-species-create.js"
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-create.js ***!
  \****************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var arraySpeciesConstructor = __webpack_require__(/*! ../internals/array-species-constructor */ "./node_modules/core-js/internals/array-species-constructor.js");

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ },

/***/ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js"
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!
  \****************************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose(iterator, 'throw', error);
  }
};


/***/ },

/***/ "./node_modules/core-js/internals/classof-raw.js"
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ },

/***/ "./node_modules/core-js/internals/classof.js"
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ },

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js"
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ },

/***/ "./node_modules/core-js/internals/correct-is-regexp-logic.js"
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-is-regexp-logic.js ***!
  \*******************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};


/***/ },

/***/ "./node_modules/core-js/internals/correct-prototype-getter.js"
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ },

/***/ "./node_modules/core-js/internals/create-iter-result-object.js"
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-iter-result-object.js ***!
  \*********************************************************************/
(module) {


// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};


/***/ },

/***/ "./node_modules/core-js/internals/create-non-enumerable-property.js"
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ },

/***/ "./node_modules/core-js/internals/create-property-descriptor.js"
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
(module) {


module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ },

/***/ "./node_modules/core-js/internals/create-property.js"
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/create-property.js ***!
  \***********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = function (object, key, value) {
  if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
  else object[key] = value;
};


/***/ },

/***/ "./node_modules/core-js/internals/define-built-in-accessor.js"
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in-accessor.js ***!
  \********************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ },

/***/ "./node_modules/core-js/internals/define-built-in.js"
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-in.js ***!
  \***********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var makeBuiltIn = __webpack_require__(/*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ },

/***/ "./node_modules/core-js/internals/define-built-ins.js"
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/define-built-ins.js ***!
  \************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");

module.exports = function (target, src, options) {
  for (var key in src) defineBuiltIn(target, key, src[key], options);
  return target;
};


/***/ },

/***/ "./node_modules/core-js/internals/define-global-property.js"
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/define-global-property.js ***!
  \******************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(globalThis, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    globalThis[key] = value;
  } return value;
};


/***/ },

/***/ "./node_modules/core-js/internals/descriptors.js"
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ },

/***/ "./node_modules/core-js/internals/document-create-element.js"
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var document = globalThis.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ },

/***/ "./node_modules/core-js/internals/enum-bug-keys.js"
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
(module) {


// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ },

/***/ "./node_modules/core-js/internals/environment-user-agent.js"
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/environment-user-agent.js ***!
  \******************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");

var navigator = globalThis.navigator;
var userAgent = navigator && navigator.userAgent;

module.exports = userAgent ? String(userAgent) : '';


/***/ },

/***/ "./node_modules/core-js/internals/environment-v8-version.js"
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/environment-v8-version.js ***!
  \******************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var userAgent = __webpack_require__(/*! ../internals/environment-user-agent */ "./node_modules/core-js/internals/environment-user-agent.js");

var process = globalThis.process;
var Deno = globalThis.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ },

/***/ "./node_modules/core-js/internals/export.js"
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = globalThis;
  } else if (STATIC) {
    target = globalThis[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = globalThis[TARGET] && globalThis[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ },

/***/ "./node_modules/core-js/internals/fails.js"
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
(module) {


module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ },

/***/ "./node_modules/core-js/internals/function-bind-context.js"
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-context.js ***!
  \*****************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this-clause */ "./node_modules/core-js/internals/function-uncurry-this-clause.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ },

/***/ "./node_modules/core-js/internals/function-bind-native.js"
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind-native.js ***!
  \****************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ },

/***/ "./node_modules/core-js/internals/function-call.js"
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-call.js ***!
  \*********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var call = Function.prototype.call;
// eslint-disable-next-line es/no-function-prototype-bind -- safe
module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ },

/***/ "./node_modules/core-js/internals/function-name.js"
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-name.js ***!
  \*********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ },

/***/ "./node_modules/core-js/internals/function-uncurry-this-clause.js"
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this-clause.js ***!
  \************************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ },

/***/ "./node_modules/core-js/internals/function-uncurry-this.js"
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/function-uncurry-this.js ***!
  \*****************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
// eslint-disable-next-line es/no-function-prototype-bind -- safe
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ },

/***/ "./node_modules/core-js/internals/get-built-in.js"
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(globalThis[namespace]) : globalThis[namespace] && globalThis[namespace][method];
};


/***/ },

/***/ "./node_modules/core-js/internals/get-iterator-direct.js"
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator-direct.js ***!
  \***************************************************************/
(module) {


// `GetIteratorDirect(obj)` abstract operation
// https://tc39.es/ecma262/#sec-getiteratordirect
module.exports = function (obj) {
  return {
    iterator: obj,
    next: obj.next,
    done: false
  };
};


/***/ },

/***/ "./node_modules/core-js/internals/get-method.js"
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/get-method.js ***!
  \******************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ },

/***/ "./node_modules/core-js/internals/global-this.js"
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/global-this.js ***!
  \*******************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ },

/***/ "./node_modules/core-js/internals/has-own-property.js"
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/has-own-property.js ***!
  \************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ },

/***/ "./node_modules/core-js/internals/hidden-keys.js"
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
(module) {


module.exports = {};


/***/ },

/***/ "./node_modules/core-js/internals/html.js"
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('document', 'documentElement');


/***/ },

/***/ "./node_modules/core-js/internals/ie8-dom-define.js"
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ },

/***/ "./node_modules/core-js/internals/indexed-object.js"
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ },

/***/ "./node_modules/core-js/internals/inspect-source.js"
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ },

/***/ "./node_modules/core-js/internals/internal-state.js"
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js/internals/weak-map-basic-detection.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = globalThis.TypeError;
var WeakMap = globalThis.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ },

/***/ "./node_modules/core-js/internals/is-array.js"
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/is-array.js ***!
  \****************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ },

/***/ "./node_modules/core-js/internals/is-callable.js"
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/is-callable.js ***!
  \*******************************************************/
(module) {


// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ },

/***/ "./node_modules/core-js/internals/is-constructor.js"
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/is-constructor.js ***!
  \**********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var noop = function () { /* empty */ };
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.test(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, [], argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ },

/***/ "./node_modules/core-js/internals/is-forced.js"
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ },

/***/ "./node_modules/core-js/internals/is-null-or-undefined.js"
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/is-null-or-undefined.js ***!
  \****************************************************************/
(module) {


// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ },

/***/ "./node_modules/core-js/internals/is-object.js"
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ },

/***/ "./node_modules/core-js/internals/is-pure.js"
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
(module) {


module.exports = false;


/***/ },

/***/ "./node_modules/core-js/internals/is-regexp.js"
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-regexp.js ***!
  \*****************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) === 'RegExp');
};


/***/ },

/***/ "./node_modules/core-js/internals/is-symbol.js"
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-symbol.js ***!
  \*****************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ },

/***/ "./node_modules/core-js/internals/iterator-close-all.js"
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-close-all.js ***!
  \**************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");

module.exports = function (iters, kind, value) {
  for (var i = iters.length - 1; i >= 0; i--) {
    if (iters[i] === undefined) continue;
    try {
      value = iteratorClose(iters[i].iterator, kind, value);
    } catch (error) {
      kind = 'throw';
      value = error;
    }
  }
  if (kind === 'throw') throw value;
  return value;
};


/***/ },

/***/ "./node_modules/core-js/internals/iterator-close.js"
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-close.js ***!
  \**********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ },

/***/ "./node_modules/core-js/internals/iterator-create-proxy.js"
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-create-proxy.js ***!
  \*****************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var defineBuiltIns = __webpack_require__(/*! ../internals/define-built-ins */ "./node_modules/core-js/internals/define-built-ins.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var IteratorPrototype = (__webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype);
var createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js/internals/create-iter-result-object.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");
var iteratorCloseAll = __webpack_require__(/*! ../internals/iterator-close-all */ "./node_modules/core-js/internals/iterator-close-all.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ITERATOR_HELPER = 'IteratorHelper';
var WRAP_FOR_VALID_ITERATOR = 'WrapForValidIterator';
var NORMAL = 'normal';
var THROW = 'throw';
var setInternalState = InternalStateModule.set;

var createIteratorProxyPrototype = function (IS_ITERATOR) {
  var getInternalState = InternalStateModule.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER);

  return defineBuiltIns(create(IteratorPrototype), {
    next: function next() {
      var state = getInternalState(this);
      // for simplification:
      //   for `%WrapForValidIteratorPrototype%.next` or with `state.returnHandlerResult` our `nextHandler` returns `IterResultObject`
      //   for `%IteratorHelperPrototype%.next` - just a value
      if (IS_ITERATOR) return state.nextHandler();
      if (state.done) return createIterResultObject(undefined, true);
      try {
        var result = state.nextHandler();
        return state.returnHandlerResult ? result : createIterResultObject(result, state.done);
      } catch (error) {
        state.done = true;
        throw error;
      }
    },
    'return': function () {
      var state = getInternalState(this);
      var iterator = state.iterator;
      state.done = true;
      if (IS_ITERATOR) {
        var returnMethod = getMethod(iterator, 'return');
        return returnMethod ? call(returnMethod, iterator) : createIterResultObject(undefined, true);
      }
      if (state.inner) try {
        iteratorClose(state.inner.iterator, NORMAL);
      } catch (error) {
        return iteratorClose(iterator, THROW, error);
      }
      if (state.openIters) try {
        iteratorCloseAll(state.openIters, NORMAL);
      } catch (error) {
        return iteratorClose(iterator, THROW, error);
      }
      if (iterator) iteratorClose(iterator, NORMAL);
      return createIterResultObject(undefined, true);
    }
  });
};

var WrapForValidIteratorPrototype = createIteratorProxyPrototype(true);
var IteratorHelperPrototype = createIteratorProxyPrototype(false);

createNonEnumerableProperty(IteratorHelperPrototype, TO_STRING_TAG, 'Iterator Helper');

module.exports = function (nextHandler, IS_ITERATOR, RETURN_HANDLER_RESULT) {
  var IteratorProxy = function Iterator(record, state) {
    if (state) {
      state.iterator = record.iterator;
      state.next = record.next;
    } else state = record;
    state.type = IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER;
    state.returnHandlerResult = !!RETURN_HANDLER_RESULT;
    state.nextHandler = nextHandler;
    state.counter = 0;
    state.done = false;
    setInternalState(this, state);
  };

  IteratorProxy.prototype = IS_ITERATOR ? WrapForValidIteratorPrototype : IteratorHelperPrototype;

  return IteratorProxy;
};


/***/ },

/***/ "./node_modules/core-js/internals/iterator-helper-throws-on-invalid-iterator.js"
/*!**************************************************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-helper-throws-on-invalid-iterator.js ***!
  \**************************************************************************************/
(module) {


// Should throw an error on invalid iterator
// https://issues.chromium.org/issues/336839115
module.exports = function (methodName, argument) {
  // eslint-disable-next-line es/no-iterator -- required for testing
  var method = typeof Iterator == 'function' && Iterator.prototype[methodName];
  if (method) try {
    method.call({ next: null }, argument).next();
  } catch (error) {
    return true;
  }
};


/***/ },

/***/ "./node_modules/core-js/internals/iterator-helper-without-closing-on-early-error.js"
/*!******************************************************************************************!*\
  !*** ./node_modules/core-js/internals/iterator-helper-without-closing-on-early-error.js ***!
  \******************************************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");

// https://github.com/tc39/ecma262/pull/3467
module.exports = function (METHOD_NAME, ExpectedError) {
  var Iterator = globalThis.Iterator;
  var IteratorPrototype = Iterator && Iterator.prototype;
  var method = IteratorPrototype && IteratorPrototype[METHOD_NAME];

  var CLOSED = false;

  if (method) try {
    method.call({
      next: function () { return { done: true }; },
      'return': function () { CLOSED = true; }
    }, -1);
  } catch (error) {
    // https://bugs.webkit.org/show_bug.cgi?id=291195
    if (!(error instanceof ExpectedError)) CLOSED = false;
  }

  if (!CLOSED) return method;
};


/***/ },

/***/ "./node_modules/core-js/internals/iterators-core.js"
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterators-core.js ***!
  \**********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ },

/***/ "./node_modules/core-js/internals/length-of-array-like.js"
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/length-of-array-like.js ***!
  \****************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ },

/***/ "./node_modules/core-js/internals/make-built-in.js"
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/make-built-in.js ***!
  \*********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js").CONFIGURABLE);
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ },

/***/ "./node_modules/core-js/internals/math-trunc.js"
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/math-trunc.js ***!
  \******************************************************/
(module) {


var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ },

/***/ "./node_modules/core-js/internals/not-a-regexp.js"
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/not-a-regexp.js ***!
  \********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var isRegExp = __webpack_require__(/*! ../internals/is-regexp */ "./node_modules/core-js/internals/is-regexp.js");

var $TypeError = TypeError;

module.exports = function (it) {
  if (isRegExp(it)) {
    throw new $TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ },

/***/ "./node_modules/core-js/internals/object-create.js"
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var definePropertiesModule = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  // eslint-disable-next-line no-useless-assignment -- avoid memory leak
  activeXDocument = null;
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ },

/***/ "./node_modules/core-js/internals/object-define-properties.js"
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ },

/***/ "./node_modules/core-js/internals/object-define-property.js"
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ },

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js"
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ },

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js"
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {


var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ },

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js"
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
(__unused_webpack_module, exports) {


// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ },

/***/ "./node_modules/core-js/internals/object-get-prototype-of.js"
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ },

/***/ "./node_modules/core-js/internals/object-is-prototype-of.js"
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-is-prototype-of.js ***!
  \******************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

module.exports = uncurryThis({}.isPrototypeOf);


/***/ },

/***/ "./node_modules/core-js/internals/object-keys-internal.js"
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var indexOf = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf);
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ },

/***/ "./node_modules/core-js/internals/object-keys.js"
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ },

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js"
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
(__unused_webpack_module, exports) {


var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ },

/***/ "./node_modules/core-js/internals/object-to-string.js"
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-string.js ***!
  \************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ },

/***/ "./node_modules/core-js/internals/ordinary-to-primitive.js"
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/ordinary-to-primitive.js ***!
  \*****************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ },

/***/ "./node_modules/core-js/internals/own-keys.js"
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ },

/***/ "./node_modules/core-js/internals/require-object-coercible.js"
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js/internals/is-null-or-undefined.js");

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ },

/***/ "./node_modules/core-js/internals/shared-key.js"
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ },

/***/ "./node_modules/core-js/internals/shared-store.js"
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js/internals/define-global-property.js");

var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

(store.versions || (store.versions = [])).push({
  version: '3.47.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2014-2025 Denis Pushkarev (zloirock.ru), 2025 CoreJS Company (core-js.io)',
  license: 'https://github.com/zloirock/core-js/blob/v3.47.0/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ },

/***/ "./node_modules/core-js/internals/shared.js"
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

module.exports = function (key, value) {
  return store[key] || (store[key] = value || {});
};


/***/ },

/***/ "./node_modules/core-js/internals/symbol-constructor-detection.js"
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/symbol-constructor-detection.js ***!
  \************************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(/*! ../internals/environment-v8-version */ "./node_modules/core-js/internals/environment-v8-version.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");

var $String = globalThis.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ },

/***/ "./node_modules/core-js/internals/to-absolute-index.js"
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ },

/***/ "./node_modules/core-js/internals/to-indexed-object.js"
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ },

/***/ "./node_modules/core-js/internals/to-integer-or-infinity.js"
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer-or-infinity.js ***!
  \******************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var trunc = __webpack_require__(/*! ../internals/math-trunc */ "./node_modules/core-js/internals/math-trunc.js");

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ },

/***/ "./node_modules/core-js/internals/to-length.js"
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ },

/***/ "./node_modules/core-js/internals/to-object.js"
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ },

/***/ "./node_modules/core-js/internals/to-primitive.js"
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ },

/***/ "./node_modules/core-js/internals/to-property-key.js"
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/to-property-key.js ***!
  \***********************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ },

/***/ "./node_modules/core-js/internals/to-string-tag-support.js"
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!
  \*****************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};
// eslint-disable-next-line unicorn/no-immediate-mutation -- ES3 syntax limitation
test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ },

/***/ "./node_modules/core-js/internals/to-string.js"
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-string.js ***!
  \*****************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ },

/***/ "./node_modules/core-js/internals/try-to-string.js"
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/try-to-string.js ***!
  \*********************************************************/
(module) {


var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ },

/***/ "./node_modules/core-js/internals/uid.js"
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.1.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ },

/***/ "./node_modules/core-js/internals/use-symbol-as-uid.js"
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");

module.exports = NATIVE_SYMBOL &&
  !Symbol.sham &&
  typeof Symbol.iterator == 'symbol';


/***/ },

/***/ "./node_modules/core-js/internals/v8-prototype-define-bug.js"
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/v8-prototype-define-bug.js ***!
  \*******************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ },

/***/ "./node_modules/core-js/internals/weak-map-basic-detection.js"
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/weak-map-basic-detection.js ***!
  \********************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var WeakMap = globalThis.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ },

/***/ "./node_modules/core-js/internals/well-known-symbol.js"
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js/internals/symbol-constructor-detection.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var Symbol = globalThis.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ },

/***/ "./node_modules/core-js/modules/es.array.filter.js"
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.filter.js ***!
  \*********************************************************/
(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $filter = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").filter);
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

// `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ },

/***/ "./node_modules/core-js/modules/es.array.includes.js"
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.includes.js ***!
  \***********************************************************/
(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $includes = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").includes);
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

// FF99+ bug
var BROKEN_ON_SPARSE = fails(function () {
  // eslint-disable-next-line es/no-array-prototype-includes -- detection
  return !Array(1).includes();
});

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ },

/***/ "./node_modules/core-js/modules/es.array.join.js"
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.join.js ***!
  \*******************************************************/
(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js/internals/array-method-is-strict.js");

var nativeJoin = uncurryThis([].join);

var ES3_STRINGS = IndexedObject !== Object;
var FORCED = ES3_STRINGS || !arrayMethodIsStrict('join', ',');

// `Array.prototype.join` method
// https://tc39.es/ecma262/#sec-array.prototype.join
$({ target: 'Array', proto: true, forced: FORCED }, {
  join: function join(separator) {
    return nativeJoin(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ },

/***/ "./node_modules/core-js/modules/es.array.map.js"
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.map.js ***!
  \******************************************************/
(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $map = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").map);
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');

// `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ },

/***/ "./node_modules/core-js/modules/es.iterator.constructor.js"
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.iterator.constructor.js ***!
  \*****************************************************************/
(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js/internals/global-this.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js/internals/define-built-in-accessor.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var IteratorPrototype = (__webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype);
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var CONSTRUCTOR = 'constructor';
var ITERATOR = 'Iterator';
var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var $TypeError = TypeError;
var NativeIterator = globalThis[ITERATOR];

// FF56- have non-standard global helper `Iterator`
var FORCED = IS_PURE
  || !isCallable(NativeIterator)
  || NativeIterator.prototype !== IteratorPrototype
  // FF44- non-standard `Iterator` passes previous tests
  || !fails(function () { NativeIterator({}); });

var IteratorConstructor = function Iterator() {
  anInstance(this, IteratorPrototype);
  if (getPrototypeOf(this) === IteratorPrototype) throw new $TypeError('Abstract class Iterator not directly constructable');
};

var defineIteratorPrototypeAccessor = function (key, value) {
  if (DESCRIPTORS) {
    defineBuiltInAccessor(IteratorPrototype, key, {
      configurable: true,
      get: function () {
        return value;
      },
      set: function (replacement) {
        anObject(this);
        if (this === IteratorPrototype) throw new $TypeError("You can't redefine this property");
        if (hasOwn(this, key)) this[key] = replacement;
        else createProperty(this, key, replacement);
      }
    });
  } else IteratorPrototype[key] = value;
};

if (!hasOwn(IteratorPrototype, TO_STRING_TAG)) defineIteratorPrototypeAccessor(TO_STRING_TAG, ITERATOR);

if (FORCED || !hasOwn(IteratorPrototype, CONSTRUCTOR) || IteratorPrototype[CONSTRUCTOR] === Object) {
  defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);
}

IteratorConstructor.prototype = IteratorPrototype;

// `Iterator` constructor
// https://tc39.es/ecma262/#sec-iterator
$({ global: true, constructor: true, forced: FORCED }, {
  Iterator: IteratorConstructor
});


/***/ },

/***/ "./node_modules/core-js/modules/es.iterator.filter.js"
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.iterator.filter.js ***!
  \************************************************************/
(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getIteratorDirect = __webpack_require__(/*! ../internals/get-iterator-direct */ "./node_modules/core-js/internals/get-iterator-direct.js");
var createIteratorProxy = __webpack_require__(/*! ../internals/iterator-create-proxy */ "./node_modules/core-js/internals/iterator-create-proxy.js");
var callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");
var iteratorHelperThrowsOnInvalidIterator = __webpack_require__(/*! ../internals/iterator-helper-throws-on-invalid-iterator */ "./node_modules/core-js/internals/iterator-helper-throws-on-invalid-iterator.js");
var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__(/*! ../internals/iterator-helper-without-closing-on-early-error */ "./node_modules/core-js/internals/iterator-helper-without-closing-on-early-error.js");

var FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator('filter', function () { /* empty */ });
var filterWithoutClosingOnEarlyError = !IS_PURE && !FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR
  && iteratorHelperWithoutClosingOnEarlyError('filter', TypeError);

var FORCED = IS_PURE || FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR || filterWithoutClosingOnEarlyError;

var IteratorProxy = createIteratorProxy(function () {
  var iterator = this.iterator;
  var predicate = this.predicate;
  var next = this.next;
  var result, done, value;
  while (true) {
    result = anObject(call(next, iterator));
    done = this.done = !!result.done;
    if (done) return;
    value = result.value;
    if (callWithSafeIterationClosing(iterator, predicate, [value, this.counter++], true)) return value;
  }
});

// `Iterator.prototype.filter` method
// https://tc39.es/ecma262/#sec-iterator.prototype.filter
$({ target: 'Iterator', proto: true, real: true, forced: FORCED }, {
  filter: function filter(predicate) {
    anObject(this);
    try {
      aCallable(predicate);
    } catch (error) {
      iteratorClose(this, 'throw', error);
    }

    if (filterWithoutClosingOnEarlyError) return call(filterWithoutClosingOnEarlyError, this, predicate);

    return new IteratorProxy(getIteratorDirect(this), {
      predicate: predicate
    });
  }
});


/***/ },

/***/ "./node_modules/core-js/modules/es.iterator.map.js"
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.iterator.map.js ***!
  \*********************************************************/
(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getIteratorDirect = __webpack_require__(/*! ../internals/get-iterator-direct */ "./node_modules/core-js/internals/get-iterator-direct.js");
var createIteratorProxy = __webpack_require__(/*! ../internals/iterator-create-proxy */ "./node_modules/core-js/internals/iterator-create-proxy.js");
var callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");
var iteratorClose = __webpack_require__(/*! ../internals/iterator-close */ "./node_modules/core-js/internals/iterator-close.js");
var iteratorHelperThrowsOnInvalidIterator = __webpack_require__(/*! ../internals/iterator-helper-throws-on-invalid-iterator */ "./node_modules/core-js/internals/iterator-helper-throws-on-invalid-iterator.js");
var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__(/*! ../internals/iterator-helper-without-closing-on-early-error */ "./node_modules/core-js/internals/iterator-helper-without-closing-on-early-error.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator('map', function () { /* empty */ });
var mapWithoutClosingOnEarlyError = !IS_PURE && !MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR
  && iteratorHelperWithoutClosingOnEarlyError('map', TypeError);

var FORCED = IS_PURE || MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || mapWithoutClosingOnEarlyError;

var IteratorProxy = createIteratorProxy(function () {
  var iterator = this.iterator;
  var result = anObject(call(this.next, iterator));
  var done = this.done = !!result.done;
  if (!done) return callWithSafeIterationClosing(iterator, this.mapper, [result.value, this.counter++], true);
});

// `Iterator.prototype.map` method
// https://tc39.es/ecma262/#sec-iterator.prototype.map
$({ target: 'Iterator', proto: true, real: true, forced: FORCED }, {
  map: function map(mapper) {
    anObject(this);
    try {
      aCallable(mapper);
    } catch (error) {
      iteratorClose(this, 'throw', error);
    }

    if (mapWithoutClosingOnEarlyError) return call(mapWithoutClosingOnEarlyError, this, mapper);

    return new IteratorProxy(getIteratorDirect(this), {
      mapper: mapper
    });
  }
});


/***/ },

/***/ "./node_modules/core-js/modules/es.object.define-property.js"
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.define-property.js ***!
  \*******************************************************************/
(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
// eslint-disable-next-line es/no-object-defineproperty -- safe
$({ target: 'Object', stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
  defineProperty: defineProperty
});


/***/ },

/***/ "./node_modules/core-js/modules/es.object.to-string.js"
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!
  \*************************************************************/
(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
var toString = __webpack_require__(/*! ../internals/object-to-string */ "./node_modules/core-js/internals/object-to-string.js");

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  defineBuiltIn(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ },

/***/ "./node_modules/core-js/modules/es.string.includes.js"
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.includes.js ***!
  \************************************************************/
(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
var notARegExp = __webpack_require__(/*! ../internals/not-a-regexp */ "./node_modules/core-js/internals/not-a-regexp.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
var correctIsRegExpLogic = __webpack_require__(/*! ../internals/correct-is-regexp-logic */ "./node_modules/core-js/internals/correct-is-regexp-logic.js");

var stringIndexOf = uncurryThis(''.indexOf);

// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~stringIndexOf(
      toString(requireObjectCoercible(this)),
      toString(notARegExp(searchString)),
      arguments.length > 1 ? arguments[1] : undefined
    );
  }
});


/***/ },

/***/ "./node_modules/core-js/modules/esnext.iterator.constructor.js"
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.iterator.constructor.js ***!
  \*********************************************************************/
(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(/*! ../modules/es.iterator.constructor */ "./node_modules/core-js/modules/es.iterator.constructor.js");


/***/ },

/***/ "./node_modules/core-js/modules/esnext.iterator.filter.js"
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.iterator.filter.js ***!
  \****************************************************************/
(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(/*! ../modules/es.iterator.filter */ "./node_modules/core-js/modules/es.iterator.filter.js");


/***/ },

/***/ "./node_modules/core-js/modules/esnext.iterator.map.js"
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/esnext.iterator.map.js ***!
  \*************************************************************/
(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


// TODO: Remove from `core-js@4`
__webpack_require__(/*! ../modules/es.iterator.map */ "./node_modules/core-js/modules/es.iterator.map.js");


/***/ },

/***/ "./node_modules/hookable/dist/index.mjs"
/*!**********************************************!*\
  !*** ./node_modules/hookable/dist/index.mjs ***!
  \**********************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hookable: () => (/* binding */ Hookable),
/* harmony export */   createDebugger: () => (/* binding */ createDebugger),
/* harmony export */   createHooks: () => (/* binding */ createHooks),
/* harmony export */   flatHooks: () => (/* binding */ flatHooks),
/* harmony export */   mergeHooks: () => (/* binding */ mergeHooks),
/* harmony export */   parallelCaller: () => (/* binding */ parallelCaller),
/* harmony export */   serial: () => (/* binding */ serial),
/* harmony export */   serialCaller: () => (/* binding */ serialCaller)
/* harmony export */ });
function flatHooks(configHooks, hooks = {}, parentName) {
  for (const key in configHooks) {
    const subHook = configHooks[key];
    const name = parentName ? `${parentName}:${key}` : key;
    if (typeof subHook === "object" && subHook !== null) {
      flatHooks(subHook, hooks, name);
    } else if (typeof subHook === "function") {
      hooks[name] = subHook;
    }
  }
  return hooks;
}
function mergeHooks(...hooks) {
  const finalHooks = {};
  for (const hook of hooks) {
    const flatenHook = flatHooks(hook);
    for (const key in flatenHook) {
      if (finalHooks[key]) {
        finalHooks[key].push(flatenHook[key]);
      } else {
        finalHooks[key] = [flatenHook[key]];
      }
    }
  }
  for (const key in finalHooks) {
    if (finalHooks[key].length > 1) {
      const array = finalHooks[key];
      finalHooks[key] = (...arguments_) => serial(array, (function_) => function_(...arguments_));
    } else {
      finalHooks[key] = finalHooks[key][0];
    }
  }
  return finalHooks;
}
function serial(tasks, function_) {
  return tasks.reduce(
    (promise, task) => promise.then(() => function_(task)),
    Promise.resolve()
  );
}
const defaultTask = { run: (function_) => function_() };
const _createTask = () => defaultTask;
const createTask = typeof console.createTask !== "undefined" ? console.createTask : _createTask;
function serialTaskCaller(hooks, args) {
  const name = args.shift();
  const task = createTask(name);
  return hooks.reduce(
    (promise, hookFunction) => promise.then(() => task.run(() => hookFunction(...args))),
    Promise.resolve()
  );
}
function parallelTaskCaller(hooks, args) {
  const name = args.shift();
  const task = createTask(name);
  return Promise.all(hooks.map((hook) => task.run(() => hook(...args))));
}
function serialCaller(hooks, arguments_) {
  return hooks.reduce(
    (promise, hookFunction) => promise.then(() => hookFunction(...arguments_ || [])),
    Promise.resolve()
  );
}
function parallelCaller(hooks, args) {
  return Promise.all(hooks.map((hook) => hook(...args || [])));
}
function callEachWith(callbacks, arg0) {
  for (const callback of [...callbacks]) {
    callback(arg0);
  }
}

class Hookable {
  constructor() {
    this._hooks = {};
    this._before = void 0;
    this._after = void 0;
    this._deprecatedMessages = void 0;
    this._deprecatedHooks = {};
    this.hook = this.hook.bind(this);
    this.callHook = this.callHook.bind(this);
    this.callHookWith = this.callHookWith.bind(this);
  }
  hook(name, function_, options = {}) {
    if (!name || typeof function_ !== "function") {
      return () => {
      };
    }
    const originalName = name;
    let dep;
    while (this._deprecatedHooks[name]) {
      dep = this._deprecatedHooks[name];
      name = dep.to;
    }
    if (dep && !options.allowDeprecated) {
      let message = dep.message;
      if (!message) {
        message = `${originalName} hook has been deprecated` + (dep.to ? `, please use ${dep.to}` : "");
      }
      if (!this._deprecatedMessages) {
        this._deprecatedMessages = /* @__PURE__ */ new Set();
      }
      if (!this._deprecatedMessages.has(message)) {
        console.warn(message);
        this._deprecatedMessages.add(message);
      }
    }
    if (!function_.name) {
      try {
        Object.defineProperty(function_, "name", {
          get: () => "_" + name.replace(/\W+/g, "_") + "_hook_cb",
          configurable: true
        });
      } catch {
      }
    }
    this._hooks[name] = this._hooks[name] || [];
    this._hooks[name].push(function_);
    return () => {
      if (function_) {
        this.removeHook(name, function_);
        function_ = void 0;
      }
    };
  }
  hookOnce(name, function_) {
    let _unreg;
    let _function = (...arguments_) => {
      if (typeof _unreg === "function") {
        _unreg();
      }
      _unreg = void 0;
      _function = void 0;
      return function_(...arguments_);
    };
    _unreg = this.hook(name, _function);
    return _unreg;
  }
  removeHook(name, function_) {
    if (this._hooks[name]) {
      const index = this._hooks[name].indexOf(function_);
      if (index !== -1) {
        this._hooks[name].splice(index, 1);
      }
      if (this._hooks[name].length === 0) {
        delete this._hooks[name];
      }
    }
  }
  deprecateHook(name, deprecated) {
    this._deprecatedHooks[name] = typeof deprecated === "string" ? { to: deprecated } : deprecated;
    const _hooks = this._hooks[name] || [];
    delete this._hooks[name];
    for (const hook of _hooks) {
      this.hook(name, hook);
    }
  }
  deprecateHooks(deprecatedHooks) {
    Object.assign(this._deprecatedHooks, deprecatedHooks);
    for (const name in deprecatedHooks) {
      this.deprecateHook(name, deprecatedHooks[name]);
    }
  }
  addHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    const removeFns = Object.keys(hooks).map(
      (key) => this.hook(key, hooks[key])
    );
    return () => {
      for (const unreg of removeFns.splice(0, removeFns.length)) {
        unreg();
      }
    };
  }
  removeHooks(configHooks) {
    const hooks = flatHooks(configHooks);
    for (const key in hooks) {
      this.removeHook(key, hooks[key]);
    }
  }
  removeAllHooks() {
    for (const key in this._hooks) {
      delete this._hooks[key];
    }
  }
  callHook(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(serialTaskCaller, name, ...arguments_);
  }
  callHookParallel(name, ...arguments_) {
    arguments_.unshift(name);
    return this.callHookWith(parallelTaskCaller, name, ...arguments_);
  }
  callHookWith(caller, name, ...arguments_) {
    const event = this._before || this._after ? { name, args: arguments_, context: {} } : void 0;
    if (this._before) {
      callEachWith(this._before, event);
    }
    const result = caller(
      name in this._hooks ? [...this._hooks[name]] : [],
      arguments_
    );
    if (result instanceof Promise) {
      return result.finally(() => {
        if (this._after && event) {
          callEachWith(this._after, event);
        }
      });
    }
    if (this._after && event) {
      callEachWith(this._after, event);
    }
    return result;
  }
  beforeEach(function_) {
    this._before = this._before || [];
    this._before.push(function_);
    return () => {
      if (this._before !== void 0) {
        const index = this._before.indexOf(function_);
        if (index !== -1) {
          this._before.splice(index, 1);
        }
      }
    };
  }
  afterEach(function_) {
    this._after = this._after || [];
    this._after.push(function_);
    return () => {
      if (this._after !== void 0) {
        const index = this._after.indexOf(function_);
        if (index !== -1) {
          this._after.splice(index, 1);
        }
      }
    };
  }
}
function createHooks() {
  return new Hookable();
}

const isBrowser = typeof window !== "undefined";
function createDebugger(hooks, _options = {}) {
  const options = {
    inspect: isBrowser,
    group: isBrowser,
    filter: () => true,
    ..._options
  };
  const _filter = options.filter;
  const filter = typeof _filter === "string" ? (name) => name.startsWith(_filter) : _filter;
  const _tag = options.tag ? `[${options.tag}] ` : "";
  const logPrefix = (event) => _tag + event.name + "".padEnd(event._id, "\0");
  const _idCtr = {};
  const unsubscribeBefore = hooks.beforeEach((event) => {
    if (filter !== void 0 && !filter(event.name)) {
      return;
    }
    _idCtr[event.name] = _idCtr[event.name] || 0;
    event._id = _idCtr[event.name]++;
    console.time(logPrefix(event));
  });
  const unsubscribeAfter = hooks.afterEach((event) => {
    if (filter !== void 0 && !filter(event.name)) {
      return;
    }
    if (options.group) {
      console.groupCollapsed(event.name);
    }
    if (options.inspect) {
      console.timeLog(logPrefix(event), event.args);
    } else {
      console.timeEnd(logPrefix(event));
    }
    if (options.group) {
      console.groupEnd();
    }
    _idCtr[event.name]--;
  });
  return {
    /** Stop debugging and remove listeners */
    close: () => {
      unsubscribeBefore();
      unsubscribeAfter();
    }
  };
}




/***/ },

/***/ "./node_modules/perfect-debounce/dist/index.mjs"
/*!******************************************************!*\
  !*** ./node_modules/perfect-debounce/dist/index.mjs ***!
  \******************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   debounce: () => (/* binding */ debounce)
/* harmony export */ });
const DEBOUNCE_DEFAULTS = {
  trailing: true
};
function debounce(fn, wait = 25, options = {}) {
  options = { ...DEBOUNCE_DEFAULTS, ...options };
  if (!Number.isFinite(wait)) {
    throw new TypeError("Expected `wait` to be a finite number");
  }
  let leadingValue;
  let timeout;
  let resolveList = [];
  let currentPromise;
  let trailingArgs;
  const applyFn = (_this, args) => {
    currentPromise = _applyPromised(fn, _this, args);
    currentPromise.finally(() => {
      currentPromise = null;
      if (options.trailing && trailingArgs && !timeout) {
        const promise = applyFn(_this, trailingArgs);
        trailingArgs = null;
        return promise;
      }
    });
    return currentPromise;
  };
  return function(...args) {
    if (currentPromise) {
      if (options.trailing) {
        trailingArgs = args;
      }
      return currentPromise;
    }
    return new Promise((resolve) => {
      const shouldCallNow = !timeout && options.leading;
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        timeout = null;
        const promise = options.leading ? leadingValue : applyFn(this, args);
        for (const _resolve of resolveList) {
          _resolve(promise);
        }
        resolveList = [];
      }, wait);
      if (shouldCallNow) {
        leadingValue = applyFn(this, args);
        resolve(leadingValue);
      } else {
        resolveList.push(resolve);
      }
    });
  };
}
async function _applyPromised(fn, _this, args) {
  return await fn.apply(_this, args);
}




/***/ },

/***/ "./node_modules/pinia/dist/pinia.mjs"
/*!*******************************************!*\
  !*** ./node_modules/pinia/dist/pinia.mjs ***!
  \*******************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MutationType: () => (/* binding */ MutationType),
/* harmony export */   acceptHMRUpdate: () => (/* binding */ acceptHMRUpdate),
/* harmony export */   createPinia: () => (/* binding */ createPinia),
/* harmony export */   defineStore: () => (/* binding */ defineStore),
/* harmony export */   disposePinia: () => (/* binding */ disposePinia),
/* harmony export */   getActivePinia: () => (/* binding */ getActivePinia),
/* harmony export */   mapActions: () => (/* binding */ mapActions),
/* harmony export */   mapGetters: () => (/* binding */ mapGetters),
/* harmony export */   mapState: () => (/* binding */ mapState),
/* harmony export */   mapStores: () => (/* binding */ mapStores),
/* harmony export */   mapWritableState: () => (/* binding */ mapWritableState),
/* harmony export */   setActivePinia: () => (/* binding */ setActivePinia),
/* harmony export */   setMapStoreSuffix: () => (/* binding */ setMapStoreSuffix),
/* harmony export */   shouldHydrate: () => (/* binding */ shouldHydrate),
/* harmony export */   skipHydrate: () => (/* binding */ skipHydrate),
/* harmony export */   storeToRefs: () => (/* binding */ storeToRefs)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
/* harmony import */ var _vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/devtools-api */ "./node_modules/@vue/devtools-kit/dist/index.js");
/*!
 * pinia v3.0.4
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */



const IS_CLIENT = typeof window !== 'undefined';

/**
 * setActivePinia must be called to handle SSR at the top of functions like
 * `fetch`, `setup`, `serverPrefetch` and others
 */
let activePinia;
/**
 * Sets or unsets the active pinia. Used in SSR and internally when calling
 * actions and getters
 *
 * @param pinia - Pinia instance
 */
// @ts-expect-error: cannot constrain the type of the return
const setActivePinia = (pinia) => (activePinia = pinia);
/**
 * Get the currently active pinia if there is any.
 */
const getActivePinia = ( true)
    ? () => {
        const pinia = (0,vue__WEBPACK_IMPORTED_MODULE_0__.hasInjectionContext)() && (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(piniaSymbol);
        if (!pinia && !IS_CLIENT) {
            console.error(`[]: Pinia instance not found in context. This falls back to the global activePinia which exposes you to cross-request pollution on the server. Most of the time, it means you are calling "useStore()" in the wrong place.\n` +
                `Read https://vuejs.org/guide/reusability/composables.html to learn more`);
        }
        return pinia || activePinia;
    }
    : 0;
const piniaSymbol = (( true) ? Symbol('pinia') : /* istanbul ignore next */ 0);

function isPlainObject(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
o) {
    return (o &&
        typeof o === 'object' &&
        Object.prototype.toString.call(o) === '[object Object]' &&
        typeof o.toJSON !== 'function');
}
// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }
// TODO: can we change these to numbers?
/**
 * Possible types for SubscriptionCallback
 */
var MutationType;
(function (MutationType) {
    /**
     * Direct mutation of the state:
     *
     * - `store.name = 'new name'`
     * - `store.$state.name = 'new name'`
     * - `store.list.push('new item')`
     */
    MutationType["direct"] = "direct";
    /**
     * Mutated the state with `$patch` and an object
     *
     * - `store.$patch({ name: 'newName' })`
     */
    MutationType["patchObject"] = "patch object";
    /**
     * Mutated the state with `$patch` and a function
     *
     * - `store.$patch(state => state.name = 'newName')`
     */
    MutationType["patchFunction"] = "patch function";
    // maybe reset? for $state = {} and $reset
})(MutationType || (MutationType = {}));

/*
 * FileSaver.js A saveAs() FileSaver implementation.
 *
 * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin
 * Morote.
 *
 * License : MIT
 */
// The one and only way of getting global scope in all environments
// https://stackoverflow.com/q/3277182/1008999
const _global = /*#__PURE__*/ (() => typeof window === 'object' && window.window === window
    ? window
    : typeof self === 'object' && self.self === self
        ? self
        : typeof __webpack_require__.g === 'object' && __webpack_require__.g.global === __webpack_require__.g
            ? __webpack_require__.g
            : typeof globalThis === 'object'
                ? globalThis
                : { HTMLElement: null })();
function bom(blob, { autoBom = false } = {}) {
    // prepend BOM for UTF-8 XML and text/* types (including HTML)
    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
    if (autoBom &&
        /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
        return new Blob([String.fromCharCode(0xfeff), blob], { type: blob.type });
    }
    return blob;
}
function download(url, name, opts) {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.responseType = 'blob';
    xhr.onload = function () {
        saveAs(xhr.response, name, opts);
    };
    xhr.onerror = function () {
        console.error('could not download file');
    };
    xhr.send();
}
function corsEnabled(url) {
    const xhr = new XMLHttpRequest();
    // use sync to avoid popup blocker
    xhr.open('HEAD', url, false);
    try {
        xhr.send();
    }
    catch (e) { }
    return xhr.status >= 200 && xhr.status <= 299;
}
// `a.click()` doesn't work for all browsers (#465)
function click(node) {
    try {
        node.dispatchEvent(new MouseEvent('click'));
    }
    catch (e) {
        const evt = new MouseEvent('click', {
            bubbles: true,
            cancelable: true,
            view: window,
            detail: 0,
            screenX: 80,
            screenY: 20,
            clientX: 80,
            clientY: 20,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            button: 0,
            relatedTarget: null,
        });
        node.dispatchEvent(evt);
    }
}
const _navigator = typeof navigator === 'object' ? navigator : { userAgent: '' };
// Detect WebView inside a native macOS app by ruling out all browsers
// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too
// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos
const isMacOSWebView = /*#__PURE__*/ (() => /Macintosh/.test(_navigator.userAgent) &&
    /AppleWebKit/.test(_navigator.userAgent) &&
    !/Safari/.test(_navigator.userAgent))();
const saveAs = !IS_CLIENT
    ? () => { } // noop
    : // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
        typeof HTMLAnchorElement !== 'undefined' &&
            'download' in HTMLAnchorElement.prototype &&
            !isMacOSWebView
            ? downloadSaveAs
            : // Use msSaveOrOpenBlob as a second approach
                'msSaveOrOpenBlob' in _navigator
                    ? msSaveAs
                    : // Fallback to using FileReader and a popup
                        fileSaverSaveAs;
function downloadSaveAs(blob, name = 'download', opts) {
    const a = document.createElement('a');
    a.download = name;
    a.rel = 'noopener'; // tabnabbing
    // TODO: detect chrome extensions & packaged apps
    // a.target = '_blank'
    if (typeof blob === 'string') {
        // Support regular links
        a.href = blob;
        if (a.origin !== location.origin) {
            if (corsEnabled(a.href)) {
                download(blob, name, opts);
            }
            else {
                a.target = '_blank';
                click(a);
            }
        }
        else {
            click(a);
        }
    }
    else {
        // Support blobs
        a.href = URL.createObjectURL(blob);
        setTimeout(function () {
            URL.revokeObjectURL(a.href);
        }, 4e4); // 40s
        setTimeout(function () {
            click(a);
        }, 0);
    }
}
function msSaveAs(blob, name = 'download', opts) {
    if (typeof blob === 'string') {
        if (corsEnabled(blob)) {
            download(blob, name, opts);
        }
        else {
            const a = document.createElement('a');
            a.href = blob;
            a.target = '_blank';
            setTimeout(function () {
                click(a);
            });
        }
    }
    else {
        // @ts-ignore: works on windows
        navigator.msSaveOrOpenBlob(bom(blob, opts), name);
    }
}
function fileSaverSaveAs(blob, name, opts, popup) {
    // Open a popup immediately do go around popup blocker
    // Mostly only available on user interaction and the fileReader is async so...
    popup = popup || open('', '_blank');
    if (popup) {
        popup.document.title = popup.document.body.innerText = 'downloading...';
    }
    if (typeof blob === 'string')
        return download(blob, name, opts);
    const force = blob.type === 'application/octet-stream';
    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || 'safari' in _global;
    const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) &&
        typeof FileReader !== 'undefined') {
        // Safari doesn't allow downloading of blob URLs
        const reader = new FileReader();
        reader.onloadend = function () {
            let url = reader.result;
            if (typeof url !== 'string') {
                popup = null;
                throw new Error('Wrong reader.result type');
            }
            url = isChromeIOS
                ? url
                : url.replace(/^data:[^;]*;/, 'data:attachment/file;');
            if (popup) {
                popup.location.href = url;
            }
            else {
                location.assign(url);
            }
            popup = null; // reverse-tabnabbing #460
        };
        reader.readAsDataURL(blob);
    }
    else {
        const url = URL.createObjectURL(blob);
        if (popup)
            popup.location.assign(url);
        else
            location.href = url;
        popup = null; // reverse-tabnabbing #460
        setTimeout(function () {
            URL.revokeObjectURL(url);
        }, 4e4); // 40s
    }
}

/**
 * Shows a toast or console.log
 *
 * @param message - message to log
 * @param type - different color of the tooltip
 */
function toastMessage(message, type) {
    const piniaMessage = ' ' + message;
    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {
        // No longer available :(
        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
    }
    else if (type === 'error') {
        console.error(piniaMessage);
    }
    else if (type === 'warn') {
        console.warn(piniaMessage);
    }
    else {
        console.log(piniaMessage);
    }
}
function isPinia(o) {
    return '_a' in o && 'install' in o;
}

/**
 * This file contain devtools actions, they are not Pinia actions.
 */
// ---
function checkClipboardAccess() {
    if (!('clipboard' in navigator)) {
        toastMessage(`Your browser doesn't support the Clipboard API`, 'error');
        return true;
    }
}
function checkNotFocusedError(error) {
    if (error instanceof Error &&
        error.message.toLowerCase().includes('document is not focused')) {
        toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', 'warn');
        return true;
    }
    return false;
}
async function actionGlobalCopyState(pinia) {
    if (checkClipboardAccess())
        return;
    try {
        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));
        toastMessage('Global state copied to clipboard.');
    }
    catch (error) {
        if (checkNotFocusedError(error))
            return;
        toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');
        console.error(error);
    }
}
async function actionGlobalPasteState(pinia) {
    if (checkClipboardAccess())
        return;
    try {
        loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));
        toastMessage('Global state pasted from clipboard.');
    }
    catch (error) {
        if (checkNotFocusedError(error))
            return;
        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');
        console.error(error);
    }
}
async function actionGlobalSaveState(pinia) {
    try {
        saveAs(new Blob([JSON.stringify(pinia.state.value)], {
            type: 'text/plain;charset=utf-8',
        }), 'pinia-state.json');
    }
    catch (error) {
        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');
        console.error(error);
    }
}
let fileInput;
function getFileOpener() {
    if (!fileInput) {
        fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json';
    }
    function openFile() {
        return new Promise((resolve, reject) => {
            fileInput.onchange = async () => {
                const files = fileInput.files;
                if (!files)
                    return resolve(null);
                const file = files.item(0);
                if (!file)
                    return resolve(null);
                return resolve({ text: await file.text(), file });
            };
            // @ts-ignore: TODO: changed from 4.3 to 4.4
            fileInput.oncancel = () => resolve(null);
            fileInput.onerror = reject;
            fileInput.click();
        });
    }
    return openFile;
}
async function actionGlobalOpenStateFile(pinia) {
    try {
        const open = getFileOpener();
        const result = await open();
        if (!result)
            return;
        const { text, file } = result;
        loadStoresState(pinia, JSON.parse(text));
        toastMessage(`Global state imported from "${file.name}".`);
    }
    catch (error) {
        toastMessage(`Failed to import the state from JSON. Check the console for more details.`, 'error');
        console.error(error);
    }
}
function loadStoresState(pinia, state) {
    for (const key in state) {
        const storeState = pinia.state.value[key];
        // store is already instantiated, patch it
        if (storeState) {
            Object.assign(storeState, state[key]);
        }
        else {
            // store is not instantiated, set the initial state
            pinia.state.value[key] = state[key];
        }
    }
}

function formatDisplay(display) {
    return {
        _custom: {
            display,
        },
    };
}
const PINIA_ROOT_LABEL = ' Pinia (root)';
const PINIA_ROOT_ID = '_root';
function formatStoreForInspectorTree(store) {
    return isPinia(store)
        ? {
            id: PINIA_ROOT_ID,
            label: PINIA_ROOT_LABEL,
        }
        : {
            id: store.$id,
            label: store.$id,
        };
}
function formatStoreForInspectorState(store) {
    if (isPinia(store)) {
        const storeNames = Array.from(store._s.keys());
        const storeMap = store._s;
        const state = {
            state: storeNames.map((storeId) => ({
                editable: true,
                key: storeId,
                value: store.state.value[storeId],
            })),
            getters: storeNames
                .filter((id) => storeMap.get(id)._getters)
                .map((id) => {
                const store = storeMap.get(id);
                return {
                    editable: false,
                    key: id,
                    value: store._getters.reduce((getters, key) => {
                        getters[key] = store[key];
                        return getters;
                    }, {}),
                };
            }),
        };
        return state;
    }
    const state = {
        state: Object.keys(store.$state).map((key) => ({
            editable: true,
            key,
            value: store.$state[key],
        })),
    };
    // avoid adding empty getters
    if (store._getters && store._getters.length) {
        state.getters = store._getters.map((getterName) => ({
            editable: false,
            key: getterName,
            value: store[getterName],
        }));
    }
    if (store._customProperties.size) {
        state.customProperties = Array.from(store._customProperties).map((key) => ({
            editable: true,
            key,
            value: store[key],
        }));
    }
    return state;
}
function formatEventData(events) {
    if (!events)
        return {};
    if (Array.isArray(events)) {
        // TODO: handle add and delete for arrays and objects
        return events.reduce((data, event) => {
            data.keys.push(event.key);
            data.operations.push(event.type);
            data.oldValue[event.key] = event.oldValue;
            data.newValue[event.key] = event.newValue;
            return data;
        }, {
            oldValue: {},
            keys: [],
            operations: [],
            newValue: {},
        });
    }
    else {
        return {
            operation: formatDisplay(events.type),
            key: formatDisplay(events.key),
            oldValue: events.oldValue,
            newValue: events.newValue,
        };
    }
}
function formatMutationType(type) {
    switch (type) {
        case MutationType.direct:
            return 'mutation';
        case MutationType.patchFunction:
            return '$patch';
        case MutationType.patchObject:
            return '$patch';
        default:
            return 'unknown';
    }
}

// timeline can be paused when directly changing the state
let isTimelineActive = true;
const componentStateTypes = [];
const MUTATIONS_LAYER_ID = 'pinia:mutations';
const INSPECTOR_ID = 'pinia';
const { assign: assign$1 } = Object;
/**
 * Gets the displayed name of a store in devtools
 *
 * @param id - id of the store
 * @returns a formatted string
 */
const getStoreType = (id) => ' ' + id;
/**
 * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab
 * as soon as it is added to the application.
 *
 * @param app - Vue application
 * @param pinia - pinia instance
 */
function registerPiniaDevtools(app, pinia) {
    (0,_vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__.setupDevToolsPlugin)({
        id: 'dev.esm.pinia',
        label: 'Pinia ',
        logo: 'https://pinia.vuejs.org/logo.svg',
        packageName: 'pinia',
        homepage: 'https://pinia.vuejs.org',
        componentStateTypes,
        app,
    }, (api) => {
        if (typeof api.now !== 'function') {
            toastMessage('You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');
        }
        api.addTimelineLayer({
            id: MUTATIONS_LAYER_ID,
            label: `Pinia `,
            color: 0xe5df88,
        });
        api.addInspector({
            id: INSPECTOR_ID,
            label: 'Pinia ',
            icon: 'storage',
            treeFilterPlaceholder: 'Search stores',
            actions: [
                {
                    icon: 'content_copy',
                    action: () => {
                        actionGlobalCopyState(pinia);
                    },
                    tooltip: 'Serialize and copy the state',
                },
                {
                    icon: 'content_paste',
                    action: async () => {
                        await actionGlobalPasteState(pinia);
                        api.sendInspectorTree(INSPECTOR_ID);
                        api.sendInspectorState(INSPECTOR_ID);
                    },
                    tooltip: 'Replace the state with the content of your clipboard',
                },
                {
                    icon: 'save',
                    action: () => {
                        actionGlobalSaveState(pinia);
                    },
                    tooltip: 'Save the state as a JSON file',
                },
                {
                    icon: 'folder_open',
                    action: async () => {
                        await actionGlobalOpenStateFile(pinia);
                        api.sendInspectorTree(INSPECTOR_ID);
                        api.sendInspectorState(INSPECTOR_ID);
                    },
                    tooltip: 'Import the state from a JSON file',
                },
            ],
            nodeActions: [
                {
                    icon: 'restore',
                    tooltip: 'Reset the state (with "$reset")',
                    action: (nodeId) => {
                        const store = pinia._s.get(nodeId);
                        if (!store) {
                            toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, 'warn');
                        }
                        else if (typeof store.$reset !== 'function') {
                            toastMessage(`Cannot reset "${nodeId}" store because it doesn't have a "$reset" method implemented.`, 'warn');
                        }
                        else {
                            store.$reset();
                            toastMessage(`Store "${nodeId}" reset.`);
                        }
                    },
                },
            ],
        });
        api.on.inspectComponent((payload) => {
            const proxy = (payload.componentInstance &&
                payload.componentInstance.proxy);
            if (proxy && proxy._pStores) {
                const piniaStores = payload.componentInstance.proxy._pStores;
                Object.values(piniaStores).forEach((store) => {
                    payload.instanceData.state.push({
                        type: getStoreType(store.$id),
                        key: 'state',
                        editable: true,
                        value: store._isOptionsAPI
                            ? {
                                _custom: {
                                    value: (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRaw)(store.$state),
                                    actions: [
                                        {
                                            icon: 'restore',
                                            tooltip: 'Reset the state of this store',
                                            action: () => store.$reset(),
                                        },
                                    ],
                                },
                            }
                            : // NOTE: workaround to unwrap transferred refs
                                Object.keys(store.$state).reduce((state, key) => {
                                    state[key] = store.$state[key];
                                    return state;
                                }, {}),
                    });
                    if (store._getters && store._getters.length) {
                        payload.instanceData.state.push({
                            type: getStoreType(store.$id),
                            key: 'getters',
                            editable: false,
                            value: store._getters.reduce((getters, key) => {
                                try {
                                    getters[key] = store[key];
                                }
                                catch (error) {
                                    // @ts-expect-error: we just want to show it in devtools
                                    getters[key] = error;
                                }
                                return getters;
                            }, {}),
                        });
                    }
                });
            }
        });
        api.on.getInspectorTree((payload) => {
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
                let stores = [pinia];
                stores = stores.concat(Array.from(pinia._s.values()));
                payload.rootNodes = (payload.filter
                    ? stores.filter((store) => '$id' in store
                        ? store.$id
                            .toLowerCase()
                            .includes(payload.filter.toLowerCase())
                        : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase()))
                    : stores).map(formatStoreForInspectorTree);
            }
        });
        // Expose pinia instance as $pinia to window
        globalThis.$pinia = pinia;
        api.on.getInspectorState((payload) => {
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
                const inspectedStore = payload.nodeId === PINIA_ROOT_ID
                    ? pinia
                    : pinia._s.get(payload.nodeId);
                if (!inspectedStore) {
                    // this could be the selected store restored for a different project
                    // so it's better not to say anything here
                    return;
                }
                if (inspectedStore) {
                    // Expose selected store as $store to window
                    if (payload.nodeId !== PINIA_ROOT_ID)
                        globalThis.$store = (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRaw)(inspectedStore);
                    payload.state = formatStoreForInspectorState(inspectedStore);
                }
            }
        });
        api.on.editInspectorState((payload) => {
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
                const inspectedStore = payload.nodeId === PINIA_ROOT_ID
                    ? pinia
                    : pinia._s.get(payload.nodeId);
                if (!inspectedStore) {
                    return toastMessage(`store "${payload.nodeId}" not found`, 'error');
                }
                const { path } = payload;
                if (!isPinia(inspectedStore)) {
                    // access only the state
                    if (path.length !== 1 ||
                        !inspectedStore._customProperties.has(path[0]) ||
                        path[0] in inspectedStore.$state) {
                        path.unshift('$state');
                    }
                }
                else {
                    // Root access, we can omit the `.value` because the devtools API does it for us
                    path.unshift('state');
                }
                isTimelineActive = false;
                payload.set(inspectedStore, path, payload.state.value);
                isTimelineActive = true;
            }
        });
        api.on.editComponentState((payload) => {
            if (payload.type.startsWith('')) {
                const storeId = payload.type.replace(/^\s*/, '');
                const store = pinia._s.get(storeId);
                if (!store) {
                    return toastMessage(`store "${storeId}" not found`, 'error');
                }
                const { path } = payload;
                if (path[0] !== 'state') {
                    return toastMessage(`Invalid path for store "${storeId}":\n${path}\nOnly state can be modified.`);
                }
                // rewrite the first entry to be able to directly set the state as
                // well as any other path
                path[0] = '$state';
                isTimelineActive = false;
                payload.set(store, path, payload.state.value);
                isTimelineActive = true;
            }
        });
    });
}
function addStoreToDevtools(app, store) {
    if (!componentStateTypes.includes(getStoreType(store.$id))) {
        componentStateTypes.push(getStoreType(store.$id));
    }
    (0,_vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__.setupDevToolsPlugin)({
        id: 'dev.esm.pinia',
        label: 'Pinia ',
        logo: 'https://pinia.vuejs.org/logo.svg',
        packageName: 'pinia',
        homepage: 'https://pinia.vuejs.org',
        componentStateTypes,
        app,
        settings: {
            logStoreChanges: {
                label: 'Notify about new/deleted stores',
                type: 'boolean',
                defaultValue: true,
            },
            // useEmojis: {
            //   label: 'Use emojis in messages ',
            //   type: 'boolean',
            //   defaultValue: true,
            // },
        },
    }, (api) => {
        // gracefully handle errors
        const now = typeof api.now === 'function' ? api.now.bind(api) : Date.now;
        store.$onAction(({ after, onError, name, args }) => {
            const groupId = runningActionId++;
            api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: {
                    time: now(),
                    title: ' ' + name,
                    subtitle: 'start',
                    data: {
                        store: formatDisplay(store.$id),
                        action: formatDisplay(name),
                        args,
                    },
                    groupId,
                },
            });
            after((result) => {
                activeAction = undefined;
                api.addTimelineEvent({
                    layerId: MUTATIONS_LAYER_ID,
                    event: {
                        time: now(),
                        title: ' ' + name,
                        subtitle: 'end',
                        data: {
                            store: formatDisplay(store.$id),
                            action: formatDisplay(name),
                            args,
                            result,
                        },
                        groupId,
                    },
                });
            });
            onError((error) => {
                activeAction = undefined;
                api.addTimelineEvent({
                    layerId: MUTATIONS_LAYER_ID,
                    event: {
                        time: now(),
                        logType: 'error',
                        title: ' ' + name,
                        subtitle: 'end',
                        data: {
                            store: formatDisplay(store.$id),
                            action: formatDisplay(name),
                            args,
                            error,
                        },
                        groupId,
                    },
                });
            });
        }, true);
        store._customProperties.forEach((name) => {
            (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => (0,vue__WEBPACK_IMPORTED_MODULE_0__.unref)(store[name]), (newValue, oldValue) => {
                api.notifyComponentUpdate();
                api.sendInspectorState(INSPECTOR_ID);
                if (isTimelineActive) {
                    api.addTimelineEvent({
                        layerId: MUTATIONS_LAYER_ID,
                        event: {
                            time: now(),
                            title: 'Change',
                            subtitle: name,
                            data: {
                                newValue,
                                oldValue,
                            },
                            groupId: activeAction,
                        },
                    });
                }
            }, { deep: true });
        });
        store.$subscribe(({ events, type }, state) => {
            api.notifyComponentUpdate();
            api.sendInspectorState(INSPECTOR_ID);
            if (!isTimelineActive)
                return;
            // rootStore.state[store.id] = state
            const eventData = {
                time: now(),
                title: formatMutationType(type),
                data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),
                groupId: activeAction,
            };
            if (type === MutationType.patchFunction) {
                eventData.subtitle = '';
            }
            else if (type === MutationType.patchObject) {
                eventData.subtitle = '';
            }
            else if (events && !Array.isArray(events)) {
                eventData.subtitle = events.type;
            }
            if (events) {
                eventData.data['rawEvent(s)'] = {
                    _custom: {
                        display: 'DebuggerEvent',
                        type: 'object',
                        tooltip: 'raw DebuggerEvent[]',
                        value: events,
                    },
                };
            }
            api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: eventData,
            });
        }, { detached: true, flush: 'sync' });
        const hotUpdate = store._hotUpdate;
        store._hotUpdate = (0,vue__WEBPACK_IMPORTED_MODULE_0__.markRaw)((newStore) => {
            hotUpdate(newStore);
            api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: {
                    time: now(),
                    title: ' ' + store.$id,
                    subtitle: 'HMR update',
                    data: {
                        store: formatDisplay(store.$id),
                        info: formatDisplay(`HMR update`),
                    },
                },
            });
            // update the devtools too
            api.notifyComponentUpdate();
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
        });
        const { $dispose } = store;
        store.$dispose = () => {
            $dispose();
            api.notifyComponentUpdate();
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
            api.getSettings().logStoreChanges &&
                toastMessage(`Disposed "${store.$id}" store `);
        };
        // trigger an update so it can display new registered stores
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
        api.getSettings().logStoreChanges &&
            toastMessage(`"${store.$id}" store installed `);
    });
}
let runningActionId = 0;
let activeAction;
/**
 * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the
 * context of all actions, allowing us to set `runningAction` on each access and effectively associating any state
 * mutation to the action.
 *
 * @param store - store to patch
 * @param actionNames - list of actionst to patch
 */
function patchActionForGrouping(store, actionNames, wrapWithProxy) {
    // original actions of the store as they are given by pinia. We are going to override them
    const actions = actionNames.reduce((storeActions, actionName) => {
        // use toRaw to avoid tracking #541
        storeActions[actionName] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRaw)(store)[actionName];
        return storeActions;
    }, {});
    for (const actionName in actions) {
        store[actionName] = function () {
            // the running action id is incremented in a before action hook
            const _actionId = runningActionId;
            const trackedStore = wrapWithProxy
                ? new Proxy(store, {
                    get(...args) {
                        activeAction = _actionId;
                        return Reflect.get(...args);
                    },
                    set(...args) {
                        activeAction = _actionId;
                        return Reflect.set(...args);
                    },
                })
                : store;
            // For Setup Stores we need https://github.com/tc39/proposal-async-context
            activeAction = _actionId;
            const retValue = actions[actionName].apply(trackedStore, arguments);
            // this is safer as async actions in Setup Stores would associate mutations done outside of the action
            activeAction = undefined;
            return retValue;
        };
    }
}
/**
 * pinia.use(devtoolsPlugin)
 */
function devtoolsPlugin({ app, store, options }) {
    // HMR module
    if (store.$id.startsWith('__hot:')) {
        return;
    }
    // detect option api vs setup api
    store._isOptionsAPI = !!options.state;
    // Do not overwrite actions mocked by @pinia/testing (#2298)
    if (!store._p._testing) {
        patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);
        // Upgrade the HMR to also update the new actions
        const originalHotUpdate = store._hotUpdate;
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRaw)(store)._hotUpdate = function (newStore) {
            originalHotUpdate.apply(this, arguments);
            patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);
        };
    }
    addStoreToDevtools(app, 
    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
    store);
}

/**
 * Creates a Pinia instance to be used by the application
 */
function createPinia() {
    const scope = (0,vue__WEBPACK_IMPORTED_MODULE_0__.effectScope)(true);
    // NOTE: here we could check the window object for a state and directly set it
    // if there is anything like it with Vue 3 SSR
    const state = scope.run(() => (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({}));
    let _p = [];
    // plugins added before calling app.use(pinia)
    let toBeInstalled = [];
    const pinia = (0,vue__WEBPACK_IMPORTED_MODULE_0__.markRaw)({
        install(app) {
            // this allows calling useStore() outside of a component setup after
            // installing pinia's plugin
            setActivePinia(pinia);
            pinia._a = app;
            app.provide(piniaSymbol, pinia);
            app.config.globalProperties.$pinia = pinia;
            /* istanbul ignore else */
            if (( true) && IS_CLIENT) {
                registerPiniaDevtools(app, pinia);
            }
            toBeInstalled.forEach((plugin) => _p.push(plugin));
            toBeInstalled = [];
        },
        use(plugin) {
            if (!this._a) {
                toBeInstalled.push(plugin);
            }
            else {
                _p.push(plugin);
            }
            return this;
        },
        _p,
        // it's actually undefined here
        // @ts-expect-error
        _a: null,
        _e: scope,
        _s: new Map(),
        state,
    });
    // pinia devtools rely on dev only features so they cannot be forced unless
    // the dev build of Vue is used. Avoid old browsers like IE11.
    if (( true) && IS_CLIENT && typeof Proxy !== 'undefined') {
        pinia.use(devtoolsPlugin);
    }
    return pinia;
}
/**
 * Dispose a Pinia instance by stopping its effectScope and removing the state, plugins and stores. This is mostly
 * useful in tests, with both a testing pinia or a regular pinia and in applications that use multiple pinia instances.
 * Once disposed, the pinia instance cannot be used anymore.
 *
 * @param pinia - pinia instance
 */
function disposePinia(pinia) {
    pinia._e.stop();
    pinia._s.clear();
    pinia._p.splice(0);
    pinia.state.value = {};
    // @ts-expect-error: non valid
    pinia._a = null;
}

/**
 * Checks if a function is a `StoreDefinition`.
 *
 * @param fn - object to test
 * @returns true if `fn` is a StoreDefinition
 */
const isUseStore = (fn) => {
    return typeof fn === 'function' && typeof fn.$id === 'string';
};
/**
 * Mutates in place `newState` with `oldState` to _hot update_ it. It will
 * remove any key not existing in `newState` and recursively merge plain
 * objects.
 *
 * @param newState - new state object to be patched
 * @param oldState - old state that should be used to patch newState
 * @returns - newState
 */
function patchObject(newState, oldState) {
    // no need to go through symbols because they cannot be serialized anyway
    for (const key in oldState) {
        const subPatch = oldState[key];
        // skip the whole sub tree
        if (!(key in newState)) {
            continue;
        }
        const targetValue = newState[key];
        if (isPlainObject(targetValue) &&
            isPlainObject(subPatch) &&
            !(0,vue__WEBPACK_IMPORTED_MODULE_0__.isRef)(subPatch) &&
            !(0,vue__WEBPACK_IMPORTED_MODULE_0__.isReactive)(subPatch)) {
            newState[key] = patchObject(targetValue, subPatch);
        }
        else {
            // objects are either a bit more complex (e.g. refs) or primitives, so we
            // just set the whole thing
            newState[key] = subPatch;
        }
    }
    return newState;
}
/**
 * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.
 *
 * @example
 * ```js
 * const useUser = defineStore(...)
 * if (import.meta.hot) {
 *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))
 * }
 * ```
 *
 * @param initialUseStore - return of the defineStore to hot update
 * @param hot - `import.meta.hot`
 */
function acceptHMRUpdate(initialUseStore, hot) {
    // strip as much as possible from iife.prod
    if (false) // removed by dead control flow
{}
    return (newModule) => {
        const pinia = hot.data.pinia || initialUseStore._pinia;
        if (!pinia) {
            // this store is still not used
            return;
        }
        // preserve the pinia instance across loads
        hot.data.pinia = pinia;
        // console.log('got data', newStore)
        for (const exportName in newModule) {
            const useStore = newModule[exportName];
            // console.log('checking for', exportName)
            if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {
                // console.log('Accepting update for', useStore.$id)
                const id = useStore.$id;
                if (id !== initialUseStore.$id) {
                    console.warn(`The id of the store changed from "${initialUseStore.$id}" to "${id}". Reloading.`);
                    // return import.meta.hot.invalidate()
                    return hot.invalidate();
                }
                const existingStore = pinia._s.get(id);
                if (!existingStore) {
                    console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);
                    return;
                }
                useStore(pinia, existingStore);
            }
        }
    };
}

const noop = () => { };
function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
    subscriptions.add(callback);
    const removeSubscription = () => {
        const isDel = subscriptions.delete(callback);
        isDel && onCleanup();
    };
    if (!detached && (0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)()) {
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose)(removeSubscription);
    }
    return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.forEach((callback) => {
        callback(...args);
    });
}

const fallbackRunWithContext = (fn) => fn();
/**
 * Marks a function as an action for `$onAction`
 * @internal
 */
const ACTION_MARKER = Symbol();
/**
 * Action name symbol. Allows to add a name to an action after defining it
 * @internal
 */
const ACTION_NAME = Symbol();
function mergeReactiveObjects(target, patchToApply) {
    // Handle Map instances
    if (target instanceof Map && patchToApply instanceof Map) {
        patchToApply.forEach((value, key) => target.set(key, value));
    }
    else if (target instanceof Set && patchToApply instanceof Set) {
        // Handle Set instances
        patchToApply.forEach(target.add, target);
    }
    // no need to go through symbols because they cannot be serialized anyway
    for (const key in patchToApply) {
        if (!patchToApply.hasOwnProperty(key))
            continue;
        const subPatch = patchToApply[key];
        const targetValue = target[key];
        if (isPlainObject(targetValue) &&
            isPlainObject(subPatch) &&
            target.hasOwnProperty(key) &&
            !(0,vue__WEBPACK_IMPORTED_MODULE_0__.isRef)(subPatch) &&
            !(0,vue__WEBPACK_IMPORTED_MODULE_0__.isReactive)(subPatch)) {
            // NOTE: here I wanted to warn about inconsistent types but it's not possible because in setup stores one might
            // start the value of a property as a certain type e.g. a Map, and then for some reason, during SSR, change that
            // to `undefined`. When trying to hydrate, we want to override the Map with `undefined`.
            target[key] = mergeReactiveObjects(targetValue, subPatch);
        }
        else {
            // @ts-expect-error: subPatch is a valid value
            target[key] = subPatch;
        }
    }
    return target;
}
const skipHydrateSymbol = ( true)
    ? Symbol('pinia:skipHydration')
    : /* istanbul ignore next */ 0;
/**
 * Tells Pinia to skip the hydration process of a given object. This is useful in setup stores (only) when you return a
 * stateful object in the store but it isn't really state. e.g. returning a router instance in a setup store.
 *
 * @param obj - target object
 * @returns obj
 */
function skipHydrate(obj) {
    return Object.defineProperty(obj, skipHydrateSymbol, {});
}
/**
 * Returns whether a value should be hydrated
 *
 * @param obj - target variable
 * @returns true if `obj` should be hydrated
 */
function shouldHydrate(obj) {
    return (!isPlainObject(obj) ||
        !Object.prototype.hasOwnProperty.call(obj, skipHydrateSymbol));
}
const { assign } = Object;
function isComputed(o) {
    return !!((0,vue__WEBPACK_IMPORTED_MODULE_0__.isRef)(o) && o.effect);
}
function createOptionsStore(id, options, pinia, hot) {
    const { state, actions, getters } = options;
    const initialState = pinia.state.value[id];
    let store;
    function setup() {
        if (!initialState && ( false || !hot)) {
            /* istanbul ignore if */
            pinia.state.value[id] = state ? state() : {};
        }
        // avoid creating a state in pinia.state.value
        const localState = ( true) && hot
            ? // use ref() to unwrap refs inside state TODO: check if this is still necessary
                (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRefs)((0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(state ? state() : {}).value)
            : (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRefs)(pinia.state.value[id]);
        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
            if (( true) && name in localState) {
                console.warn(`[]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name}" in store "${id}".`);
            }
            computedGetters[name] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.markRaw)((0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
                setActivePinia(pinia);
                // it was created just before
                const store = pinia._s.get(id);
                // allow cross using stores
                // @ts-expect-error
                // return getters![name].call(context, context)
                // TODO: avoid reading the getter while assigning with a global variable
                return getters[name].call(store, store);
            }));
            return computedGetters;
        }, {}));
    }
    store = createSetupStore(id, setup, options, pinia, hot, true);
    return store;
}
function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({ actions: {} }, options);
    /* istanbul ignore if */
    if (( true) && !pinia._e.active) {
        throw new Error('Pinia destroyed');
    }
    // watcher options for $subscribe
    const $subscribeOptions = { deep: true };
    /* istanbul ignore else */
    if ((true)) {
        $subscribeOptions.onTrigger = (event) => {
            /* istanbul ignore else */
            if (isListening) {
                debuggerEvents = event;
                // avoid triggering this while the store is being built and the state is being set in pinia
            }
            else if (isListening == false && !store._hotUpdating) {
                // let patch send all the events together later
                /* istanbul ignore else */
                if (Array.isArray(debuggerEvents)) {
                    debuggerEvents.push(event);
                }
                else {
                    console.error(' debuggerEvents should be an array. This is most likely an internal Pinia bug.');
                }
            }
        };
    }
    // internal state
    let isListening; // set to true at the end
    let isSyncListening; // set to true at the end
    let subscriptions = new Set();
    let actionSubscriptions = new Set();
    let debuggerEvents;
    const initialState = pinia.state.value[$id];
    // avoid setting the state for option stores if it is set
    // by the setup
    if (!isOptionsStore && !initialState && ( false || !hot)) {
        /* istanbul ignore if */
        pinia.state.value[$id] = {};
    }
    const hotState = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({});
    // avoid triggering too many listeners
    // https://github.com/vuejs/pinia/issues/1129
    let activeListener;
    function $patch(partialStateOrMutator) {
        let subscriptionMutation;
        isListening = isSyncListening = false;
        // reset the debugger events since patches are sync
        /* istanbul ignore else */
        if ((true)) {
            debuggerEvents = [];
        }
        if (typeof partialStateOrMutator === 'function') {
            partialStateOrMutator(pinia.state.value[$id]);
            subscriptionMutation = {
                type: MutationType.patchFunction,
                storeId: $id,
                events: debuggerEvents,
            };
        }
        else {
            mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
            subscriptionMutation = {
                type: MutationType.patchObject,
                payload: partialStateOrMutator,
                storeId: $id,
                events: debuggerEvents,
            };
        }
        const myListenerId = (activeListener = Symbol());
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)().then(() => {
            if (activeListener === myListenerId) {
                isListening = true;
            }
        });
        isSyncListening = true;
        // because we paused the watcher, we need to manually call the subscriptions
        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
    }
    const $reset = isOptionsStore
        ? function $reset() {
            const { state } = options;
            const newState = state ? state() : {};
            // we use a patch to group all changes into one single subscription
            this.$patch(($state) => {
                // @ts-expect-error: FIXME: shouldn't error?
                assign($state, newState);
            });
        }
        : /* istanbul ignore next */
            ( true)
                ? () => {
                    throw new Error(`: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
                }
                : 0;
    function $dispose() {
        scope.stop();
        subscriptions.clear();
        actionSubscriptions.clear();
        pinia._s.delete($id);
    }
    /**
     * Helper that wraps function so it can be tracked with $onAction
     * @param fn - action to wrap
     * @param name - name of the action
     */
    const action = (fn, name = '') => {
        if (ACTION_MARKER in fn) {
            fn[ACTION_NAME] = name;
            return fn;
        }
        const wrappedAction = function () {
            setActivePinia(pinia);
            const args = Array.from(arguments);
            const afterCallbackSet = new Set();
            const onErrorCallbackSet = new Set();
            function after(callback) {
                afterCallbackSet.add(callback);
            }
            function onError(callback) {
                onErrorCallbackSet.add(callback);
            }
            // @ts-expect-error
            triggerSubscriptions(actionSubscriptions, {
                args,
                name: wrappedAction[ACTION_NAME],
                store,
                after,
                onError,
            });
            let ret;
            try {
                ret = fn.apply(this && this.$id === $id ? this : store, args);
                // handle sync errors
            }
            catch (error) {
                triggerSubscriptions(onErrorCallbackSet, error);
                throw error;
            }
            if (ret instanceof Promise) {
                return ret
                    .then((value) => {
                    triggerSubscriptions(afterCallbackSet, value);
                    return value;
                })
                    .catch((error) => {
                    triggerSubscriptions(onErrorCallbackSet, error);
                    return Promise.reject(error);
                });
            }
            // trigger after callbacks
            triggerSubscriptions(afterCallbackSet, ret);
            return ret;
        };
        wrappedAction[ACTION_MARKER] = true;
        wrappedAction[ACTION_NAME] = name; // will be set later
        // @ts-expect-error: we are intentionally limiting the returned type to just Fn
        // because all the added properties are internals that are exposed through `$onAction()` only
        return wrappedAction;
    };
    const _hmrPayload = /*#__PURE__*/ (0,vue__WEBPACK_IMPORTED_MODULE_0__.markRaw)({
        actions: {},
        getters: {},
        state: [],
        hotState,
    });
    const partialStore = {
        _p: pinia,
        // _s: scope,
        $id,
        $onAction: addSubscription.bind(null, actionSubscriptions),
        $patch,
        $reset,
        $subscribe(callback, options = {}) {
            const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());
            const stopWatcher = scope.run(() => (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(() => pinia.state.value[$id], (state) => {
                if (options.flush === 'sync' ? isSyncListening : isListening) {
                    callback({
                        storeId: $id,
                        type: MutationType.direct,
                        events: debuggerEvents,
                    }, state);
                }
            }, assign({}, $subscribeOptions, options)));
            return removeSubscription;
        },
        $dispose,
    };
    const store = (0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)( true
        ? assign({
            _hmrPayload,
            _customProperties: (0,vue__WEBPACK_IMPORTED_MODULE_0__.markRaw)(new Set()), // devtools custom properties
        }, partialStore
        // must be added later
        // setupStore
        )
        : 0);
    // store the partial store now so the setup of stores can instantiate each other before they are finished without
    // creating infinite loops.
    pinia._s.set($id, store);
    const runWithContext = (pinia._a && pinia._a.runWithContext) || fallbackRunWithContext;
    // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped
    const setupStore = runWithContext(() => pinia._e.run(() => (scope = (0,vue__WEBPACK_IMPORTED_MODULE_0__.effectScope)()).run(() => setup({ action }))));
    // overwrite existing actions to support $onAction
    for (const key in setupStore) {
        const prop = setupStore[key];
        if (((0,vue__WEBPACK_IMPORTED_MODULE_0__.isRef)(prop) && !isComputed(prop)) || (0,vue__WEBPACK_IMPORTED_MODULE_0__.isReactive)(prop)) {
            // mark it as a piece of state to be serialized
            if (( true) && hot) {
                hotState.value[key] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRef)(setupStore, key);
                // createOptionStore directly sets the state in pinia.state.value so we
                // can just skip that
            }
            else if (!isOptionsStore) {
                // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created
                if (initialState && shouldHydrate(prop)) {
                    if ((0,vue__WEBPACK_IMPORTED_MODULE_0__.isRef)(prop)) {
                        prop.value = initialState[key];
                    }
                    else {
                        // probably a reactive object, lets recursively assign
                        // @ts-expect-error: prop is unknown
                        mergeReactiveObjects(prop, initialState[key]);
                    }
                }
                // transfer the ref to the pinia state to keep everything in sync
                pinia.state.value[$id][key] = prop;
            }
            /* istanbul ignore else */
            if ((true)) {
                _hmrPayload.state.push(key);
            }
            // action
        }
        else if (typeof prop === 'function') {
            const actionValue = ( true) && hot ? prop : action(prop, key);
            // this a hot module replacement store because the hotUpdate method needs
            // to do it with the right context
            // @ts-expect-error
            setupStore[key] = actionValue;
            /* istanbul ignore else */
            if ((true)) {
                _hmrPayload.actions[key] = prop;
            }
            // list actions so they can be used in plugins
            // @ts-expect-error
            optionsForPlugin.actions[key] = prop;
        }
        else if ((true)) {
            // add getters for devtools
            if (isComputed(prop)) {
                _hmrPayload.getters[key] = isOptionsStore
                    ? // @ts-expect-error
                        options.getters[key]
                    : prop;
                if (IS_CLIENT) {
                    const getters = setupStore._getters ||
                        // @ts-expect-error: same
                        (setupStore._getters = (0,vue__WEBPACK_IMPORTED_MODULE_0__.markRaw)([]));
                    getters.push(key);
                }
            }
        }
    }
    // add the state, getters, and action properties
    /* istanbul ignore if */
    assign(store, setupStore);
    // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.
    // Make `storeToRefs()` work with `reactive()` #799
    assign((0,vue__WEBPACK_IMPORTED_MODULE_0__.toRaw)(store), setupStore);
    // use this instead of a computed with setter to be able to create it anywhere
    // without linking the computed lifespan to wherever the store is first
    // created.
    Object.defineProperty(store, '$state', {
        get: () => (( true) && hot ? hotState.value : pinia.state.value[$id]),
        set: (state) => {
            /* istanbul ignore if */
            if (( true) && hot) {
                throw new Error('cannot set hotState');
            }
            $patch(($state) => {
                // @ts-expect-error: FIXME: shouldn't error?
                assign($state, state);
            });
        },
    });
    // add the hotUpdate before plugins to allow them to override it
    /* istanbul ignore else */
    if ((true)) {
        store._hotUpdate = (0,vue__WEBPACK_IMPORTED_MODULE_0__.markRaw)((newStore) => {
            store._hotUpdating = true;
            newStore._hmrPayload.state.forEach((stateKey) => {
                if (stateKey in store.$state) {
                    const newStateTarget = newStore.$state[stateKey];
                    const oldStateSource = store.$state[stateKey];
                    if (typeof newStateTarget === 'object' &&
                        isPlainObject(newStateTarget) &&
                        isPlainObject(oldStateSource)) {
                        patchObject(newStateTarget, oldStateSource);
                    }
                    else {
                        // transfer the ref
                        newStore.$state[stateKey] = oldStateSource;
                    }
                }
                // patch direct access properties to allow store.stateProperty to work as
                // store.$state.stateProperty
                // @ts-expect-error: any type
                store[stateKey] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRef)(newStore.$state, stateKey);
            });
            // remove deleted state properties
            Object.keys(store.$state).forEach((stateKey) => {
                if (!(stateKey in newStore.$state)) {
                    // @ts-expect-error: noop if doesn't exist
                    delete store[stateKey];
                }
            });
            // avoid devtools logging this as a mutation
            isListening = false;
            isSyncListening = false;
            pinia.state.value[$id] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRef)(newStore._hmrPayload, 'hotState');
            isSyncListening = true;
            (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)().then(() => {
                isListening = true;
            });
            for (const actionName in newStore._hmrPayload.actions) {
                const actionFn = newStore[actionName];
                // @ts-expect-error: actionName is a string
                store[actionName] =
                    //
                    action(actionFn, actionName);
            }
            // TODO: does this work in both setup and option store?
            for (const getterName in newStore._hmrPayload.getters) {
                const getter = newStore._hmrPayload.getters[getterName];
                const getterValue = isOptionsStore
                    ? // special handling of options api
                        (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
                            setActivePinia(pinia);
                            return getter.call(store, store);
                        })
                    : getter;
                // @ts-expect-error: getterName is a string
                store[getterName] =
                    //
                    getterValue;
            }
            // remove deleted getters
            Object.keys(store._hmrPayload.getters).forEach((key) => {
                if (!(key in newStore._hmrPayload.getters)) {
                    // @ts-expect-error: noop if doesn't exist
                    delete store[key];
                }
            });
            // remove old actions
            Object.keys(store._hmrPayload.actions).forEach((key) => {
                if (!(key in newStore._hmrPayload.actions)) {
                    // @ts-expect-error: noop if doesn't exist
                    delete store[key];
                }
            });
            // update the values used in devtools and to allow deleting new properties later on
            store._hmrPayload = newStore._hmrPayload;
            store._getters = newStore._getters;
            store._hotUpdating = false;
        });
    }
    if (( true) && IS_CLIENT) {
        const nonEnumerable = {
            writable: true,
            configurable: true,
            // avoid warning on devtools trying to display this property
            enumerable: false,
        };
        ['_p', '_hmrPayload', '_getters', '_customProperties'].forEach((p) => {
            Object.defineProperty(store, p, assign({ value: store[p] }, nonEnumerable));
        });
    }
    // apply all plugins
    pinia._p.forEach((extender) => {
        /* istanbul ignore else */
        if (( true) && IS_CLIENT) {
            const extensions = scope.run(() => extender({
                store: store,
                app: pinia._a,
                pinia,
                options: optionsForPlugin,
            }));
            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
            assign(store, extensions);
        }
        else {
            assign(store, scope.run(() => extender({
                store: store,
                app: pinia._a,
                pinia,
                options: optionsForPlugin,
            })));
        }
    });
    if (( true) &&
        store.$state &&
        typeof store.$state === 'object' &&
        typeof store.$state.constructor === 'function' &&
        !store.$state.constructor.toString().includes('[native code]')) {
        console.warn(`[]: The "state" must be a plain object. It cannot be\n` +
            `\tstate: () => new MyClass()\n` +
            `Found in store "${store.$id}".`);
    }
    // only apply hydrate to option stores with an initial state in pinia
    if (initialState &&
        isOptionsStore &&
        options.hydrate) {
        options.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
}
// allows unused stores to be tree shaken
/*! #__NO_SIDE_EFFECTS__ */
function defineStore(
// TODO: add proper types from above
id, setup, setupOptions) {
    let options;
    const isSetupStore = typeof setup === 'function';
    // the option store setup will contain the actual options in this case
    options = isSetupStore ? setupOptions : setup;
    function useStore(pinia, hot) {
        const hasContext = (0,vue__WEBPACK_IMPORTED_MODULE_0__.hasInjectionContext)();
        pinia =
            // in test mode, ignore the argument provided as we can always retrieve a
            // pinia instance with getActivePinia()
            ( false ? 0 : pinia) ||
                (hasContext ? (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(piniaSymbol, null) : null);
        if (pinia)
            setActivePinia(pinia);
        if (( true) && !activePinia) {
            throw new Error(`[]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?\n` +
                `See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.\n` +
                `This will fail in production.`);
        }
        pinia = activePinia;
        if (!pinia._s.has(id)) {
            // creating the store registers it in `pinia._s`
            if (isSetupStore) {
                createSetupStore(id, setup, options, pinia);
            }
            else {
                createOptionsStore(id, options, pinia);
            }
            /* istanbul ignore else */
            if ((true)) {
                // @ts-expect-error: not the right inferred type
                useStore._pinia = pinia;
            }
        }
        const store = pinia._s.get(id);
        if (( true) && hot) {
            const hotId = '__hot:' + id;
            const newStore = isSetupStore
                ? createSetupStore(hotId, setup, options, pinia, true)
                : createOptionsStore(hotId, assign({}, options), pinia, true);
            hot._hotUpdate(newStore);
            // cleanup the state properties and the store from the cache
            delete pinia.state.value[hotId];
            pinia._s.delete(hotId);
        }
        if (( true) && IS_CLIENT) {
            const currentInstance = (0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
            // save stores in instances to access them devtools
            if (currentInstance &&
                currentInstance.proxy &&
                // avoid adding stores that are just built for hot module replacement
                !hot) {
                const vm = currentInstance.proxy;
                const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});
                cache[id] = store;
            }
        }
        // StoreGeneric cannot be casted towards Store
        return store;
    }
    useStore.$id = id;
    return useStore;
}

let mapStoreSuffix = 'Store';
/**
 * Changes the suffix added by `mapStores()`. Can be set to an empty string.
 * Defaults to `"Store"`. Make sure to extend the MapStoresCustomization
 * interface if you are using TypeScript.
 *
 * @param suffix - new suffix
 */
function setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS
) {
    mapStoreSuffix = suffix;
}
/**
 * Allows using stores without the composition API (`setup()`) by generating an
 * object to be spread in the `computed` field of a component. It accepts a list
 * of store definitions.
 *
 * @example
 * ```js
 * export default {
 *   computed: {
 *     // other computed properties
 *     ...mapStores(useUserStore, useCartStore)
 *   },
 *
 *   created() {
 *     this.userStore // store with id "user"
 *     this.cartStore // store with id "cart"
 *   }
 * }
 * ```
 *
 * @param stores - list of stores to map to an object
 */
function mapStores(...stores) {
    if (( true) && Array.isArray(stores[0])) {
        console.warn(`[]: Directly pass all stores to "mapStores()" without putting them in an array:\n` +
            `Replace\n` +
            `\tmapStores([useAuthStore, useCartStore])\n` +
            `with\n` +
            `\tmapStores(useAuthStore, useCartStore)\n` +
            `This will fail in production if not fixed.`);
        stores = stores[0];
    }
    return stores.reduce((reduced, useStore) => {
        // @ts-expect-error: $id is added by defineStore
        reduced[useStore.$id + mapStoreSuffix] = function () {
            return useStore(this.$pinia);
        };
        return reduced;
    }, {});
}
/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */
function mapState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper)
        ? keysOrMapper.reduce((reduced, key) => {
            reduced[key] = function () {
                // @ts-expect-error: FIXME: should work?
                return useStore(this.$pinia)[key];
            };
            return reduced;
        }, {})
        : Object.keys(keysOrMapper).reduce((reduced, key) => {
            // @ts-expect-error
            reduced[key] = function () {
                const store = useStore(this.$pinia);
                const storeKey = keysOrMapper[key];
                // for some reason TS is unable to infer the type of storeKey to be a
                // function
                return typeof storeKey === 'function'
                    ? storeKey.call(this, store)
                    : // @ts-expect-error: FIXME: should work?
                        store[storeKey];
            };
            return reduced;
        }, {});
}
/**
 * Alias for `mapState()`. You should use `mapState()` instead.
 * @deprecated use `mapState()` instead.
 */
const mapGetters = mapState;
/**
 * Allows directly using actions from your store without using the composition
 * API (`setup()`) by generating an object to be spread in the `methods` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */
function mapActions(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper)
        ? keysOrMapper.reduce((reduced, key) => {
            // @ts-expect-error
            reduced[key] = function (...args) {
                // @ts-expect-error: FIXME: should work?
                return useStore(this.$pinia)[key](...args);
            };
            return reduced;
        }, {})
        : Object.keys(keysOrMapper).reduce((reduced, key) => {
            // @ts-expect-error
            reduced[key] = function (...args) {
                // @ts-expect-error: FIXME: should work?
                return useStore(this.$pinia)[keysOrMapper[key]](...args);
            };
            return reduced;
        }, {});
}
/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */
function mapWritableState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper)
        ? keysOrMapper.reduce((reduced, key) => {
            reduced[key] = {
                get() {
                    return useStore(this.$pinia)[key];
                },
                set(value) {
                    return (useStore(this.$pinia)[key] = value);
                },
            };
            return reduced;
        }, {})
        : Object.keys(keysOrMapper).reduce((reduced, key) => {
            reduced[key] = {
                get() {
                    return useStore(this.$pinia)[keysOrMapper[key]];
                },
                set(value) {
                    return (useStore(this.$pinia)[keysOrMapper[key]] = value);
                },
            };
            return reduced;
        }, {});
}

/**
 * Creates an object of references with all the state, getters, and plugin-added
 * state properties of the store. Similar to `toRefs()` but specifically
 * designed for Pinia stores so methods and non reactive properties are
 * completely ignored.
 *
 * @param store - store to extract the refs from
 */
function storeToRefs(store) {
    const rawStore = (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRaw)(store);
    const refs = {};
    for (const key in rawStore) {
        const value = rawStore[key];
        // There is no native method to check for a computed
        // https://github.com/vuejs/core/pull/4165
        if (value.effect) {
            // @ts-expect-error: too hard to type correctly
            refs[key] =
                // ...
                (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)({
                    get: () => store[key],
                    set(value) {
                        store[key] = value;
                    },
                });
        }
        else if ((0,vue__WEBPACK_IMPORTED_MODULE_0__.isRef)(value) || (0,vue__WEBPACK_IMPORTED_MODULE_0__.isReactive)(value)) {
            // @ts-expect-error: the key is state or getter
            refs[key] =
                // ---
                (0,vue__WEBPACK_IMPORTED_MODULE_0__.toRef)(store, key);
        }
    }
    return refs;
}




/***/ },

/***/ "./node_modules/vue-loader/dist/exportHelper.js"
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
// runtime helper for setting properties on components
// in a tree-shakable way
exports["default"] = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};


/***/ },

/***/ "./node_modules/vue/dist/vue.esm-bundler.js"
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.esm-bundler.js ***!
  \**************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTransition: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   BaseTransitionPropsValidators: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransitionPropsValidators),
/* harmony export */   Comment: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   DeprecationTypes: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.DeprecationTypes),
/* harmony export */   EffectScope: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.EffectScope),
/* harmony export */   ErrorCodes: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ErrorCodes),
/* harmony export */   ErrorTypeStrings: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ErrorTypeStrings),
/* harmony export */   Fragment: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   KeepAlive: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   ReactiveEffect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),
/* harmony export */   Static: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   Suspense: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   Teleport: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   Text: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   TrackOpTypes: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TrackOpTypes),
/* harmony export */   Transition: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   TransitionGroup: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),
/* harmony export */   TriggerOpTypes: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TriggerOpTypes),
/* harmony export */   VueElement: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.VueElement),
/* harmony export */   assertNumber: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.assertNumber),
/* harmony export */   callWithAsyncErrorHandling: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   callWithErrorHandling: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   camelize: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   capitalize: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   cloneVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   compatUtils: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   compile: () => (/* binding */ compileToFunction),
/* harmony export */   computed: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   createApp: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp),
/* harmony export */   createBlock: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   createCommentVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   createElementBlock: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),
/* harmony export */   createElementVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),
/* harmony export */   createHydrationRenderer: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   createPropsRestProxy: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),
/* harmony export */   createRenderer: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   createSSRApp: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),
/* harmony export */   createSlots: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   createStaticVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   createTextVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   createVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   customRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   defineAsyncComponent: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   defineComponent: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   defineCustomElement: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement),
/* harmony export */   defineEmits: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmits),
/* harmony export */   defineExpose: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineExpose),
/* harmony export */   defineModel: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineModel),
/* harmony export */   defineOptions: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineOptions),
/* harmony export */   defineProps: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   defineSSRCustomElement: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement),
/* harmony export */   defineSlots: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSlots),
/* harmony export */   devtools: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   effect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effect),
/* harmony export */   effectScope: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effectScope),
/* harmony export */   getCurrentInstance: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   getCurrentScope: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),
/* harmony export */   getCurrentWatcher: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentWatcher),
/* harmony export */   getTransitionRawChildren: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   guardReactiveProps: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),
/* harmony export */   h: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   handleError: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   hasInjectionContext: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hasInjectionContext),
/* harmony export */   hydrate: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate),
/* harmony export */   hydrateOnIdle: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrateOnIdle),
/* harmony export */   hydrateOnInteraction: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrateOnInteraction),
/* harmony export */   hydrateOnMediaQuery: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrateOnMediaQuery),
/* harmony export */   hydrateOnVisible: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrateOnVisible),
/* harmony export */   initCustomFormatter: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   initDirectivesForSSR: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR),
/* harmony export */   inject: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   isMemoSame: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),
/* harmony export */   isProxy: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   isReactive: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   isReadonly: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   isRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   isRuntimeOnly: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   isShallow: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isShallow),
/* harmony export */   isVNode: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   markRaw: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   mergeDefaults: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),
/* harmony export */   mergeModels: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeModels),
/* harmony export */   mergeProps: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   nextTick: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   nodeOps: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nodeOps),
/* harmony export */   normalizeClass: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),
/* harmony export */   normalizeProps: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   normalizeStyle: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),
/* harmony export */   onActivated: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   onBeforeMount: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   onBeforeUnmount: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   onBeforeUpdate: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   onDeactivated: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   onErrorCaptured: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   onMounted: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   onRenderTracked: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   onRenderTriggered: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   onScopeDispose: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),
/* harmony export */   onServerPrefetch: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   onUnmounted: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   onUpdated: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   onWatcherCleanup: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onWatcherCleanup),
/* harmony export */   openBlock: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   patchProp: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.patchProp),
/* harmony export */   popScopeId: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   provide: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   proxyRefs: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   pushScopeId: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   queuePostFlushCb: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   reactive: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   readonly: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   ref: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   registerRuntimeCompiler: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   render: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   renderList: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   renderSlot: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   resolveComponent: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   resolveDirective: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   resolveDynamicComponent: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   resolveFilter: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   resolveTransitionHooks: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   setBlockTracking: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   setDevtoolsHook: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   setTransitionHooks: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   shallowReactive: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   shallowReadonly: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   shallowRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   ssrContextKey: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   ssrUtils: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   stop: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.stop),
/* harmony export */   toDisplayString: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   toHandlerKey: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   toHandlers: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   toRaw: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   toRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   toRefs: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   toValue: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toValue),
/* harmony export */   transformVNodeArgs: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   triggerRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   unref: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   useAttrs: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useAttrs),
/* harmony export */   useCssModule: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule),
/* harmony export */   useCssVars: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars),
/* harmony export */   useHost: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useHost),
/* harmony export */   useId: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useId),
/* harmony export */   useModel: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useModel),
/* harmony export */   useSSRContext: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   useShadowRoot: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useShadowRoot),
/* harmony export */   useSlots: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSlots),
/* harmony export */   useTemplateRef: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTemplateRef),
/* harmony export */   useTransitionState: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   vModelCheckbox: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),
/* harmony export */   vModelDynamic: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),
/* harmony export */   vModelRadio: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),
/* harmony export */   vModelSelect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),
/* harmony export */   vModelText: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText),
/* harmony export */   vShow: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow),
/* harmony export */   version: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   warn: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   watch: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   watchEffect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   watchPostEffect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),
/* harmony export */   watchSyncEffect: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),
/* harmony export */   withAsyncContext: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),
/* harmony export */   withCtx: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   withDefaults: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDefaults),
/* harmony export */   withDirectives: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   withKeys: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys),
/* harmony export */   withMemo: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withMemo),
/* harmony export */   withModifiers: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers),
/* harmony export */   withScopeId: () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js");
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_compiler_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/compiler-dom */ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/**
* vue v3.5.26
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/






function initDev() {
  {
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.initCustomFormatter)();
  }
}

if (true) {
  initDev();
}
const compileCache = /* @__PURE__ */ Object.create(null);
function compileToFunction(template, options) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__.isString)(template)) {
    if (template.nodeType) {
      template = template.innerHTML;
    } else {
       true && (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(`invalid template option: `, template);
      return _vue_shared__WEBPACK_IMPORTED_MODULE_3__.NOOP;
    }
  }
  const key = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__.genCacheKey)(template, options);
  const cached = compileCache[key];
  if (cached) {
    return cached;
  }
  if (template[0] === "#") {
    const el = document.querySelector(template);
    if ( true && !el) {
      (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(`Template element not found or is empty: ${template}`);
    }
    template = el ? el.innerHTML : ``;
  }
  const opts = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__.extend)(
    {
      hoistStatic: true,
      onError:  true ? onError : 0,
      onWarn:  true ? (e) => onError(e, true) : 0
    },
    options
  );
  if (!opts.isCustomElement && typeof customElements !== "undefined") {
    opts.isCustomElement = (tag) => !!customElements.get(tag);
  }
  const { code } = (0,_vue_compiler_dom__WEBPACK_IMPORTED_MODULE_2__.compile)(template, opts);
  function onError(err, asWarning = false) {
    const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
    const codeFrame = err.loc && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_3__.generateCodeFrame)(
      template,
      err.loc.start.offset,
      err.loc.end.offset
    );
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(codeFrame ? `${message}
${codeFrame}` : message);
  }
  const render = new Function("Vue", code)(_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__);
  render._rc = true;
  return compileCache[key] = render;
}
(0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.registerRuntimeCompiler)(compileToFunction);




/***/ }

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdnVlLWxvYWRlcl9kaXN0X2V4cG9ydEhlbHBlcl9qcy1ub2RlX21vZHVsZXNfY29yZS1qc19tb2R1bGVzX2VzX2FycmF5X2ZpLWY2ODcyYS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOE07QUFDOUo7O0FBRWhELHdDQUF3QyxLQUF5QyxnQkFBZ0IsQ0FBRTtBQUNuRyx3Q0FBd0MsS0FBeUMsZ0JBQWdCLENBQUU7QUFDbkcsd0NBQXdDLEtBQXlDLGdCQUFnQixDQUFFO0FBQ25HLDBDQUEwQyxLQUF5QyxpQkFBaUIsQ0FBRTtBQUN0RztBQUNBLEVBQUUsS0FBeUMsc0JBQXNCLENBQUU7QUFDbkU7QUFDQSwwQ0FBMEMsS0FBeUMsaUJBQWlCLENBQUU7QUFDdEcsNENBQTRDLEtBQXlDLG1CQUFtQixDQUFFO0FBQzFHO0FBQ0EsRUFBRSxLQUF5QywwQkFBMEIsQ0FBRTtBQUN2RTtBQUNBLDRDQUE0QyxLQUF5QyxtQkFBbUIsQ0FBRTtBQUMxRztBQUNBLEVBQUUsS0FBeUMsMEJBQTBCLENBQUU7QUFDdkU7QUFDQTtBQUNBLEVBQUUsS0FBeUMsMEJBQTBCLENBQUU7QUFDdkU7QUFDQTtBQUNBLEVBQUUsS0FBeUMsdUJBQXVCLENBQUU7QUFDcEU7QUFDQTtBQUNBLEVBQUUsS0FBeUMseUJBQXlCLENBQUU7QUFDdEU7QUFDQTtBQUNBLEVBQUUsS0FBeUMsd0JBQXdCLENBQUU7QUFDckU7QUFDQTtBQUNBLEVBQUUsS0FBeUMsK0JBQStCLENBQUU7QUFDNUU7QUFDQTtBQUNBLEVBQUUsS0FBeUMsd0JBQXdCLENBQUU7QUFDckU7QUFDQTtBQUNBLEVBQUUsS0FBeUMscUJBQXFCLENBQUU7QUFDbEU7QUFDQTtBQUNBLEVBQUUsS0FBeUMsc0JBQXNCLENBQUU7QUFDbkU7QUFDQSwyQ0FBMkMsS0FBeUMsa0JBQWtCLENBQUU7QUFDeEcsMkNBQTJDLEtBQXlDLGtCQUFrQixDQUFFO0FBQ3hHLDRDQUE0QyxLQUF5QyxtQkFBbUIsQ0FBRTtBQUMxRztBQUNBLEVBQUUsS0FBeUMsdUJBQXVCLENBQUU7QUFDcEU7QUFDQSwyQ0FBMkMsS0FBeUMsa0JBQWtCLENBQUU7QUFDeEc7QUFDQSxFQUFFLEtBQXlDLHNCQUFzQixDQUFFO0FBQ25FO0FBQ0E7QUFDQSxFQUFFLEtBQXlDLHNCQUFzQixDQUFFO0FBQ25FO0FBQ0E7QUFDQSxFQUFFLEtBQXlDLHNCQUFzQixDQUFFO0FBQ25FO0FBQ0E7QUFDQSxFQUFFLEtBQXlDLDBCQUEwQixDQUFFO0FBQ3ZFO0FBQ0EsMkNBQTJDLEtBQXlDLGtCQUFrQixDQUFFO0FBQ3hHLHdDQUF3QyxLQUF5QyxnQkFBZ0IsQ0FBRTtBQUNuRywwQ0FBMEMsS0FBeUMsa0JBQWtCLENBQUU7QUFDdkc7QUFDQSxFQUFFLEtBQXlDLG9CQUFvQixDQUFFO0FBQ2pFO0FBQ0E7QUFDQSxFQUFFLEtBQXlDLHdCQUF3QixDQUFFO0FBQ3JFO0FBQ0EsNkNBQTZDLEtBQXlDLG1CQUFtQixDQUFFO0FBQzNHLDRDQUE0QyxLQUF5QyxrQkFBa0IsQ0FBRTtBQUN6Ryx3Q0FBd0MsS0FBeUMsZUFBZSxDQUFFO0FBQ2xHLHFDQUFxQyxLQUF5QyxhQUFhLENBQUU7QUFDN0Ysc0NBQXNDLEtBQXlDLGFBQWEsQ0FBRTtBQUM5Rix5Q0FBeUMsS0FBeUMsZ0JBQWdCLENBQUU7QUFDcEcsNENBQTRDLEtBQXlDLGtCQUFrQixDQUFFO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQyxTQUFTLCtCQUErQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFEQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxREFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkJBQTZCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsVUFBVSxJQUFrRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFdBQVcsS0FBa0Q7QUFDN0Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sV0FBVyxLQUFrRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFVBQVUsS0FBa0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVLElBQWtEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFVBQVUsS0FBa0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNLHdSQUF3UjtBQUM5UjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlIQUFpSCxJQUFJLHlDQUF5QyxJQUFJO0FBQ2xLO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXlDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCLDhCQUE4QixJQUFJLElBQUksMkRBQTJELEVBQUU7QUFDbkcsYUFBYSxLQUFLLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBeUMsK0JBQStCLFlBQVk7QUFDdEY7QUFDQTtBQUNBLGNBQWMsS0FBa0QsbUVBQW1FLENBQXFEO0FBQ3hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0Q0FBNEM7QUFDdEQsVUFBVSw0QkFBNEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBaUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsb0NBQW9DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1Q0FBdUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0EsY0FBYyxxREFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLFVBQVUsK0RBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUNBQXVDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaURBQUk7QUFDdEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLHdCQUF3QixtQkFBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyxLQUF5QyxnREFBZ0QsQ0FBRTtBQUNoRztBQUNBO0FBQ0EsU0FBUyxzRUFBc0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxTQUFTLCtEQUFXO0FBQ3BCO0FBQ0EsSUFBSSxtREFBTSxHQUFHO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtREFBTTtBQUNqQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxTQUFTLDZEQUFTLFdBQVcsbURBQU0sR0FBRztBQUN0Qzs7QUFFd1Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqckJ4VDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSw4QkFBOEI7QUFDekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFT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QTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNEJBQTRCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FB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QUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDZFQUE2RSxnREFBZ0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQseUNBQXlDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsa0NBQWtDO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsa0NBQWtDO0FBQzdHO0FBQ0E7QUFDQSwwRkFBMEYsMENBQTBDO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSw4QkFBOEI7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSw4QkFBOEI7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsS0FBSztBQUM3RjtBQUNBO0FBQ0Esa0ZBQWtGLFVBQVU7QUFDNUY7QUFDQTtBQUNBLDhFQUE4RSxVQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixLQUFLO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ3lEOztBQUV6RDtBQUNBOztBQUVBO0FBQ0E7QUFDZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixZQUFZO0FBQ1osY0FBYztBQUNkLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0NBQWdDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsMkNBQTJDLHdDQUF3QztBQUNuRixxREFBcUQscUJBQXFCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0NBQWtDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0NBQWtDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOERBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUSxJQUFJO0FBQ1osS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQyxFQUFFLG1CQUFtQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCLElBQUk7QUFDeEQsb0JBQW9CLFlBQVksSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0EsaURBQWlELHdCQUF3QixTQUFTLGVBQWU7QUFDakc7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSUFBcUk7QUFDckkseUlBQXlJO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsVUFBVTtBQUNwRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ3VFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhEQUFTLDhDQUE4Qyw4REFBUTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUE4QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscUNBQXFDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsZ0NBQWdDO0FBQy9GLFFBQVE7QUFDUjtBQUNBLHVGQUF1RixrQ0FBa0M7QUFDekgsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3RUFBd0UscUNBQXFDO0FBQzdHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUMrRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJLEdBQUcsS0FBSztBQUNsQyx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUksR0FBRyxLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSixpQ0FBaUMsb0NBQW9DO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTywyREFBVTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsR0FBRyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QyxnQkFBZ0IsRUFBRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQ0FBc0MsMERBQVM7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsdUNBQXVDLDBEQUFTO0FBQ2hEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHdEQUFPO0FBQ1Q7QUFDQTtBQUNBLE1BQU0sd0RBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSx3REFBTztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNvRTtBQUNYOztBQUV6RDtBQUNBO0FBQ3lEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3REFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3REFBTztBQUN2QixtQ0FBbUMsd0RBQU87QUFDMUM7QUFDQSxXQUFXLHdEQUFPO0FBQ2xCO0FBQ0EsQ0FBQztBQUNELCtCQUErQix3REFBTztBQUN0QztBQUNBO0FBQ0EsYUFBYSx3REFBTztBQUNwQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyREFBMkQ7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdEQUFPO0FBQ1gsbUNBQW1DLCtEQUFTLG1CQUFtQjtBQUMvRCxjQUFjLCtEQUFTO0FBQ3ZCO0FBQ0EsSUFBSSx3REFBTztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsT0FBTyx3REFBTyxtQkFBbUI7QUFDckgsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0EsMEJBQTBCO0FBQzFCLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUFPO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDMEQ7QUFDMUQ7QUFDQSxnQkFBZ0Isd0RBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3REFBUTtBQUNqQjtBQUNBO0FBQ0EsRUFBRSx3REFBUTtBQUNWLE9BQU8sd0RBQVE7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQix3REFBUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ21GO0FBQ25GO0FBQ0Esb0NBQW9DLHdEQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsYUFBYTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVSxHQUFHLE1BQU07QUFDMUQ7QUFDQSxZQUFZLFVBQVUsR0FBRyxNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJEQUFVO0FBQ3hCO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsR0FBRywyQkFBMkI7QUFDL0Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQVE7QUFDMUI7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQ0FBa0Msd0RBQVE7QUFDMUMsTUFBTSx3REFBUTtBQUNkO0FBQ0E7QUFDQSxNQUFNLHdEQUFRO0FBQ2Q7QUFDQSxNQUFNLHdEQUFRO0FBQ2QsTUFBTSx3REFBUTtBQUNkLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0RBQVE7QUFDWixrRUFBa0UsZ0JBQWdCLGdCQUFnQjtBQUNsRyw4SEFBOEgsZ0JBQWdCO0FBQzlJO0FBQ0E7QUFDQSxvSEFBb0gsZ0JBQWdCLG9CQUFvQixnQ0FBZ0MsZ0JBQWdCLGdCQUFnQjtBQUN4TixxSEFBcUgsaUJBQWlCLG9CQUFvQixnQ0FBZ0MsZ0JBQWdCLGdCQUFnQjtBQUMxTiwyR0FBMkcsZ0JBQWdCO0FBQzNILGtFQUFrRSxnQkFBZ0IsZ0JBQWdCO0FBQ2xHLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyxrQkFBa0I7QUFDN0gsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdEQUFRLDBDQUEwQyx3REFBUTtBQUM5RDtBQUNBLEdBQUc7QUFDSDtBQUNBLE9BQU8sd0RBQVE7QUFDZiwwQkFBMEIsd0RBQVE7QUFDbEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osU0FBUywyREFBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLE9BQU87QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQzBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkMsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx1QkFBdUIsd0RBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixNQUFNO0FBQzdCLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osb0JBQW9CLGFBQWE7QUFDakMsSUFBSTtBQUNKLG9CQUFvQiw0Q0FBNEM7QUFDaEUsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwrQkFBK0IscUVBQXFFLG1CQUFtQixHQUFHLG9CQUFvQiwrQkFBK0I7QUFDN0ssTUFBTTtBQUNOLG9GQUFvRiwyRUFBMkUsSUFBSSxvQkFBb0I7QUFDdkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVJQUF1STtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFROztBQUV4QjtBQUNBO0FBQzBEO0FBQ0o7O0FBRXREO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw0REFBNEQsS0FBSztBQUNqRTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEdBQThHLHFCQUFNLG1CQUFtQixxQkFBTTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQixHQUFHLGdCQUFnQjtBQUNwRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUMsNkRBQTZELElBQUk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTRCRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwVkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyTTs7QUFFM007QUFDQSw2QkFBNkIsSUFBSTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU0sU0FBUyxJQUF5QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksU0FBUyxLQUF5QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLEtBQXlDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1REFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBeUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEdBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVMsS0FBeUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFD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QUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLGVBQWUsS0FBb0Y7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFDQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEtBQW9GO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLElBQXlDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLElBQXlDO0FBQzVELGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxZQUFZLEtBQXlDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLDRCQUE0QixpQkFBaUI7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseURBQXlEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQWlEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFEQUFRO0FBQ3hDLE1BQU0sSUFBeUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBeUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0dBQStHO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyxZQUFZLElBQXlDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFFBQVE7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxHQUFHLHlCQUF5QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxTQUFTLFFBQVE7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0JBQStCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQSxvREFBb0QsVUFBVTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSTtBQUN6QjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzRUFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE9BQU87QUFDakU7QUFDQTtBQUNBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFEO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQ0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDBDQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0EsbUVBQW1FLFFBQVEsTUFBTSxLQUFLO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNFQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxZQUFZLDBDQUFLLE9BQU8sMENBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWEsSUFBSSxZQUFZO0FBQzdCLFNBQVM7QUFDVCw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlDQUFpQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTLElBQUksK0JBQStCO0FBQzVDO0FBQ0EsMkJBQTJCLDRDQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7QUFDdkMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQ0FBSztBQUN4QztBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQ0FBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0RBQVc7QUFDN0I7QUFDQTtBQUNBLGtDQUFrQyx3Q0FBRyxHQUFHO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0Q0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQTBKO0FBQzNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFNBQVMsS0FBMEo7QUFDbks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMENBQUs7QUFDbEIsYUFBYSwrQ0FBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUF3QyxFQUFFO0FBQUEsRUFFN0M7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxvQkFBb0IsUUFBUSxHQUFHO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9EQUFlO0FBQ3BDLFFBQVEsbURBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBDQUFLO0FBQ2xCLGFBQWEsK0NBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQXFDO0FBQ2hFO0FBQ0EsaUNBQWlDLENBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0EsY0FBYywwQ0FBSztBQUNuQjtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQXdDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQXFDO0FBQ2pFO0FBQ0EsZ0JBQWdCLDJDQUFNLENBQUMsd0NBQUcscUJBQXFCO0FBQy9DLGNBQWMsMkNBQU07QUFDcEIsb0VBQW9FO0FBQ3BFLGlCQUFpQixLQUFxQztBQUN0RCxvSUFBb0ksS0FBSyxjQUFjLEdBQUc7QUFDMUo7QUFDQSxvQ0FBb0MsNENBQU8sQ0FBQyw2Q0FBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRDtBQUNBLFNBQVMsS0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsU0FBUyxJQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQXdDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3Q0FBRyxHQUFHO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZDQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhLEtBQXFDO0FBQ2xEO0FBQ0Esa0RBQWtELElBQUk7QUFDdEQ7QUFDQSxrQkFBa0IsQ0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNENBQU87QUFDN0MsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsZ0RBQWdELDBDQUFLO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQiw2Q0FBUSxDQUFDLEtBQXNOO0FBQ2pQO0FBQ0E7QUFDQSwrQkFBK0IsNENBQU87QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVUsQ0FBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGdEQUFXLHNCQUFzQixRQUFRO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMENBQUssZ0NBQWdDLCtDQUFVO0FBQzVEO0FBQ0EsaUJBQWlCLEtBQXFDO0FBQ3RELHNDQUFzQywwQ0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMENBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBcUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFxQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBcUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDRDQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFxQztBQUMxRDtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsU0FBUyxJQUFxQztBQUM5QywyQkFBMkIsNENBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBDQUFLO0FBQ3ZDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBDQUFLO0FBQzFDO0FBQ0EsWUFBWSw2Q0FBUTtBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkNBQVE7QUFDaEM7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUyxLQUEwSjtBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxpQkFBaUI7QUFDdEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUEwSjtBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLFNBQVMsS0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQXdFLEdBQUcsQ0FBSTtBQUM1Riw4QkFBOEIsMkNBQU07QUFDcEM7QUFDQTtBQUNBLGFBQWEsS0FBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFxQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBcUM7QUFDbEQsb0NBQW9DLHVEQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZDQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUIsMENBQUssV0FBVywrQ0FBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMENBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRTRPOzs7Ozs7Ozs7OztBQ3A1RC9OO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQztBQUN1QztBQUNyRDtBQUNXO0FBQ3lDOztBQUVyRjtBQUNBO0FBQ0EsSUFBSSxxRUFBbUI7QUFDdkI7QUFDQTs7QUFFQSxJQUFJLElBQXlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxxREFBUTtBQUNmO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTSxLQUF5QyxJQUFJLHNEQUFJO0FBQ3ZELGFBQWEsNkNBQUk7QUFDakI7QUFDQTtBQUNBLGNBQWMsd0RBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUF5QztBQUNqRCxNQUFNLHNEQUFJLDRDQUE0QyxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQU07QUFDckI7QUFDQTtBQUNBLGVBQWUsS0FBeUMsYUFBYSxDQUFNO0FBQzNFLGNBQWMsS0FBeUMsNkJBQTZCLENBQUk7QUFDeEYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU8sRUFBRSwwREFBTztBQUMxQjtBQUNBLDZFQUE2RSxZQUFZO0FBQ3pGLGlDQUFpQyw4REFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFJLGdCQUFnQjtBQUN4QixFQUFFLFVBQVU7QUFDWjtBQUNBLDJDQUEyQyw2Q0FBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSx5RUFBdUI7O0FBRWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B2dWUvY29tcGlsZXItY29yZS9kaXN0L2NvbXBpbGVyLWNvcmUuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B2dWUvY29tcGlsZXItZG9tL2Rpc3QvY29tcGlsZXItZG9tLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL2RldnRvb2xzLWtpdC9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL2RldnRvb2xzLXNoYXJlZC9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL3JlYWN0aXZpdHkvZGlzdC9yZWFjdGl2aXR5LmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9kaXN0L3J1bnRpbWUtY29yZS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWRvbS9kaXN0L3J1bnRpbWUtZG9tLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmlycGMvZGlzdC9pbmRleC5tanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtY2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4taW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1pcy1yZWdleHAtbG9naWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4tYWNjZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWlucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnZpcm9ubWVudC11c2VyLWFnZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnZpcm9ubWVudC12OC12ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1jYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi1uYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtY2xhdXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItY2xvc2UtYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1jbG9zZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3ItY3JlYXRlLXByb3h5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvci1oZWxwZXItdGhyb3dzLW9uLWludmFsaWQtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9yLWhlbHBlci13aXRob3V0LWNsb3Npbmctb24tZWFybHktZXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWFrZS1idWlsdC1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWF0aC10cnVuYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbm90LWEtcmVnZXhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90cnktdG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1Zy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2Vhay1tYXAtYmFzaWMtZGV0ZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLml0ZXJhdG9yLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3IuZmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuaXRlcmF0b3IubWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuaXRlcmF0b3IuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lc25leHQuaXRlcmF0b3IuZmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXNuZXh0Lml0ZXJhdG9yLm1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaG9va2FibGUvZGlzdC9pbmRleC5tanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BlcmZlY3QtZGVib3VuY2UvZGlzdC9pbmRleC5tanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BpbmlhL2Rpc3QvcGluaWEubWpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvZXhwb3J0SGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qIEB2dWUvY29tcGlsZXItY29yZSB2My41LjI2XG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5pbXBvcnQgeyBpc1N0cmluZywgTk9PUCwgaXNPYmplY3QsIGV4dGVuZCwgTk8sIGlzU3ltYm9sLCBQYXRjaEZsYWdOYW1lcywgaXNBcnJheSwgY2FwaXRhbGl6ZSwgY2FtZWxpemUsIEVNUFRZX09CSiwgc2xvdEZsYWdzVGV4dCwgaXNPbiwgaXNCdWlsdEluRGlyZWN0aXZlLCBpc1Jlc2VydmVkUHJvcCwgdG9IYW5kbGVyS2V5IH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuZXhwb3J0IHsgZ2VuZXJhdGVDb2RlRnJhbWUgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IEZSQUdNRU5UID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYEZyYWdtZW50YCA6IGBgKTtcbmNvbnN0IFRFTEVQT1JUID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYFRlbGVwb3J0YCA6IGBgKTtcbmNvbnN0IFNVU1BFTlNFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYFN1c3BlbnNlYCA6IGBgKTtcbmNvbnN0IEtFRVBfQUxJVkUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgS2VlcEFsaXZlYCA6IGBgKTtcbmNvbnN0IEJBU0VfVFJBTlNJVElPTiA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgQmFzZVRyYW5zaXRpb25gIDogYGBcbik7XG5jb25zdCBPUEVOX0JMT0NLID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYG9wZW5CbG9ja2AgOiBgYCk7XG5jb25zdCBDUkVBVEVfQkxPQ0sgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgY3JlYXRlQmxvY2tgIDogYGApO1xuY29uc3QgQ1JFQVRFX0VMRU1FTlRfQkxPQ0sgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKFxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYGNyZWF0ZUVsZW1lbnRCbG9ja2AgOiBgYFxuKTtcbmNvbnN0IENSRUFURV9WTk9ERSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBjcmVhdGVWTm9kZWAgOiBgYCk7XG5jb25zdCBDUkVBVEVfRUxFTUVOVF9WTk9ERSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgY3JlYXRlRWxlbWVudFZOb2RlYCA6IGBgXG4pO1xuY29uc3QgQ1JFQVRFX0NPTU1FTlQgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKFxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYGNyZWF0ZUNvbW1lbnRWTm9kZWAgOiBgYFxuKTtcbmNvbnN0IENSRUFURV9URVhUID0gLyogQF9fUFVSRV9fICovIFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBjcmVhdGVUZXh0Vk5vZGVgIDogYGBcbik7XG5jb25zdCBDUkVBVEVfU1RBVElDID0gLyogQF9fUFVSRV9fICovIFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBjcmVhdGVTdGF0aWNWTm9kZWAgOiBgYFxuKTtcbmNvbnN0IFJFU09MVkVfQ09NUE9ORU5UID0gLyogQF9fUFVSRV9fICovIFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGByZXNvbHZlQ29tcG9uZW50YCA6IGBgXG4pO1xuY29uc3QgUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnRgIDogYGBcbik7XG5jb25zdCBSRVNPTFZFX0RJUkVDVElWRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgcmVzb2x2ZURpcmVjdGl2ZWAgOiBgYFxuKTtcbmNvbnN0IFJFU09MVkVfRklMVEVSID0gLyogQF9fUFVSRV9fICovIFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGByZXNvbHZlRmlsdGVyYCA6IGBgXG4pO1xuY29uc3QgV0lUSF9ESVJFQ1RJVkVTID0gLyogQF9fUFVSRV9fICovIFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGB3aXRoRGlyZWN0aXZlc2AgOiBgYFxuKTtcbmNvbnN0IFJFTkRFUl9MSVNUID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYHJlbmRlckxpc3RgIDogYGApO1xuY29uc3QgUkVOREVSX1NMT1QgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgcmVuZGVyU2xvdGAgOiBgYCk7XG5jb25zdCBDUkVBVEVfU0xPVFMgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgY3JlYXRlU2xvdHNgIDogYGApO1xuY29uc3QgVE9fRElTUExBWV9TVFJJTkcgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKFxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYHRvRGlzcGxheVN0cmluZ2AgOiBgYFxuKTtcbmNvbnN0IE1FUkdFX1BST1BTID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYG1lcmdlUHJvcHNgIDogYGApO1xuY29uc3QgTk9STUFMSVpFX0NMQVNTID0gLyogQF9fUFVSRV9fICovIFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBub3JtYWxpemVDbGFzc2AgOiBgYFxuKTtcbmNvbnN0IE5PUk1BTElaRV9TVFlMRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgbm9ybWFsaXplU3R5bGVgIDogYGBcbik7XG5jb25zdCBOT1JNQUxJWkVfUFJPUFMgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKFxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYG5vcm1hbGl6ZVByb3BzYCA6IGBgXG4pO1xuY29uc3QgR1VBUkRfUkVBQ1RJVkVfUFJPUFMgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKFxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYGd1YXJkUmVhY3RpdmVQcm9wc2AgOiBgYFxuKTtcbmNvbnN0IFRPX0hBTkRMRVJTID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYHRvSGFuZGxlcnNgIDogYGApO1xuY29uc3QgQ0FNRUxJWkUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgY2FtZWxpemVgIDogYGApO1xuY29uc3QgQ0FQSVRBTElaRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBjYXBpdGFsaXplYCA6IGBgKTtcbmNvbnN0IFRPX0hBTkRMRVJfS0VZID0gLyogQF9fUFVSRV9fICovIFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGB0b0hhbmRsZXJLZXlgIDogYGBcbik7XG5jb25zdCBTRVRfQkxPQ0tfVFJBQ0tJTkcgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKFxuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYHNldEJsb2NrVHJhY2tpbmdgIDogYGBcbik7XG5jb25zdCBQVVNIX1NDT1BFX0lEID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYHB1c2hTY29wZUlkYCA6IGBgKTtcbmNvbnN0IFBPUF9TQ09QRV9JRCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBwb3BTY29wZUlkYCA6IGBgKTtcbmNvbnN0IFdJVEhfQ1RYID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYHdpdGhDdHhgIDogYGApO1xuY29uc3QgVU5SRUYgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgdW5yZWZgIDogYGApO1xuY29uc3QgSVNfUkVGID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYGlzUmVmYCA6IGBgKTtcbmNvbnN0IFdJVEhfTUVNTyA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGB3aXRoTWVtb2AgOiBgYCk7XG5jb25zdCBJU19NRU1PX1NBTUUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgaXNNZW1vU2FtZWAgOiBgYCk7XG5jb25zdCBoZWxwZXJOYW1lTWFwID0ge1xuICBbRlJBR01FTlRdOiBgRnJhZ21lbnRgLFxuICBbVEVMRVBPUlRdOiBgVGVsZXBvcnRgLFxuICBbU1VTUEVOU0VdOiBgU3VzcGVuc2VgLFxuICBbS0VFUF9BTElWRV06IGBLZWVwQWxpdmVgLFxuICBbQkFTRV9UUkFOU0lUSU9OXTogYEJhc2VUcmFuc2l0aW9uYCxcbiAgW09QRU5fQkxPQ0tdOiBgb3BlbkJsb2NrYCxcbiAgW0NSRUFURV9CTE9DS106IGBjcmVhdGVCbG9ja2AsXG4gIFtDUkVBVEVfRUxFTUVOVF9CTE9DS106IGBjcmVhdGVFbGVtZW50QmxvY2tgLFxuICBbQ1JFQVRFX1ZOT0RFXTogYGNyZWF0ZVZOb2RlYCxcbiAgW0NSRUFURV9FTEVNRU5UX1ZOT0RFXTogYGNyZWF0ZUVsZW1lbnRWTm9kZWAsXG4gIFtDUkVBVEVfQ09NTUVOVF06IGBjcmVhdGVDb21tZW50Vk5vZGVgLFxuICBbQ1JFQVRFX1RFWFRdOiBgY3JlYXRlVGV4dFZOb2RlYCxcbiAgW0NSRUFURV9TVEFUSUNdOiBgY3JlYXRlU3RhdGljVk5vZGVgLFxuICBbUkVTT0xWRV9DT01QT05FTlRdOiBgcmVzb2x2ZUNvbXBvbmVudGAsXG4gIFtSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UXTogYHJlc29sdmVEeW5hbWljQ29tcG9uZW50YCxcbiAgW1JFU09MVkVfRElSRUNUSVZFXTogYHJlc29sdmVEaXJlY3RpdmVgLFxuICBbUkVTT0xWRV9GSUxURVJdOiBgcmVzb2x2ZUZpbHRlcmAsXG4gIFtXSVRIX0RJUkVDVElWRVNdOiBgd2l0aERpcmVjdGl2ZXNgLFxuICBbUkVOREVSX0xJU1RdOiBgcmVuZGVyTGlzdGAsXG4gIFtSRU5ERVJfU0xPVF06IGByZW5kZXJTbG90YCxcbiAgW0NSRUFURV9TTE9UU106IGBjcmVhdGVTbG90c2AsXG4gIFtUT19ESVNQTEFZX1NUUklOR106IGB0b0Rpc3BsYXlTdHJpbmdgLFxuICBbTUVSR0VfUFJPUFNdOiBgbWVyZ2VQcm9wc2AsXG4gIFtOT1JNQUxJWkVfQ0xBU1NdOiBgbm9ybWFsaXplQ2xhc3NgLFxuICBbTk9STUFMSVpFX1NUWUxFXTogYG5vcm1hbGl6ZVN0eWxlYCxcbiAgW05PUk1BTElaRV9QUk9QU106IGBub3JtYWxpemVQcm9wc2AsXG4gIFtHVUFSRF9SRUFDVElWRV9QUk9QU106IGBndWFyZFJlYWN0aXZlUHJvcHNgLFxuICBbVE9fSEFORExFUlNdOiBgdG9IYW5kbGVyc2AsXG4gIFtDQU1FTElaRV06IGBjYW1lbGl6ZWAsXG4gIFtDQVBJVEFMSVpFXTogYGNhcGl0YWxpemVgLFxuICBbVE9fSEFORExFUl9LRVldOiBgdG9IYW5kbGVyS2V5YCxcbiAgW1NFVF9CTE9DS19UUkFDS0lOR106IGBzZXRCbG9ja1RyYWNraW5nYCxcbiAgW1BVU0hfU0NPUEVfSURdOiBgcHVzaFNjb3BlSWRgLFxuICBbUE9QX1NDT1BFX0lEXTogYHBvcFNjb3BlSWRgLFxuICBbV0lUSF9DVFhdOiBgd2l0aEN0eGAsXG4gIFtVTlJFRl06IGB1bnJlZmAsXG4gIFtJU19SRUZdOiBgaXNSZWZgLFxuICBbV0lUSF9NRU1PXTogYHdpdGhNZW1vYCxcbiAgW0lTX01FTU9fU0FNRV06IGBpc01lbW9TYW1lYFxufTtcbmZ1bmN0aW9uIHJlZ2lzdGVyUnVudGltZUhlbHBlcnMoaGVscGVycykge1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGhlbHBlcnMpLmZvckVhY2goKHMpID0+IHtcbiAgICBoZWxwZXJOYW1lTWFwW3NdID0gaGVscGVyc1tzXTtcbiAgfSk7XG59XG5cbmNvbnN0IE5hbWVzcGFjZXMgPSB7XG4gIFwiSFRNTFwiOiAwLFxuICBcIjBcIjogXCJIVE1MXCIsXG4gIFwiU1ZHXCI6IDEsXG4gIFwiMVwiOiBcIlNWR1wiLFxuICBcIk1BVEhfTUxcIjogMixcbiAgXCIyXCI6IFwiTUFUSF9NTFwiXG59O1xuY29uc3QgTm9kZVR5cGVzID0ge1xuICBcIlJPT1RcIjogMCxcbiAgXCIwXCI6IFwiUk9PVFwiLFxuICBcIkVMRU1FTlRcIjogMSxcbiAgXCIxXCI6IFwiRUxFTUVOVFwiLFxuICBcIlRFWFRcIjogMixcbiAgXCIyXCI6IFwiVEVYVFwiLFxuICBcIkNPTU1FTlRcIjogMyxcbiAgXCIzXCI6IFwiQ09NTUVOVFwiLFxuICBcIlNJTVBMRV9FWFBSRVNTSU9OXCI6IDQsXG4gIFwiNFwiOiBcIlNJTVBMRV9FWFBSRVNTSU9OXCIsXG4gIFwiSU5URVJQT0xBVElPTlwiOiA1LFxuICBcIjVcIjogXCJJTlRFUlBPTEFUSU9OXCIsXG4gIFwiQVRUUklCVVRFXCI6IDYsXG4gIFwiNlwiOiBcIkFUVFJJQlVURVwiLFxuICBcIkRJUkVDVElWRVwiOiA3LFxuICBcIjdcIjogXCJESVJFQ1RJVkVcIixcbiAgXCJDT01QT1VORF9FWFBSRVNTSU9OXCI6IDgsXG4gIFwiOFwiOiBcIkNPTVBPVU5EX0VYUFJFU1NJT05cIixcbiAgXCJJRlwiOiA5LFxuICBcIjlcIjogXCJJRlwiLFxuICBcIklGX0JSQU5DSFwiOiAxMCxcbiAgXCIxMFwiOiBcIklGX0JSQU5DSFwiLFxuICBcIkZPUlwiOiAxMSxcbiAgXCIxMVwiOiBcIkZPUlwiLFxuICBcIlRFWFRfQ0FMTFwiOiAxMixcbiAgXCIxMlwiOiBcIlRFWFRfQ0FMTFwiLFxuICBcIlZOT0RFX0NBTExcIjogMTMsXG4gIFwiMTNcIjogXCJWTk9ERV9DQUxMXCIsXG4gIFwiSlNfQ0FMTF9FWFBSRVNTSU9OXCI6IDE0LFxuICBcIjE0XCI6IFwiSlNfQ0FMTF9FWFBSRVNTSU9OXCIsXG4gIFwiSlNfT0JKRUNUX0VYUFJFU1NJT05cIjogMTUsXG4gIFwiMTVcIjogXCJKU19PQkpFQ1RfRVhQUkVTU0lPTlwiLFxuICBcIkpTX1BST1BFUlRZXCI6IDE2LFxuICBcIjE2XCI6IFwiSlNfUFJPUEVSVFlcIixcbiAgXCJKU19BUlJBWV9FWFBSRVNTSU9OXCI6IDE3LFxuICBcIjE3XCI6IFwiSlNfQVJSQVlfRVhQUkVTU0lPTlwiLFxuICBcIkpTX0ZVTkNUSU9OX0VYUFJFU1NJT05cIjogMTgsXG4gIFwiMThcIjogXCJKU19GVU5DVElPTl9FWFBSRVNTSU9OXCIsXG4gIFwiSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTlwiOiAxOSxcbiAgXCIxOVwiOiBcIkpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT05cIixcbiAgXCJKU19DQUNIRV9FWFBSRVNTSU9OXCI6IDIwLFxuICBcIjIwXCI6IFwiSlNfQ0FDSEVfRVhQUkVTU0lPTlwiLFxuICBcIkpTX0JMT0NLX1NUQVRFTUVOVFwiOiAyMSxcbiAgXCIyMVwiOiBcIkpTX0JMT0NLX1NUQVRFTUVOVFwiLFxuICBcIkpTX1RFTVBMQVRFX0xJVEVSQUxcIjogMjIsXG4gIFwiMjJcIjogXCJKU19URU1QTEFURV9MSVRFUkFMXCIsXG4gIFwiSlNfSUZfU1RBVEVNRU5UXCI6IDIzLFxuICBcIjIzXCI6IFwiSlNfSUZfU1RBVEVNRU5UXCIsXG4gIFwiSlNfQVNTSUdOTUVOVF9FWFBSRVNTSU9OXCI6IDI0LFxuICBcIjI0XCI6IFwiSlNfQVNTSUdOTUVOVF9FWFBSRVNTSU9OXCIsXG4gIFwiSlNfU0VRVUVOQ0VfRVhQUkVTU0lPTlwiOiAyNSxcbiAgXCIyNVwiOiBcIkpTX1NFUVVFTkNFX0VYUFJFU1NJT05cIixcbiAgXCJKU19SRVRVUk5fU1RBVEVNRU5UXCI6IDI2LFxuICBcIjI2XCI6IFwiSlNfUkVUVVJOX1NUQVRFTUVOVFwiXG59O1xuY29uc3QgRWxlbWVudFR5cGVzID0ge1xuICBcIkVMRU1FTlRcIjogMCxcbiAgXCIwXCI6IFwiRUxFTUVOVFwiLFxuICBcIkNPTVBPTkVOVFwiOiAxLFxuICBcIjFcIjogXCJDT01QT05FTlRcIixcbiAgXCJTTE9UXCI6IDIsXG4gIFwiMlwiOiBcIlNMT1RcIixcbiAgXCJURU1QTEFURVwiOiAzLFxuICBcIjNcIjogXCJURU1QTEFURVwiXG59O1xuY29uc3QgQ29uc3RhbnRUeXBlcyA9IHtcbiAgXCJOT1RfQ09OU1RBTlRcIjogMCxcbiAgXCIwXCI6IFwiTk9UX0NPTlNUQU5UXCIsXG4gIFwiQ0FOX1NLSVBfUEFUQ0hcIjogMSxcbiAgXCIxXCI6IFwiQ0FOX1NLSVBfUEFUQ0hcIixcbiAgXCJDQU5fQ0FDSEVcIjogMixcbiAgXCIyXCI6IFwiQ0FOX0NBQ0hFXCIsXG4gIFwiQ0FOX1NUUklOR0lGWVwiOiAzLFxuICBcIjNcIjogXCJDQU5fU1RSSU5HSUZZXCJcbn07XG5jb25zdCBsb2NTdHViID0ge1xuICBzdGFydDogeyBsaW5lOiAxLCBjb2x1bW46IDEsIG9mZnNldDogMCB9LFxuICBlbmQ6IHsgbGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDAgfSxcbiAgc291cmNlOiBcIlwiXG59O1xuZnVuY3Rpb24gY3JlYXRlUm9vdChjaGlsZHJlbiwgc291cmNlID0gXCJcIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDAsXG4gICAgc291cmNlLFxuICAgIGNoaWxkcmVuLFxuICAgIGhlbHBlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgY29tcG9uZW50czogW10sXG4gICAgZGlyZWN0aXZlczogW10sXG4gICAgaG9pc3RzOiBbXSxcbiAgICBpbXBvcnRzOiBbXSxcbiAgICBjYWNoZWQ6IFtdLFxuICAgIHRlbXBzOiAwLFxuICAgIGNvZGVnZW5Ob2RlOiB2b2lkIDAsXG4gICAgbG9jOiBsb2NTdHViXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgdGFnLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBkaXJlY3RpdmVzLCBpc0Jsb2NrID0gZmFsc2UsIGRpc2FibGVUcmFja2luZyA9IGZhbHNlLCBpc0NvbXBvbmVudCA9IGZhbHNlLCBsb2MgPSBsb2NTdHViKSB7XG4gIGlmIChjb250ZXh0KSB7XG4gICAgaWYgKGlzQmxvY2spIHtcbiAgICAgIGNvbnRleHQuaGVscGVyKE9QRU5fQkxPQ0spO1xuICAgICAgY29udGV4dC5oZWxwZXIoZ2V0Vk5vZGVCbG9ja0hlbHBlcihjb250ZXh0LmluU1NSLCBpc0NvbXBvbmVudCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmhlbHBlcihnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBpc0NvbXBvbmVudCkpO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aXZlcykge1xuICAgICAgY29udGV4dC5oZWxwZXIoV0lUSF9ESVJFQ1RJVkVTKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxMyxcbiAgICB0YWcsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgcGF0Y2hGbGFnLFxuICAgIGR5bmFtaWNQcm9wcyxcbiAgICBkaXJlY3RpdmVzLFxuICAgIGlzQmxvY2ssXG4gICAgZGlzYWJsZVRyYWNraW5nLFxuICAgIGlzQ29tcG9uZW50LFxuICAgIGxvY1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzLCBsb2MgPSBsb2NTdHViKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMTcsXG4gICAgbG9jLFxuICAgIGVsZW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMsIGxvYyA9IGxvY1N0dWIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxNSxcbiAgICBsb2MsXG4gICAgcHJvcGVydGllc1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0UHJvcGVydHkoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDE2LFxuICAgIGxvYzogbG9jU3R1YixcbiAgICBrZXk6IGlzU3RyaW5nKGtleSkgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGtleSwgdHJ1ZSkgOiBrZXksXG4gICAgdmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oY29udGVudCwgaXNTdGF0aWMgPSBmYWxzZSwgbG9jID0gbG9jU3R1YiwgY29uc3RUeXBlID0gMCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDQsXG4gICAgbG9jLFxuICAgIGNvbnRlbnQsXG4gICAgaXNTdGF0aWMsXG4gICAgY29uc3RUeXBlOiBpc1N0YXRpYyA/IDMgOiBjb25zdFR5cGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRpb24oY29udGVudCwgbG9jKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogNSxcbiAgICBsb2MsXG4gICAgY29udGVudDogaXNTdHJpbmcoY29udGVudCkgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGZhbHNlLCBsb2MpIDogY29udGVudFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKGNoaWxkcmVuLCBsb2MgPSBsb2NTdHViKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogOCxcbiAgICBsb2MsXG4gICAgY2hpbGRyZW5cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNhbGxlZSwgYXJncyA9IFtdLCBsb2MgPSBsb2NTdHViKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMTQsXG4gICAgbG9jLFxuICAgIGNhbGxlZSxcbiAgICBhcmd1bWVudHM6IGFyZ3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihwYXJhbXMsIHJldHVybnMgPSB2b2lkIDAsIG5ld2xpbmUgPSBmYWxzZSwgaXNTbG90ID0gZmFsc2UsIGxvYyA9IGxvY1N0dWIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxOCxcbiAgICBwYXJhbXMsXG4gICAgcmV0dXJucyxcbiAgICBuZXdsaW5lLFxuICAgIGlzU2xvdCxcbiAgICBsb2NcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIG5ld2xpbmUgPSB0cnVlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMTksXG4gICAgdGVzdCxcbiAgICBjb25zZXF1ZW50LFxuICAgIGFsdGVybmF0ZSxcbiAgICBuZXdsaW5lLFxuICAgIGxvYzogbG9jU3R1YlxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVFeHByZXNzaW9uKGluZGV4LCB2YWx1ZSwgbmVlZFBhdXNlVHJhY2tpbmcgPSBmYWxzZSwgaW5WT25jZSA9IGZhbHNlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMjAsXG4gICAgaW5kZXgsXG4gICAgdmFsdWUsXG4gICAgbmVlZFBhdXNlVHJhY2tpbmcsXG4gICAgaW5WT25jZSxcbiAgICBuZWVkQXJyYXlTcHJlYWQ6IGZhbHNlLFxuICAgIGxvYzogbG9jU3R1YlxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQmxvY2tTdGF0ZW1lbnQoYm9keSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDIxLFxuICAgIGJvZHksXG4gICAgbG9jOiBsb2NTdHViXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZUxpdGVyYWwoZWxlbWVudHMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAyMixcbiAgICBlbGVtZW50cyxcbiAgICBsb2M6IGxvY1N0dWJcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUlmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDIzLFxuICAgIHRlc3QsXG4gICAgY29uc2VxdWVudCxcbiAgICBhbHRlcm5hdGUsXG4gICAgbG9jOiBsb2NTdHViXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbihsZWZ0LCByaWdodCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDI0LFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgbG9jOiBsb2NTdHViXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAyNSxcbiAgICBleHByZXNzaW9ucyxcbiAgICBsb2M6IGxvY1N0dWJcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJldHVyblN0YXRlbWVudChyZXR1cm5zKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMjYsXG4gICAgcmV0dXJucyxcbiAgICBsb2M6IGxvY1N0dWJcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFZOb2RlSGVscGVyKHNzciwgaXNDb21wb25lbnQpIHtcbiAgcmV0dXJuIHNzciB8fCBpc0NvbXBvbmVudCA/IENSRUFURV9WTk9ERSA6IENSRUFURV9FTEVNRU5UX1ZOT0RFO1xufVxuZnVuY3Rpb24gZ2V0Vk5vZGVCbG9ja0hlbHBlcihzc3IsIGlzQ29tcG9uZW50KSB7XG4gIHJldHVybiBzc3IgfHwgaXNDb21wb25lbnQgPyBDUkVBVEVfQkxPQ0sgOiBDUkVBVEVfRUxFTUVOVF9CTE9DSztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0Jsb2NrKG5vZGUsIHsgaGVscGVyLCByZW1vdmVIZWxwZXIsIGluU1NSIH0pIHtcbiAgaWYgKCFub2RlLmlzQmxvY2spIHtcbiAgICBub2RlLmlzQmxvY2sgPSB0cnVlO1xuICAgIHJlbW92ZUhlbHBlcihnZXRWTm9kZUhlbHBlcihpblNTUiwgbm9kZS5pc0NvbXBvbmVudCkpO1xuICAgIGhlbHBlcihPUEVOX0JMT0NLKTtcbiAgICBoZWxwZXIoZ2V0Vk5vZGVCbG9ja0hlbHBlcihpblNTUiwgbm9kZS5pc0NvbXBvbmVudCkpO1xuICB9XG59XG5cbmNvbnN0IGRlZmF1bHREZWxpbWl0ZXJzT3BlbiA9IG5ldyBVaW50OEFycmF5KFsxMjMsIDEyM10pO1xuY29uc3QgZGVmYXVsdERlbGltaXRlcnNDbG9zZSA9IG5ldyBVaW50OEFycmF5KFsxMjUsIDEyNV0pO1xuZnVuY3Rpb24gaXNUYWdTdGFydENoYXIoYykge1xuICByZXR1cm4gYyA+PSA5NyAmJiBjIDw9IDEyMiB8fCBjID49IDY1ICYmIGMgPD0gOTA7XG59XG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoYykge1xuICByZXR1cm4gYyA9PT0gMzIgfHwgYyA9PT0gMTAgfHwgYyA9PT0gOSB8fCBjID09PSAxMiB8fCBjID09PSAxMztcbn1cbmZ1bmN0aW9uIGlzRW5kT2ZUYWdTZWN0aW9uKGMpIHtcbiAgcmV0dXJuIGMgPT09IDQ3IHx8IGMgPT09IDYyIHx8IGlzV2hpdGVzcGFjZShjKTtcbn1cbmZ1bmN0aW9uIHRvQ2hhckNvZGVzKHN0cikge1xuICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICByZXRbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuY29uc3QgU2VxdWVuY2VzID0ge1xuICBDZGF0YTogbmV3IFVpbnQ4QXJyYXkoWzY3LCA2OCwgNjUsIDg0LCA2NSwgOTFdKSxcbiAgLy8gQ0RBVEFbXG4gIENkYXRhRW5kOiBuZXcgVWludDhBcnJheShbOTMsIDkzLCA2Ml0pLFxuICAvLyBdXT5cbiAgQ29tbWVudEVuZDogbmV3IFVpbnQ4QXJyYXkoWzQ1LCA0NSwgNjJdKSxcbiAgLy8gYC0tPmBcbiAgU2NyaXB0RW5kOiBuZXcgVWludDhBcnJheShbNjAsIDQ3LCAxMTUsIDk5LCAxMTQsIDEwNSwgMTEyLCAxMTZdKSxcbiAgLy8gYDxcXC9zY3JpcHRgXG4gIFN0eWxlRW5kOiBuZXcgVWludDhBcnJheShbNjAsIDQ3LCAxMTUsIDExNiwgMTIxLCAxMDgsIDEwMV0pLFxuICAvLyBgPC9zdHlsZWBcbiAgVGl0bGVFbmQ6IG5ldyBVaW50OEFycmF5KFs2MCwgNDcsIDExNiwgMTA1LCAxMTYsIDEwOCwgMTAxXSksXG4gIC8vIGA8L3RpdGxlYFxuICBUZXh0YXJlYUVuZDogbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDYwLFxuICAgIDQ3LFxuICAgIDExNixcbiAgICAxMDEsXG4gICAgMTIwLFxuICAgIDExNixcbiAgICA5NyxcbiAgICAxMTQsXG4gICAgMTAxLFxuICAgIDk3XG4gIF0pXG4gIC8vIGA8L3RleHRhcmVhXG59O1xuY2xhc3MgVG9rZW5pemVyIHtcbiAgY29uc3RydWN0b3Ioc3RhY2ssIGNicykge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLmNicyA9IGNicztcbiAgICAvKiogVGhlIGN1cnJlbnQgc3RhdGUgdGhlIHRva2VuaXplciBpcyBpbi4gKi9cbiAgICB0aGlzLnN0YXRlID0gMTtcbiAgICAvKiogVGhlIHJlYWQgYnVmZmVyLiAqL1xuICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICAvKiogVGhlIGJlZ2lubmluZyBvZiB0aGUgc2VjdGlvbiB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyByZWFkLiAqL1xuICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gMDtcbiAgICAvKiogVGhlIGluZGV4IHdpdGhpbiB0aGUgYnVmZmVyIHRoYXQgd2UgYXJlIGN1cnJlbnRseSBsb29raW5nIGF0LiAqL1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIC8qKiBUaGUgc3RhcnQgb2YgdGhlIGxhc3QgZW50aXR5LiAqL1xuICAgIHRoaXMuZW50aXR5U3RhcnQgPSAwO1xuICAgIC8qKiBTb21lIGJlaGF2aW9yLCBlZy4gd2hlbiBkZWNvZGluZyBlbnRpdGllcywgaXMgZG9uZSB3aGlsZSB3ZSBhcmUgaW4gYW5vdGhlciBzdGF0ZS4gVGhpcyBrZWVwcyB0cmFjayBvZiB0aGUgb3RoZXIgc3RhdGUgdHlwZS4gKi9cbiAgICB0aGlzLmJhc2VTdGF0ZSA9IDE7XG4gICAgLyoqIEZvciBzcGVjaWFsIHBhcnNpbmcgYmVoYXZpb3IgaW5zaWRlIG9mIHNjcmlwdCBhbmQgc3R5bGUgdGFncy4gKi9cbiAgICB0aGlzLmluUkNEQVRBID0gZmFsc2U7XG4gICAgLyoqIEZvciBkaXNhYmxpbmcgUkNEQVRBIHRhZ3MgaGFuZGxpbmcgKi9cbiAgICB0aGlzLmluWE1MID0gZmFsc2U7XG4gICAgLyoqIEZvciBkaXNhYmxpbmcgaW50ZXJwb2xhdGlvbiBwYXJzaW5nIGluIHYtcHJlICovXG4gICAgdGhpcy5pblZQcmUgPSBmYWxzZTtcbiAgICAvKiogUmVjb3JkIG5ld2xpbmUgcG9zaXRpb25zIGZvciBmYXN0IGxpbmUgLyBjb2x1bW4gY2FsY3VsYXRpb24gKi9cbiAgICB0aGlzLm5ld2xpbmVzID0gW107XG4gICAgdGhpcy5tb2RlID0gMDtcbiAgICB0aGlzLmRlbGltaXRlck9wZW4gPSBkZWZhdWx0RGVsaW1pdGVyc09wZW47XG4gICAgdGhpcy5kZWxpbWl0ZXJDbG9zZSA9IGRlZmF1bHREZWxpbWl0ZXJzQ2xvc2U7XG4gICAgdGhpcy5kZWxpbWl0ZXJJbmRleCA9IC0xO1xuICAgIHRoaXMuY3VycmVudFNlcXVlbmNlID0gdm9pZCAwO1xuICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDA7XG4gIH1cbiAgZ2V0IGluU0ZDUm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlID09PSAyICYmIHRoaXMuc3RhY2subGVuZ3RoID09PSAwO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuc3RhdGUgPSAxO1xuICAgIHRoaXMubW9kZSA9IDA7XG4gICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gMDtcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB0aGlzLmJhc2VTdGF0ZSA9IDE7XG4gICAgdGhpcy5pblJDREFUQSA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudFNlcXVlbmNlID0gdm9pZCAwO1xuICAgIHRoaXMubmV3bGluZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRlbGltaXRlck9wZW4gPSBkZWZhdWx0RGVsaW1pdGVyc09wZW47XG4gICAgdGhpcy5kZWxpbWl0ZXJDbG9zZSA9IGRlZmF1bHREZWxpbWl0ZXJzQ2xvc2U7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIFBvc2l0aW9uIG9iamVjdCB3aXRoIGxpbmUgLyBjb2x1bW4gaW5mb3JtYXRpb24gdXNpbmcgcmVjb3JkZWRcbiAgICogbmV3bGluZSBwb3NpdGlvbnMuIFdlIGtub3cgdGhlIGluZGV4IGlzIGFsd2F5cyBnb2luZyB0byBiZSBhbiBhbHJlYWR5XG4gICAqIHByb2Nlc3NlZCBpbmRleCwgc28gYWxsIHRoZSBuZXdsaW5lcyB1cCB0byB0aGlzIGluZGV4IHNob3VsZCBoYXZlIGJlZW5cbiAgICogcmVjb3JkZWQuXG4gICAqL1xuICBnZXRQb3MoaW5kZXgpIHtcbiAgICBsZXQgbGluZSA9IDE7XG4gICAgbGV0IGNvbHVtbiA9IGluZGV4ICsgMTtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLm5ld2xpbmVzLmxlbmd0aDtcbiAgICBsZXQgaiA9IC0xO1xuICAgIGlmIChsZW5ndGggPiAxMDApIHtcbiAgICAgIGxldCBsID0gLTE7XG4gICAgICBsZXQgciA9IGxlbmd0aDtcbiAgICAgIHdoaWxlIChsICsgMSA8IHIpIHtcbiAgICAgICAgY29uc3QgbSA9IGwgKyByID4+PiAxO1xuICAgICAgICB0aGlzLm5ld2xpbmVzW21dIDwgaW5kZXggPyBsID0gbSA6IHIgPSBtO1xuICAgICAgfVxuICAgICAgaiA9IGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoaW5kZXggPiB0aGlzLm5ld2xpbmVzW2ldKSB7XG4gICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGogPj0gMCkge1xuICAgICAgbGluZSA9IGogKyAyO1xuICAgICAgY29sdW1uID0gaW5kZXggLSB0aGlzLm5ld2xpbmVzW2pdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uLFxuICAgICAgbGluZSxcbiAgICAgIG9mZnNldDogaW5kZXhcbiAgICB9O1xuICB9XG4gIHBlZWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpO1xuICB9XG4gIHN0YXRlVGV4dChjKSB7XG4gICAgaWYgKGMgPT09IDYwKSB7XG4gICAgICBpZiAodGhpcy5pbmRleCA+IHRoaXMuc2VjdGlvblN0YXJ0KSB7XG4gICAgICAgIHRoaXMuY2JzLm9udGV4dCh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gNTtcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmluVlByZSAmJiBjID09PSB0aGlzLmRlbGltaXRlck9wZW5bMF0pIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAyO1xuICAgICAgdGhpcy5kZWxpbWl0ZXJJbmRleCA9IDA7XG4gICAgICB0aGlzLnN0YXRlSW50ZXJwb2xhdGlvbk9wZW4oYyk7XG4gICAgfVxuICB9XG4gIHN0YXRlSW50ZXJwb2xhdGlvbk9wZW4oYykge1xuICAgIGlmIChjID09PSB0aGlzLmRlbGltaXRlck9wZW5bdGhpcy5kZWxpbWl0ZXJJbmRleF0pIHtcbiAgICAgIGlmICh0aGlzLmRlbGltaXRlckluZGV4ID09PSB0aGlzLmRlbGltaXRlck9wZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5kZXggKyAxIC0gdGhpcy5kZWxpbWl0ZXJPcGVuLmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YXJ0ID4gdGhpcy5zZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICB0aGlzLmNicy5vbnRleHQodGhpcy5zZWN0aW9uU3RhcnQsIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gMztcbiAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVsaW1pdGVySW5kZXgrKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5SQ0RBVEEpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAzMjtcbiAgICAgIHRoaXMuc3RhdGVJblJDREFUQShjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IDE7XG4gICAgICB0aGlzLnN0YXRlVGV4dChjKTtcbiAgICB9XG4gIH1cbiAgc3RhdGVJbnRlcnBvbGF0aW9uKGMpIHtcbiAgICBpZiAoYyA9PT0gdGhpcy5kZWxpbWl0ZXJDbG9zZVswXSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IDQ7XG4gICAgICB0aGlzLmRlbGltaXRlckluZGV4ID0gMDtcbiAgICAgIHRoaXMuc3RhdGVJbnRlcnBvbGF0aW9uQ2xvc2UoYyk7XG4gICAgfVxuICB9XG4gIHN0YXRlSW50ZXJwb2xhdGlvbkNsb3NlKGMpIHtcbiAgICBpZiAoYyA9PT0gdGhpcy5kZWxpbWl0ZXJDbG9zZVt0aGlzLmRlbGltaXRlckluZGV4XSkge1xuICAgICAgaWYgKHRoaXMuZGVsaW1pdGVySW5kZXggPT09IHRoaXMuZGVsaW1pdGVyQ2xvc2UubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLmNicy5vbmludGVycG9sYXRpb24odGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXggKyAxKTtcbiAgICAgICAgaWYgKHRoaXMuaW5SQ0RBVEEpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gMzI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVsaW1pdGVySW5kZXgrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IDM7XG4gICAgICB0aGlzLnN0YXRlSW50ZXJwb2xhdGlvbihjKTtcbiAgICB9XG4gIH1cbiAgc3RhdGVTcGVjaWFsU3RhcnRTZXF1ZW5jZShjKSB7XG4gICAgY29uc3QgaXNFbmQgPSB0aGlzLnNlcXVlbmNlSW5kZXggPT09IHRoaXMuY3VycmVudFNlcXVlbmNlLmxlbmd0aDtcbiAgICBjb25zdCBpc01hdGNoID0gaXNFbmQgPyAoXG4gICAgICAvLyBJZiB3ZSBhcmUgYXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UsIG1ha2Ugc3VyZSB0aGUgdGFnIG5hbWUgaGFzIGVuZGVkXG4gICAgICBpc0VuZE9mVGFnU2VjdGlvbihjKVxuICAgICkgOiAoXG4gICAgICAvLyBPdGhlcndpc2UsIGRvIGEgY2FzZS1pbnNlbnNpdGl2ZSBjb21wYXJpc29uXG4gICAgICAoYyB8IDMyKSA9PT0gdGhpcy5jdXJyZW50U2VxdWVuY2VbdGhpcy5zZXF1ZW5jZUluZGV4XVxuICAgICk7XG4gICAgaWYgKCFpc01hdGNoKSB7XG4gICAgICB0aGlzLmluUkNEQVRBID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNFbmQpIHtcbiAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCsrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgIHRoaXMuc3RhdGUgPSA2O1xuICAgIHRoaXMuc3RhdGVJblRhZ05hbWUoYyk7XG4gIH1cbiAgLyoqIExvb2sgZm9yIGFuIGVuZCB0YWcuIEZvciA8dGl0bGU+IGFuZCA8dGV4dGFyZWE+LCBhbHNvIGRlY29kZSBlbnRpdGllcy4gKi9cbiAgc3RhdGVJblJDREFUQShjKSB7XG4gICAgaWYgKHRoaXMuc2VxdWVuY2VJbmRleCA9PT0gdGhpcy5jdXJyZW50U2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICBpZiAoYyA9PT0gNjIgfHwgaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgIGNvbnN0IGVuZE9mVGV4dCA9IHRoaXMuaW5kZXggLSB0aGlzLmN1cnJlbnRTZXF1ZW5jZS5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLnNlY3Rpb25TdGFydCA8IGVuZE9mVGV4dCkge1xuICAgICAgICAgIGNvbnN0IGFjdHVhbEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gZW5kT2ZUZXh0O1xuICAgICAgICAgIHRoaXMuY2JzLm9udGV4dCh0aGlzLnNlY3Rpb25TdGFydCwgZW5kT2ZUZXh0KTtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gYWN0dWFsSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSBlbmRPZlRleHQgKyAyO1xuICAgICAgICB0aGlzLnN0YXRlSW5DbG9zaW5nVGFnTmFtZShjKTtcbiAgICAgICAgdGhpcy5pblJDREFUQSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICAgIH1cbiAgICBpZiAoKGMgfCAzMikgPT09IHRoaXMuY3VycmVudFNlcXVlbmNlW3RoaXMuc2VxdWVuY2VJbmRleF0pIHtcbiAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCArPSAxO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zZXF1ZW5jZUluZGV4ID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50U2VxdWVuY2UgPT09IFNlcXVlbmNlcy5UaXRsZUVuZCB8fCB0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9PT0gU2VxdWVuY2VzLlRleHRhcmVhRW5kICYmICF0aGlzLmluU0ZDUm9vdCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5WUHJlICYmIGMgPT09IHRoaXMuZGVsaW1pdGVyT3BlblswXSkge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAyO1xuICAgICAgICAgIHRoaXMuZGVsaW1pdGVySW5kZXggPSAwO1xuICAgICAgICAgIHRoaXMuc3RhdGVJbnRlcnBvbGF0aW9uT3BlbihjKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmZhc3RGb3J3YXJkVG8oNjApKSB7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IE51bWJlcihjID09PSA2MCk7XG4gICAgfVxuICB9XG4gIHN0YXRlQ0RBVEFTZXF1ZW5jZShjKSB7XG4gICAgaWYgKGMgPT09IFNlcXVlbmNlcy5DZGF0YVt0aGlzLnNlcXVlbmNlSW5kZXhdKSB7XG4gICAgICBpZiAoKyt0aGlzLnNlcXVlbmNlSW5kZXggPT09IFNlcXVlbmNlcy5DZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDI4O1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9IFNlcXVlbmNlcy5DZGF0YUVuZDtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICAgIHRoaXMuc3RhdGUgPSAyMztcbiAgICAgIHRoaXMuc3RhdGVJbkRlY2xhcmF0aW9uKGMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogV2hlbiB3ZSB3YWl0IGZvciBvbmUgc3BlY2lmaWMgY2hhcmFjdGVyLCB3ZSBjYW4gc3BlZWQgdGhpbmdzIHVwXG4gICAqIGJ5IHNraXBwaW5nIHRocm91Z2ggdGhlIGJ1ZmZlciB1bnRpbCB3ZSBmaW5kIGl0LlxuICAgKlxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgd2FzIGZvdW5kLlxuICAgKi9cbiAgZmFzdEZvcndhcmRUbyhjKSB7XG4gICAgd2hpbGUgKCsrdGhpcy5pbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgY29uc3QgY2MgPSB0aGlzLmJ1ZmZlci5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xuICAgICAgaWYgKGNjID09PSAxMCkge1xuICAgICAgICB0aGlzLm5ld2xpbmVzLnB1c2godGhpcy5pbmRleCk7XG4gICAgICB9XG4gICAgICBpZiAoY2MgPT09IGMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaW5kZXggPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQ29tbWVudHMgYW5kIENEQVRBIGVuZCB3aXRoIGAtLT5gIGFuZCBgXV0+YC5cbiAgICpcbiAgICogVGhlaXIgY29tbW9uIHF1YWxpdGllcyBhcmU6XG4gICAqIC0gVGhlaXIgZW5kIHNlcXVlbmNlcyBoYXZlIGEgZGlzdGluY3QgY2hhcmFjdGVyIHRoZXkgc3RhcnQgd2l0aC5cbiAgICogLSBUaGF0IGNoYXJhY3RlciBpcyB0aGVuIHJlcGVhdGVkLCBzbyB3ZSBoYXZlIHRvIGNoZWNrIG11bHRpcGxlIHJlcGVhdHMuXG4gICAqIC0gQWxsIGNoYXJhY3RlcnMgYnV0IHRoZSBzdGFydCBjaGFyYWN0ZXIgb2YgdGhlIHNlcXVlbmNlIGNhbiBiZSBza2lwcGVkLlxuICAgKi9cbiAgc3RhdGVJbkNvbW1lbnRMaWtlKGMpIHtcbiAgICBpZiAoYyA9PT0gdGhpcy5jdXJyZW50U2VxdWVuY2VbdGhpcy5zZXF1ZW5jZUluZGV4XSkge1xuICAgICAgaWYgKCsrdGhpcy5zZXF1ZW5jZUluZGV4ID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFNlcXVlbmNlID09PSBTZXF1ZW5jZXMuQ2RhdGFFbmQpIHtcbiAgICAgICAgICB0aGlzLmNicy5vbmNkYXRhKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4IC0gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jYnMub25jb21tZW50KHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4IC0gMik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnNlcXVlbmNlSW5kZXggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLmZhc3RGb3J3YXJkVG8odGhpcy5jdXJyZW50U2VxdWVuY2VbMF0pKSB7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjICE9PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZVt0aGlzLnNlcXVlbmNlSW5kZXggLSAxXSkge1xuICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICB9XG4gIH1cbiAgc3RhcnRTcGVjaWFsKHNlcXVlbmNlLCBvZmZzZXQpIHtcbiAgICB0aGlzLmVudGVyUkNEQVRBKHNlcXVlbmNlLCBvZmZzZXQpO1xuICAgIHRoaXMuc3RhdGUgPSAzMTtcbiAgfVxuICBlbnRlclJDREFUQShzZXF1ZW5jZSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5pblJDREFUQSA9IHRydWU7XG4gICAgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSBzZXF1ZW5jZTtcbiAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSBvZmZzZXQ7XG4gIH1cbiAgc3RhdGVCZWZvcmVUYWdOYW1lKGMpIHtcbiAgICBpZiAoYyA9PT0gMzMpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAyMjtcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgfSBlbHNlIGlmIChjID09PSA2Mykge1xuICAgICAgdGhpcy5zdGF0ZSA9IDI0O1xuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICB9IGVsc2UgaWYgKGlzVGFnU3RhcnRDaGFyKGMpKSB7XG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSAwKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSA2O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmluU0ZDUm9vdCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gMzQ7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmluWE1MKSB7XG4gICAgICAgIGlmIChjID09PSAxMTYpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gMzA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IGMgPT09IDExNSA/IDI5IDogNjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDY7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjID09PSA0Nykge1xuICAgICAgdGhpcy5zdGF0ZSA9IDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAxO1xuICAgICAgdGhpcy5zdGF0ZVRleHQoYyk7XG4gICAgfVxuICB9XG4gIHN0YXRlSW5UYWdOYW1lKGMpIHtcbiAgICBpZiAoaXNFbmRPZlRhZ1NlY3Rpb24oYykpIHtcbiAgICAgIHRoaXMuaGFuZGxlVGFnTmFtZShjKTtcbiAgICB9XG4gIH1cbiAgc3RhdGVJblNGQ1Jvb3RUYWdOYW1lKGMpIHtcbiAgICBpZiAoaXNFbmRPZlRhZ1NlY3Rpb24oYykpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHRoaXMuYnVmZmVyLnNsaWNlKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgIGlmICh0YWcgIT09IFwidGVtcGxhdGVcIikge1xuICAgICAgICB0aGlzLmVudGVyUkNEQVRBKHRvQ2hhckNvZGVzKGA8L2AgKyB0YWcpLCAwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFuZGxlVGFnTmFtZShjKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlVGFnTmFtZShjKSB7XG4gICAgdGhpcy5jYnMub25vcGVudGFnbmFtZSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAtMTtcbiAgICB0aGlzLnN0YXRlID0gMTE7XG4gICAgdGhpcy5zdGF0ZUJlZm9yZUF0dHJOYW1lKGMpO1xuICB9XG4gIHN0YXRlQmVmb3JlQ2xvc2luZ1RhZ05hbWUoYykge1xuICAgIGlmIChpc1doaXRlc3BhY2UoYykpIDsgZWxzZSBpZiAoYyA9PT0gNjIpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuY2JzLm9uZXJyKDE0LCB0aGlzLmluZGV4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSAxO1xuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IGlzVGFnU3RhcnRDaGFyKGMpID8gOSA6IDI3O1xuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgIH1cbiAgfVxuICBzdGF0ZUluQ2xvc2luZ1RhZ05hbWUoYykge1xuICAgIGlmIChjID09PSA2MiB8fCBpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgIHRoaXMuY2JzLm9uY2xvc2V0YWcodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAtMTtcbiAgICAgIHRoaXMuc3RhdGUgPSAxMDtcbiAgICAgIHRoaXMuc3RhdGVBZnRlckNsb3NpbmdUYWdOYW1lKGMpO1xuICAgIH1cbiAgfVxuICBzdGF0ZUFmdGVyQ2xvc2luZ1RhZ05hbWUoYykge1xuICAgIGlmIChjID09PSA2Mikge1xuICAgICAgdGhpcy5zdGF0ZSA9IDE7XG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgIH1cbiAgfVxuICBzdGF0ZUJlZm9yZUF0dHJOYW1lKGMpIHtcbiAgICBpZiAoYyA9PT0gNjIpIHtcbiAgICAgIHRoaXMuY2JzLm9ub3BlbnRhZ2VuZCh0aGlzLmluZGV4KTtcbiAgICAgIGlmICh0aGlzLmluUkNEQVRBKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAzMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAxO1xuICAgICAgfVxuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDQ3KSB7XG4gICAgICB0aGlzLnN0YXRlID0gNztcbiAgICAgIGlmICgoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBmYWxzZSkgJiYgdGhpcy5wZWVrKCkgIT09IDYyKSB7XG4gICAgICAgIHRoaXMuY2JzLm9uZXJyKDIyLCB0aGlzLmluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGMgPT09IDYwICYmIHRoaXMucGVlaygpID09PSA0Nykge1xuICAgICAgdGhpcy5jYnMub25vcGVudGFnZW5kKHRoaXMuaW5kZXgpO1xuICAgICAgdGhpcy5zdGF0ZSA9IDU7XG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgfSBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgZmFsc2UpICYmIGMgPT09IDYxKSB7XG4gICAgICAgIHRoaXMuY2JzLm9uZXJyKFxuICAgICAgICAgIDE5LFxuICAgICAgICAgIHRoaXMuaW5kZXhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFuZGxlQXR0clN0YXJ0KGMpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVBdHRyU3RhcnQoYykge1xuICAgIGlmIChjID09PSAxMTggJiYgdGhpcy5wZWVrKCkgPT09IDQ1KSB7XG4gICAgICB0aGlzLnN0YXRlID0gMTM7XG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgfSBlbHNlIGlmIChjID09PSA0NiB8fCBjID09PSA1OCB8fCBjID09PSA2NCB8fCBjID09PSAzNSkge1xuICAgICAgdGhpcy5jYnMub25kaXJuYW1lKHRoaXMuaW5kZXgsIHRoaXMuaW5kZXggKyAxKTtcbiAgICAgIHRoaXMuc3RhdGUgPSAxNDtcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAxMjtcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICB9XG4gIH1cbiAgc3RhdGVJblNlbGZDbG9zaW5nVGFnKGMpIHtcbiAgICBpZiAoYyA9PT0gNjIpIHtcbiAgICAgIHRoaXMuY2JzLm9uc2VsZmNsb3Npbmd0YWcodGhpcy5pbmRleCk7XG4gICAgICB0aGlzLnN0YXRlID0gMTtcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgICB0aGlzLmluUkNEQVRBID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gMTE7XG4gICAgICB0aGlzLnN0YXRlQmVmb3JlQXR0ck5hbWUoYyk7XG4gICAgfVxuICB9XG4gIHN0YXRlSW5BdHRyTmFtZShjKSB7XG4gICAgaWYgKGMgPT09IDYxIHx8IGlzRW5kT2ZUYWdTZWN0aW9uKGMpKSB7XG4gICAgICB0aGlzLmNicy5vbmF0dHJpYm5hbWUodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgdGhpcy5oYW5kbGVBdHRyTmFtZUVuZChjKTtcbiAgICB9IGVsc2UgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZhbHNlKSAmJiAoYyA9PT0gMzQgfHwgYyA9PT0gMzkgfHwgYyA9PT0gNjApKSB7XG4gICAgICB0aGlzLmNicy5vbmVycihcbiAgICAgICAgMTcsXG4gICAgICAgIHRoaXMuaW5kZXhcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHN0YXRlSW5EaXJOYW1lKGMpIHtcbiAgICBpZiAoYyA9PT0gNjEgfHwgaXNFbmRPZlRhZ1NlY3Rpb24oYykpIHtcbiAgICAgIHRoaXMuY2JzLm9uZGlybmFtZSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICB0aGlzLmhhbmRsZUF0dHJOYW1lRW5kKGMpO1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gNTgpIHtcbiAgICAgIHRoaXMuY2JzLm9uZGlybmFtZSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICB0aGlzLnN0YXRlID0gMTQ7XG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gNDYpIHtcbiAgICAgIHRoaXMuY2JzLm9uZGlybmFtZSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICB0aGlzLnN0YXRlID0gMTY7XG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgIH1cbiAgfVxuICBzdGF0ZUluRGlyQXJnKGMpIHtcbiAgICBpZiAoYyA9PT0gNjEgfHwgaXNFbmRPZlRhZ1NlY3Rpb24oYykpIHtcbiAgICAgIHRoaXMuY2JzLm9uZGlyYXJnKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgIHRoaXMuaGFuZGxlQXR0ck5hbWVFbmQoYyk7XG4gICAgfSBlbHNlIGlmIChjID09PSA5MSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IDE1O1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gNDYpIHtcbiAgICAgIHRoaXMuY2JzLm9uZGlyYXJnKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgIHRoaXMuc3RhdGUgPSAxNjtcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgfVxuICB9XG4gIHN0YXRlSW5EeW5hbWljRGlyQXJnKGMpIHtcbiAgICBpZiAoYyA9PT0gOTMpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAxNDtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDYxIHx8IGlzRW5kT2ZUYWdTZWN0aW9uKGMpKSB7XG4gICAgICB0aGlzLmNicy5vbmRpcmFyZyh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCArIDEpO1xuICAgICAgdGhpcy5oYW5kbGVBdHRyTmFtZUVuZChjKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuY2JzLm9uZXJyKFxuICAgICAgICAgIDI3LFxuICAgICAgICAgIHRoaXMuaW5kZXhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGVJbkRpck1vZGlmaWVyKGMpIHtcbiAgICBpZiAoYyA9PT0gNjEgfHwgaXNFbmRPZlRhZ1NlY3Rpb24oYykpIHtcbiAgICAgIHRoaXMuY2JzLm9uZGlybW9kaWZpZXIodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgdGhpcy5oYW5kbGVBdHRyTmFtZUVuZChjKTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDQ2KSB7XG4gICAgICB0aGlzLmNicy5vbmRpcm1vZGlmaWVyKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDE7XG4gICAgfVxuICB9XG4gIGhhbmRsZUF0dHJOYW1lRW5kKGMpIHtcbiAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgdGhpcy5zdGF0ZSA9IDE3O1xuICAgIHRoaXMuY2JzLm9uYXR0cmlibmFtZWVuZCh0aGlzLmluZGV4KTtcbiAgICB0aGlzLnN0YXRlQWZ0ZXJBdHRyTmFtZShjKTtcbiAgfVxuICBzdGF0ZUFmdGVyQXR0ck5hbWUoYykge1xuICAgIGlmIChjID09PSA2MSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IDE4O1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gNDcgfHwgYyA9PT0gNjIpIHtcbiAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW5kKDAsIHRoaXMuc2VjdGlvblN0YXJ0KTtcbiAgICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gLTE7XG4gICAgICB0aGlzLnN0YXRlID0gMTE7XG4gICAgICB0aGlzLnN0YXRlQmVmb3JlQXR0ck5hbWUoYyk7XG4gICAgfSBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICB0aGlzLmNicy5vbmF0dHJpYmVuZCgwLCB0aGlzLnNlY3Rpb25TdGFydCk7XG4gICAgICB0aGlzLmhhbmRsZUF0dHJTdGFydChjKTtcbiAgICB9XG4gIH1cbiAgc3RhdGVCZWZvcmVBdHRyVmFsdWUoYykge1xuICAgIGlmIChjID09PSAzNCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IDE5O1xuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDM5KSB7XG4gICAgICB0aGlzLnN0YXRlID0gMjA7XG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgIH0gZWxzZSBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgdGhpcy5zdGF0ZSA9IDIxO1xuICAgICAgdGhpcy5zdGF0ZUluQXR0clZhbHVlTm9RdW90ZXMoYyk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUluQXR0clZhbHVlKGMsIHF1b3RlKSB7XG4gICAgaWYgKGMgPT09IHF1b3RlIHx8IHRoaXMuZmFzdEZvcndhcmRUbyhxdW90ZSkpIHtcbiAgICAgIHRoaXMuY2JzLm9uYXR0cmliZGF0YSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IC0xO1xuICAgICAgdGhpcy5jYnMub25hdHRyaWJlbmQoXG4gICAgICAgIHF1b3RlID09PSAzNCA/IDMgOiAyLFxuICAgICAgICB0aGlzLmluZGV4ICsgMVxuICAgICAgKTtcbiAgICAgIHRoaXMuc3RhdGUgPSAxMTtcbiAgICB9XG4gIH1cbiAgc3RhdGVJbkF0dHJWYWx1ZURvdWJsZVF1b3RlcyhjKSB7XG4gICAgdGhpcy5oYW5kbGVJbkF0dHJWYWx1ZShjLCAzNCk7XG4gIH1cbiAgc3RhdGVJbkF0dHJWYWx1ZVNpbmdsZVF1b3RlcyhjKSB7XG4gICAgdGhpcy5oYW5kbGVJbkF0dHJWYWx1ZShjLCAzOSk7XG4gIH1cbiAgc3RhdGVJbkF0dHJWYWx1ZU5vUXVvdGVzKGMpIHtcbiAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpIHx8IGMgPT09IDYyKSB7XG4gICAgICB0aGlzLmNicy5vbmF0dHJpYmRhdGEodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSAtMTtcbiAgICAgIHRoaXMuY2JzLm9uYXR0cmliZW5kKDEsIHRoaXMuaW5kZXgpO1xuICAgICAgdGhpcy5zdGF0ZSA9IDExO1xuICAgICAgdGhpcy5zdGF0ZUJlZm9yZUF0dHJOYW1lKGMpO1xuICAgIH0gZWxzZSBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgZmFsc2UpICYmIGMgPT09IDM0IHx8IGMgPT09IDM5IHx8IGMgPT09IDYwIHx8IGMgPT09IDYxIHx8IGMgPT09IDk2KSB7XG4gICAgICB0aGlzLmNicy5vbmVycihcbiAgICAgICAgMTgsXG4gICAgICAgIHRoaXMuaW5kZXhcbiAgICAgICk7XG4gICAgfSBlbHNlIDtcbiAgfVxuICBzdGF0ZUJlZm9yZURlY2xhcmF0aW9uKGMpIHtcbiAgICBpZiAoYyA9PT0gOTEpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAyNjtcbiAgICAgIHRoaXMuc2VxdWVuY2VJbmRleCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBjID09PSA0NSA/IDI1IDogMjM7XG4gICAgfVxuICB9XG4gIHN0YXRlSW5EZWNsYXJhdGlvbihjKSB7XG4gICAgaWYgKGMgPT09IDYyIHx8IHRoaXMuZmFzdEZvcndhcmRUbyg2MikpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAxO1xuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICB9XG4gIH1cbiAgc3RhdGVJblByb2Nlc3NpbmdJbnN0cnVjdGlvbihjKSB7XG4gICAgaWYgKGMgPT09IDYyIHx8IHRoaXMuZmFzdEZvcndhcmRUbyg2MikpIHtcbiAgICAgIHRoaXMuY2JzLm9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgIHRoaXMuc3RhdGUgPSAxO1xuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICB9XG4gIH1cbiAgc3RhdGVCZWZvcmVDb21tZW50KGMpIHtcbiAgICBpZiAoYyA9PT0gNDUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSAyODtcbiAgICAgIHRoaXMuY3VycmVudFNlcXVlbmNlID0gU2VxdWVuY2VzLkNvbW1lbnRFbmQ7XG4gICAgICB0aGlzLnNlcXVlbmNlSW5kZXggPSAyO1xuICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IDIzO1xuICAgIH1cbiAgfVxuICBzdGF0ZUluU3BlY2lhbENvbW1lbnQoYykge1xuICAgIGlmIChjID09PSA2MiB8fCB0aGlzLmZhc3RGb3J3YXJkVG8oNjIpKSB7XG4gICAgICB0aGlzLmNicy5vbmNvbW1lbnQodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgdGhpcy5zdGF0ZSA9IDE7XG4gICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxO1xuICAgIH1cbiAgfVxuICBzdGF0ZUJlZm9yZVNwZWNpYWxTKGMpIHtcbiAgICBpZiAoYyA9PT0gU2VxdWVuY2VzLlNjcmlwdEVuZFszXSkge1xuICAgICAgdGhpcy5zdGFydFNwZWNpYWwoU2VxdWVuY2VzLlNjcmlwdEVuZCwgNCk7XG4gICAgfSBlbHNlIGlmIChjID09PSBTZXF1ZW5jZXMuU3R5bGVFbmRbM10pIHtcbiAgICAgIHRoaXMuc3RhcnRTcGVjaWFsKFNlcXVlbmNlcy5TdHlsZUVuZCwgNCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUgPSA2O1xuICAgICAgdGhpcy5zdGF0ZUluVGFnTmFtZShjKTtcbiAgICB9XG4gIH1cbiAgc3RhdGVCZWZvcmVTcGVjaWFsVChjKSB7XG4gICAgaWYgKGMgPT09IFNlcXVlbmNlcy5UaXRsZUVuZFszXSkge1xuICAgICAgdGhpcy5zdGFydFNwZWNpYWwoU2VxdWVuY2VzLlRpdGxlRW5kLCA0KTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IFNlcXVlbmNlcy5UZXh0YXJlYUVuZFszXSkge1xuICAgICAgdGhpcy5zdGFydFNwZWNpYWwoU2VxdWVuY2VzLlRleHRhcmVhRW5kLCA0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IDY7XG4gICAgICB0aGlzLnN0YXRlSW5UYWdOYW1lKGMpO1xuICAgIH1cbiAgfVxuICBzdGFydEVudGl0eSgpIHtcbiAgfVxuICBzdGF0ZUluRW50aXR5KCkge1xuICB9XG4gIC8qKlxuICAgKiBJdGVyYXRlcyB0aHJvdWdoIHRoZSBidWZmZXIsIGNhbGxpbmcgdGhlIGZ1bmN0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqXG4gICAqIFN0YXRlcyB0aGF0IGFyZSBtb3JlIGxpa2VseSB0byBiZSBoaXQgYXJlIGhpZ2hlciB1cCwgYXMgYSBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudC5cbiAgICovXG4gIHBhcnNlKGlucHV0KSB7XG4gICAgdGhpcy5idWZmZXIgPSBpbnB1dDtcbiAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgY29uc3QgYyA9IHRoaXMuYnVmZmVyLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XG4gICAgICBpZiAoYyA9PT0gMTAgJiYgdGhpcy5zdGF0ZSAhPT0gMzMpIHtcbiAgICAgICAgdGhpcy5uZXdsaW5lcy5wdXNoKHRoaXMuaW5kZXgpO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgMToge1xuICAgICAgICAgIHRoaXMuc3RhdGVUZXh0KGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgIHRoaXMuc3RhdGVJbnRlcnBvbGF0aW9uT3BlbihjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlSW50ZXJwb2xhdGlvbihjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlSW50ZXJwb2xhdGlvbkNsb3NlKGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzE6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlU3BlY2lhbFN0YXJ0U2VxdWVuY2UoYyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzMjoge1xuICAgICAgICAgIHRoaXMuc3RhdGVJblJDREFUQShjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDI2OiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUNEQVRBU2VxdWVuY2UoYyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxOToge1xuICAgICAgICAgIHRoaXMuc3RhdGVJbkF0dHJWYWx1ZURvdWJsZVF1b3RlcyhjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDEyOiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUluQXR0ck5hbWUoYyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxMzoge1xuICAgICAgICAgIHRoaXMuc3RhdGVJbkRpck5hbWUoYyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxNDoge1xuICAgICAgICAgIHRoaXMuc3RhdGVJbkRpckFyZyhjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDE1OiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUluRHluYW1pY0RpckFyZyhjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDE2OiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUluRGlyTW9kaWZpZXIoYyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyODoge1xuICAgICAgICAgIHRoaXMuc3RhdGVJbkNvbW1lbnRMaWtlKGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjc6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlSW5TcGVjaWFsQ29tbWVudChjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDExOiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUF0dHJOYW1lKGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNjoge1xuICAgICAgICAgIHRoaXMuc3RhdGVJblRhZ05hbWUoYyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzNDoge1xuICAgICAgICAgIHRoaXMuc3RhdGVJblNGQ1Jvb3RUYWdOYW1lKGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgOToge1xuICAgICAgICAgIHRoaXMuc3RhdGVJbkNsb3NpbmdUYWdOYW1lKGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNToge1xuICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVUYWdOYW1lKGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTc6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlQWZ0ZXJBdHRyTmFtZShjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIwOiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUluQXR0clZhbHVlU2luZ2xlUXVvdGVzKGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTg6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQXR0clZhbHVlKGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgODoge1xuICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVDbG9zaW5nVGFnTmFtZShjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDEwOiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUFmdGVyQ2xvc2luZ1RhZ05hbWUoYyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyOToge1xuICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVTcGVjaWFsUyhjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMwOiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZVNwZWNpYWxUKGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjE6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlSW5BdHRyVmFsdWVOb1F1b3RlcyhjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDc6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlSW5TZWxmQ2xvc2luZ1RhZyhjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIzOiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUluRGVjbGFyYXRpb24oYyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyMjoge1xuICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVEZWNsYXJhdGlvbihjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDI1OiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUNvbW1lbnQoYyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyNDoge1xuICAgICAgICAgIHRoaXMuc3RhdGVJblByb2Nlc3NpbmdJbnN0cnVjdGlvbihjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMzOiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUluRW50aXR5KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuaW5kZXgrKztcbiAgICB9XG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgdGhpcy5maW5pc2goKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGRhdGEgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGNvbnN1bWVkIGZyb20gdGhlIGJ1ZmZlci5cbiAgICovXG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuc2VjdGlvblN0YXJ0ICE9PSB0aGlzLmluZGV4KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gMSB8fCB0aGlzLnN0YXRlID09PSAzMiAmJiB0aGlzLnNlcXVlbmNlSW5kZXggPT09IDApIHtcbiAgICAgICAgdGhpcy5jYnMub250ZXh0KHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAxOSB8fCB0aGlzLnN0YXRlID09PSAyMCB8fCB0aGlzLnN0YXRlID09PSAyMSkge1xuICAgICAgICB0aGlzLmNicy5vbmF0dHJpYmRhdGEodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbmlzaCgpIHtcbiAgICB0aGlzLmhhbmRsZVRyYWlsaW5nRGF0YSgpO1xuICAgIHRoaXMuY2JzLm9uZW5kKCk7XG4gIH1cbiAgLyoqIEhhbmRsZSBhbnkgdHJhaWxpbmcgZGF0YS4gKi9cbiAgaGFuZGxlVHJhaWxpbmdEYXRhKCkge1xuICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgIGlmICh0aGlzLnNlY3Rpb25TdGFydCA+PSBlbmRJbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gMjgpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9PT0gU2VxdWVuY2VzLkNkYXRhRW5kKSB7XG4gICAgICAgIHRoaXMuY2JzLm9uY2RhdGEodGhpcy5zZWN0aW9uU3RhcnQsIGVuZEluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2JzLm9uY29tbWVudCh0aGlzLnNlY3Rpb25TdGFydCwgZW5kSW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gNiB8fCB0aGlzLnN0YXRlID09PSAxMSB8fCB0aGlzLnN0YXRlID09PSAxOCB8fCB0aGlzLnN0YXRlID09PSAxNyB8fCB0aGlzLnN0YXRlID09PSAxMiB8fCB0aGlzLnN0YXRlID09PSAxMyB8fCB0aGlzLnN0YXRlID09PSAxNCB8fCB0aGlzLnN0YXRlID09PSAxNSB8fCB0aGlzLnN0YXRlID09PSAxNiB8fCB0aGlzLnN0YXRlID09PSAyMCB8fCB0aGlzLnN0YXRlID09PSAxOSB8fCB0aGlzLnN0YXRlID09PSAyMSB8fCB0aGlzLnN0YXRlID09PSA5KSA7IGVsc2Uge1xuICAgICAgdGhpcy5jYnMub250ZXh0KHRoaXMuc2VjdGlvblN0YXJ0LCBlbmRJbmRleCk7XG4gICAgfVxuICB9XG4gIGVtaXRDb2RlUG9pbnQoY3AsIGNvbnN1bWVkKSB7XG4gIH1cbn1cblxuY29uc3QgQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzID0ge1xuICBcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIjogXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIsXG4gIFwiQ09NUElMRVJfVl9CSU5EX1NZTkNcIjogXCJDT01QSUxFUl9WX0JJTkRfU1lOQ1wiLFxuICBcIkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVJcIjogXCJDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSXCIsXG4gIFwiQ09NUElMRVJfVl9PTl9OQVRJVkVcIjogXCJDT01QSUxFUl9WX09OX05BVElWRVwiLFxuICBcIkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRVwiOiBcIkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRVwiLFxuICBcIkNPTVBJTEVSX05BVElWRV9URU1QTEFURVwiOiBcIkNPTVBJTEVSX05BVElWRV9URU1QTEFURVwiLFxuICBcIkNPTVBJTEVSX0lOTElORV9URU1QTEFURVwiOiBcIkNPTVBJTEVSX0lOTElORV9URU1QTEFURVwiLFxuICBcIkNPTVBJTEVSX0ZJTFRFUlNcIjogXCJDT01QSUxFUl9GSUxURVJTXCJcbn07XG5jb25zdCBkZXByZWNhdGlvbkRhdGEgPSB7XG4gIFtcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIl06IHtcbiAgICBtZXNzYWdlOiBgUGxhdGZvcm0tbmF0aXZlIGVsZW1lbnRzIHdpdGggXCJpc1wiIHByb3Agd2lsbCBubyBsb25nZXIgYmUgdHJlYXRlZCBhcyBjb21wb25lbnRzIGluIFZ1ZSAzIHVubGVzcyB0aGUgXCJpc1wiIHZhbHVlIGlzIGV4cGxpY2l0bHkgcHJlZml4ZWQgd2l0aCBcInZ1ZTpcIi5gLFxuICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9jdXN0b20tZWxlbWVudHMtaW50ZXJvcC5odG1sYFxuICB9LFxuICBbXCJDT01QSUxFUl9WX0JJTkRfU1lOQ1wiXToge1xuICAgIG1lc3NhZ2U6IChrZXkpID0+IGAuc3luYyBtb2RpZmllciBmb3Igdi1iaW5kIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2LW1vZGVsIHdpdGggYXJndW1lbnQgaW5zdGVhZC4gXFxgdi1iaW5kOiR7a2V5fS5zeW5jXFxgIHNob3VsZCBiZSBjaGFuZ2VkIHRvIFxcYHYtbW9kZWw6JHtrZXl9XFxgLmAsXG4gICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3YtbW9kZWwuaHRtbGBcbiAgfSxcbiAgW1wiQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUlwiXToge1xuICAgIG1lc3NhZ2U6IGB2LWJpbmQ9XCJvYmpcIiB1c2FnZSBpcyBub3cgb3JkZXIgc2Vuc2l0aXZlIGFuZCBiZWhhdmVzIGxpa2UgSmF2YVNjcmlwdCBvYmplY3Qgc3ByZWFkOiBpdCB3aWxsIG5vdyBvdmVyd3JpdGUgYW4gZXhpc3Rpbmcgbm9uLW1lcmdlYWJsZSBhdHRyaWJ1dGUgdGhhdCBhcHBlYXJzIGJlZm9yZSB2LWJpbmQgaW4gdGhlIGNhc2Ugb2YgY29uZmxpY3QuIFRvIHJldGFpbiAyLnggYmVoYXZpb3IsIG1vdmUgdi1iaW5kIHRvIG1ha2UgaXQgdGhlIGZpcnN0IGF0dHJpYnV0ZS4gWW91IGNhbiBhbHNvIHN1cHByZXNzIHRoaXMgd2FybmluZyBpZiB0aGUgdXNhZ2UgaXMgaW50ZW5kZWQuYCxcbiAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvdi1iaW5kLmh0bWxgXG4gIH0sXG4gIFtcIkNPTVBJTEVSX1ZfT05fTkFUSVZFXCJdOiB7XG4gICAgbWVzc2FnZTogYC5uYXRpdmUgbW9kaWZpZXIgZm9yIHYtb24gaGFzIGJlZW4gcmVtb3ZlZCBhcyBpcyBubyBsb25nZXIgbmVjZXNzYXJ5LmAsXG4gICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3Ytb24tbmF0aXZlLW1vZGlmaWVyLXJlbW92ZWQuaHRtbGBcbiAgfSxcbiAgW1wiQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFXCJdOiB7XG4gICAgbWVzc2FnZTogYHYtaWYgLyB2LWZvciBwcmVjZWRlbmNlIHdoZW4gdXNlZCBvbiB0aGUgc2FtZSBlbGVtZW50IGhhcyBjaGFuZ2VkIGluIFZ1ZSAzOiB2LWlmIG5vdyB0YWtlcyBoaWdoZXIgcHJlY2VkZW5jZSBhbmQgd2lsbCBubyBsb25nZXIgaGF2ZSBhY2Nlc3MgdG8gdi1mb3Igc2NvcGUgdmFyaWFibGVzLiBJdCBpcyBiZXN0IHRvIGF2b2lkIHRoZSBhbWJpZ3VpdHkgd2l0aCA8dGVtcGxhdGU+IHRhZ3Mgb3IgdXNlIGEgY29tcHV0ZWQgcHJvcGVydHkgdGhhdCBmaWx0ZXJzIHYtZm9yIGRhdGEgc291cmNlLmAsXG4gICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3YtaWYtdi1mb3IuaHRtbGBcbiAgfSxcbiAgW1wiQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFXCJdOiB7XG4gICAgbWVzc2FnZTogYDx0ZW1wbGF0ZT4gd2l0aCBubyBzcGVjaWFsIGRpcmVjdGl2ZXMgd2lsbCByZW5kZXIgYXMgYSBuYXRpdmUgdGVtcGxhdGUgZWxlbWVudCBpbnN0ZWFkIG9mIGl0cyBpbm5lciBjb250ZW50IGluIFZ1ZSAzLmBcbiAgfSxcbiAgW1wiQ09NUElMRVJfSU5MSU5FX1RFTVBMQVRFXCJdOiB7XG4gICAgbWVzc2FnZTogYFwiaW5saW5lLXRlbXBsYXRlXCIgaGFzIGJlZW4gcmVtb3ZlZCBpbiBWdWUgMy5gLFxuICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9pbmxpbmUtdGVtcGxhdGUtYXR0cmlidXRlLmh0bWxgXG4gIH0sXG4gIFtcIkNPTVBJTEVSX0ZJTFRFUlNcIl06IHtcbiAgICBtZXNzYWdlOiBgZmlsdGVycyBoYXZlIGJlZW4gcmVtb3ZlZCBpbiBWdWUgMy4gVGhlIFwifFwiIHN5bWJvbCB3aWxsIGJlIHRyZWF0ZWQgYXMgbmF0aXZlIEphdmFTY3JpcHQgYml0d2lzZSBPUiBvcGVyYXRvci4gVXNlIG1ldGhvZCBjYWxscyBvciBjb21wdXRlZCBwcm9wZXJ0aWVzIGluc3RlYWQuYCxcbiAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvZmlsdGVycy5odG1sYFxuICB9XG59O1xuZnVuY3Rpb24gZ2V0Q29tcGF0VmFsdWUoa2V5LCB7IGNvbXBhdENvbmZpZyB9KSB7XG4gIGNvbnN0IHZhbHVlID0gY29tcGF0Q29uZmlnICYmIGNvbXBhdENvbmZpZ1trZXldO1xuICBpZiAoa2V5ID09PSBcIk1PREVcIikge1xuICAgIHJldHVybiB2YWx1ZSB8fCAzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNDb21wYXRFbmFibGVkKGtleSwgY29udGV4dCkge1xuICBjb25zdCBtb2RlID0gZ2V0Q29tcGF0VmFsdWUoXCJNT0RFXCIsIGNvbnRleHQpO1xuICBjb25zdCB2YWx1ZSA9IGdldENvbXBhdFZhbHVlKGtleSwgY29udGV4dCk7XG4gIHJldHVybiBtb2RlID09PSAzID8gdmFsdWUgPT09IHRydWUgOiB2YWx1ZSAhPT0gZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja0NvbXBhdEVuYWJsZWQoa2V5LCBjb250ZXh0LCBsb2MsIC4uLmFyZ3MpIHtcbiAgY29uc3QgZW5hYmxlZCA9IGlzQ29tcGF0RW5hYmxlZChrZXksIGNvbnRleHQpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBlbmFibGVkKSB7XG4gICAgd2FybkRlcHJlY2F0aW9uKGtleSwgY29udGV4dCwgbG9jLCAuLi5hcmdzKTtcbiAgfVxuICByZXR1cm4gZW5hYmxlZDtcbn1cbmZ1bmN0aW9uIHdhcm5EZXByZWNhdGlvbihrZXksIGNvbnRleHQsIGxvYywgLi4uYXJncykge1xuICBjb25zdCB2YWwgPSBnZXRDb21wYXRWYWx1ZShrZXksIGNvbnRleHQpO1xuICBpZiAodmFsID09PSBcInN1cHByZXNzLXdhcm5pbmdcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7IG1lc3NhZ2UsIGxpbmsgfSA9IGRlcHJlY2F0aW9uRGF0YVtrZXldO1xuICBjb25zdCBtc2cgPSBgKGRlcHJlY2F0aW9uICR7a2V5fSkgJHt0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiID8gbWVzc2FnZSguLi5hcmdzKSA6IG1lc3NhZ2V9JHtsaW5rID8gYFxuICBEZXRhaWxzOiAke2xpbmt9YCA6IGBgfWA7XG4gIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihtc2cpO1xuICBlcnIuY29kZSA9IGtleTtcbiAgaWYgKGxvYykgZXJyLmxvYyA9IGxvYztcbiAgY29udGV4dC5vbldhcm4oZXJyKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3IoZXJyb3IpIHtcbiAgdGhyb3cgZXJyb3I7XG59XG5mdW5jdGlvbiBkZWZhdWx0T25XYXJuKG1zZykge1xuICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbnNvbGUud2FybihgW1Z1ZSB3YXJuXSAke21zZy5tZXNzYWdlfWApO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJFcnJvcihjb2RlLCBsb2MsIG1lc3NhZ2VzLCBhZGRpdGlvbmFsTWVzc2FnZSkge1xuICBjb25zdCBtc2cgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZhbHNlID8gKG1lc3NhZ2VzIHx8IGVycm9yTWVzc2FnZXMpW2NvZGVdICsgKGFkZGl0aW9uYWxNZXNzYWdlIHx8IGBgKSA6IGBodHRwczovL3Z1ZWpzLm9yZy9lcnJvci1yZWZlcmVuY2UvI2NvbXBpbGVyLSR7Y29kZX1gO1xuICBjb25zdCBlcnJvciA9IG5ldyBTeW50YXhFcnJvcihTdHJpbmcobXNnKSk7XG4gIGVycm9yLmNvZGUgPSBjb2RlO1xuICBlcnJvci5sb2MgPSBsb2M7XG4gIHJldHVybiBlcnJvcjtcbn1cbmNvbnN0IEVycm9yQ29kZXMgPSB7XG4gIFwiQUJSVVBUX0NMT1NJTkdfT0ZfRU1QVFlfQ09NTUVOVFwiOiAwLFxuICBcIjBcIjogXCJBQlJVUFRfQ0xPU0lOR19PRl9FTVBUWV9DT01NRU5UXCIsXG4gIFwiQ0RBVEFfSU5fSFRNTF9DT05URU5UXCI6IDEsXG4gIFwiMVwiOiBcIkNEQVRBX0lOX0hUTUxfQ09OVEVOVFwiLFxuICBcIkRVUExJQ0FURV9BVFRSSUJVVEVcIjogMixcbiAgXCIyXCI6IFwiRFVQTElDQVRFX0FUVFJJQlVURVwiLFxuICBcIkVORF9UQUdfV0lUSF9BVFRSSUJVVEVTXCI6IDMsXG4gIFwiM1wiOiBcIkVORF9UQUdfV0lUSF9BVFRSSUJVVEVTXCIsXG4gIFwiRU5EX1RBR19XSVRIX1RSQUlMSU5HX1NPTElEVVNcIjogNCxcbiAgXCI0XCI6IFwiRU5EX1RBR19XSVRIX1RSQUlMSU5HX1NPTElEVVNcIixcbiAgXCJFT0ZfQkVGT1JFX1RBR19OQU1FXCI6IDUsXG4gIFwiNVwiOiBcIkVPRl9CRUZPUkVfVEFHX05BTUVcIixcbiAgXCJFT0ZfSU5fQ0RBVEFcIjogNixcbiAgXCI2XCI6IFwiRU9GX0lOX0NEQVRBXCIsXG4gIFwiRU9GX0lOX0NPTU1FTlRcIjogNyxcbiAgXCI3XCI6IFwiRU9GX0lOX0NPTU1FTlRcIixcbiAgXCJFT0ZfSU5fU0NSSVBUX0hUTUxfQ09NTUVOVF9MSUtFX1RFWFRcIjogOCxcbiAgXCI4XCI6IFwiRU9GX0lOX1NDUklQVF9IVE1MX0NPTU1FTlRfTElLRV9URVhUXCIsXG4gIFwiRU9GX0lOX1RBR1wiOiA5LFxuICBcIjlcIjogXCJFT0ZfSU5fVEFHXCIsXG4gIFwiSU5DT1JSRUNUTFlfQ0xPU0VEX0NPTU1FTlRcIjogMTAsXG4gIFwiMTBcIjogXCJJTkNPUlJFQ1RMWV9DTE9TRURfQ09NTUVOVFwiLFxuICBcIklOQ09SUkVDVExZX09QRU5FRF9DT01NRU5UXCI6IDExLFxuICBcIjExXCI6IFwiSU5DT1JSRUNUTFlfT1BFTkVEX0NPTU1FTlRcIixcbiAgXCJJTlZBTElEX0ZJUlNUX0NIQVJBQ1RFUl9PRl9UQUdfTkFNRVwiOiAxMixcbiAgXCIxMlwiOiBcIklOVkFMSURfRklSU1RfQ0hBUkFDVEVSX09GX1RBR19OQU1FXCIsXG4gIFwiTUlTU0lOR19BVFRSSUJVVEVfVkFMVUVcIjogMTMsXG4gIFwiMTNcIjogXCJNSVNTSU5HX0FUVFJJQlVURV9WQUxVRVwiLFxuICBcIk1JU1NJTkdfRU5EX1RBR19OQU1FXCI6IDE0LFxuICBcIjE0XCI6IFwiTUlTU0lOR19FTkRfVEFHX05BTUVcIixcbiAgXCJNSVNTSU5HX1dISVRFU1BBQ0VfQkVUV0VFTl9BVFRSSUJVVEVTXCI6IDE1LFxuICBcIjE1XCI6IFwiTUlTU0lOR19XSElURVNQQUNFX0JFVFdFRU5fQVRUUklCVVRFU1wiLFxuICBcIk5FU1RFRF9DT01NRU5UXCI6IDE2LFxuICBcIjE2XCI6IFwiTkVTVEVEX0NPTU1FTlRcIixcbiAgXCJVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9BVFRSSUJVVEVfTkFNRVwiOiAxNyxcbiAgXCIxN1wiOiBcIlVORVhQRUNURURfQ0hBUkFDVEVSX0lOX0FUVFJJQlVURV9OQU1FXCIsXG4gIFwiVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fVU5RVU9URURfQVRUUklCVVRFX1ZBTFVFXCI6IDE4LFxuICBcIjE4XCI6IFwiVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fVU5RVU9URURfQVRUUklCVVRFX1ZBTFVFXCIsXG4gIFwiVU5FWFBFQ1RFRF9FUVVBTFNfU0lHTl9CRUZPUkVfQVRUUklCVVRFX05BTUVcIjogMTksXG4gIFwiMTlcIjogXCJVTkVYUEVDVEVEX0VRVUFMU19TSUdOX0JFRk9SRV9BVFRSSUJVVEVfTkFNRVwiLFxuICBcIlVORVhQRUNURURfTlVMTF9DSEFSQUNURVJcIjogMjAsXG4gIFwiMjBcIjogXCJVTkVYUEVDVEVEX05VTExfQ0hBUkFDVEVSXCIsXG4gIFwiVU5FWFBFQ1RFRF9RVUVTVElPTl9NQVJLX0lOU1RFQURfT0ZfVEFHX05BTUVcIjogMjEsXG4gIFwiMjFcIjogXCJVTkVYUEVDVEVEX1FVRVNUSU9OX01BUktfSU5TVEVBRF9PRl9UQUdfTkFNRVwiLFxuICBcIlVORVhQRUNURURfU09MSURVU19JTl9UQUdcIjogMjIsXG4gIFwiMjJcIjogXCJVTkVYUEVDVEVEX1NPTElEVVNfSU5fVEFHXCIsXG4gIFwiWF9JTlZBTElEX0VORF9UQUdcIjogMjMsXG4gIFwiMjNcIjogXCJYX0lOVkFMSURfRU5EX1RBR1wiLFxuICBcIlhfTUlTU0lOR19FTkRfVEFHXCI6IDI0LFxuICBcIjI0XCI6IFwiWF9NSVNTSU5HX0VORF9UQUdcIixcbiAgXCJYX01JU1NJTkdfSU5URVJQT0xBVElPTl9FTkRcIjogMjUsXG4gIFwiMjVcIjogXCJYX01JU1NJTkdfSU5URVJQT0xBVElPTl9FTkRcIixcbiAgXCJYX01JU1NJTkdfRElSRUNUSVZFX05BTUVcIjogMjYsXG4gIFwiMjZcIjogXCJYX01JU1NJTkdfRElSRUNUSVZFX05BTUVcIixcbiAgXCJYX01JU1NJTkdfRFlOQU1JQ19ESVJFQ1RJVkVfQVJHVU1FTlRfRU5EXCI6IDI3LFxuICBcIjI3XCI6IFwiWF9NSVNTSU5HX0RZTkFNSUNfRElSRUNUSVZFX0FSR1VNRU5UX0VORFwiLFxuICBcIlhfVl9JRl9OT19FWFBSRVNTSU9OXCI6IDI4LFxuICBcIjI4XCI6IFwiWF9WX0lGX05PX0VYUFJFU1NJT05cIixcbiAgXCJYX1ZfSUZfU0FNRV9LRVlcIjogMjksXG4gIFwiMjlcIjogXCJYX1ZfSUZfU0FNRV9LRVlcIixcbiAgXCJYX1ZfRUxTRV9OT19BREpBQ0VOVF9JRlwiOiAzMCxcbiAgXCIzMFwiOiBcIlhfVl9FTFNFX05PX0FESkFDRU5UX0lGXCIsXG4gIFwiWF9WX0ZPUl9OT19FWFBSRVNTSU9OXCI6IDMxLFxuICBcIjMxXCI6IFwiWF9WX0ZPUl9OT19FWFBSRVNTSU9OXCIsXG4gIFwiWF9WX0ZPUl9NQUxGT1JNRURfRVhQUkVTU0lPTlwiOiAzMixcbiAgXCIzMlwiOiBcIlhfVl9GT1JfTUFMRk9STUVEX0VYUFJFU1NJT05cIixcbiAgXCJYX1ZfRk9SX1RFTVBMQVRFX0tFWV9QTEFDRU1FTlRcIjogMzMsXG4gIFwiMzNcIjogXCJYX1ZfRk9SX1RFTVBMQVRFX0tFWV9QTEFDRU1FTlRcIixcbiAgXCJYX1ZfQklORF9OT19FWFBSRVNTSU9OXCI6IDM0LFxuICBcIjM0XCI6IFwiWF9WX0JJTkRfTk9fRVhQUkVTU0lPTlwiLFxuICBcIlhfVl9PTl9OT19FWFBSRVNTSU9OXCI6IDM1LFxuICBcIjM1XCI6IFwiWF9WX09OX05PX0VYUFJFU1NJT05cIixcbiAgXCJYX1ZfU0xPVF9VTkVYUEVDVEVEX0RJUkVDVElWRV9PTl9TTE9UX09VVExFVFwiOiAzNixcbiAgXCIzNlwiOiBcIlhfVl9TTE9UX1VORVhQRUNURURfRElSRUNUSVZFX09OX1NMT1RfT1VUTEVUXCIsXG4gIFwiWF9WX1NMT1RfTUlYRURfU0xPVF9VU0FHRVwiOiAzNyxcbiAgXCIzN1wiOiBcIlhfVl9TTE9UX01JWEVEX1NMT1RfVVNBR0VcIixcbiAgXCJYX1ZfU0xPVF9EVVBMSUNBVEVfU0xPVF9OQU1FU1wiOiAzOCxcbiAgXCIzOFwiOiBcIlhfVl9TTE9UX0RVUExJQ0FURV9TTE9UX05BTUVTXCIsXG4gIFwiWF9WX1NMT1RfRVhUUkFORU9VU19ERUZBVUxUX1NMT1RfQ0hJTERSRU5cIjogMzksXG4gIFwiMzlcIjogXCJYX1ZfU0xPVF9FWFRSQU5FT1VTX0RFRkFVTFRfU0xPVF9DSElMRFJFTlwiLFxuICBcIlhfVl9TTE9UX01JU1BMQUNFRFwiOiA0MCxcbiAgXCI0MFwiOiBcIlhfVl9TTE9UX01JU1BMQUNFRFwiLFxuICBcIlhfVl9NT0RFTF9OT19FWFBSRVNTSU9OXCI6IDQxLFxuICBcIjQxXCI6IFwiWF9WX01PREVMX05PX0VYUFJFU1NJT05cIixcbiAgXCJYX1ZfTU9ERUxfTUFMRk9STUVEX0VYUFJFU1NJT05cIjogNDIsXG4gIFwiNDJcIjogXCJYX1ZfTU9ERUxfTUFMRk9STUVEX0VYUFJFU1NJT05cIixcbiAgXCJYX1ZfTU9ERUxfT05fU0NPUEVfVkFSSUFCTEVcIjogNDMsXG4gIFwiNDNcIjogXCJYX1ZfTU9ERUxfT05fU0NPUEVfVkFSSUFCTEVcIixcbiAgXCJYX1ZfTU9ERUxfT05fUFJPUFNcIjogNDQsXG4gIFwiNDRcIjogXCJYX1ZfTU9ERUxfT05fUFJPUFNcIixcbiAgXCJYX1ZfTU9ERUxfT05fQ09OU1RcIjogNDUsXG4gIFwiNDVcIjogXCJYX1ZfTU9ERUxfT05fQ09OU1RcIixcbiAgXCJYX0lOVkFMSURfRVhQUkVTU0lPTlwiOiA0NixcbiAgXCI0NlwiOiBcIlhfSU5WQUxJRF9FWFBSRVNTSU9OXCIsXG4gIFwiWF9LRUVQX0FMSVZFX0lOVkFMSURfQ0hJTERSRU5cIjogNDcsXG4gIFwiNDdcIjogXCJYX0tFRVBfQUxJVkVfSU5WQUxJRF9DSElMRFJFTlwiLFxuICBcIlhfUFJFRklYX0lEX05PVF9TVVBQT1JURURcIjogNDgsXG4gIFwiNDhcIjogXCJYX1BSRUZJWF9JRF9OT1RfU1VQUE9SVEVEXCIsXG4gIFwiWF9NT0RVTEVfTU9ERV9OT1RfU1VQUE9SVEVEXCI6IDQ5LFxuICBcIjQ5XCI6IFwiWF9NT0RVTEVfTU9ERV9OT1RfU1VQUE9SVEVEXCIsXG4gIFwiWF9DQUNIRV9IQU5ETEVSX05PVF9TVVBQT1JURURcIjogNTAsXG4gIFwiNTBcIjogXCJYX0NBQ0hFX0hBTkRMRVJfTk9UX1NVUFBPUlRFRFwiLFxuICBcIlhfU0NPUEVfSURfTk9UX1NVUFBPUlRFRFwiOiA1MSxcbiAgXCI1MVwiOiBcIlhfU0NPUEVfSURfTk9UX1NVUFBPUlRFRFwiLFxuICBcIlhfVk5PREVfSE9PS1NcIjogNTIsXG4gIFwiNTJcIjogXCJYX1ZOT0RFX0hPT0tTXCIsXG4gIFwiWF9WX0JJTkRfSU5WQUxJRF9TQU1FX05BTUVfQVJHVU1FTlRcIjogNTMsXG4gIFwiNTNcIjogXCJYX1ZfQklORF9JTlZBTElEX1NBTUVfTkFNRV9BUkdVTUVOVFwiLFxuICBcIl9fRVhURU5EX1BPSU5UX19cIjogNTQsXG4gIFwiNTRcIjogXCJfX0VYVEVORF9QT0lOVF9fXCJcbn07XG5jb25zdCBlcnJvck1lc3NhZ2VzID0ge1xuICAvLyBwYXJzZSBlcnJvcnNcbiAgWzBdOiBcIklsbGVnYWwgY29tbWVudC5cIixcbiAgWzFdOiBcIkNEQVRBIHNlY3Rpb24gaXMgYWxsb3dlZCBvbmx5IGluIFhNTCBjb250ZXh0LlwiLFxuICBbMl06IFwiRHVwbGljYXRlIGF0dHJpYnV0ZS5cIixcbiAgWzNdOiBcIkVuZCB0YWcgY2Fubm90IGhhdmUgYXR0cmlidXRlcy5cIixcbiAgWzRdOiBcIklsbGVnYWwgJy8nIGluIHRhZ3MuXCIsXG4gIFs1XTogXCJVbmV4cGVjdGVkIEVPRiBpbiB0YWcuXCIsXG4gIFs2XTogXCJVbmV4cGVjdGVkIEVPRiBpbiBDREFUQSBzZWN0aW9uLlwiLFxuICBbN106IFwiVW5leHBlY3RlZCBFT0YgaW4gY29tbWVudC5cIixcbiAgWzhdOiBcIlVuZXhwZWN0ZWQgRU9GIGluIHNjcmlwdC5cIixcbiAgWzldOiBcIlVuZXhwZWN0ZWQgRU9GIGluIHRhZy5cIixcbiAgWzEwXTogXCJJbmNvcnJlY3RseSBjbG9zZWQgY29tbWVudC5cIixcbiAgWzExXTogXCJJbmNvcnJlY3RseSBvcGVuZWQgY29tbWVudC5cIixcbiAgWzEyXTogXCJJbGxlZ2FsIHRhZyBuYW1lLiBVc2UgJyZsdDsnIHRvIHByaW50ICc8Jy5cIixcbiAgWzEzXTogXCJBdHRyaWJ1dGUgdmFsdWUgd2FzIGV4cGVjdGVkLlwiLFxuICBbMTRdOiBcIkVuZCB0YWcgbmFtZSB3YXMgZXhwZWN0ZWQuXCIsXG4gIFsxNV06IFwiV2hpdGVzcGFjZSB3YXMgZXhwZWN0ZWQuXCIsXG4gIFsxNl06IFwiVW5leHBlY3RlZCAnPCEtLScgaW4gY29tbWVudC5cIixcbiAgWzE3XTogYEF0dHJpYnV0ZSBuYW1lIGNhbm5vdCBjb250YWluIFUrMDAyMiAoXCIpLCBVKzAwMjcgKCcpLCBhbmQgVSswMDNDICg8KS5gLFxuICBbMThdOiBcIlVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZSBjYW5ub3QgY29udGFpbiBVKzAwMjIgKFxcXCIpLCBVKzAwMjcgKCcpLCBVKzAwM0MgKDwpLCBVKzAwM0QgKD0pLCBhbmQgVSswMDYwIChgKS5cIixcbiAgWzE5XTogXCJBdHRyaWJ1dGUgbmFtZSBjYW5ub3Qgc3RhcnQgd2l0aCAnPScuXCIsXG4gIFsyMV06IFwiJzw/JyBpcyBhbGxvd2VkIG9ubHkgaW4gWE1MIGNvbnRleHQuXCIsXG4gIFsyMF06IGBVbmV4cGVjdGVkIG51bGwgY2hhcmFjdGVyLmAsXG4gIFsyMl06IFwiSWxsZWdhbCAnLycgaW4gdGFncy5cIixcbiAgLy8gVnVlLXNwZWNpZmljIHBhcnNlIGVycm9yc1xuICBbMjNdOiBcIkludmFsaWQgZW5kIHRhZy5cIixcbiAgWzI0XTogXCJFbGVtZW50IGlzIG1pc3NpbmcgZW5kIHRhZy5cIixcbiAgWzI1XTogXCJJbnRlcnBvbGF0aW9uIGVuZCBzaWduIHdhcyBub3QgZm91bmQuXCIsXG4gIFsyN106IFwiRW5kIGJyYWNrZXQgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IHdhcyBub3QgZm91bmQuIE5vdGUgdGhhdCBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCBjYW5ub3QgY29udGFpbiBzcGFjZXMuXCIsXG4gIFsyNl06IFwiTGVnYWwgZGlyZWN0aXZlIG5hbWUgd2FzIGV4cGVjdGVkLlwiLFxuICAvLyB0cmFuc2Zvcm0gZXJyb3JzXG4gIFsyOF06IGB2LWlmL3YtZWxzZS1pZiBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcbiAgWzI5XTogYHYtaWYvZWxzZSBicmFuY2hlcyBtdXN0IHVzZSB1bmlxdWUga2V5cy5gLFxuICBbMzBdOiBgdi1lbHNlL3YtZWxzZS1pZiBoYXMgbm8gYWRqYWNlbnQgdi1pZiBvciB2LWVsc2UtaWYuYCxcbiAgWzMxXTogYHYtZm9yIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxuICBbMzJdOiBgdi1mb3IgaGFzIGludmFsaWQgZXhwcmVzc2lvbi5gLFxuICBbMzNdOiBgPHRlbXBsYXRlIHYtZm9yPiBrZXkgc2hvdWxkIGJlIHBsYWNlZCBvbiB0aGUgPHRlbXBsYXRlPiB0YWcuYCxcbiAgWzM0XTogYHYtYmluZCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcbiAgWzUzXTogYHYtYmluZCB3aXRoIHNhbWUtbmFtZSBzaG9ydGhhbmQgb25seSBhbGxvd3Mgc3RhdGljIGFyZ3VtZW50LmAsXG4gIFszNV06IGB2LW9uIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxuICBbMzZdOiBgVW5leHBlY3RlZCBjdXN0b20gZGlyZWN0aXZlIG9uIDxzbG90PiBvdXRsZXQuYCxcbiAgWzM3XTogYE1peGVkIHYtc2xvdCB1c2FnZSBvbiBib3RoIHRoZSBjb21wb25lbnQgYW5kIG5lc3RlZCA8dGVtcGxhdGU+LiBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBuYW1lZCBzbG90cywgYWxsIHNsb3RzIHNob3VsZCB1c2UgPHRlbXBsYXRlPiBzeW50YXggdG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LmAsXG4gIFszOF06IGBEdXBsaWNhdGUgc2xvdCBuYW1lcyBmb3VuZC4gYCxcbiAgWzM5XTogYEV4dHJhbmVvdXMgY2hpbGRyZW4gZm91bmQgd2hlbiBjb21wb25lbnQgYWxyZWFkeSBoYXMgZXhwbGljaXRseSBuYW1lZCBkZWZhdWx0IHNsb3QuIFRoZXNlIGNoaWxkcmVuIHdpbGwgYmUgaWdub3JlZC5gLFxuICBbNDBdOiBgdi1zbG90IGNhbiBvbmx5IGJlIHVzZWQgb24gY29tcG9uZW50cyBvciA8dGVtcGxhdGU+IHRhZ3MuYCxcbiAgWzQxXTogYHYtbW9kZWwgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXG4gIFs0Ml06IGB2LW1vZGVsIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBKYXZhU2NyaXB0IG1lbWJlciBleHByZXNzaW9uLmAsXG4gIFs0M106IGB2LW1vZGVsIGNhbm5vdCBiZSB1c2VkIG9uIHYtZm9yIG9yIHYtc2xvdCBzY29wZSB2YXJpYWJsZXMgYmVjYXVzZSB0aGV5IGFyZSBub3Qgd3JpdGFibGUuYCxcbiAgWzQ0XTogYHYtbW9kZWwgY2Fubm90IGJlIHVzZWQgb24gYSBwcm9wLCBiZWNhdXNlIGxvY2FsIHByb3AgYmluZGluZ3MgYXJlIG5vdCB3cml0YWJsZS5cblVzZSBhIHYtYmluZCBiaW5kaW5nIGNvbWJpbmVkIHdpdGggYSB2LW9uIGxpc3RlbmVyIHRoYXQgZW1pdHMgdXBkYXRlOnggZXZlbnQgaW5zdGVhZC5gLFxuICBbNDVdOiBgdi1tb2RlbCBjYW5ub3QgYmUgdXNlZCBvbiBhIGNvbnN0IGJpbmRpbmcgYmVjYXVzZSBpdCBpcyBub3Qgd3JpdGFibGUuYCxcbiAgWzQ2XTogYEVycm9yIHBhcnNpbmcgSmF2YVNjcmlwdCBleHByZXNzaW9uOiBgLFxuICBbNDddOiBgPEtlZXBBbGl2ZT4gZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCBjb21wb25lbnQuYCxcbiAgWzUyXTogYEB2bm9kZS0qIGhvb2tzIGluIHRlbXBsYXRlcyBhcmUgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gVXNlIHRoZSB2dWU6IHByZWZpeCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgQHZub2RlLW1vdW50ZWQgc2hvdWxkIGJlIGNoYW5nZWQgdG8gQHZ1ZTptb3VudGVkLiBAdm5vZGUtKiBob29rcyBzdXBwb3J0IGhhcyBiZWVuIHJlbW92ZWQgaW4gMy40LmAsXG4gIC8vIGdlbmVyaWMgZXJyb3JzXG4gIFs0OF06IGBcInByZWZpeElkZW50aWZpZXJzXCIgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBjb21waWxlci5gLFxuICBbNDldOiBgRVMgbW9kdWxlIG1vZGUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIGNvbXBpbGVyLmAsXG4gIFs1MF06IGBcImNhY2hlSGFuZGxlcnNcIiBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB0aGUgXCJwcmVmaXhJZGVudGlmaWVyc1wiIG9wdGlvbiBpcyBlbmFibGVkLmAsXG4gIFs1MV06IGBcInNjb3BlSWRcIiBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgaW4gbW9kdWxlIG1vZGUuYCxcbiAgLy8ganVzdCB0byBmdWxmaWxsIHR5cGVzXG4gIFs1NF06IGBgXG59O1xuXG5mdW5jdGlvbiB3YWxrSWRlbnRpZmllcnMocm9vdCwgb25JZGVudGlmaWVyLCBpbmNsdWRlQWxsID0gZmFsc2UsIHBhcmVudFN0YWNrID0gW10sIGtub3duSWRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpIHtcbiAge1xuICAgIHJldHVybjtcbiAgfVxufVxuZnVuY3Rpb24gaXNSZWZlcmVuY2VkSWRlbnRpZmllcihpZCwgcGFyZW50LCBwYXJlbnRTdGFjaykge1xuICB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc0luRGVzdHJ1Y3R1cmVBc3NpZ25tZW50KHBhcmVudCwgcGFyZW50U3RhY2spIHtcbiAgaWYgKHBhcmVudCAmJiAocGFyZW50LnR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIikpIHtcbiAgICBsZXQgaSA9IHBhcmVudFN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBwID0gcGFyZW50U3RhY2tbaV07XG4gICAgICBpZiAocC50eXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHAudHlwZSAhPT0gXCJPYmplY3RQcm9wZXJ0eVwiICYmICFwLnR5cGUuZW5kc1dpdGgoXCJQYXR0ZXJuXCIpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0luTmV3RXhwcmVzc2lvbihwYXJlbnRTdGFjaykge1xuICBsZXQgaSA9IHBhcmVudFN0YWNrLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGNvbnN0IHAgPSBwYXJlbnRTdGFja1tpXTtcbiAgICBpZiAocC50eXBlID09PSBcIk5ld0V4cHJlc3Npb25cIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChwLnR5cGUgIT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gd2Fsa0Z1bmN0aW9uUGFyYW1zKG5vZGUsIG9uSWRlbnQpIHtcbiAgZm9yIChjb25zdCBwIG9mIG5vZGUucGFyYW1zKSB7XG4gICAgZm9yIChjb25zdCBpZCBvZiBleHRyYWN0SWRlbnRpZmllcnMocCkpIHtcbiAgICAgIG9uSWRlbnQoaWQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gd2Fsa0Jsb2NrRGVjbGFyYXRpb25zKGJsb2NrLCBvbklkZW50KSB7XG4gIGNvbnN0IGJvZHkgPSBibG9jay50eXBlID09PSBcIlN3aXRjaENhc2VcIiA/IGJsb2NrLmNvbnNlcXVlbnQgOiBibG9jay5ib2R5O1xuICBmb3IgKGNvbnN0IHN0bXQgb2YgYm9keSkge1xuICAgIGlmIChzdG10LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKSB7XG4gICAgICBpZiAoc3RtdC5kZWNsYXJlKSBjb250aW51ZTtcbiAgICAgIGZvciAoY29uc3QgZGVjbCBvZiBzdG10LmRlY2xhcmF0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGV4dHJhY3RJZGVudGlmaWVycyhkZWNsLmlkKSkge1xuICAgICAgICAgIG9uSWRlbnQoaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdG10LnR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIHx8IHN0bXQudHlwZSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIpIHtcbiAgICAgIGlmIChzdG10LmRlY2xhcmUgfHwgIXN0bXQuaWQpIGNvbnRpbnVlO1xuICAgICAgb25JZGVudChzdG10LmlkKTtcbiAgICB9IGVsc2UgaWYgKGlzRm9yU3RhdGVtZW50KHN0bXQpKSB7XG4gICAgICB3YWxrRm9yU3RhdGVtZW50KHN0bXQsIHRydWUsIG9uSWRlbnQpO1xuICAgIH0gZWxzZSBpZiAoc3RtdC50eXBlID09PSBcIlN3aXRjaFN0YXRlbWVudFwiKSB7XG4gICAgICB3YWxrU3dpdGNoU3RhdGVtZW50KHN0bXQsIHRydWUsIG9uSWRlbnQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNGb3JTdGF0ZW1lbnQoc3RtdCkge1xuICByZXR1cm4gc3RtdC50eXBlID09PSBcIkZvck9mU3RhdGVtZW50XCIgfHwgc3RtdC50eXBlID09PSBcIkZvckluU3RhdGVtZW50XCIgfHwgc3RtdC50eXBlID09PSBcIkZvclN0YXRlbWVudFwiO1xufVxuZnVuY3Rpb24gd2Fsa0ZvclN0YXRlbWVudChzdG10LCBpc1Zhciwgb25JZGVudCkge1xuICBjb25zdCB2YXJpYWJsZSA9IHN0bXQudHlwZSA9PT0gXCJGb3JTdGF0ZW1lbnRcIiA/IHN0bXQuaW5pdCA6IHN0bXQubGVmdDtcbiAgaWYgKHZhcmlhYmxlICYmIHZhcmlhYmxlLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmICh2YXJpYWJsZS5raW5kID09PSBcInZhclwiID8gaXNWYXIgOiAhaXNWYXIpKSB7XG4gICAgZm9yIChjb25zdCBkZWNsIG9mIHZhcmlhYmxlLmRlY2xhcmF0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBpZCBvZiBleHRyYWN0SWRlbnRpZmllcnMoZGVjbC5pZCkpIHtcbiAgICAgICAgb25JZGVudChpZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB3YWxrU3dpdGNoU3RhdGVtZW50KHN0bXQsIGlzVmFyLCBvbklkZW50KSB7XG4gIGZvciAoY29uc3QgY3Mgb2Ygc3RtdC5jYXNlcykge1xuICAgIGZvciAoY29uc3Qgc3RtdDIgb2YgY3MuY29uc2VxdWVudCkge1xuICAgICAgaWYgKHN0bXQyLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmIChzdG10Mi5raW5kID09PSBcInZhclwiID8gaXNWYXIgOiAhaXNWYXIpKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGVjbCBvZiBzdG10Mi5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGV4dHJhY3RJZGVudGlmaWVycyhkZWNsLmlkKSkge1xuICAgICAgICAgICAgb25JZGVudChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHdhbGtCbG9ja0RlY2xhcmF0aW9ucyhjcywgb25JZGVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4dHJhY3RJZGVudGlmaWVycyhwYXJhbSwgbm9kZXMgPSBbXSkge1xuICBzd2l0Y2ggKHBhcmFtLnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgbm9kZXMucHVzaChwYXJhbSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgbGV0IG9iamVjdCA9IHBhcmFtO1xuICAgICAgd2hpbGUgKG9iamVjdC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgICBvYmplY3QgPSBvYmplY3Qub2JqZWN0O1xuICAgICAgfVxuICAgICAgbm9kZXMucHVzaChvYmplY3QpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwYXJhbS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIikge1xuICAgICAgICAgIGV4dHJhY3RJZGVudGlmaWVycyhwcm9wLmFyZ3VtZW50LCBub2Rlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHByb3AudmFsdWUsIG5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgcGFyYW0uZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudCkgZXh0cmFjdElkZW50aWZpZXJzKGVsZW1lbnQsIG5vZGVzKTtcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICBleHRyYWN0SWRlbnRpZmllcnMocGFyYW0uYXJndW1lbnQsIG5vZGVzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHBhcmFtLmxlZnQsIG5vZGVzKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cbmNvbnN0IGlzRnVuY3Rpb25UeXBlID0gKG5vZGUpID0+IHtcbiAgcmV0dXJuIC9GdW5jdGlvbig/OkV4cHJlc3Npb258RGVjbGFyYXRpb24pJHxNZXRob2QkLy50ZXN0KG5vZGUudHlwZSk7XG59O1xuY29uc3QgaXNTdGF0aWNQcm9wZXJ0eSA9IChub2RlKSA9PiBub2RlICYmIChub2RlLnR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIiB8fCBub2RlLnR5cGUgPT09IFwiT2JqZWN0TWV0aG9kXCIpICYmICFub2RlLmNvbXB1dGVkO1xuY29uc3QgaXNTdGF0aWNQcm9wZXJ0eUtleSA9IChub2RlLCBwYXJlbnQpID0+IGlzU3RhdGljUHJvcGVydHkocGFyZW50KSAmJiBwYXJlbnQua2V5ID09PSBub2RlO1xuY29uc3QgVFNfTk9ERV9UWVBFUyA9IFtcbiAgXCJUU0FzRXhwcmVzc2lvblwiLFxuICAvLyBmb28gYXMgbnVtYmVyXG4gIFwiVFNUeXBlQXNzZXJ0aW9uXCIsXG4gIC8vICg8bnVtYmVyPmZvbylcbiAgXCJUU05vbk51bGxFeHByZXNzaW9uXCIsXG4gIC8vIGZvbyFcbiAgXCJUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uXCIsXG4gIC8vIGZvbzxzdHJpbmc+XG4gIFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCJcbiAgLy8gZm9vIHNhdGlzZmllcyBUXG5dO1xuZnVuY3Rpb24gdW53cmFwVFNOb2RlKG5vZGUpIHtcbiAgaWYgKFRTX05PREVfVFlQRVMuaW5jbHVkZXMobm9kZS50eXBlKSkge1xuICAgIHJldHVybiB1bndyYXBUU05vZGUobm9kZS5leHByZXNzaW9uKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufVxuXG5jb25zdCBpc1N0YXRpY0V4cCA9IChwKSA9PiBwLnR5cGUgPT09IDQgJiYgcC5pc1N0YXRpYztcbmZ1bmN0aW9uIGlzQ29yZUNvbXBvbmVudCh0YWcpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIFwiVGVsZXBvcnRcIjpcbiAgICBjYXNlIFwidGVsZXBvcnRcIjpcbiAgICAgIHJldHVybiBURUxFUE9SVDtcbiAgICBjYXNlIFwiU3VzcGVuc2VcIjpcbiAgICBjYXNlIFwic3VzcGVuc2VcIjpcbiAgICAgIHJldHVybiBTVVNQRU5TRTtcbiAgICBjYXNlIFwiS2VlcEFsaXZlXCI6XG4gICAgY2FzZSBcImtlZXAtYWxpdmVcIjpcbiAgICAgIHJldHVybiBLRUVQX0FMSVZFO1xuICAgIGNhc2UgXCJCYXNlVHJhbnNpdGlvblwiOlxuICAgIGNhc2UgXCJiYXNlLXRyYW5zaXRpb25cIjpcbiAgICAgIHJldHVybiBCQVNFX1RSQU5TSVRJT047XG4gIH1cbn1cbmNvbnN0IG5vbklkZW50aWZpZXJSRSA9IC9eJHxeXFxkfFteXFwkXFx3XFx4QTAtXFx1RkZGRl0vO1xuY29uc3QgaXNTaW1wbGVJZGVudGlmaWVyID0gKG5hbWUpID0+ICFub25JZGVudGlmaWVyUkUudGVzdChuYW1lKTtcbmNvbnN0IHZhbGlkRmlyc3RJZGVudENoYXJSRSA9IC9bQS1aYS16XyRcXHhBMC1cXHVGRkZGXS87XG5jb25zdCB2YWxpZElkZW50Q2hhclJFID0gL1tcXC5cXD9cXHckXFx4QTAtXFx1RkZGRl0vO1xuY29uc3Qgd2hpdGVzcGFjZVJFID0gL1xccytbLltdXFxzKnxcXHMqWy5bXVxccysvZztcbmNvbnN0IGdldEV4cFNvdXJjZSA9IChleHApID0+IGV4cC50eXBlID09PSA0ID8gZXhwLmNvbnRlbnQgOiBleHAubG9jLnNvdXJjZTtcbmNvbnN0IGlzTWVtYmVyRXhwcmVzc2lvbkJyb3dzZXIgPSAoZXhwKSA9PiB7XG4gIGNvbnN0IHBhdGggPSBnZXRFeHBTb3VyY2UoZXhwKS50cmltKCkucmVwbGFjZSh3aGl0ZXNwYWNlUkUsIChzKSA9PiBzLnRyaW0oKSk7XG4gIGxldCBzdGF0ZSA9IDAgLyogaW5NZW1iZXJFeHAgKi87XG4gIGxldCBzdGF0ZVN0YWNrID0gW107XG4gIGxldCBjdXJyZW50T3BlbkJyYWNrZXRDb3VudCA9IDA7XG4gIGxldCBjdXJyZW50T3BlblBhcmVuc0NvdW50ID0gMDtcbiAgbGV0IGN1cnJlbnRTdHJpbmdUeXBlID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHBhdGguY2hhckF0KGkpO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgMCAvKiBpbk1lbWJlckV4cCAqLzpcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiW1wiKSB7XG4gICAgICAgICAgc3RhdGVTdGFjay5wdXNoKHN0YXRlKTtcbiAgICAgICAgICBzdGF0ZSA9IDEgLyogaW5CcmFja2V0cyAqLztcbiAgICAgICAgICBjdXJyZW50T3BlbkJyYWNrZXRDb3VudCsrO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IFwiKFwiKSB7XG4gICAgICAgICAgc3RhdGVTdGFjay5wdXNoKHN0YXRlKTtcbiAgICAgICAgICBzdGF0ZSA9IDIgLyogaW5QYXJlbnMgKi87XG4gICAgICAgICAgY3VycmVudE9wZW5QYXJlbnNDb3VudCsrO1xuICAgICAgICB9IGVsc2UgaWYgKCEoaSA9PT0gMCA/IHZhbGlkRmlyc3RJZGVudENoYXJSRSA6IHZhbGlkSWRlbnRDaGFyUkUpLnRlc3QoY2hhcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEgLyogaW5CcmFja2V0cyAqLzpcbiAgICAgICAgaWYgKGNoYXIgPT09IGAnYCB8fCBjaGFyID09PSBgXCJgIHx8IGNoYXIgPT09IFwiYFwiKSB7XG4gICAgICAgICAgc3RhdGVTdGFjay5wdXNoKHN0YXRlKTtcbiAgICAgICAgICBzdGF0ZSA9IDMgLyogaW5TdHJpbmcgKi87XG4gICAgICAgICAgY3VycmVudFN0cmluZ1R5cGUgPSBjaGFyO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IGBbYCkge1xuICAgICAgICAgIGN1cnJlbnRPcGVuQnJhY2tldENvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gYF1gKSB7XG4gICAgICAgICAgaWYgKCEtLWN1cnJlbnRPcGVuQnJhY2tldENvdW50KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RhY2sucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyIC8qIGluUGFyZW5zICovOlxuICAgICAgICBpZiAoY2hhciA9PT0gYCdgIHx8IGNoYXIgPT09IGBcImAgfHwgY2hhciA9PT0gXCJgXCIpIHtcbiAgICAgICAgICBzdGF0ZVN0YWNrLnB1c2goc3RhdGUpO1xuICAgICAgICAgIHN0YXRlID0gMyAvKiBpblN0cmluZyAqLztcbiAgICAgICAgICBjdXJyZW50U3RyaW5nVHlwZSA9IGNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gYChgKSB7XG4gICAgICAgICAgY3VycmVudE9wZW5QYXJlbnNDb3VudCsrO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IGApYCkge1xuICAgICAgICAgIGlmIChpID09PSBwYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEtLWN1cnJlbnRPcGVuUGFyZW5zQ291bnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDMgLyogaW5TdHJpbmcgKi86XG4gICAgICAgIGlmIChjaGFyID09PSBjdXJyZW50U3RyaW5nVHlwZSkge1xuICAgICAgICAgIHN0YXRlID0gc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgICAgICBjdXJyZW50U3RyaW5nVHlwZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiAhY3VycmVudE9wZW5CcmFja2V0Q291bnQgJiYgIWN1cnJlbnRPcGVuUGFyZW5zQ291bnQ7XG59O1xuY29uc3QgaXNNZW1iZXJFeHByZXNzaW9uTm9kZSA9IE5PT1AgO1xuY29uc3QgaXNNZW1iZXJFeHByZXNzaW9uID0gaXNNZW1iZXJFeHByZXNzaW9uQnJvd3NlciA7XG5jb25zdCBmbkV4cFJFID0gL15cXHMqKD86YXN5bmNcXHMqKT8oPzpcXChbXildKj9cXCl8W1xcdyRfXSspXFxzKig/OjpbXj1dKyk/PT58XlxccyooPzphc3luY1xccyspP2Z1bmN0aW9uKD86XFxzK1tcXHckXSspP1xccypcXCgvO1xuY29uc3QgaXNGbkV4cHJlc3Npb25Ccm93c2VyID0gKGV4cCkgPT4gZm5FeHBSRS50ZXN0KGdldEV4cFNvdXJjZShleHApKTtcbmNvbnN0IGlzRm5FeHByZXNzaW9uTm9kZSA9IE5PT1AgO1xuY29uc3QgaXNGbkV4cHJlc3Npb24gPSBpc0ZuRXhwcmVzc2lvbkJyb3dzZXIgO1xuZnVuY3Rpb24gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHBvcywgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMgPSBzb3VyY2UubGVuZ3RoKSB7XG4gIHJldHVybiBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oXG4gICAge1xuICAgICAgb2Zmc2V0OiBwb3Mub2Zmc2V0LFxuICAgICAgbGluZTogcG9zLmxpbmUsXG4gICAgICBjb2x1bW46IHBvcy5jb2x1bW5cbiAgICB9LFxuICAgIHNvdXJjZSxcbiAgICBudW1iZXJPZkNoYXJhY3RlcnNcbiAgKTtcbn1cbmZ1bmN0aW9uIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihwb3MsIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzID0gc291cmNlLmxlbmd0aCkge1xuICBsZXQgbGluZXNDb3VudCA9IDA7XG4gIGxldCBsYXN0TmV3TGluZVBvcyA9IC0xO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2hhcmFjdGVyczsgaSsrKSB7XG4gICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGkpID09PSAxMCkge1xuICAgICAgbGluZXNDb3VudCsrO1xuICAgICAgbGFzdE5ld0xpbmVQb3MgPSBpO1xuICAgIH1cbiAgfVxuICBwb3Mub2Zmc2V0ICs9IG51bWJlck9mQ2hhcmFjdGVycztcbiAgcG9zLmxpbmUgKz0gbGluZXNDb3VudDtcbiAgcG9zLmNvbHVtbiA9IGxhc3ROZXdMaW5lUG9zID09PSAtMSA/IHBvcy5jb2x1bW4gKyBudW1iZXJPZkNoYXJhY3RlcnMgOiBudW1iZXJPZkNoYXJhY3RlcnMgLSBsYXN0TmV3TGluZVBvcztcbiAgcmV0dXJuIHBvcztcbn1cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZykge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgYHVuZXhwZWN0ZWQgY29tcGlsZXIgY29uZGl0aW9uYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmREaXIobm9kZSwgbmFtZSwgYWxsb3dFbXB0eSA9IGZhbHNlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xuICAgIGlmIChwLnR5cGUgPT09IDcgJiYgKGFsbG93RW1wdHkgfHwgcC5leHApICYmIChpc1N0cmluZyhuYW1lKSA/IHAubmFtZSA9PT0gbmFtZSA6IG5hbWUudGVzdChwLm5hbWUpKSkge1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaW5kUHJvcChub2RlLCBuYW1lLCBkeW5hbWljT25seSA9IGZhbHNlLCBhbGxvd0VtcHR5ID0gZmFsc2UpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XG4gICAgaWYgKHAudHlwZSA9PT0gNikge1xuICAgICAgaWYgKGR5bmFtaWNPbmx5KSBjb250aW51ZTtcbiAgICAgIGlmIChwLm5hbWUgPT09IG5hbWUgJiYgKHAudmFsdWUgfHwgYWxsb3dFbXB0eSkpIHtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwLm5hbWUgPT09IFwiYmluZFwiICYmIChwLmV4cCB8fCBhbGxvd0VtcHR5KSAmJiBpc1N0YXRpY0FyZ09mKHAuYXJnLCBuYW1lKSkge1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc1N0YXRpY0FyZ09mKGFyZywgbmFtZSkge1xuICByZXR1cm4gISEoYXJnICYmIGlzU3RhdGljRXhwKGFyZykgJiYgYXJnLmNvbnRlbnQgPT09IG5hbWUpO1xufVxuZnVuY3Rpb24gaGFzRHluYW1pY0tleVZCaW5kKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucHJvcHMuc29tZShcbiAgICAocCkgPT4gcC50eXBlID09PSA3ICYmIHAubmFtZSA9PT0gXCJiaW5kXCIgJiYgKCFwLmFyZyB8fCAvLyB2LWJpbmQ9XCJvYmpcIlxuICAgIHAuYXJnLnR5cGUgIT09IDQgfHwgLy8gdi1iaW5kOltfY3R4LmZvb11cbiAgICAhcC5hcmcuaXNTdGF0aWMpXG4gICAgLy8gdi1iaW5kOltmb29dXG4gICk7XG59XG5mdW5jdGlvbiBpc1RleHQkMShub2RlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IDUgfHwgbm9kZS50eXBlID09PSAyO1xufVxuZnVuY3Rpb24gaXNWUHJlKHApIHtcbiAgcmV0dXJuIHAudHlwZSA9PT0gNyAmJiBwLm5hbWUgPT09IFwicHJlXCI7XG59XG5mdW5jdGlvbiBpc1ZTbG90KHApIHtcbiAgcmV0dXJuIHAudHlwZSA9PT0gNyAmJiBwLm5hbWUgPT09IFwic2xvdFwiO1xufVxuZnVuY3Rpb24gaXNUZW1wbGF0ZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSAxICYmIG5vZGUudGFnVHlwZSA9PT0gMztcbn1cbmZ1bmN0aW9uIGlzU2xvdE91dGxldChub2RlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IDEgJiYgbm9kZS50YWdUeXBlID09PSAyO1xufVxuY29uc3QgcHJvcHNIZWxwZXJTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbTk9STUFMSVpFX1BST1BTLCBHVUFSRF9SRUFDVElWRV9QUk9QU10pO1xuZnVuY3Rpb24gZ2V0VW5ub3JtYWxpemVkUHJvcHMocHJvcHMsIGNhbGxQYXRoID0gW10pIHtcbiAgaWYgKHByb3BzICYmICFpc1N0cmluZyhwcm9wcykgJiYgcHJvcHMudHlwZSA9PT0gMTQpIHtcbiAgICBjb25zdCBjYWxsZWUgPSBwcm9wcy5jYWxsZWU7XG4gICAgaWYgKCFpc1N0cmluZyhjYWxsZWUpICYmIHByb3BzSGVscGVyU2V0LmhhcyhjYWxsZWUpKSB7XG4gICAgICByZXR1cm4gZ2V0VW5ub3JtYWxpemVkUHJvcHMoXG4gICAgICAgIHByb3BzLmFyZ3VtZW50c1swXSxcbiAgICAgICAgY2FsbFBhdGguY29uY2F0KHByb3BzKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtwcm9wcywgY2FsbFBhdGhdO1xufVxuZnVuY3Rpb24gaW5qZWN0UHJvcChub2RlLCBwcm9wLCBjb250ZXh0KSB7XG4gIGxldCBwcm9wc1dpdGhJbmplY3Rpb247XG4gIGxldCBwcm9wcyA9IG5vZGUudHlwZSA9PT0gMTMgPyBub2RlLnByb3BzIDogbm9kZS5hcmd1bWVudHNbMl07XG4gIGxldCBjYWxsUGF0aCA9IFtdO1xuICBsZXQgcGFyZW50Q2FsbDtcbiAgaWYgKHByb3BzICYmICFpc1N0cmluZyhwcm9wcykgJiYgcHJvcHMudHlwZSA9PT0gMTQpIHtcbiAgICBjb25zdCByZXQgPSBnZXRVbm5vcm1hbGl6ZWRQcm9wcyhwcm9wcyk7XG4gICAgcHJvcHMgPSByZXRbMF07XG4gICAgY2FsbFBhdGggPSByZXRbMV07XG4gICAgcGFyZW50Q2FsbCA9IGNhbGxQYXRoW2NhbGxQYXRoLmxlbmd0aCAtIDFdO1xuICB9XG4gIGlmIChwcm9wcyA9PSBudWxsIHx8IGlzU3RyaW5nKHByb3BzKSkge1xuICAgIHByb3BzV2l0aEluamVjdGlvbiA9IGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKTtcbiAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAxNCkge1xuICAgIGNvbnN0IGZpcnN0ID0gcHJvcHMuYXJndW1lbnRzWzBdO1xuICAgIGlmICghaXNTdHJpbmcoZmlyc3QpICYmIGZpcnN0LnR5cGUgPT09IDE1KSB7XG4gICAgICBpZiAoIWhhc1Byb3AocHJvcCwgZmlyc3QpKSB7XG4gICAgICAgIGZpcnN0LnByb3BlcnRpZXMudW5zaGlmdChwcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BzLmNhbGxlZSA9PT0gVE9fSEFORExFUlMpIHtcbiAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTUVSR0VfUFJPUFMpLCBbXG4gICAgICAgICAgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pLFxuICAgICAgICAgIHByb3BzXG4gICAgICAgIF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcHMuYXJndW1lbnRzLnVuc2hpZnQoY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihbcHJvcF0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgIXByb3BzV2l0aEluamVjdGlvbiAmJiAocHJvcHNXaXRoSW5qZWN0aW9uID0gcHJvcHMpO1xuICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09IDE1KSB7XG4gICAgaWYgKCFoYXNQcm9wKHByb3AsIHByb3BzKSkge1xuICAgICAgcHJvcHMucHJvcGVydGllcy51bnNoaWZ0KHByb3ApO1xuICAgIH1cbiAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBwcm9wcztcbiAgfSBlbHNlIHtcbiAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihNRVJHRV9QUk9QUyksIFtcbiAgICAgIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKSxcbiAgICAgIHByb3BzXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudENhbGwgJiYgcGFyZW50Q2FsbC5jYWxsZWUgPT09IEdVQVJEX1JFQUNUSVZFX1BST1BTKSB7XG4gICAgICBwYXJlbnRDYWxsID0gY2FsbFBhdGhbY2FsbFBhdGgubGVuZ3RoIC0gMl07XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDEzKSB7XG4gICAgaWYgKHBhcmVudENhbGwpIHtcbiAgICAgIHBhcmVudENhbGwuYXJndW1lbnRzWzBdID0gcHJvcHNXaXRoSW5qZWN0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnByb3BzID0gcHJvcHNXaXRoSW5qZWN0aW9uO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocGFyZW50Q2FsbCkge1xuICAgICAgcGFyZW50Q2FsbC5hcmd1bWVudHNbMF0gPSBwcm9wc1dpdGhJbmplY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuYXJndW1lbnRzWzJdID0gcHJvcHNXaXRoSW5qZWN0aW9uO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaGFzUHJvcChwcm9wLCBwcm9wcykge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gIGlmIChwcm9wLmtleS50eXBlID09PSA0KSB7XG4gICAgY29uc3QgcHJvcEtleU5hbWUgPSBwcm9wLmtleS5jb250ZW50O1xuICAgIHJlc3VsdCA9IHByb3BzLnByb3BlcnRpZXMuc29tZShcbiAgICAgIChwKSA9PiBwLmtleS50eXBlID09PSA0ICYmIHAua2V5LmNvbnRlbnQgPT09IHByb3BLZXlOYW1lXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9WYWxpZEFzc2V0SWQobmFtZSwgdHlwZSkge1xuICByZXR1cm4gYF8ke3R5cGV9XyR7bmFtZS5yZXBsYWNlKC9bXlxcd10vZywgKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpID0+IHtcbiAgICByZXR1cm4gc2VhcmNoVmFsdWUgPT09IFwiLVwiID8gXCJfXCIgOiBuYW1lLmNoYXJDb2RlQXQocmVwbGFjZVZhbHVlKS50b1N0cmluZygpO1xuICB9KX1gO1xufVxuZnVuY3Rpb24gaGFzU2NvcGVSZWYobm9kZSwgaWRzKSB7XG4gIGlmICghbm9kZSB8fCBPYmplY3Qua2V5cyhpZHMpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgMTpcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAmJiAoaGFzU2NvcGVSZWYocC5hcmcsIGlkcykgfHwgaGFzU2NvcGVSZWYocC5leHAsIGlkcykpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoKGMpID0+IGhhc1Njb3BlUmVmKGMsIGlkcykpO1xuICAgIGNhc2UgMTE6XG4gICAgICBpZiAoaGFzU2NvcGVSZWYobm9kZS5zb3VyY2UsIGlkcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKChjKSA9PiBoYXNTY29wZVJlZihjLCBpZHMpKTtcbiAgICBjYXNlIDk6XG4gICAgICByZXR1cm4gbm9kZS5icmFuY2hlcy5zb21lKChiKSA9PiBoYXNTY29wZVJlZihiLCBpZHMpKTtcbiAgICBjYXNlIDEwOlxuICAgICAgaWYgKGhhc1Njb3BlUmVmKG5vZGUuY29uZGl0aW9uLCBpZHMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZSgoYykgPT4gaGFzU2NvcGVSZWYoYywgaWRzKSk7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuICFub2RlLmlzU3RhdGljICYmIGlzU2ltcGxlSWRlbnRpZmllcihub2RlLmNvbnRlbnQpICYmICEhaWRzW25vZGUuY29udGVudF07XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZSgoYykgPT4gaXNPYmplY3QoYykgJiYgaGFzU2NvcGVSZWYoYywgaWRzKSk7XG4gICAgY2FzZSA1OlxuICAgIGNhc2UgMTI6XG4gICAgICByZXR1cm4gaGFzU2NvcGVSZWYobm9kZS5jb250ZW50LCBpZHMpO1xuICAgIGNhc2UgMjpcbiAgICBjYXNlIDM6XG4gICAgY2FzZSAyMDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TWVtb2VkVk5vZGVDYWxsKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMTQgJiYgbm9kZS5jYWxsZWUgPT09IFdJVEhfTUVNTykge1xuICAgIHJldHVybiBub2RlLmFyZ3VtZW50c1sxXS5yZXR1cm5zO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2RlO1xuICB9XG59XG5jb25zdCBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFxcU1tcXHNcXFNdKikvO1xuZnVuY3Rpb24gaXNBbGxXaGl0ZXNwYWNlKHN0cikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaXNXaGl0ZXNwYWNlKHN0ci5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZVRleHQobm9kZSkge1xuICByZXR1cm4gbm9kZS50eXBlID09PSAyICYmIGlzQWxsV2hpdGVzcGFjZShub2RlLmNvbnRlbnQpIHx8IG5vZGUudHlwZSA9PT0gMTIgJiYgaXNXaGl0ZXNwYWNlVGV4dChub2RlLmNvbnRlbnQpO1xufVxuZnVuY3Rpb24gaXNDb21tZW50T3JXaGl0ZXNwYWNlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gMyB8fCBpc1doaXRlc3BhY2VUZXh0KG5vZGUpO1xufVxuXG5jb25zdCBkZWZhdWx0UGFyc2VyT3B0aW9ucyA9IHtcbiAgcGFyc2VNb2RlOiBcImJhc2VcIixcbiAgbnM6IDAsXG4gIGRlbGltaXRlcnM6IFtge3tgLCBgfX1gXSxcbiAgZ2V0TmFtZXNwYWNlOiAoKSA9PiAwLFxuICBpc1ZvaWRUYWc6IE5PLFxuICBpc1ByZVRhZzogTk8sXG4gIGlzSWdub3JlTmV3bGluZVRhZzogTk8sXG4gIGlzQ3VzdG9tRWxlbWVudDogTk8sXG4gIG9uRXJyb3I6IGRlZmF1bHRPbkVycm9yLFxuICBvbldhcm46IGRlZmF1bHRPbldhcm4sXG4gIGNvbW1lbnRzOiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpLFxuICBwcmVmaXhJZGVudGlmaWVyczogZmFsc2Vcbn07XG5sZXQgY3VycmVudE9wdGlvbnMgPSBkZWZhdWx0UGFyc2VyT3B0aW9ucztcbmxldCBjdXJyZW50Um9vdCA9IG51bGw7XG5sZXQgY3VycmVudElucHV0ID0gXCJcIjtcbmxldCBjdXJyZW50T3BlblRhZyA9IG51bGw7XG5sZXQgY3VycmVudFByb3AgPSBudWxsO1xubGV0IGN1cnJlbnRBdHRyVmFsdWUgPSBcIlwiO1xubGV0IGN1cnJlbnRBdHRyU3RhcnRJbmRleCA9IC0xO1xubGV0IGN1cnJlbnRBdHRyRW5kSW5kZXggPSAtMTtcbmxldCBpblByZSA9IDA7XG5sZXQgaW5WUHJlID0gZmFsc2U7XG5sZXQgY3VycmVudFZQcmVCb3VuZGFyeSA9IG51bGw7XG5jb25zdCBzdGFjayA9IFtdO1xuY29uc3QgdG9rZW5pemVyID0gbmV3IFRva2VuaXplcihzdGFjaywge1xuICBvbmVycjogZW1pdEVycm9yLFxuICBvbnRleHQoc3RhcnQsIGVuZCkge1xuICAgIG9uVGV4dChnZXRTbGljZShzdGFydCwgZW5kKSwgc3RhcnQsIGVuZCk7XG4gIH0sXG4gIG9udGV4dGVudGl0eShjaGFyLCBzdGFydCwgZW5kKSB7XG4gICAgb25UZXh0KGNoYXIsIHN0YXJ0LCBlbmQpO1xuICB9LFxuICBvbmludGVycG9sYXRpb24oc3RhcnQsIGVuZCkge1xuICAgIGlmIChpblZQcmUpIHtcbiAgICAgIHJldHVybiBvblRleHQoZ2V0U2xpY2Uoc3RhcnQsIGVuZCksIHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBsZXQgaW5uZXJTdGFydCA9IHN0YXJ0ICsgdG9rZW5pemVyLmRlbGltaXRlck9wZW4ubGVuZ3RoO1xuICAgIGxldCBpbm5lckVuZCA9IGVuZCAtIHRva2VuaXplci5kZWxpbWl0ZXJDbG9zZS5sZW5ndGg7XG4gICAgd2hpbGUgKGlzV2hpdGVzcGFjZShjdXJyZW50SW5wdXQuY2hhckNvZGVBdChpbm5lclN0YXJ0KSkpIHtcbiAgICAgIGlubmVyU3RhcnQrKztcbiAgICB9XG4gICAgd2hpbGUgKGlzV2hpdGVzcGFjZShjdXJyZW50SW5wdXQuY2hhckNvZGVBdChpbm5lckVuZCAtIDEpKSkge1xuICAgICAgaW5uZXJFbmQtLTtcbiAgICB9XG4gICAgbGV0IGV4cCA9IGdldFNsaWNlKGlubmVyU3RhcnQsIGlubmVyRW5kKTtcbiAgICBpZiAoZXhwLmluY2x1ZGVzKFwiJlwiKSkge1xuICAgICAge1xuICAgICAgICBleHAgPSBjdXJyZW50T3B0aW9ucy5kZWNvZGVFbnRpdGllcyhleHAsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYWRkTm9kZSh7XG4gICAgICB0eXBlOiA1LFxuICAgICAgY29udGVudDogY3JlYXRlRXhwKGV4cCwgZmFsc2UsIGdldExvYyhpbm5lclN0YXJ0LCBpbm5lckVuZCkpLFxuICAgICAgbG9jOiBnZXRMb2Moc3RhcnQsIGVuZClcbiAgICB9KTtcbiAgfSxcbiAgb25vcGVudGFnbmFtZShzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgbmFtZSA9IGdldFNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIGN1cnJlbnRPcGVuVGFnID0ge1xuICAgICAgdHlwZTogMSxcbiAgICAgIHRhZzogbmFtZSxcbiAgICAgIG5zOiBjdXJyZW50T3B0aW9ucy5nZXROYW1lc3BhY2UobmFtZSwgc3RhY2tbMF0sIGN1cnJlbnRPcHRpb25zLm5zKSxcbiAgICAgIHRhZ1R5cGU6IDAsXG4gICAgICAvLyB3aWxsIGJlIHJlZmluZWQgb24gdGFnIGNsb3NlXG4gICAgICBwcm9wczogW10sXG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBsb2M6IGdldExvYyhzdGFydCAtIDEsIGVuZCksXG4gICAgICBjb2RlZ2VuTm9kZTogdm9pZCAwXG4gICAgfTtcbiAgfSxcbiAgb25vcGVudGFnZW5kKGVuZCkge1xuICAgIGVuZE9wZW5UYWcoZW5kKTtcbiAgfSxcbiAgb25jbG9zZXRhZyhzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgbmFtZSA9IGdldFNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIGlmICghY3VycmVudE9wdGlvbnMuaXNWb2lkVGFnKG5hbWUpKSB7XG4gICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IHN0YWNrW2ldO1xuICAgICAgICBpZiAoZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgZW1pdEVycm9yKDI0LCBzdGFja1swXS5sb2Muc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gaTsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICBvbkNsb3NlVGFnKGVsLCBlbmQsIGogPCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgZW1pdEVycm9yKDIzLCBiYWNrVHJhY2soc3RhcnQsIDYwKSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBvbnNlbGZjbG9zaW5ndGFnKGVuZCkge1xuICAgIGNvbnN0IG5hbWUgPSBjdXJyZW50T3BlblRhZy50YWc7XG4gICAgY3VycmVudE9wZW5UYWcuaXNTZWxmQ2xvc2luZyA9IHRydWU7XG4gICAgZW5kT3BlblRhZyhlbmQpO1xuICAgIGlmIChzdGFja1swXSAmJiBzdGFja1swXS50YWcgPT09IG5hbWUpIHtcbiAgICAgIG9uQ2xvc2VUYWcoc3RhY2suc2hpZnQoKSwgZW5kKTtcbiAgICB9XG4gIH0sXG4gIG9uYXR0cmlibmFtZShzdGFydCwgZW5kKSB7XG4gICAgY3VycmVudFByb3AgPSB7XG4gICAgICB0eXBlOiA2LFxuICAgICAgbmFtZTogZ2V0U2xpY2Uoc3RhcnQsIGVuZCksXG4gICAgICBuYW1lTG9jOiBnZXRMb2Moc3RhcnQsIGVuZCksXG4gICAgICB2YWx1ZTogdm9pZCAwLFxuICAgICAgbG9jOiBnZXRMb2Moc3RhcnQpXG4gICAgfTtcbiAgfSxcbiAgb25kaXJuYW1lKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCByYXcgPSBnZXRTbGljZShzdGFydCwgZW5kKTtcbiAgICBjb25zdCBuYW1lID0gcmF3ID09PSBcIi5cIiB8fCByYXcgPT09IFwiOlwiID8gXCJiaW5kXCIgOiByYXcgPT09IFwiQFwiID8gXCJvblwiIDogcmF3ID09PSBcIiNcIiA/IFwic2xvdFwiIDogcmF3LnNsaWNlKDIpO1xuICAgIGlmICghaW5WUHJlICYmIG5hbWUgPT09IFwiXCIpIHtcbiAgICAgIGVtaXRFcnJvcigyNiwgc3RhcnQpO1xuICAgIH1cbiAgICBpZiAoaW5WUHJlIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgIGN1cnJlbnRQcm9wID0ge1xuICAgICAgICB0eXBlOiA2LFxuICAgICAgICBuYW1lOiByYXcsXG4gICAgICAgIG5hbWVMb2M6IGdldExvYyhzdGFydCwgZW5kKSxcbiAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAgbG9jOiBnZXRMb2Moc3RhcnQpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50UHJvcCA9IHtcbiAgICAgICAgdHlwZTogNyxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcmF3TmFtZTogcmF3LFxuICAgICAgICBleHA6IHZvaWQgMCxcbiAgICAgICAgYXJnOiB2b2lkIDAsXG4gICAgICAgIG1vZGlmaWVyczogcmF3ID09PSBcIi5cIiA/IFtjcmVhdGVTaW1wbGVFeHByZXNzaW9uKFwicHJvcFwiKV0gOiBbXSxcbiAgICAgICAgbG9jOiBnZXRMb2Moc3RhcnQpXG4gICAgICB9O1xuICAgICAgaWYgKG5hbWUgPT09IFwicHJlXCIpIHtcbiAgICAgICAgaW5WUHJlID0gdG9rZW5pemVyLmluVlByZSA9IHRydWU7XG4gICAgICAgIGN1cnJlbnRWUHJlQm91bmRhcnkgPSBjdXJyZW50T3BlblRhZztcbiAgICAgICAgY29uc3QgcHJvcHMgPSBjdXJyZW50T3BlblRhZy5wcm9wcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwcm9wc1tpXS50eXBlID09PSA3KSB7XG4gICAgICAgICAgICBwcm9wc1tpXSA9IGRpclRvQXR0cihwcm9wc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBvbmRpcmFyZyhzdGFydCwgZW5kKSB7XG4gICAgaWYgKHN0YXJ0ID09PSBlbmQpIHJldHVybjtcbiAgICBjb25zdCBhcmcgPSBnZXRTbGljZShzdGFydCwgZW5kKTtcbiAgICBpZiAoaW5WUHJlICYmICFpc1ZQcmUoY3VycmVudFByb3ApKSB7XG4gICAgICBjdXJyZW50UHJvcC5uYW1lICs9IGFyZztcbiAgICAgIHNldExvY0VuZChjdXJyZW50UHJvcC5uYW1lTG9jLCBlbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc1N0YXRpYyA9IGFyZ1swXSAhPT0gYFtgO1xuICAgICAgY3VycmVudFByb3AuYXJnID0gY3JlYXRlRXhwKFxuICAgICAgICBpc1N0YXRpYyA/IGFyZyA6IGFyZy5zbGljZSgxLCAtMSksXG4gICAgICAgIGlzU3RhdGljLFxuICAgICAgICBnZXRMb2Moc3RhcnQsIGVuZCksXG4gICAgICAgIGlzU3RhdGljID8gMyA6IDBcbiAgICAgICk7XG4gICAgfVxuICB9LFxuICBvbmRpcm1vZGlmaWVyKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBtb2QgPSBnZXRTbGljZShzdGFydCwgZW5kKTtcbiAgICBpZiAoaW5WUHJlICYmICFpc1ZQcmUoY3VycmVudFByb3ApKSB7XG4gICAgICBjdXJyZW50UHJvcC5uYW1lICs9IFwiLlwiICsgbW9kO1xuICAgICAgc2V0TG9jRW5kKGN1cnJlbnRQcm9wLm5hbWVMb2MsIGVuZCk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50UHJvcC5uYW1lID09PSBcInNsb3RcIikge1xuICAgICAgY29uc3QgYXJnID0gY3VycmVudFByb3AuYXJnO1xuICAgICAgaWYgKGFyZykge1xuICAgICAgICBhcmcuY29udGVudCArPSBcIi5cIiArIG1vZDtcbiAgICAgICAgc2V0TG9jRW5kKGFyZy5sb2MsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV4cCA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24obW9kLCB0cnVlLCBnZXRMb2Moc3RhcnQsIGVuZCkpO1xuICAgICAgY3VycmVudFByb3AubW9kaWZpZXJzLnB1c2goZXhwKTtcbiAgICB9XG4gIH0sXG4gIG9uYXR0cmliZGF0YShzdGFydCwgZW5kKSB7XG4gICAgY3VycmVudEF0dHJWYWx1ZSArPSBnZXRTbGljZShzdGFydCwgZW5kKTtcbiAgICBpZiAoY3VycmVudEF0dHJTdGFydEluZGV4IDwgMCkgY3VycmVudEF0dHJTdGFydEluZGV4ID0gc3RhcnQ7XG4gICAgY3VycmVudEF0dHJFbmRJbmRleCA9IGVuZDtcbiAgfSxcbiAgb25hdHRyaWJlbnRpdHkoY2hhciwgc3RhcnQsIGVuZCkge1xuICAgIGN1cnJlbnRBdHRyVmFsdWUgKz0gY2hhcjtcbiAgICBpZiAoY3VycmVudEF0dHJTdGFydEluZGV4IDwgMCkgY3VycmVudEF0dHJTdGFydEluZGV4ID0gc3RhcnQ7XG4gICAgY3VycmVudEF0dHJFbmRJbmRleCA9IGVuZDtcbiAgfSxcbiAgb25hdHRyaWJuYW1lZW5kKGVuZCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gY3VycmVudFByb3AubG9jLnN0YXJ0Lm9mZnNldDtcbiAgICBjb25zdCBuYW1lID0gZ2V0U2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgaWYgKGN1cnJlbnRQcm9wLnR5cGUgPT09IDcpIHtcbiAgICAgIGN1cnJlbnRQcm9wLnJhd05hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBpZiAoY3VycmVudE9wZW5UYWcucHJvcHMuc29tZShcbiAgICAgIChwKSA9PiAocC50eXBlID09PSA3ID8gcC5yYXdOYW1lIDogcC5uYW1lKSA9PT0gbmFtZVxuICAgICkpIHtcbiAgICAgIGVtaXRFcnJvcigyLCBzdGFydCk7XG4gICAgfVxuICB9LFxuICBvbmF0dHJpYmVuZChxdW90ZSwgZW5kKSB7XG4gICAgaWYgKGN1cnJlbnRPcGVuVGFnICYmIGN1cnJlbnRQcm9wKSB7XG4gICAgICBzZXRMb2NFbmQoY3VycmVudFByb3AubG9jLCBlbmQpO1xuICAgICAgaWYgKHF1b3RlICE9PSAwKSB7XG4gICAgICAgIGlmIChjdXJyZW50QXR0clZhbHVlLmluY2x1ZGVzKFwiJlwiKSkge1xuICAgICAgICAgIGN1cnJlbnRBdHRyVmFsdWUgPSBjdXJyZW50T3B0aW9ucy5kZWNvZGVFbnRpdGllcyhcbiAgICAgICAgICAgIGN1cnJlbnRBdHRyVmFsdWUsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFByb3AudHlwZSA9PT0gNikge1xuICAgICAgICAgIGlmIChjdXJyZW50UHJvcC5uYW1lID09PSBcImNsYXNzXCIpIHtcbiAgICAgICAgICAgIGN1cnJlbnRBdHRyVmFsdWUgPSBjb25kZW5zZShjdXJyZW50QXR0clZhbHVlKS50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChxdW90ZSA9PT0gMSAmJiAhY3VycmVudEF0dHJWYWx1ZSkge1xuICAgICAgICAgICAgZW1pdEVycm9yKDEzLCBlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50UHJvcC52YWx1ZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICBjb250ZW50OiBjdXJyZW50QXR0clZhbHVlLFxuICAgICAgICAgICAgbG9jOiBxdW90ZSA9PT0gMSA/IGdldExvYyhjdXJyZW50QXR0clN0YXJ0SW5kZXgsIGN1cnJlbnRBdHRyRW5kSW5kZXgpIDogZ2V0TG9jKGN1cnJlbnRBdHRyU3RhcnRJbmRleCAtIDEsIGN1cnJlbnRBdHRyRW5kSW5kZXggKyAxKVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHRva2VuaXplci5pblNGQ1Jvb3QgJiYgY3VycmVudE9wZW5UYWcudGFnID09PSBcInRlbXBsYXRlXCIgJiYgY3VycmVudFByb3AubmFtZSA9PT0gXCJsYW5nXCIgJiYgY3VycmVudEF0dHJWYWx1ZSAmJiBjdXJyZW50QXR0clZhbHVlICE9PSBcImh0bWxcIikge1xuICAgICAgICAgICAgdG9rZW5pemVyLmVudGVyUkNEQVRBKHRvQ2hhckNvZGVzKGA8L3RlbXBsYXRlYCksIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgZXhwUGFyc2VNb2RlID0gMCAvKiBOb3JtYWwgKi87XG4gICAgICAgICAgY3VycmVudFByb3AuZXhwID0gY3JlYXRlRXhwKFxuICAgICAgICAgICAgY3VycmVudEF0dHJWYWx1ZSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgZ2V0TG9jKGN1cnJlbnRBdHRyU3RhcnRJbmRleCwgY3VycmVudEF0dHJFbmRJbmRleCksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgZXhwUGFyc2VNb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoY3VycmVudFByb3AubmFtZSA9PT0gXCJmb3JcIikge1xuICAgICAgICAgICAgY3VycmVudFByb3AuZm9yUGFyc2VSZXN1bHQgPSBwYXJzZUZvckV4cHJlc3Npb24oY3VycmVudFByb3AuZXhwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHN5bmNJbmRleCA9IC0xO1xuICAgICAgICAgIGlmIChjdXJyZW50UHJvcC5uYW1lID09PSBcImJpbmRcIiAmJiAoc3luY0luZGV4ID0gY3VycmVudFByb3AubW9kaWZpZXJzLmZpbmRJbmRleChcbiAgICAgICAgICAgIChtb2QpID0+IG1vZC5jb250ZW50ID09PSBcInN5bmNcIlxuICAgICAgICAgICkpID4gLTEgJiYgY2hlY2tDb21wYXRFbmFibGVkKFxuICAgICAgICAgICAgXCJDT01QSUxFUl9WX0JJTkRfU1lOQ1wiLFxuICAgICAgICAgICAgY3VycmVudE9wdGlvbnMsXG4gICAgICAgICAgICBjdXJyZW50UHJvcC5sb2MsXG4gICAgICAgICAgICBjdXJyZW50UHJvcC5hcmcubG9jLnNvdXJjZVxuICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9wLm5hbWUgPSBcIm1vZGVsXCI7XG4gICAgICAgICAgICBjdXJyZW50UHJvcC5tb2RpZmllcnMuc3BsaWNlKHN5bmNJbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFByb3AudHlwZSAhPT0gNyB8fCBjdXJyZW50UHJvcC5uYW1lICE9PSBcInByZVwiKSB7XG4gICAgICAgIGN1cnJlbnRPcGVuVGFnLnByb3BzLnB1c2goY3VycmVudFByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyZW50QXR0clZhbHVlID0gXCJcIjtcbiAgICBjdXJyZW50QXR0clN0YXJ0SW5kZXggPSBjdXJyZW50QXR0ckVuZEluZGV4ID0gLTE7XG4gIH0sXG4gIG9uY29tbWVudChzdGFydCwgZW5kKSB7XG4gICAgaWYgKGN1cnJlbnRPcHRpb25zLmNvbW1lbnRzKSB7XG4gICAgICBhZGROb2RlKHtcbiAgICAgICAgdHlwZTogMyxcbiAgICAgICAgY29udGVudDogZ2V0U2xpY2Uoc3RhcnQsIGVuZCksXG4gICAgICAgIGxvYzogZ2V0TG9jKHN0YXJ0IC0gNCwgZW5kICsgMylcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgb25lbmQoKSB7XG4gICAgY29uc3QgZW5kID0gY3VycmVudElucHV0Lmxlbmd0aDtcbiAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgZmFsc2UpICYmIHRva2VuaXplci5zdGF0ZSAhPT0gMSkge1xuICAgICAgc3dpdGNoICh0b2tlbml6ZXIuc3RhdGUpIHtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgZW1pdEVycm9yKDUsIGVuZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGVtaXRFcnJvcihcbiAgICAgICAgICAgIDI1LFxuICAgICAgICAgICAgdG9rZW5pemVyLnNlY3Rpb25TdGFydFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgaWYgKHRva2VuaXplci5jdXJyZW50U2VxdWVuY2UgPT09IFNlcXVlbmNlcy5DZGF0YUVuZCkge1xuICAgICAgICAgICAgZW1pdEVycm9yKDYsIGVuZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcig3LCBlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgY2FzZSAxODpcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIGVtaXRFcnJvcig5LCBlbmQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc3RhY2subGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBvbkNsb3NlVGFnKHN0YWNrW2luZGV4XSwgZW5kIC0gMSk7XG4gICAgICBlbWl0RXJyb3IoMjQsIHN0YWNrW2luZGV4XS5sb2Muc3RhcnQub2Zmc2V0KTtcbiAgICB9XG4gIH0sXG4gIG9uY2RhdGEoc3RhcnQsIGVuZCkge1xuICAgIGlmIChzdGFja1swXS5ucyAhPT0gMCkge1xuICAgICAgb25UZXh0KGdldFNsaWNlKHN0YXJ0LCBlbmQpLCBzdGFydCwgZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdEVycm9yKDEsIHN0YXJ0IC0gOSk7XG4gICAgfVxuICB9LFxuICBvbnByb2Nlc3NpbmdpbnN0cnVjdGlvbihzdGFydCkge1xuICAgIGlmICgoc3RhY2tbMF0gPyBzdGFja1swXS5ucyA6IGN1cnJlbnRPcHRpb25zLm5zKSA9PT0gMCkge1xuICAgICAgZW1pdEVycm9yKFxuICAgICAgICAyMSxcbiAgICAgICAgc3RhcnQgLSAxXG4gICAgICApO1xuICAgIH1cbiAgfVxufSk7XG5jb25zdCBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xuY29uc3Qgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcbmZ1bmN0aW9uIHBhcnNlRm9yRXhwcmVzc2lvbihpbnB1dCkge1xuICBjb25zdCBsb2MgPSBpbnB1dC5sb2M7XG4gIGNvbnN0IGV4cCA9IGlucHV0LmNvbnRlbnQ7XG4gIGNvbnN0IGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gIGlmICghaW5NYXRjaCkgcmV0dXJuO1xuICBjb25zdCBbLCBMSFMsIFJIU10gPSBpbk1hdGNoO1xuICBjb25zdCBjcmVhdGVBbGlhc0V4cHJlc3Npb24gPSAoY29udGVudCwgb2Zmc2V0LCBhc1BhcmFtID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBzdGFydCA9IGxvYy5zdGFydC5vZmZzZXQgKyBvZmZzZXQ7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb250ZW50Lmxlbmd0aDtcbiAgICByZXR1cm4gY3JlYXRlRXhwKFxuICAgICAgY29udGVudCxcbiAgICAgIGZhbHNlLFxuICAgICAgZ2V0TG9jKHN0YXJ0LCBlbmQpLFxuICAgICAgMCxcbiAgICAgIGFzUGFyYW0gPyAxIC8qIFBhcmFtcyAqLyA6IDAgLyogTm9ybWFsICovXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHNvdXJjZTogY3JlYXRlQWxpYXNFeHByZXNzaW9uKFJIUy50cmltKCksIGV4cC5pbmRleE9mKFJIUywgTEhTLmxlbmd0aCkpLFxuICAgIHZhbHVlOiB2b2lkIDAsXG4gICAga2V5OiB2b2lkIDAsXG4gICAgaW5kZXg6IHZvaWQgMCxcbiAgICBmaW5hbGl6ZWQ6IGZhbHNlXG4gIH07XG4gIGxldCB2YWx1ZUNvbnRlbnQgPSBMSFMudHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgXCJcIikudHJpbSgpO1xuICBjb25zdCB0cmltbWVkT2Zmc2V0ID0gTEhTLmluZGV4T2YodmFsdWVDb250ZW50KTtcbiAgY29uc3QgaXRlcmF0b3JNYXRjaCA9IHZhbHVlQ29udGVudC5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICB2YWx1ZUNvbnRlbnQgPSB2YWx1ZUNvbnRlbnQucmVwbGFjZShmb3JJdGVyYXRvclJFLCBcIlwiKS50cmltKCk7XG4gICAgY29uc3Qga2V5Q29udGVudCA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgIGxldCBrZXlPZmZzZXQ7XG4gICAgaWYgKGtleUNvbnRlbnQpIHtcbiAgICAgIGtleU9mZnNldCA9IGV4cC5pbmRleE9mKGtleUNvbnRlbnQsIHRyaW1tZWRPZmZzZXQgKyB2YWx1ZUNvbnRlbnQubGVuZ3RoKTtcbiAgICAgIHJlc3VsdC5rZXkgPSBjcmVhdGVBbGlhc0V4cHJlc3Npb24oa2V5Q29udGVudCwga2V5T2Zmc2V0LCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgIGNvbnN0IGluZGV4Q29udGVudCA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgaWYgKGluZGV4Q29udGVudCkge1xuICAgICAgICByZXN1bHQuaW5kZXggPSBjcmVhdGVBbGlhc0V4cHJlc3Npb24oXG4gICAgICAgICAgaW5kZXhDb250ZW50LFxuICAgICAgICAgIGV4cC5pbmRleE9mKFxuICAgICAgICAgICAgaW5kZXhDb250ZW50LFxuICAgICAgICAgICAgcmVzdWx0LmtleSA/IGtleU9mZnNldCArIGtleUNvbnRlbnQubGVuZ3RoIDogdHJpbW1lZE9mZnNldCArIHZhbHVlQ29udGVudC5sZW5ndGhcbiAgICAgICAgICApLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZhbHVlQ29udGVudCkge1xuICAgIHJlc3VsdC52YWx1ZSA9IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbih2YWx1ZUNvbnRlbnQsIHRyaW1tZWRPZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRTbGljZShzdGFydCwgZW5kKSB7XG4gIHJldHVybiBjdXJyZW50SW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5mdW5jdGlvbiBlbmRPcGVuVGFnKGVuZCkge1xuICBpZiAodG9rZW5pemVyLmluU0ZDUm9vdCkge1xuICAgIGN1cnJlbnRPcGVuVGFnLmlubmVyTG9jID0gZ2V0TG9jKGVuZCArIDEsIGVuZCArIDEpO1xuICB9XG4gIGFkZE5vZGUoY3VycmVudE9wZW5UYWcpO1xuICBjb25zdCB7IHRhZywgbnMgfSA9IGN1cnJlbnRPcGVuVGFnO1xuICBpZiAobnMgPT09IDAgJiYgY3VycmVudE9wdGlvbnMuaXNQcmVUYWcodGFnKSkge1xuICAgIGluUHJlKys7XG4gIH1cbiAgaWYgKGN1cnJlbnRPcHRpb25zLmlzVm9pZFRhZyh0YWcpKSB7XG4gICAgb25DbG9zZVRhZyhjdXJyZW50T3BlblRhZywgZW5kKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFjay51bnNoaWZ0KGN1cnJlbnRPcGVuVGFnKTtcbiAgICBpZiAobnMgPT09IDEgfHwgbnMgPT09IDIpIHtcbiAgICAgIHRva2VuaXplci5pblhNTCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGN1cnJlbnRPcGVuVGFnID0gbnVsbDtcbn1cbmZ1bmN0aW9uIG9uVGV4dChjb250ZW50LCBzdGFydCwgZW5kKSB7XG4gIHtcbiAgICBjb25zdCB0YWcgPSBzdGFja1swXSAmJiBzdGFja1swXS50YWc7XG4gICAgaWYgKHRhZyAhPT0gXCJzY3JpcHRcIiAmJiB0YWcgIT09IFwic3R5bGVcIiAmJiBjb250ZW50LmluY2x1ZGVzKFwiJlwiKSkge1xuICAgICAgY29udGVudCA9IGN1cnJlbnRPcHRpb25zLmRlY29kZUVudGl0aWVzKGNvbnRlbnQsIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcGFyZW50ID0gc3RhY2tbMF0gfHwgY3VycmVudFJvb3Q7XG4gIGNvbnN0IGxhc3ROb2RlID0gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDIpIHtcbiAgICBsYXN0Tm9kZS5jb250ZW50ICs9IGNvbnRlbnQ7XG4gICAgc2V0TG9jRW5kKGxhc3ROb2RlLmxvYywgZW5kKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaCh7XG4gICAgICB0eXBlOiAyLFxuICAgICAgY29udGVudCxcbiAgICAgIGxvYzogZ2V0TG9jKHN0YXJ0LCBlbmQpXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uQ2xvc2VUYWcoZWwsIGVuZCwgaXNJbXBsaWVkID0gZmFsc2UpIHtcbiAgaWYgKGlzSW1wbGllZCkge1xuICAgIHNldExvY0VuZChlbC5sb2MsIGJhY2tUcmFjayhlbmQsIDYwKSk7XG4gIH0gZWxzZSB7XG4gICAgc2V0TG9jRW5kKGVsLmxvYywgbG9va0FoZWFkKGVuZCwgNjIpICsgMSk7XG4gIH1cbiAgaWYgKHRva2VuaXplci5pblNGQ1Jvb3QpIHtcbiAgICBpZiAoZWwuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBlbC5pbm5lckxvYy5lbmQgPSBleHRlbmQoe30sIGVsLmNoaWxkcmVuW2VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5pbm5lckxvYy5lbmQgPSBleHRlbmQoe30sIGVsLmlubmVyTG9jLnN0YXJ0KTtcbiAgICB9XG4gICAgZWwuaW5uZXJMb2Muc291cmNlID0gZ2V0U2xpY2UoXG4gICAgICBlbC5pbm5lckxvYy5zdGFydC5vZmZzZXQsXG4gICAgICBlbC5pbm5lckxvYy5lbmQub2Zmc2V0XG4gICAgKTtcbiAgfVxuICBjb25zdCB7IHRhZywgbnMsIGNoaWxkcmVuIH0gPSBlbDtcbiAgaWYgKCFpblZQcmUpIHtcbiAgICBpZiAodGFnID09PSBcInNsb3RcIikge1xuICAgICAgZWwudGFnVHlwZSA9IDI7XG4gICAgfSBlbHNlIGlmIChpc0ZyYWdtZW50VGVtcGxhdGUoZWwpKSB7XG4gICAgICBlbC50YWdUeXBlID0gMztcbiAgICB9IGVsc2UgaWYgKGlzQ29tcG9uZW50KGVsKSkge1xuICAgICAgZWwudGFnVHlwZSA9IDE7XG4gICAgfVxuICB9XG4gIGlmICghdG9rZW5pemVyLmluUkNEQVRBKSB7XG4gICAgZWwuY2hpbGRyZW4gPSBjb25kZW5zZVdoaXRlc3BhY2UoY2hpbGRyZW4pO1xuICB9XG4gIGlmIChucyA9PT0gMCAmJiBjdXJyZW50T3B0aW9ucy5pc0lnbm9yZU5ld2xpbmVUYWcodGFnKSkge1xuICAgIGNvbnN0IGZpcnN0ID0gY2hpbGRyZW5bMF07XG4gICAgaWYgKGZpcnN0ICYmIGZpcnN0LnR5cGUgPT09IDIpIHtcbiAgICAgIGZpcnN0LmNvbnRlbnQgPSBmaXJzdC5jb250ZW50LnJlcGxhY2UoL15cXHI/XFxuLywgXCJcIik7XG4gICAgfVxuICB9XG4gIGlmIChucyA9PT0gMCAmJiBjdXJyZW50T3B0aW9ucy5pc1ByZVRhZyh0YWcpKSB7XG4gICAgaW5QcmUtLTtcbiAgfVxuICBpZiAoY3VycmVudFZQcmVCb3VuZGFyeSA9PT0gZWwpIHtcbiAgICBpblZQcmUgPSB0b2tlbml6ZXIuaW5WUHJlID0gZmFsc2U7XG4gICAgY3VycmVudFZQcmVCb3VuZGFyeSA9IG51bGw7XG4gIH1cbiAgaWYgKHRva2VuaXplci5pblhNTCAmJiAoc3RhY2tbMF0gPyBzdGFja1swXS5ucyA6IGN1cnJlbnRPcHRpb25zLm5zKSA9PT0gMCkge1xuICAgIHRva2VuaXplci5pblhNTCA9IGZhbHNlO1xuICB9XG4gIHtcbiAgICBjb25zdCBwcm9wcyA9IGVsLnByb3BzO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzQ29tcGF0RW5hYmxlZChcbiAgICAgIFwiQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFXCIsXG4gICAgICBjdXJyZW50T3B0aW9uc1xuICAgICkpIHtcbiAgICAgIGxldCBoYXNJZiA9IGZhbHNlO1xuICAgICAgbGV0IGhhc0ZvciA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwID0gcHJvcHNbaV07XG4gICAgICAgIGlmIChwLnR5cGUgPT09IDcpIHtcbiAgICAgICAgICBpZiAocC5uYW1lID09PSBcImlmXCIpIHtcbiAgICAgICAgICAgIGhhc0lmID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAubmFtZSA9PT0gXCJmb3JcIikge1xuICAgICAgICAgICAgaGFzRm9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0lmICYmIGhhc0Zvcikge1xuICAgICAgICAgIHdhcm5EZXByZWNhdGlvbihcbiAgICAgICAgICAgIFwiQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFXCIsXG4gICAgICAgICAgICBjdXJyZW50T3B0aW9ucyxcbiAgICAgICAgICAgIGVsLmxvY1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0b2tlbml6ZXIuaW5TRkNSb290ICYmIGlzQ29tcGF0RW5hYmxlZChcbiAgICAgIFwiQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFXCIsXG4gICAgICBjdXJyZW50T3B0aW9uc1xuICAgICkgJiYgZWwudGFnID09PSBcInRlbXBsYXRlXCIgJiYgIWlzRnJhZ21lbnRUZW1wbGF0ZShlbCkpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybkRlcHJlY2F0aW9uKFxuICAgICAgICBcIkNPTVBJTEVSX05BVElWRV9URU1QTEFURVwiLFxuICAgICAgICBjdXJyZW50T3B0aW9ucyxcbiAgICAgICAgZWwubG9jXG4gICAgICApO1xuICAgICAgY29uc3QgcGFyZW50ID0gc3RhY2tbMF0gfHwgY3VycmVudFJvb3Q7XG4gICAgICBjb25zdCBpbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGVsKTtcbiAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEsIC4uLmVsLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgY29uc3QgaW5saW5lVGVtcGxhdGVQcm9wID0gcHJvcHMuZmluZChcbiAgICAgIChwKSA9PiBwLnR5cGUgPT09IDYgJiYgcC5uYW1lID09PSBcImlubGluZS10ZW1wbGF0ZVwiXG4gICAgKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGVQcm9wICYmIGNoZWNrQ29tcGF0RW5hYmxlZChcbiAgICAgIFwiQ09NUElMRVJfSU5MSU5FX1RFTVBMQVRFXCIsXG4gICAgICBjdXJyZW50T3B0aW9ucyxcbiAgICAgIGlubGluZVRlbXBsYXRlUHJvcC5sb2NcbiAgICApICYmIGVsLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgaW5saW5lVGVtcGxhdGVQcm9wLnZhbHVlID0ge1xuICAgICAgICB0eXBlOiAyLFxuICAgICAgICBjb250ZW50OiBnZXRTbGljZShcbiAgICAgICAgICBlbC5jaGlsZHJlblswXS5sb2Muc3RhcnQub2Zmc2V0LFxuICAgICAgICAgIGVsLmNoaWxkcmVuW2VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQub2Zmc2V0XG4gICAgICAgICksXG4gICAgICAgIGxvYzogaW5saW5lVGVtcGxhdGVQcm9wLmxvY1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGxvb2tBaGVhZChpbmRleCwgYykge1xuICBsZXQgaSA9IGluZGV4O1xuICB3aGlsZSAoY3VycmVudElucHV0LmNoYXJDb2RlQXQoaSkgIT09IGMgJiYgaSA8IGN1cnJlbnRJbnB1dC5sZW5ndGggLSAxKSBpKys7XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gYmFja1RyYWNrKGluZGV4LCBjKSB7XG4gIGxldCBpID0gaW5kZXg7XG4gIHdoaWxlIChjdXJyZW50SW5wdXQuY2hhckNvZGVBdChpKSAhPT0gYyAmJiBpID49IDApIGktLTtcbiAgcmV0dXJuIGk7XG59XG5jb25zdCBzcGVjaWFsVGVtcGxhdGVEaXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJpZlwiLCBcImVsc2VcIiwgXCJlbHNlLWlmXCIsIFwiZm9yXCIsIFwic2xvdFwiXSk7XG5mdW5jdGlvbiBpc0ZyYWdtZW50VGVtcGxhdGUoeyB0YWcsIHByb3BzIH0pIHtcbiAgaWYgKHRhZyA9PT0gXCJ0ZW1wbGF0ZVwiKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHByb3BzW2ldLnR5cGUgPT09IDcgJiYgc3BlY2lhbFRlbXBsYXRlRGlyLmhhcyhwcm9wc1tpXS5uYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNDb21wb25lbnQoeyB0YWcsIHByb3BzIH0pIHtcbiAgaWYgKGN1cnJlbnRPcHRpb25zLmlzQ3VzdG9tRWxlbWVudCh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0YWcgPT09IFwiY29tcG9uZW50XCIgfHwgaXNVcHBlckNhc2UodGFnLmNoYXJDb2RlQXQoMCkpIHx8IGlzQ29yZUNvbXBvbmVudCh0YWcpIHx8IGN1cnJlbnRPcHRpb25zLmlzQnVpbHRJbkNvbXBvbmVudCAmJiBjdXJyZW50T3B0aW9ucy5pc0J1aWx0SW5Db21wb25lbnQodGFnKSB8fCBjdXJyZW50T3B0aW9ucy5pc05hdGl2ZVRhZyAmJiAhY3VycmVudE9wdGlvbnMuaXNOYXRpdmVUYWcodGFnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwID0gcHJvcHNbaV07XG4gICAgaWYgKHAudHlwZSA9PT0gNikge1xuICAgICAgaWYgKHAubmFtZSA9PT0gXCJpc1wiICYmIHAudmFsdWUpIHtcbiAgICAgICAgaWYgKHAudmFsdWUuY29udGVudC5zdGFydHNXaXRoKFwidnVlOlwiKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoZWNrQ29tcGF0RW5hYmxlZChcbiAgICAgICAgICBcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIixcbiAgICAgICAgICBjdXJyZW50T3B0aW9ucyxcbiAgICAgICAgICBwLmxvY1xuICAgICAgICApKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKC8vIDppcyBvbiBwbGFpbiBlbGVtZW50IC0gb25seSB0cmVhdCBhcyBjb21wb25lbnQgaW4gY29tcGF0IG1vZGVcbiAgICBwLm5hbWUgPT09IFwiYmluZFwiICYmIGlzU3RhdGljQXJnT2YocC5hcmcsIFwiaXNcIikgJiYgY2hlY2tDb21wYXRFbmFibGVkKFxuICAgICAgXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIsXG4gICAgICBjdXJyZW50T3B0aW9ucyxcbiAgICAgIHAubG9jXG4gICAgKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzVXBwZXJDYXNlKGMpIHtcbiAgcmV0dXJuIGMgPiA2NCAmJiBjIDwgOTE7XG59XG5jb25zdCB3aW5kb3dzTmV3bGluZVJFID0gL1xcclxcbi9nO1xuZnVuY3Rpb24gY29uZGVuc2VXaGl0ZXNwYWNlKG5vZGVzKSB7XG4gIGNvbnN0IHNob3VsZENvbmRlbnNlID0gY3VycmVudE9wdGlvbnMud2hpdGVzcGFjZSAhPT0gXCJwcmVzZXJ2ZVwiO1xuICBsZXQgcmVtb3ZlZFdoaXRlc3BhY2UgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgICBpZiAoIWluUHJlKSB7XG4gICAgICAgIGlmIChpc0FsbFdoaXRlc3BhY2Uobm9kZS5jb250ZW50KSkge1xuICAgICAgICAgIGNvbnN0IHByZXYgPSBub2Rlc1tpIC0gMV0gJiYgbm9kZXNbaSAtIDFdLnR5cGU7XG4gICAgICAgICAgY29uc3QgbmV4dCA9IG5vZGVzW2kgKyAxXSAmJiBub2Rlc1tpICsgMV0udHlwZTtcbiAgICAgICAgICBpZiAoIXByZXYgfHwgIW5leHQgfHwgc2hvdWxkQ29uZGVuc2UgJiYgKHByZXYgPT09IDMgJiYgKG5leHQgPT09IDMgfHwgbmV4dCA9PT0gMSkgfHwgcHJldiA9PT0gMSAmJiAobmV4dCA9PT0gMyB8fCBuZXh0ID09PSAxICYmIGhhc05ld2xpbmVDaGFyKG5vZGUuY29udGVudCkpKSkge1xuICAgICAgICAgICAgcmVtb3ZlZFdoaXRlc3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgbm9kZXNbaV0gPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLmNvbnRlbnQgPSBcIiBcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkQ29uZGVuc2UpIHtcbiAgICAgICAgICBub2RlLmNvbnRlbnQgPSBjb25kZW5zZShub2RlLmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmNvbnRlbnQgPSBub2RlLmNvbnRlbnQucmVwbGFjZSh3aW5kb3dzTmV3bGluZVJFLCBcIlxcblwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbW92ZWRXaGl0ZXNwYWNlID8gbm9kZXMuZmlsdGVyKEJvb2xlYW4pIDogbm9kZXM7XG59XG5mdW5jdGlvbiBoYXNOZXdsaW5lQ2hhcihzdHIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPT09IDEwIHx8IGMgPT09IDEzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29uZGVuc2Uoc3RyKSB7XG4gIGxldCByZXQgPSBcIlwiO1xuICBsZXQgcHJldkNoYXJJc1doaXRlc3BhY2UgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNXaGl0ZXNwYWNlKHN0ci5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgaWYgKCFwcmV2Q2hhcklzV2hpdGVzcGFjZSkge1xuICAgICAgICByZXQgKz0gXCIgXCI7XG4gICAgICAgIHByZXZDaGFySXNXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ICs9IHN0cltpXTtcbiAgICAgIHByZXZDaGFySXNXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBhZGROb2RlKG5vZGUpIHtcbiAgKHN0YWNrWzBdIHx8IGN1cnJlbnRSb290KS5jaGlsZHJlbi5wdXNoKG5vZGUpO1xufVxuZnVuY3Rpb24gZ2V0TG9jKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogdG9rZW5pemVyLmdldFBvcyhzdGFydCksXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBhbGxvdyBsYXRlIGF0dGFjaG1lbnRcbiAgICBlbmQ6IGVuZCA9PSBudWxsID8gZW5kIDogdG9rZW5pemVyLmdldFBvcyhlbmQpLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYWxsb3cgbGF0ZSBhdHRhY2htZW50XG4gICAgc291cmNlOiBlbmQgPT0gbnVsbCA/IGVuZCA6IGdldFNsaWNlKHN0YXJ0LCBlbmQpXG4gIH07XG59XG5mdW5jdGlvbiBjbG9uZUxvYyhsb2MpIHtcbiAgcmV0dXJuIGdldExvYyhsb2Muc3RhcnQub2Zmc2V0LCBsb2MuZW5kLm9mZnNldCk7XG59XG5mdW5jdGlvbiBzZXRMb2NFbmQobG9jLCBlbmQpIHtcbiAgbG9jLmVuZCA9IHRva2VuaXplci5nZXRQb3MoZW5kKTtcbiAgbG9jLnNvdXJjZSA9IGdldFNsaWNlKGxvYy5zdGFydC5vZmZzZXQsIGVuZCk7XG59XG5mdW5jdGlvbiBkaXJUb0F0dHIoZGlyKSB7XG4gIGNvbnN0IGF0dHIgPSB7XG4gICAgdHlwZTogNixcbiAgICBuYW1lOiBkaXIucmF3TmFtZSxcbiAgICBuYW1lTG9jOiBnZXRMb2MoXG4gICAgICBkaXIubG9jLnN0YXJ0Lm9mZnNldCxcbiAgICAgIGRpci5sb2Muc3RhcnQub2Zmc2V0ICsgZGlyLnJhd05hbWUubGVuZ3RoXG4gICAgKSxcbiAgICB2YWx1ZTogdm9pZCAwLFxuICAgIGxvYzogZGlyLmxvY1xuICB9O1xuICBpZiAoZGlyLmV4cCkge1xuICAgIGNvbnN0IGxvYyA9IGRpci5leHAubG9jO1xuICAgIGlmIChsb2MuZW5kLm9mZnNldCA8IGRpci5sb2MuZW5kLm9mZnNldCkge1xuICAgICAgbG9jLnN0YXJ0Lm9mZnNldC0tO1xuICAgICAgbG9jLnN0YXJ0LmNvbHVtbi0tO1xuICAgICAgbG9jLmVuZC5vZmZzZXQrKztcbiAgICAgIGxvYy5lbmQuY29sdW1uKys7XG4gICAgfVxuICAgIGF0dHIudmFsdWUgPSB7XG4gICAgICB0eXBlOiAyLFxuICAgICAgY29udGVudDogZGlyLmV4cC5jb250ZW50LFxuICAgICAgbG9jXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYXR0cjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV4cChjb250ZW50LCBpc1N0YXRpYyA9IGZhbHNlLCBsb2MsIGNvbnN0VHlwZSA9IDAsIHBhcnNlTW9kZSA9IDAgLyogTm9ybWFsICovKSB7XG4gIGNvbnN0IGV4cCA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oY29udGVudCwgaXNTdGF0aWMsIGxvYywgY29uc3RUeXBlKTtcbiAgcmV0dXJuIGV4cDtcbn1cbmZ1bmN0aW9uIGVtaXRFcnJvcihjb2RlLCBpbmRleCwgbWVzc2FnZSkge1xuICBjdXJyZW50T3B0aW9ucy5vbkVycm9yKFxuICAgIGNyZWF0ZUNvbXBpbGVyRXJyb3IoY29kZSwgZ2V0TG9jKGluZGV4LCBpbmRleCksIHZvaWQgMCwgbWVzc2FnZSlcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICB0b2tlbml6ZXIucmVzZXQoKTtcbiAgY3VycmVudE9wZW5UYWcgPSBudWxsO1xuICBjdXJyZW50UHJvcCA9IG51bGw7XG4gIGN1cnJlbnRBdHRyVmFsdWUgPSBcIlwiO1xuICBjdXJyZW50QXR0clN0YXJ0SW5kZXggPSAtMTtcbiAgY3VycmVudEF0dHJFbmRJbmRleCA9IC0xO1xuICBzdGFjay5sZW5ndGggPSAwO1xufVxuZnVuY3Rpb24gYmFzZVBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIHJlc2V0KCk7XG4gIGN1cnJlbnRJbnB1dCA9IGlucHV0O1xuICBjdXJyZW50T3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdFBhcnNlck9wdGlvbnMpO1xuICBpZiAob3B0aW9ucykge1xuICAgIGxldCBrZXk7XG4gICAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnNba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaWYgKCFjdXJyZW50T3B0aW9ucy5kZWNvZGVFbnRpdGllcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgW0B2dWUvY29tcGlsZXItY29yZV0gZGVjb2RlRW50aXRpZXMgb3B0aW9uIGlzIHJlcXVpcmVkIGluIGJyb3dzZXIgYnVpbGRzLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRva2VuaXplci5tb2RlID0gY3VycmVudE9wdGlvbnMucGFyc2VNb2RlID09PSBcImh0bWxcIiA/IDEgOiBjdXJyZW50T3B0aW9ucy5wYXJzZU1vZGUgPT09IFwic2ZjXCIgPyAyIDogMDtcbiAgdG9rZW5pemVyLmluWE1MID0gY3VycmVudE9wdGlvbnMubnMgPT09IDEgfHwgY3VycmVudE9wdGlvbnMubnMgPT09IDI7XG4gIGNvbnN0IGRlbGltaXRlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVycztcbiAgaWYgKGRlbGltaXRlcnMpIHtcbiAgICB0b2tlbml6ZXIuZGVsaW1pdGVyT3BlbiA9IHRvQ2hhckNvZGVzKGRlbGltaXRlcnNbMF0pO1xuICAgIHRva2VuaXplci5kZWxpbWl0ZXJDbG9zZSA9IHRvQ2hhckNvZGVzKGRlbGltaXRlcnNbMV0pO1xuICB9XG4gIGNvbnN0IHJvb3QgPSBjdXJyZW50Um9vdCA9IGNyZWF0ZVJvb3QoW10sIGlucHV0KTtcbiAgdG9rZW5pemVyLnBhcnNlKGN1cnJlbnRJbnB1dCk7XG4gIHJvb3QubG9jID0gZ2V0TG9jKDAsIGlucHV0Lmxlbmd0aCk7XG4gIHJvb3QuY2hpbGRyZW4gPSBjb25kZW5zZVdoaXRlc3BhY2Uocm9vdC5jaGlsZHJlbik7XG4gIGN1cnJlbnRSb290ID0gbnVsbDtcbiAgcmV0dXJuIHJvb3Q7XG59XG5cbmZ1bmN0aW9uIGNhY2hlU3RhdGljKHJvb3QsIGNvbnRleHQpIHtcbiAgd2FsayhcbiAgICByb290LFxuICAgIHZvaWQgMCxcbiAgICBjb250ZXh0LFxuICAgIC8vIFJvb3Qgbm9kZSBpcyB1bmZvcnR1bmF0ZWx5IG5vbi1ob2lzdGFibGUgZHVlIHRvIHBvdGVudGlhbCBwYXJlbnRcbiAgICAvLyBmYWxsdGhyb3VnaCBhdHRyaWJ1dGVzLlxuICAgICEhZ2V0U2luZ2xlRWxlbWVudFJvb3Qocm9vdClcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFNpbmdsZUVsZW1lbnRSb290KHJvb3QpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSByb290LmNoaWxkcmVuLmZpbHRlcigoeCkgPT4geC50eXBlICE9PSAzKTtcbiAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXS50eXBlID09PSAxICYmICFpc1Nsb3RPdXRsZXQoY2hpbGRyZW5bMF0pID8gY2hpbGRyZW5bMF0gOiBudWxsO1xufVxuZnVuY3Rpb24gd2Fsayhub2RlLCBwYXJlbnQsIGNvbnRleHQsIGRvTm90SG9pc3ROb2RlID0gZmFsc2UsIGluRm9yID0gZmFsc2UpIHtcbiAgY29uc3QgeyBjaGlsZHJlbiB9ID0gbm9kZTtcbiAgY29uc3QgdG9DYWNoZSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gMSAmJiBjaGlsZC50YWdUeXBlID09PSAwKSB7XG4gICAgICBjb25zdCBjb25zdGFudFR5cGUgPSBkb05vdEhvaXN0Tm9kZSA/IDAgOiBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpO1xuICAgICAgaWYgKGNvbnN0YW50VHlwZSA+IDApIHtcbiAgICAgICAgaWYgKGNvbnN0YW50VHlwZSA+PSAyKSB7XG4gICAgICAgICAgY2hpbGQuY29kZWdlbk5vZGUucGF0Y2hGbGFnID0gLTE7XG4gICAgICAgICAgdG9DYWNoZS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBjaGlsZC5jb2RlZ2VuTm9kZTtcbiAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzKSB7XG4gICAgICAgICAgY29uc3QgZmxhZyA9IGNvZGVnZW5Ob2RlLnBhdGNoRmxhZztcbiAgICAgICAgICBpZiAoKGZsYWcgPT09IHZvaWQgMCB8fCBmbGFnID09PSA1MTIgfHwgZmxhZyA9PT0gMSkgJiYgZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpID49IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gZ2V0Tm9kZVByb3BzKGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgICAgICBjb2RlZ2VuTm9kZS5wcm9wcyA9IGNvbnRleHQuaG9pc3QocHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZWdlbk5vZGUuZHluYW1pY1Byb3BzKSB7XG4gICAgICAgICAgICBjb2RlZ2VuTm9kZS5keW5hbWljUHJvcHMgPSBjb250ZXh0LmhvaXN0KGNvZGVnZW5Ob2RlLmR5bmFtaWNQcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGlsZC50eXBlID09PSAxMikge1xuICAgICAgY29uc3QgY29uc3RhbnRUeXBlID0gZG9Ob3RIb2lzdE5vZGUgPyAwIDogZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KTtcbiAgICAgIGlmIChjb25zdGFudFR5cGUgPj0gMikge1xuICAgICAgICBpZiAoY2hpbGQuY29kZWdlbk5vZGUudHlwZSA9PT0gMTQgJiYgY2hpbGQuY29kZWdlbk5vZGUuYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjaGlsZC5jb2RlZ2VuTm9kZS5hcmd1bWVudHMucHVzaChcbiAgICAgICAgICAgIC0xICsgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbLTFdfSAqL2AgOiBgYClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRvQ2FjaGUucHVzaChjaGlsZCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gMSkge1xuICAgICAgY29uc3QgaXNDb21wb25lbnQgPSBjaGlsZC50YWdUeXBlID09PSAxO1xuICAgICAgaWYgKGlzQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnRleHQuc2NvcGVzLnZTbG90Kys7XG4gICAgICB9XG4gICAgICB3YWxrKGNoaWxkLCBub2RlLCBjb250ZXh0LCBmYWxzZSwgaW5Gb3IpO1xuICAgICAgaWYgKGlzQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnRleHQuc2NvcGVzLnZTbG90LS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGlsZC50eXBlID09PSAxMSkge1xuICAgICAgd2FsayhjaGlsZCwgbm9kZSwgY29udGV4dCwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID09PSAxLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDkpIHtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBjaGlsZC5icmFuY2hlcy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgd2FsayhcbiAgICAgICAgICBjaGlsZC5icmFuY2hlc1tpMl0sXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGNoaWxkLmJyYW5jaGVzW2kyXS5jaGlsZHJlbi5sZW5ndGggPT09IDEsXG4gICAgICAgICAgaW5Gb3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGNhY2hlZEFzQXJyYXkgPSBmYWxzZTtcbiAgaWYgKHRvQ2FjaGUubGVuZ3RoID09PSBjaGlsZHJlbi5sZW5ndGggJiYgbm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUudGFnVHlwZSA9PT0gMCAmJiBub2RlLmNvZGVnZW5Ob2RlICYmIG5vZGUuY29kZWdlbk5vZGUudHlwZSA9PT0gMTMgJiYgaXNBcnJheShub2RlLmNvZGVnZW5Ob2RlLmNoaWxkcmVuKSkge1xuICAgICAgbm9kZS5jb2RlZ2VuTm9kZS5jaGlsZHJlbiA9IGdldENhY2hlRXhwcmVzc2lvbihcbiAgICAgICAgY3JlYXRlQXJyYXlFeHByZXNzaW9uKG5vZGUuY29kZWdlbk5vZGUuY2hpbGRyZW4pXG4gICAgICApO1xuICAgICAgY2FjaGVkQXNBcnJheSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChub2RlLnRhZ1R5cGUgPT09IDEgJiYgbm9kZS5jb2RlZ2VuTm9kZSAmJiBub2RlLmNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzICYmIG5vZGUuY29kZWdlbk5vZGUuY2hpbGRyZW4gJiYgIWlzQXJyYXkobm9kZS5jb2RlZ2VuTm9kZS5jaGlsZHJlbikgJiYgbm9kZS5jb2RlZ2VuTm9kZS5jaGlsZHJlbi50eXBlID09PSAxNSkge1xuICAgICAgY29uc3Qgc2xvdCA9IGdldFNsb3ROb2RlKG5vZGUuY29kZWdlbk5vZGUsIFwiZGVmYXVsdFwiKTtcbiAgICAgIGlmIChzbG90KSB7XG4gICAgICAgIHNsb3QucmV0dXJucyA9IGdldENhY2hlRXhwcmVzc2lvbihcbiAgICAgICAgICBjcmVhdGVBcnJheUV4cHJlc3Npb24oc2xvdC5yZXR1cm5zKVxuICAgICAgICApO1xuICAgICAgICBjYWNoZWRBc0FycmF5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnVHlwZSA9PT0gMyAmJiBwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09IDEgJiYgcGFyZW50LnRhZ1R5cGUgPT09IDEgJiYgcGFyZW50LmNvZGVnZW5Ob2RlICYmIHBhcmVudC5jb2RlZ2VuTm9kZS50eXBlID09PSAxMyAmJiBwYXJlbnQuY29kZWdlbk5vZGUuY2hpbGRyZW4gJiYgIWlzQXJyYXkocGFyZW50LmNvZGVnZW5Ob2RlLmNoaWxkcmVuKSAmJiBwYXJlbnQuY29kZWdlbk5vZGUuY2hpbGRyZW4udHlwZSA9PT0gMTUpIHtcbiAgICAgIGNvbnN0IHNsb3ROYW1lID0gZmluZERpcihub2RlLCBcInNsb3RcIiwgdHJ1ZSk7XG4gICAgICBjb25zdCBzbG90ID0gc2xvdE5hbWUgJiYgc2xvdE5hbWUuYXJnICYmIGdldFNsb3ROb2RlKHBhcmVudC5jb2RlZ2VuTm9kZSwgc2xvdE5hbWUuYXJnKTtcbiAgICAgIGlmIChzbG90KSB7XG4gICAgICAgIHNsb3QucmV0dXJucyA9IGdldENhY2hlRXhwcmVzc2lvbihcbiAgICAgICAgICBjcmVhdGVBcnJheUV4cHJlc3Npb24oc2xvdC5yZXR1cm5zKVxuICAgICAgICApO1xuICAgICAgICBjYWNoZWRBc0FycmF5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFjYWNoZWRBc0FycmF5KSB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0b0NhY2hlKSB7XG4gICAgICBjaGlsZC5jb2RlZ2VuTm9kZSA9IGNvbnRleHQuY2FjaGUoY2hpbGQuY29kZWdlbk5vZGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRDYWNoZUV4cHJlc3Npb24odmFsdWUpIHtcbiAgICBjb25zdCBleHAgPSBjb250ZXh0LmNhY2hlKHZhbHVlKTtcbiAgICBleHAubmVlZEFycmF5U3ByZWFkID0gdHJ1ZTtcbiAgICByZXR1cm4gZXhwO1xuICB9XG4gIGZ1bmN0aW9uIGdldFNsb3ROb2RlKG5vZGUyLCBuYW1lKSB7XG4gICAgaWYgKG5vZGUyLmNoaWxkcmVuICYmICFpc0FycmF5KG5vZGUyLmNoaWxkcmVuKSAmJiBub2RlMi5jaGlsZHJlbi50eXBlID09PSAxNSkge1xuICAgICAgY29uc3Qgc2xvdCA9IG5vZGUyLmNoaWxkcmVuLnByb3BlcnRpZXMuZmluZChcbiAgICAgICAgKHApID0+IHAua2V5ID09PSBuYW1lIHx8IHAua2V5LmNvbnRlbnQgPT09IG5hbWVcbiAgICAgICk7XG4gICAgICByZXR1cm4gc2xvdCAmJiBzbG90LnZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAodG9DYWNoZS5sZW5ndGggJiYgY29udGV4dC50cmFuc2Zvcm1Ib2lzdCkge1xuICAgIGNvbnRleHQudHJhbnNmb3JtSG9pc3QoY2hpbGRyZW4sIGNvbnRleHQsIG5vZGUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDb25zdGFudFR5cGUobm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IGNvbnN0YW50Q2FjaGUgfSA9IGNvbnRleHQ7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSAxOlxuICAgICAgaWYgKG5vZGUudGFnVHlwZSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNvbnN0YW50Q2FjaGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKGNhY2hlZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IG5vZGUuY29kZWdlbk5vZGU7XG4gICAgICBpZiAoY29kZWdlbk5vZGUudHlwZSAhPT0gMTMpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoY29kZWdlbk5vZGUuaXNCbG9jayAmJiBub2RlLnRhZyAhPT0gXCJzdmdcIiAmJiBub2RlLnRhZyAhPT0gXCJmb3JlaWduT2JqZWN0XCIgJiYgbm9kZS50YWcgIT09IFwibWF0aFwiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGVnZW5Ob2RlLnBhdGNoRmxhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxldCByZXR1cm5UeXBlMiA9IDM7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZFByb3BzVHlwZSA9IGdldEdlbmVyYXRlZFByb3BzQ29uc3RhbnRUeXBlKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICBpZiAoZ2VuZXJhdGVkUHJvcHNUeXBlID09PSAwKSB7XG4gICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCk7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlbmVyYXRlZFByb3BzVHlwZSA8IHJldHVyblR5cGUyKSB7XG4gICAgICAgICAgcmV0dXJuVHlwZTIgPSBnZW5lcmF0ZWRQcm9wc1R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKG5vZGUuY2hpbGRyZW5baV0sIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChjaGlsZFR5cGUgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDApO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGlsZFR5cGUgPCByZXR1cm5UeXBlMikge1xuICAgICAgICAgICAgcmV0dXJuVHlwZTIgPSBjaGlsZFR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXR1cm5UeXBlMiA+IDEpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xuICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAmJiBwLm5hbWUgPT09IFwiYmluZFwiICYmIHAuZXhwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4cFR5cGUgPSBnZXRDb25zdGFudFR5cGUocC5leHAsIGNvbnRleHQpO1xuICAgICAgICAgICAgICBpZiAoZXhwVHlwZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChleHBUeXBlIDwgcmV0dXJuVHlwZTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5UeXBlMiA9IGV4cFR5cGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLmlzQmxvY2spIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xuICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNykge1xuICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCAwKTtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRleHQucmVtb3ZlSGVscGVyKE9QRU5fQkxPQ0spO1xuICAgICAgICAgIGNvbnRleHQucmVtb3ZlSGVscGVyKFxuICAgICAgICAgICAgZ2V0Vk5vZGVCbG9ja0hlbHBlcihjb250ZXh0LmluU1NSLCBjb2RlZ2VuTm9kZS5pc0NvbXBvbmVudClcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvZGVnZW5Ob2RlLmlzQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICBjb250ZXh0LmhlbHBlcihnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBjb2RlZ2VuTm9kZS5pc0NvbXBvbmVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIHJldHVyblR5cGUyKTtcbiAgICAgICAgcmV0dXJuIHJldHVyblR5cGUyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIGNhc2UgMjpcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gMztcbiAgICBjYXNlIDk6XG4gICAgY2FzZSAxMTpcbiAgICBjYXNlIDEwOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSA1OlxuICAgIGNhc2UgMTI6XG4gICAgICByZXR1cm4gZ2V0Q29uc3RhbnRUeXBlKG5vZGUuY29udGVudCwgY29udGV4dCk7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIG5vZGUuY29uc3RUeXBlO1xuICAgIGNhc2UgODpcbiAgICAgIGxldCByZXR1cm5UeXBlID0gMztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChpc1N0cmluZyhjaGlsZCkgfHwgaXNTeW1ib2woY2hpbGQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGNoaWxkVHlwZSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkVHlwZSA8IHJldHVyblR5cGUpIHtcbiAgICAgICAgICByZXR1cm5UeXBlID0gY2hpbGRUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuVHlwZTtcbiAgICBjYXNlIDIwOlxuICAgICAgcmV0dXJuIDI7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSA7XG4gICAgICByZXR1cm4gMDtcbiAgfVxufVxuY29uc3QgYWxsb3dIb2lzdGVkSGVscGVyU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBOT1JNQUxJWkVfQ0xBU1MsXG4gIE5PUk1BTElaRV9TVFlMRSxcbiAgTk9STUFMSVpFX1BST1BTLFxuICBHVUFSRF9SRUFDVElWRV9QUk9QU1xuXSk7XG5mdW5jdGlvbiBnZXRDb25zdGFudFR5cGVPZkhlbHBlckNhbGwodmFsdWUsIGNvbnRleHQpIHtcbiAgaWYgKHZhbHVlLnR5cGUgPT09IDE0ICYmICFpc1N0cmluZyh2YWx1ZS5jYWxsZWUpICYmIGFsbG93SG9pc3RlZEhlbHBlclNldC5oYXModmFsdWUuY2FsbGVlKSkge1xuICAgIGNvbnN0IGFyZyA9IHZhbHVlLmFyZ3VtZW50c1swXTtcbiAgICBpZiAoYXJnLnR5cGUgPT09IDQpIHtcbiAgICAgIHJldHVybiBnZXRDb25zdGFudFR5cGUoYXJnLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGFyZy50eXBlID09PSAxNCkge1xuICAgICAgcmV0dXJuIGdldENvbnN0YW50VHlwZU9mSGVscGVyQ2FsbChhcmcsIGNvbnRleHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGdldEdlbmVyYXRlZFByb3BzQ29uc3RhbnRUeXBlKG5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IHJldHVyblR5cGUgPSAzO1xuICBjb25zdCBwcm9wcyA9IGdldE5vZGVQcm9wcyhub2RlKTtcbiAgaWYgKHByb3BzICYmIHByb3BzLnR5cGUgPT09IDE1KSB7XG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBwcm9wcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcHJvcGVydGllc1tpXTtcbiAgICAgIGNvbnN0IGtleVR5cGUgPSBnZXRDb25zdGFudFR5cGUoa2V5LCBjb250ZXh0KTtcbiAgICAgIGlmIChrZXlUeXBlID09PSAwKSB7XG4gICAgICAgIHJldHVybiBrZXlUeXBlO1xuICAgICAgfVxuICAgICAgaWYgKGtleVR5cGUgPCByZXR1cm5UeXBlKSB7XG4gICAgICAgIHJldHVyblR5cGUgPSBrZXlUeXBlO1xuICAgICAgfVxuICAgICAgbGV0IHZhbHVlVHlwZTtcbiAgICAgIGlmICh2YWx1ZS50eXBlID09PSA0KSB7XG4gICAgICAgIHZhbHVlVHlwZSA9IGdldENvbnN0YW50VHlwZSh2YWx1ZSwgY29udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09IDE0KSB7XG4gICAgICAgIHZhbHVlVHlwZSA9IGdldENvbnN0YW50VHlwZU9mSGVscGVyQ2FsbCh2YWx1ZSwgY29udGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZVR5cGUgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdmFsdWVUeXBlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlVHlwZSA8IHJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuVHlwZSA9IHZhbHVlVHlwZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldHVyblR5cGU7XG59XG5mdW5jdGlvbiBnZXROb2RlUHJvcHMobm9kZSkge1xuICBjb25zdCBjb2RlZ2VuTm9kZSA9IG5vZGUuY29kZWdlbk5vZGU7XG4gIGlmIChjb2RlZ2VuTm9kZS50eXBlID09PSAxMykge1xuICAgIHJldHVybiBjb2RlZ2VuTm9kZS5wcm9wcztcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1Db250ZXh0KHJvb3QsIHtcbiAgZmlsZW5hbWUgPSBcIlwiLFxuICBwcmVmaXhJZGVudGlmaWVycyA9IGZhbHNlLFxuICBob2lzdFN0YXRpYyA9IGZhbHNlLFxuICBobXIgPSBmYWxzZSxcbiAgY2FjaGVIYW5kbGVycyA9IGZhbHNlLFxuICBub2RlVHJhbnNmb3JtcyA9IFtdLFxuICBkaXJlY3RpdmVUcmFuc2Zvcm1zID0ge30sXG4gIHRyYW5zZm9ybUhvaXN0ID0gbnVsbCxcbiAgaXNCdWlsdEluQ29tcG9uZW50ID0gTk9PUCxcbiAgaXNDdXN0b21FbGVtZW50ID0gTk9PUCxcbiAgZXhwcmVzc2lvblBsdWdpbnMgPSBbXSxcbiAgc2NvcGVJZCA9IG51bGwsXG4gIHNsb3R0ZWQgPSB0cnVlLFxuICBzc3IgPSBmYWxzZSxcbiAgaW5TU1IgPSBmYWxzZSxcbiAgc3NyQ3NzVmFycyA9IGBgLFxuICBiaW5kaW5nTWV0YWRhdGEgPSBFTVBUWV9PQkosXG4gIGlubGluZSA9IGZhbHNlLFxuICBpc1RTID0gZmFsc2UsXG4gIG9uRXJyb3IgPSBkZWZhdWx0T25FcnJvcixcbiAgb25XYXJuID0gZGVmYXVsdE9uV2FybixcbiAgY29tcGF0Q29uZmlnXG59KSB7XG4gIGNvbnN0IG5hbWVNYXRjaCA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgLy8gb3B0aW9uc1xuICAgIGZpbGVuYW1lLFxuICAgIHNlbGZOYW1lOiBuYW1lTWF0Y2ggJiYgY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lTWF0Y2hbMV0pKSxcbiAgICBwcmVmaXhJZGVudGlmaWVycyxcbiAgICBob2lzdFN0YXRpYyxcbiAgICBobXIsXG4gICAgY2FjaGVIYW5kbGVycyxcbiAgICBub2RlVHJhbnNmb3JtcyxcbiAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zLFxuICAgIHRyYW5zZm9ybUhvaXN0LFxuICAgIGlzQnVpbHRJbkNvbXBvbmVudCxcbiAgICBpc0N1c3RvbUVsZW1lbnQsXG4gICAgZXhwcmVzc2lvblBsdWdpbnMsXG4gICAgc2NvcGVJZCxcbiAgICBzbG90dGVkLFxuICAgIHNzcixcbiAgICBpblNTUixcbiAgICBzc3JDc3NWYXJzLFxuICAgIGJpbmRpbmdNZXRhZGF0YSxcbiAgICBpbmxpbmUsXG4gICAgaXNUUyxcbiAgICBvbkVycm9yLFxuICAgIG9uV2FybixcbiAgICBjb21wYXRDb25maWcsXG4gICAgLy8gc3RhdGVcbiAgICByb290LFxuICAgIGhlbHBlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgY29tcG9uZW50czogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICBkaXJlY3RpdmVzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgIGhvaXN0czogW10sXG4gICAgaW1wb3J0czogW10sXG4gICAgY2FjaGVkOiBbXSxcbiAgICBjb25zdGFudENhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSxcbiAgICB0ZW1wczogMCxcbiAgICBpZGVudGlmaWVyczogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgc2NvcGVzOiB7XG4gICAgICB2Rm9yOiAwLFxuICAgICAgdlNsb3Q6IDAsXG4gICAgICB2UHJlOiAwLFxuICAgICAgdk9uY2U6IDBcbiAgICB9LFxuICAgIHBhcmVudDogbnVsbCxcbiAgICBncmFuZFBhcmVudDogbnVsbCxcbiAgICBjdXJyZW50Tm9kZTogcm9vdCxcbiAgICBjaGlsZEluZGV4OiAwLFxuICAgIGluVk9uY2U6IGZhbHNlLFxuICAgIC8vIG1ldGhvZHNcbiAgICBoZWxwZXIobmFtZSkge1xuICAgICAgY29uc3QgY291bnQgPSBjb250ZXh0LmhlbHBlcnMuZ2V0KG5hbWUpIHx8IDA7XG4gICAgICBjb250ZXh0LmhlbHBlcnMuc2V0KG5hbWUsIGNvdW50ICsgMSk7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9LFxuICAgIHJlbW92ZUhlbHBlcihuYW1lKSB7XG4gICAgICBjb25zdCBjb3VudCA9IGNvbnRleHQuaGVscGVycy5nZXQobmFtZSk7XG4gICAgICBpZiAoY291bnQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENvdW50ID0gY291bnQgLSAxO1xuICAgICAgICBpZiAoIWN1cnJlbnRDb3VudCkge1xuICAgICAgICAgIGNvbnRleHQuaGVscGVycy5kZWxldGUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5oZWxwZXJzLnNldChuYW1lLCBjdXJyZW50Q291bnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBoZWxwZXJTdHJpbmcobmFtZSkge1xuICAgICAgcmV0dXJuIGBfJHtoZWxwZXJOYW1lTWFwW2NvbnRleHQuaGVscGVyKG5hbWUpXX1gO1xuICAgIH0sXG4gICAgcmVwbGFjZU5vZGUobm9kZSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgaWYgKCFjb250ZXh0LmN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb2RlIGJlaW5nIHJlcGxhY2VkIGlzIGFscmVhZHkgcmVtb3ZlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRleHQucGFyZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVwbGFjZSByb290IG5vZGUuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnRleHQucGFyZW50LmNoaWxkcmVuW2NvbnRleHQuY2hpbGRJbmRleF0gPSBjb250ZXh0LmN1cnJlbnROb2RlID0gbm9kZTtcbiAgICB9LFxuICAgIHJlbW92ZU5vZGUobm9kZSkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWNvbnRleHQucGFyZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlbW92ZSByb290IG5vZGUuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaXN0ID0gY29udGV4dC5wYXJlbnQuY2hpbGRyZW47XG4gICAgICBjb25zdCByZW1vdmFsSW5kZXggPSBub2RlID8gbGlzdC5pbmRleE9mKG5vZGUpIDogY29udGV4dC5jdXJyZW50Tm9kZSA/IGNvbnRleHQuY2hpbGRJbmRleCA6IC0xO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcmVtb3ZhbEluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vZGUgYmVpbmcgcmVtb3ZlZCBpcyBub3QgYSBjaGlsZCBvZiBjdXJyZW50IHBhcmVudGApO1xuICAgICAgfVxuICAgICAgaWYgKCFub2RlIHx8IG5vZGUgPT09IGNvbnRleHQuY3VycmVudE5vZGUpIHtcbiAgICAgICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbnRleHQuY2hpbGRJbmRleCA+IHJlbW92YWxJbmRleCkge1xuICAgICAgICAgIGNvbnRleHQuY2hpbGRJbmRleC0tO1xuICAgICAgICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250ZXh0LnBhcmVudC5jaGlsZHJlbi5zcGxpY2UocmVtb3ZhbEluZGV4LCAxKTtcbiAgICB9LFxuICAgIG9uTm9kZVJlbW92ZWQ6IE5PT1AsXG4gICAgYWRkSWRlbnRpZmllcnMoZXhwKSB7XG4gICAgfSxcbiAgICByZW1vdmVJZGVudGlmaWVycyhleHApIHtcbiAgICB9LFxuICAgIGhvaXN0KGV4cCkge1xuICAgICAgaWYgKGlzU3RyaW5nKGV4cCkpIGV4cCA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oZXhwKTtcbiAgICAgIGNvbnRleHQuaG9pc3RzLnB1c2goZXhwKTtcbiAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKFxuICAgICAgICBgX2hvaXN0ZWRfJHtjb250ZXh0LmhvaXN0cy5sZW5ndGh9YCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGV4cC5sb2MsXG4gICAgICAgIDJcbiAgICAgICk7XG4gICAgICBpZGVudGlmaWVyLmhvaXN0ZWQgPSBleHA7XG4gICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICB9LFxuICAgIGNhY2hlKGV4cCwgaXNWTm9kZSA9IGZhbHNlLCBpblZPbmNlID0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGNhY2hlRXhwID0gY3JlYXRlQ2FjaGVFeHByZXNzaW9uKFxuICAgICAgICBjb250ZXh0LmNhY2hlZC5sZW5ndGgsXG4gICAgICAgIGV4cCxcbiAgICAgICAgaXNWTm9kZSxcbiAgICAgICAgaW5WT25jZVxuICAgICAgKTtcbiAgICAgIGNvbnRleHQuY2FjaGVkLnB1c2goY2FjaGVFeHApO1xuICAgICAgcmV0dXJuIGNhY2hlRXhwO1xuICAgIH1cbiAgfTtcbiAge1xuICAgIGNvbnRleHQuZmlsdGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm0ocm9vdCwgb3B0aW9ucykge1xuICBjb25zdCBjb250ZXh0ID0gY3JlYXRlVHJhbnNmb3JtQ29udGV4dChyb290LCBvcHRpb25zKTtcbiAgdHJhdmVyc2VOb2RlKHJvb3QsIGNvbnRleHQpO1xuICBpZiAob3B0aW9ucy5ob2lzdFN0YXRpYykge1xuICAgIGNhY2hlU3RhdGljKHJvb3QsIGNvbnRleHQpO1xuICB9XG4gIGlmICghb3B0aW9ucy5zc3IpIHtcbiAgICBjcmVhdGVSb290Q29kZWdlbihyb290LCBjb250ZXh0KTtcbiAgfVxuICByb290LmhlbHBlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uY29udGV4dC5oZWxwZXJzLmtleXMoKV0pO1xuICByb290LmNvbXBvbmVudHMgPSBbLi4uY29udGV4dC5jb21wb25lbnRzXTtcbiAgcm9vdC5kaXJlY3RpdmVzID0gWy4uLmNvbnRleHQuZGlyZWN0aXZlc107XG4gIHJvb3QuaW1wb3J0cyA9IGNvbnRleHQuaW1wb3J0cztcbiAgcm9vdC5ob2lzdHMgPSBjb250ZXh0LmhvaXN0cztcbiAgcm9vdC50ZW1wcyA9IGNvbnRleHQudGVtcHM7XG4gIHJvb3QuY2FjaGVkID0gY29udGV4dC5jYWNoZWQ7XG4gIHJvb3QudHJhbnNmb3JtZWQgPSB0cnVlO1xuICB7XG4gICAgcm9vdC5maWx0ZXJzID0gWy4uLmNvbnRleHQuZmlsdGVyc107XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RDb2RlZ2VuKHJvb3QsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBoZWxwZXIgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHJvb3Q7XG4gIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBzaW5nbGVFbGVtZW50Um9vdENoaWxkID0gZ2V0U2luZ2xlRWxlbWVudFJvb3Qocm9vdCk7XG4gICAgaWYgKHNpbmdsZUVsZW1lbnRSb290Q2hpbGQgJiYgc2luZ2xlRWxlbWVudFJvb3RDaGlsZC5jb2RlZ2VuTm9kZSkge1xuICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBzaW5nbGVFbGVtZW50Um9vdENoaWxkLmNvZGVnZW5Ob2RlO1xuICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzKSB7XG4gICAgICAgIGNvbnZlcnRUb0Jsb2NrKGNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIHJvb3QuY29kZWdlbk5vZGUgPSBjb2RlZ2VuTm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdC5jb2RlZ2VuTm9kZSA9IGNoaWxkcmVuWzBdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgbGV0IHBhdGNoRmxhZyA9IDY0O1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoaWxkcmVuLmZpbHRlcigoYykgPT4gYy50eXBlICE9PSAzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHBhdGNoRmxhZyB8PSAyMDQ4O1xuICAgIH1cbiAgICByb290LmNvZGVnZW5Ob2RlID0gY3JlYXRlVk5vZGVDYWxsKFxuICAgICAgY29udGV4dCxcbiAgICAgIGhlbHBlcihGUkFHTUVOVCksXG4gICAgICB2b2lkIDAsXG4gICAgICByb290LmNoaWxkcmVuLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgdm9pZCAwLFxuICAgICAgdm9pZCAwLFxuICAgICAgdHJ1ZSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgfSBlbHNlIDtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlQ2hpbGRyZW4ocGFyZW50LCBjb250ZXh0KSB7XG4gIGxldCBpID0gMDtcbiAgY29uc3Qgbm9kZVJlbW92ZWQgPSAoKSA9PiB7XG4gICAgaS0tO1xuICB9O1xuICBmb3IgKDsgaSA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1N0cmluZyhjaGlsZCkpIGNvbnRpbnVlO1xuICAgIGNvbnRleHQuZ3JhbmRQYXJlbnQgPSBjb250ZXh0LnBhcmVudDtcbiAgICBjb250ZXh0LnBhcmVudCA9IHBhcmVudDtcbiAgICBjb250ZXh0LmNoaWxkSW5kZXggPSBpO1xuICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCA9IG5vZGVSZW1vdmVkO1xuICAgIHRyYXZlcnNlTm9kZShjaGlsZCwgY29udGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlTm9kZShub2RlLCBjb250ZXh0KSB7XG4gIGNvbnRleHQuY3VycmVudE5vZGUgPSBub2RlO1xuICBjb25zdCB7IG5vZGVUcmFuc2Zvcm1zIH0gPSBjb250ZXh0O1xuICBjb25zdCBleGl0Rm5zID0gW107XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBub2RlVHJhbnNmb3Jtcy5sZW5ndGg7IGkyKyspIHtcbiAgICBjb25zdCBvbkV4aXQgPSBub2RlVHJhbnNmb3Jtc1tpMl0obm9kZSwgY29udGV4dCk7XG4gICAgaWYgKG9uRXhpdCkge1xuICAgICAgaWYgKGlzQXJyYXkob25FeGl0KSkge1xuICAgICAgICBleGl0Rm5zLnB1c2goLi4ub25FeGl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXRGbnMucHVzaChvbkV4aXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNvbnRleHQuY3VycmVudE5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IGNvbnRleHQuY3VycmVudE5vZGU7XG4gICAgfVxuICB9XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSAzOlxuICAgICAgaWYgKCFjb250ZXh0LnNzcikge1xuICAgICAgICBjb250ZXh0LmhlbHBlcihDUkVBVEVfQ09NTUVOVCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDU6XG4gICAgICBpZiAoIWNvbnRleHQuc3NyKSB7XG4gICAgICAgIGNvbnRleHQuaGVscGVyKFRPX0RJU1BMQVlfU1RSSU5HKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIC8vIGZvciBjb250YWluZXIgdHlwZXMsIGZ1cnRoZXIgdHJhdmVyc2UgZG93bndhcmRzXG4gICAgY2FzZSA5OlxuICAgICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IG5vZGUuYnJhbmNoZXMubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgIHRyYXZlcnNlTm9kZShub2RlLmJyYW5jaGVzW2kyXSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEwOlxuICAgIGNhc2UgMTE6XG4gICAgY2FzZSAxOlxuICAgIGNhc2UgMDpcbiAgICAgIHRyYXZlcnNlQ2hpbGRyZW4obm9kZSwgY29udGV4dCk7XG4gICAgICBicmVhaztcbiAgfVxuICBjb250ZXh0LmN1cnJlbnROb2RlID0gbm9kZTtcbiAgbGV0IGkgPSBleGl0Rm5zLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGV4aXRGbnNbaV0oKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybShuYW1lLCBmbikge1xuICBjb25zdCBtYXRjaGVzID0gaXNTdHJpbmcobmFtZSkgPyAobikgPT4gbiA9PT0gbmFtZSA6IChuKSA9PiBuYW1lLnRlc3Qobik7XG4gIHJldHVybiAobm9kZSwgY29udGV4dCkgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IG5vZGU7XG4gICAgICBpZiAobm9kZS50YWdUeXBlID09PSAzICYmIHByb3BzLnNvbWUoaXNWU2xvdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZXhpdEZucyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgIGlmIChwcm9wLnR5cGUgPT09IDcgJiYgbWF0Y2hlcyhwcm9wLm5hbWUpKSB7XG4gICAgICAgICAgcHJvcHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgICBjb25zdCBvbkV4aXQgPSBmbihub2RlLCBwcm9wLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAob25FeGl0KSBleGl0Rm5zLnB1c2gob25FeGl0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV4aXRGbnM7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBQVVJFX0FOTk9UQVRJT04gPSBgLypAX19QVVJFX18qL2A7XG5jb25zdCBhbGlhc0hlbHBlciA9IChzKSA9PiBgJHtoZWxwZXJOYW1lTWFwW3NdfTogXyR7aGVscGVyTmFtZU1hcFtzXX1gO1xuZnVuY3Rpb24gY3JlYXRlQ29kZWdlbkNvbnRleHQoYXN0LCB7XG4gIG1vZGUgPSBcImZ1bmN0aW9uXCIsXG4gIHByZWZpeElkZW50aWZpZXJzID0gbW9kZSA9PT0gXCJtb2R1bGVcIixcbiAgc291cmNlTWFwID0gZmFsc2UsXG4gIGZpbGVuYW1lID0gYHRlbXBsYXRlLnZ1ZS5odG1sYCxcbiAgc2NvcGVJZCA9IG51bGwsXG4gIG9wdGltaXplSW1wb3J0cyA9IGZhbHNlLFxuICBydW50aW1lR2xvYmFsTmFtZSA9IGBWdWVgLFxuICBydW50aW1lTW9kdWxlTmFtZSA9IGB2dWVgLFxuICBzc3JSdW50aW1lTW9kdWxlTmFtZSA9IFwidnVlL3NlcnZlci1yZW5kZXJlclwiLFxuICBzc3IgPSBmYWxzZSxcbiAgaXNUUyA9IGZhbHNlLFxuICBpblNTUiA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgbW9kZSxcbiAgICBwcmVmaXhJZGVudGlmaWVycyxcbiAgICBzb3VyY2VNYXAsXG4gICAgZmlsZW5hbWUsXG4gICAgc2NvcGVJZCxcbiAgICBvcHRpbWl6ZUltcG9ydHMsXG4gICAgcnVudGltZUdsb2JhbE5hbWUsXG4gICAgcnVudGltZU1vZHVsZU5hbWUsXG4gICAgc3NyUnVudGltZU1vZHVsZU5hbWUsXG4gICAgc3NyLFxuICAgIGlzVFMsXG4gICAgaW5TU1IsXG4gICAgc291cmNlOiBhc3Quc291cmNlLFxuICAgIGNvZGU6IGBgLFxuICAgIGNvbHVtbjogMSxcbiAgICBsaW5lOiAxLFxuICAgIG9mZnNldDogMCxcbiAgICBpbmRlbnRMZXZlbDogMCxcbiAgICBwdXJlOiBmYWxzZSxcbiAgICBtYXA6IHZvaWQgMCxcbiAgICBoZWxwZXIoa2V5KSB7XG4gICAgICByZXR1cm4gYF8ke2hlbHBlck5hbWVNYXBba2V5XX1gO1xuICAgIH0sXG4gICAgcHVzaChjb2RlLCBuZXdsaW5lSW5kZXggPSAtMiAvKiBOb25lICovLCBub2RlKSB7XG4gICAgICBjb250ZXh0LmNvZGUgKz0gY29kZTtcbiAgICB9LFxuICAgIGluZGVudCgpIHtcbiAgICAgIG5ld2xpbmUoKytjb250ZXh0LmluZGVudExldmVsKTtcbiAgICB9LFxuICAgIGRlaW5kZW50KHdpdGhvdXROZXdMaW5lID0gZmFsc2UpIHtcbiAgICAgIGlmICh3aXRob3V0TmV3TGluZSkge1xuICAgICAgICAtLWNvbnRleHQuaW5kZW50TGV2ZWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdsaW5lKC0tY29udGV4dC5pbmRlbnRMZXZlbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBuZXdsaW5lKCkge1xuICAgICAgbmV3bGluZShjb250ZXh0LmluZGVudExldmVsKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIG5ld2xpbmUobikge1xuICAgIGNvbnRleHQucHVzaChcIlxcblwiICsgYCAgYC5yZXBlYXQobiksIDAgLyogU3RhcnQgKi8pO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGUoYXN0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNvZGVnZW5Db250ZXh0KGFzdCwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLm9uQ29udGV4dENyZWF0ZWQpIG9wdGlvbnMub25Db250ZXh0Q3JlYXRlZChjb250ZXh0KTtcbiAgY29uc3Qge1xuICAgIG1vZGUsXG4gICAgcHVzaCxcbiAgICBwcmVmaXhJZGVudGlmaWVycyxcbiAgICBpbmRlbnQsXG4gICAgZGVpbmRlbnQsXG4gICAgbmV3bGluZSxcbiAgICBzY29wZUlkLFxuICAgIHNzclxuICB9ID0gY29udGV4dDtcbiAgY29uc3QgaGVscGVycyA9IEFycmF5LmZyb20oYXN0LmhlbHBlcnMpO1xuICBjb25zdCBoYXNIZWxwZXJzID0gaGVscGVycy5sZW5ndGggPiAwO1xuICBjb25zdCB1c2VXaXRoQmxvY2sgPSAhcHJlZml4SWRlbnRpZmllcnMgJiYgbW9kZSAhPT0gXCJtb2R1bGVcIjtcbiAgY29uc3QgcHJlYW1ibGVDb250ZXh0ID0gY29udGV4dDtcbiAge1xuICAgIGdlbkZ1bmN0aW9uUHJlYW1ibGUoYXN0LCBwcmVhbWJsZUNvbnRleHQpO1xuICB9XG4gIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IHNzciA/IGBzc3JSZW5kZXJgIDogYHJlbmRlcmA7XG4gIGNvbnN0IGFyZ3MgPSBzc3IgPyBbXCJfY3R4XCIsIFwiX3B1c2hcIiwgXCJfcGFyZW50XCIsIFwiX2F0dHJzXCJdIDogW1wiX2N0eFwiLCBcIl9jYWNoZVwiXTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXJncy5qb2luKFwiLCBcIik7XG4gIHtcbiAgICBwdXNoKGBmdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0oJHtzaWduYXR1cmV9KSB7YCk7XG4gIH1cbiAgaW5kZW50KCk7XG4gIGlmICh1c2VXaXRoQmxvY2spIHtcbiAgICBwdXNoKGB3aXRoIChfY3R4KSB7YCk7XG4gICAgaW5kZW50KCk7XG4gICAgaWYgKGhhc0hlbHBlcnMpIHtcbiAgICAgIHB1c2goXG4gICAgICAgIGBjb25zdCB7ICR7aGVscGVycy5tYXAoYWxpYXNIZWxwZXIpLmpvaW4oXCIsIFwiKX0gfSA9IF9WdWVcbmAsXG4gICAgICAgIC0xIC8qIEVuZCAqL1xuICAgICAgKTtcbiAgICAgIG5ld2xpbmUoKTtcbiAgICB9XG4gIH1cbiAgaWYgKGFzdC5jb21wb25lbnRzLmxlbmd0aCkge1xuICAgIGdlbkFzc2V0cyhhc3QuY29tcG9uZW50cywgXCJjb21wb25lbnRcIiwgY29udGV4dCk7XG4gICAgaWYgKGFzdC5kaXJlY3RpdmVzLmxlbmd0aCB8fCBhc3QudGVtcHMgPiAwKSB7XG4gICAgICBuZXdsaW5lKCk7XG4gICAgfVxuICB9XG4gIGlmIChhc3QuZGlyZWN0aXZlcy5sZW5ndGgpIHtcbiAgICBnZW5Bc3NldHMoYXN0LmRpcmVjdGl2ZXMsIFwiZGlyZWN0aXZlXCIsIGNvbnRleHQpO1xuICAgIGlmIChhc3QudGVtcHMgPiAwKSB7XG4gICAgICBuZXdsaW5lKCk7XG4gICAgfVxuICB9XG4gIGlmIChhc3QuZmlsdGVycyAmJiBhc3QuZmlsdGVycy5sZW5ndGgpIHtcbiAgICBuZXdsaW5lKCk7XG4gICAgZ2VuQXNzZXRzKGFzdC5maWx0ZXJzLCBcImZpbHRlclwiLCBjb250ZXh0KTtcbiAgICBuZXdsaW5lKCk7XG4gIH1cbiAgaWYgKGFzdC50ZW1wcyA+IDApIHtcbiAgICBwdXNoKGBsZXQgYCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QudGVtcHM7IGkrKykge1xuICAgICAgcHVzaChgJHtpID4gMCA/IGAsIGAgOiBgYH1fdGVtcCR7aX1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKGFzdC5jb21wb25lbnRzLmxlbmd0aCB8fCBhc3QuZGlyZWN0aXZlcy5sZW5ndGggfHwgYXN0LnRlbXBzKSB7XG4gICAgcHVzaChgXG5gLCAwIC8qIFN0YXJ0ICovKTtcbiAgICBuZXdsaW5lKCk7XG4gIH1cbiAgaWYgKCFzc3IpIHtcbiAgICBwdXNoKGByZXR1cm4gYCk7XG4gIH1cbiAgaWYgKGFzdC5jb2RlZ2VuTm9kZSkge1xuICAgIGdlbk5vZGUoYXN0LmNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBwdXNoKGBudWxsYCk7XG4gIH1cbiAgaWYgKHVzZVdpdGhCbG9jaykge1xuICAgIGRlaW5kZW50KCk7XG4gICAgcHVzaChgfWApO1xuICB9XG4gIGRlaW5kZW50KCk7XG4gIHB1c2goYH1gKTtcbiAgcmV0dXJuIHtcbiAgICBhc3QsXG4gICAgY29kZTogY29udGV4dC5jb2RlLFxuICAgIHByZWFtYmxlOiBgYCxcbiAgICBtYXA6IGNvbnRleHQubWFwID8gY29udGV4dC5tYXAudG9KU09OKCkgOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGdlbkZ1bmN0aW9uUHJlYW1ibGUoYXN0LCBjb250ZXh0KSB7XG4gIGNvbnN0IHtcbiAgICBzc3IsXG4gICAgcHJlZml4SWRlbnRpZmllcnMsXG4gICAgcHVzaCxcbiAgICBuZXdsaW5lLFxuICAgIHJ1bnRpbWVNb2R1bGVOYW1lLFxuICAgIHJ1bnRpbWVHbG9iYWxOYW1lLFxuICAgIHNzclJ1bnRpbWVNb2R1bGVOYW1lXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCBWdWVCaW5kaW5nID0gcnVudGltZUdsb2JhbE5hbWU7XG4gIGNvbnN0IGhlbHBlcnMgPSBBcnJheS5mcm9tKGFzdC5oZWxwZXJzKTtcbiAgaWYgKGhlbHBlcnMubGVuZ3RoID4gMCkge1xuICAgIHtcbiAgICAgIHB1c2goYGNvbnN0IF9WdWUgPSAke1Z1ZUJpbmRpbmd9XG5gLCAtMSAvKiBFbmQgKi8pO1xuICAgICAgaWYgKGFzdC5ob2lzdHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRpY0hlbHBlcnMgPSBbXG4gICAgICAgICAgQ1JFQVRFX1ZOT0RFLFxuICAgICAgICAgIENSRUFURV9FTEVNRU5UX1ZOT0RFLFxuICAgICAgICAgIENSRUFURV9DT01NRU5ULFxuICAgICAgICAgIENSRUFURV9URVhULFxuICAgICAgICAgIENSRUFURV9TVEFUSUNcbiAgICAgICAgXS5maWx0ZXIoKGhlbHBlcikgPT4gaGVscGVycy5pbmNsdWRlcyhoZWxwZXIpKS5tYXAoYWxpYXNIZWxwZXIpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgcHVzaChgY29uc3QgeyAke3N0YXRpY0hlbHBlcnN9IH0gPSBfVnVlXG5gLCAtMSAvKiBFbmQgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZW5Ib2lzdHMoYXN0LmhvaXN0cywgY29udGV4dCk7XG4gIG5ld2xpbmUoKTtcbiAgcHVzaChgcmV0dXJuIGApO1xufVxuZnVuY3Rpb24gZ2VuQXNzZXRzKGFzc2V0cywgdHlwZSwgeyBoZWxwZXIsIHB1c2gsIG5ld2xpbmUsIGlzVFMgfSkge1xuICBjb25zdCByZXNvbHZlciA9IGhlbHBlcihcbiAgICB0eXBlID09PSBcImZpbHRlclwiID8gUkVTT0xWRV9GSUxURVIgOiB0eXBlID09PSBcImNvbXBvbmVudFwiID8gUkVTT0xWRV9DT01QT05FTlQgOiBSRVNPTFZFX0RJUkVDVElWRVxuICApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFzc2V0cy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBpZCA9IGFzc2V0c1tpXTtcbiAgICBjb25zdCBtYXliZVNlbGZSZWZlcmVuY2UgPSBpZC5lbmRzV2l0aChcIl9fc2VsZlwiKTtcbiAgICBpZiAobWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gICAgICBpZCA9IGlkLnNsaWNlKDAsIC02KTtcbiAgICB9XG4gICAgcHVzaChcbiAgICAgIGBjb25zdCAke3RvVmFsaWRBc3NldElkKGlkLCB0eXBlKX0gPSAke3Jlc29sdmVyfSgke0pTT04uc3RyaW5naWZ5KGlkKX0ke21heWJlU2VsZlJlZmVyZW5jZSA/IGAsIHRydWVgIDogYGB9KSR7aXNUUyA/IGAhYCA6IGBgfWBcbiAgICApO1xuICAgIGlmIChpIDwgYXNzZXRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIG5ld2xpbmUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdlbkhvaXN0cyhob2lzdHMsIGNvbnRleHQpIHtcbiAgaWYgKCFob2lzdHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnRleHQucHVyZSA9IHRydWU7XG4gIGNvbnN0IHsgcHVzaCwgbmV3bGluZSB9ID0gY29udGV4dDtcbiAgbmV3bGluZSgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGhvaXN0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGV4cCA9IGhvaXN0c1tpXTtcbiAgICBpZiAoZXhwKSB7XG4gICAgICBwdXNoKGBjb25zdCBfaG9pc3RlZF8ke2kgKyAxfSA9IGApO1xuICAgICAgZ2VuTm9kZShleHAsIGNvbnRleHQpO1xuICAgICAgbmV3bGluZSgpO1xuICAgIH1cbiAgfVxuICBjb250ZXh0LnB1cmUgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzVGV4dChuKSB7XG4gIHJldHVybiBpc1N0cmluZyhuKSB8fCBuLnR5cGUgPT09IDQgfHwgbi50eXBlID09PSAyIHx8IG4udHlwZSA9PT0gNSB8fCBuLnR5cGUgPT09IDg7XG59XG5mdW5jdGlvbiBnZW5Ob2RlTGlzdEFzQXJyYXkobm9kZXMsIGNvbnRleHQpIHtcbiAgY29uc3QgbXVsdGlsaW5lcyA9IG5vZGVzLmxlbmd0aCA+IDMgfHwgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBub2Rlcy5zb21lKChuKSA9PiBpc0FycmF5KG4pIHx8ICFpc1RleHQobikpO1xuICBjb250ZXh0LnB1c2goYFtgKTtcbiAgbXVsdGlsaW5lcyAmJiBjb250ZXh0LmluZGVudCgpO1xuICBnZW5Ob2RlTGlzdChub2RlcywgY29udGV4dCwgbXVsdGlsaW5lcyk7XG4gIG11bHRpbGluZXMgJiYgY29udGV4dC5kZWluZGVudCgpO1xuICBjb250ZXh0LnB1c2goYF1gKTtcbn1cbmZ1bmN0aW9uIGdlbk5vZGVMaXN0KG5vZGVzLCBjb250ZXh0LCBtdWx0aWxpbmVzID0gZmFsc2UsIGNvbW1hID0gdHJ1ZSkge1xuICBjb25zdCB7IHB1c2gsIG5ld2xpbmUgfSA9IGNvbnRleHQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKGlzU3RyaW5nKG5vZGUpKSB7XG4gICAgICBwdXNoKG5vZGUsIC0zIC8qIFVua25vd24gKi8pO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZ2VuTm9kZUxpc3RBc0FycmF5KG5vZGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5Ob2RlKG5vZGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoaSA8IG5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgIGlmIChtdWx0aWxpbmVzKSB7XG4gICAgICAgIGNvbW1hICYmIHB1c2goXCIsXCIpO1xuICAgICAgICBuZXdsaW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21tYSAmJiBwdXNoKFwiLCBcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZW5Ob2RlKG5vZGUsIGNvbnRleHQpIHtcbiAgaWYgKGlzU3RyaW5nKG5vZGUpKSB7XG4gICAgY29udGV4dC5wdXNoKG5vZGUsIC0zIC8qIFVua25vd24gKi8pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNTeW1ib2wobm9kZSkpIHtcbiAgICBjb250ZXh0LnB1c2goY29udGV4dC5oZWxwZXIobm9kZSkpO1xuICAgIHJldHVybjtcbiAgfVxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgMTpcbiAgICBjYXNlIDk6XG4gICAgY2FzZSAxMTpcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYXNzZXJ0KFxuICAgICAgICBub2RlLmNvZGVnZW5Ob2RlICE9IG51bGwsXG4gICAgICAgIGBDb2RlZ2VuIG5vZGUgaXMgbWlzc2luZyBmb3IgZWxlbWVudC9pZi9mb3Igbm9kZS4gQXBwbHkgYXBwcm9wcmlhdGUgdHJhbnNmb3JtcyBmaXJzdC5gXG4gICAgICApO1xuICAgICAgZ2VuTm9kZShub2RlLmNvZGVnZW5Ob2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGdlblRleHQobm9kZSwgY29udGV4dCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBnZW5FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA1OlxuICAgICAgZ2VuSW50ZXJwb2xhdGlvbihub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTI6XG4gICAgICBnZW5Ob2RlKG5vZGUuY29kZWdlbk5vZGUsIGNvbnRleHQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA4OlxuICAgICAgZ2VuQ29tcG91bmRFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZ2VuQ29tbWVudChub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTM6XG4gICAgICBnZW5WTm9kZUNhbGwobm9kZSwgY29udGV4dCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE0OlxuICAgICAgZ2VuQ2FsbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE1OlxuICAgICAgZ2VuT2JqZWN0RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTc6XG4gICAgICBnZW5BcnJheUV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE4OlxuICAgICAgZ2VuRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOTpcbiAgICAgIGdlbkNvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjA6XG4gICAgICBnZW5DYWNoZUV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIxOlxuICAgICAgZ2VuTm9kZUxpc3Qobm9kZS5ib2R5LCBjb250ZXh0LCB0cnVlLCBmYWxzZSk7XG4gICAgICBicmVhaztcbiAgICAvLyBTU1Igb25seSB0eXBlc1xuICAgIGNhc2UgMjI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIzOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyNDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjU6XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI2OlxuICAgICAgYnJlYWs7XG4gICAgLyogdjggaWdub3JlIHN0YXJ0ICovXG4gICAgY2FzZSAxMDpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIGB1bmhhbmRsZWQgY29kZWdlbiBub2RlIHR5cGU6ICR7bm9kZS50eXBlfWApO1xuICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBub2RlO1xuICAgICAgICByZXR1cm4gZXhoYXVzdGl2ZUNoZWNrO1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZW5UZXh0KG5vZGUsIGNvbnRleHQpIHtcbiAgY29udGV4dC5wdXNoKEpTT04uc3RyaW5naWZ5KG5vZGUuY29udGVudCksIC0zIC8qIFVua25vd24gKi8sIG5vZGUpO1xufVxuZnVuY3Rpb24gZ2VuRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgY29udGVudCwgaXNTdGF0aWMgfSA9IG5vZGU7XG4gIGNvbnRleHQucHVzaChcbiAgICBpc1N0YXRpYyA/IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpIDogY29udGVudCxcbiAgICAtMyAvKiBVbmtub3duICovLFxuICAgIG5vZGVcbiAgKTtcbn1cbmZ1bmN0aW9uIGdlbkludGVycG9sYXRpb24obm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IHB1c2gsIGhlbHBlciwgcHVyZSB9ID0gY29udGV4dDtcbiAgaWYgKHB1cmUpIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcbiAgcHVzaChgJHtoZWxwZXIoVE9fRElTUExBWV9TVFJJTkcpfShgKTtcbiAgZ2VuTm9kZShub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xuICBwdXNoKGApYCk7XG59XG5mdW5jdGlvbiBnZW5Db21wb3VuZEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgaWYgKGlzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgY29udGV4dC5wdXNoKGNoaWxkLCAtMyAvKiBVbmtub3duICovKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuTm9kZShjaGlsZCwgY29udGV4dCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZW5FeHByZXNzaW9uQXNQcm9wZXJ0eUtleShub2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgcHVzaCB9ID0gY29udGV4dDtcbiAgaWYgKG5vZGUudHlwZSA9PT0gOCkge1xuICAgIHB1c2goYFtgKTtcbiAgICBnZW5Db21wb3VuZEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgcHVzaChgXWApO1xuICB9IGVsc2UgaWYgKG5vZGUuaXNTdGF0aWMpIHtcbiAgICBjb25zdCB0ZXh0ID0gaXNTaW1wbGVJZGVudGlmaWVyKG5vZGUuY29udGVudCkgPyBub2RlLmNvbnRlbnQgOiBKU09OLnN0cmluZ2lmeShub2RlLmNvbnRlbnQpO1xuICAgIHB1c2godGV4dCwgLTIgLyogTm9uZSAqLywgbm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcHVzaChgWyR7bm9kZS5jb250ZW50fV1gLCAtMyAvKiBVbmtub3duICovLCBub2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2VuQ29tbWVudChub2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xuICBpZiAocHVyZSkge1xuICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcbiAgfVxuICBwdXNoKFxuICAgIGAke2hlbHBlcihDUkVBVEVfQ09NTUVOVCl9KCR7SlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KX0pYCxcbiAgICAtMyAvKiBVbmtub3duICovLFxuICAgIG5vZGVcbiAgKTtcbn1cbmZ1bmN0aW9uIGdlblZOb2RlQ2FsbChub2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgdGFnLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHMsXG4gICAgZGlyZWN0aXZlcyxcbiAgICBpc0Jsb2NrLFxuICAgIGRpc2FibGVUcmFja2luZyxcbiAgICBpc0NvbXBvbmVudFxuICB9ID0gbm9kZTtcbiAgbGV0IHBhdGNoRmxhZ1N0cmluZztcbiAgaWYgKHBhdGNoRmxhZykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBpZiAocGF0Y2hGbGFnIDwgMCkge1xuICAgICAgICBwYXRjaEZsYWdTdHJpbmcgPSBwYXRjaEZsYWcgKyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbcGF0Y2hGbGFnXX0gKi9gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmxhZ05hbWVzID0gT2JqZWN0LmtleXMoUGF0Y2hGbGFnTmFtZXMpLm1hcChOdW1iZXIpLmZpbHRlcigobikgPT4gbiA+IDAgJiYgcGF0Y2hGbGFnICYgbikubWFwKChuKSA9PiBQYXRjaEZsYWdOYW1lc1tuXSkuam9pbihgLCBgKTtcbiAgICAgICAgcGF0Y2hGbGFnU3RyaW5nID0gcGF0Y2hGbGFnICsgYCAvKiAke2ZsYWdOYW1lc30gKi9gO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaEZsYWdTdHJpbmcgPSBTdHJpbmcocGF0Y2hGbGFnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGRpcmVjdGl2ZXMpIHtcbiAgICBwdXNoKGhlbHBlcihXSVRIX0RJUkVDVElWRVMpICsgYChgKTtcbiAgfVxuICBpZiAoaXNCbG9jaykge1xuICAgIHB1c2goYCgke2hlbHBlcihPUEVOX0JMT0NLKX0oJHtkaXNhYmxlVHJhY2tpbmcgPyBgdHJ1ZWAgOiBgYH0pLCBgKTtcbiAgfVxuICBpZiAocHVyZSkge1xuICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcbiAgfVxuICBjb25zdCBjYWxsSGVscGVyID0gaXNCbG9jayA/IGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgaXNDb21wb25lbnQpIDogZ2V0Vk5vZGVIZWxwZXIoY29udGV4dC5pblNTUiwgaXNDb21wb25lbnQpO1xuICBwdXNoKGhlbHBlcihjYWxsSGVscGVyKSArIGAoYCwgLTIgLyogTm9uZSAqLywgbm9kZSk7XG4gIGdlbk5vZGVMaXN0KFxuICAgIGdlbk51bGxhYmxlQXJncyhbdGFnLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZ1N0cmluZywgZHluYW1pY1Byb3BzXSksXG4gICAgY29udGV4dFxuICApO1xuICBwdXNoKGApYCk7XG4gIGlmIChpc0Jsb2NrKSB7XG4gICAgcHVzaChgKWApO1xuICB9XG4gIGlmIChkaXJlY3RpdmVzKSB7XG4gICAgcHVzaChgLCBgKTtcbiAgICBnZW5Ob2RlKGRpcmVjdGl2ZXMsIGNvbnRleHQpO1xuICAgIHB1c2goYClgKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2VuTnVsbGFibGVBcmdzKGFyZ3MpIHtcbiAgbGV0IGkgPSBhcmdzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChhcmdzW2ldICE9IG51bGwpIGJyZWFrO1xuICB9XG4gIHJldHVybiBhcmdzLnNsaWNlKDAsIGkgKyAxKS5tYXAoKGFyZykgPT4gYXJnIHx8IGBudWxsYCk7XG59XG5mdW5jdGlvbiBnZW5DYWxsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xuICBjb25zdCBjYWxsZWUgPSBpc1N0cmluZyhub2RlLmNhbGxlZSkgPyBub2RlLmNhbGxlZSA6IGhlbHBlcihub2RlLmNhbGxlZSk7XG4gIGlmIChwdXJlKSB7XG4gICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xuICB9XG4gIHB1c2goY2FsbGVlICsgYChgLCAtMiAvKiBOb25lICovLCBub2RlKTtcbiAgZ2VuTm9kZUxpc3Qobm9kZS5hcmd1bWVudHMsIGNvbnRleHQpO1xuICBwdXNoKGApYCk7XG59XG5mdW5jdGlvbiBnZW5PYmplY3RFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xuICBjb25zdCB7IHByb3BlcnRpZXMgfSA9IG5vZGU7XG4gIGlmICghcHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICBwdXNoKGB7fWAsIC0yIC8qIE5vbmUgKi8sIG5vZGUpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBtdWx0aWxpbmVzID0gcHJvcGVydGllcy5sZW5ndGggPiAxIHx8ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgcHJvcGVydGllcy5zb21lKChwKSA9PiBwLnZhbHVlLnR5cGUgIT09IDQpO1xuICBwdXNoKG11bHRpbGluZXMgPyBge2AgOiBgeyBgKTtcbiAgbXVsdGlsaW5lcyAmJiBpbmRlbnQoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwcm9wZXJ0aWVzW2ldO1xuICAgIGdlbkV4cHJlc3Npb25Bc1Byb3BlcnR5S2V5KGtleSwgY29udGV4dCk7XG4gICAgcHVzaChgOiBgKTtcbiAgICBnZW5Ob2RlKHZhbHVlLCBjb250ZXh0KTtcbiAgICBpZiAoaSA8IHByb3BlcnRpZXMubGVuZ3RoIC0gMSkge1xuICAgICAgcHVzaChgLGApO1xuICAgICAgbmV3bGluZSgpO1xuICAgIH1cbiAgfVxuICBtdWx0aWxpbmVzICYmIGRlaW5kZW50KCk7XG4gIHB1c2gobXVsdGlsaW5lcyA/IGB9YCA6IGAgfWApO1xufVxuZnVuY3Rpb24gZ2VuQXJyYXlFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgZ2VuTm9kZUxpc3RBc0FycmF5KG5vZGUuZWxlbWVudHMsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gZ2VuRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50IH0gPSBjb250ZXh0O1xuICBjb25zdCB7IHBhcmFtcywgcmV0dXJucywgYm9keSwgbmV3bGluZSwgaXNTbG90IH0gPSBub2RlO1xuICBpZiAoaXNTbG90KSB7XG4gICAgcHVzaChgXyR7aGVscGVyTmFtZU1hcFtXSVRIX0NUWF19KGApO1xuICB9XG4gIHB1c2goYChgLCAtMiAvKiBOb25lICovLCBub2RlKTtcbiAgaWYgKGlzQXJyYXkocGFyYW1zKSkge1xuICAgIGdlbk5vZGVMaXN0KHBhcmFtcywgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAocGFyYW1zKSB7XG4gICAgZ2VuTm9kZShwYXJhbXMsIGNvbnRleHQpO1xuICB9XG4gIHB1c2goYCkgPT4gYCk7XG4gIGlmIChuZXdsaW5lIHx8IGJvZHkpIHtcbiAgICBwdXNoKGB7YCk7XG4gICAgaW5kZW50KCk7XG4gIH1cbiAgaWYgKHJldHVybnMpIHtcbiAgICBpZiAobmV3bGluZSkge1xuICAgICAgcHVzaChgcmV0dXJuIGApO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheShyZXR1cm5zKSkge1xuICAgICAgZ2VuTm9kZUxpc3RBc0FycmF5KHJldHVybnMsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5Ob2RlKHJldHVybnMsIGNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChib2R5KSB7XG4gICAgZ2VuTm9kZShib2R5LCBjb250ZXh0KTtcbiAgfVxuICBpZiAobmV3bGluZSB8fCBib2R5KSB7XG4gICAgZGVpbmRlbnQoKTtcbiAgICBwdXNoKGB9YCk7XG4gIH1cbiAgaWYgKGlzU2xvdCkge1xuICAgIGlmIChub2RlLmlzTm9uU2NvcGVkU2xvdCkge1xuICAgICAgcHVzaChgLCB1bmRlZmluZWQsIHRydWVgKTtcbiAgICB9XG4gICAgcHVzaChgKWApO1xuICB9XG59XG5mdW5jdGlvbiBnZW5Db25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xuICBjb25zdCB7IHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSwgbmV3bGluZTogbmVlZE5ld2xpbmUgfSA9IG5vZGU7XG4gIGNvbnN0IHsgcHVzaCwgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSB9ID0gY29udGV4dDtcbiAgaWYgKHRlc3QudHlwZSA9PT0gNCkge1xuICAgIGNvbnN0IG5lZWRzUGFyZW5zID0gIWlzU2ltcGxlSWRlbnRpZmllcih0ZXN0LmNvbnRlbnQpO1xuICAgIG5lZWRzUGFyZW5zICYmIHB1c2goYChgKTtcbiAgICBnZW5FeHByZXNzaW9uKHRlc3QsIGNvbnRleHQpO1xuICAgIG5lZWRzUGFyZW5zICYmIHB1c2goYClgKTtcbiAgfSBlbHNlIHtcbiAgICBwdXNoKGAoYCk7XG4gICAgZ2VuTm9kZSh0ZXN0LCBjb250ZXh0KTtcbiAgICBwdXNoKGApYCk7XG4gIH1cbiAgbmVlZE5ld2xpbmUgJiYgaW5kZW50KCk7XG4gIGNvbnRleHQuaW5kZW50TGV2ZWwrKztcbiAgbmVlZE5ld2xpbmUgfHwgcHVzaChgIGApO1xuICBwdXNoKGA/IGApO1xuICBnZW5Ob2RlKGNvbnNlcXVlbnQsIGNvbnRleHQpO1xuICBjb250ZXh0LmluZGVudExldmVsLS07XG4gIG5lZWROZXdsaW5lICYmIG5ld2xpbmUoKTtcbiAgbmVlZE5ld2xpbmUgfHwgcHVzaChgIGApO1xuICBwdXNoKGA6IGApO1xuICBjb25zdCBpc05lc3RlZCA9IGFsdGVybmF0ZS50eXBlID09PSAxOTtcbiAgaWYgKCFpc05lc3RlZCkge1xuICAgIGNvbnRleHQuaW5kZW50TGV2ZWwrKztcbiAgfVxuICBnZW5Ob2RlKGFsdGVybmF0ZSwgY29udGV4dCk7XG4gIGlmICghaXNOZXN0ZWQpIHtcbiAgICBjb250ZXh0LmluZGVudExldmVsLS07XG4gIH1cbiAgbmVlZE5ld2xpbmUgJiYgZGVpbmRlbnQoXG4gICAgdHJ1ZVxuICAgIC8qIHdpdGhvdXQgbmV3bGluZSAqL1xuICApO1xufVxuZnVuY3Rpb24gZ2VuQ2FjaGVFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIGluZGVudCwgZGVpbmRlbnQsIG5ld2xpbmUgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHsgbmVlZFBhdXNlVHJhY2tpbmcsIG5lZWRBcnJheVNwcmVhZCB9ID0gbm9kZTtcbiAgaWYgKG5lZWRBcnJheVNwcmVhZCkge1xuICAgIHB1c2goYFsuLi4oYCk7XG4gIH1cbiAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dIHx8IChgKTtcbiAgaWYgKG5lZWRQYXVzZVRyYWNraW5nKSB7XG4gICAgaW5kZW50KCk7XG4gICAgcHVzaChgJHtoZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKX0oLTFgKTtcbiAgICBpZiAobm9kZS5pblZPbmNlKSBwdXNoKGAsIHRydWVgKTtcbiAgICBwdXNoKGApLGApO1xuICAgIG5ld2xpbmUoKTtcbiAgICBwdXNoKGAoYCk7XG4gIH1cbiAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dID0gYCk7XG4gIGdlbk5vZGUobm9kZS52YWx1ZSwgY29udGV4dCk7XG4gIGlmIChuZWVkUGF1c2VUcmFja2luZykge1xuICAgIHB1c2goYCkuY2FjaGVJbmRleCA9ICR7bm9kZS5pbmRleH0sYCk7XG4gICAgbmV3bGluZSgpO1xuICAgIHB1c2goYCR7aGVscGVyKFNFVF9CTE9DS19UUkFDS0lORyl9KDEpLGApO1xuICAgIG5ld2xpbmUoKTtcbiAgICBwdXNoKGBfY2FjaGVbJHtub2RlLmluZGV4fV1gKTtcbiAgICBkZWluZGVudCgpO1xuICB9XG4gIHB1c2goYClgKTtcbiAgaWYgKG5lZWRBcnJheVNwcmVhZCkge1xuICAgIHB1c2goYCldYCk7XG4gIH1cbn1cblxuY29uc3QgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoXG4gIFwiXFxcXGJcIiArIFwiYXJndW1lbnRzLGF3YWl0LGJyZWFrLGNhc2UsY2F0Y2gsY2xhc3MsY29uc3QsY29udGludWUsZGVidWdnZXIsZGVmYXVsdCxkZWxldGUsZG8sZWxzZSxleHBvcnQsZXh0ZW5kcyxmaW5hbGx5LGZvcixmdW5jdGlvbixpZixpbXBvcnQsbGV0LG5ldyxyZXR1cm4sc3VwZXIsc3dpdGNoLHRocm93LHRyeSx2YXIsdm9pZCx3aGlsZSx3aXRoLHlpZWxkXCIuc3BsaXQoXCIsXCIpLmpvaW4oXCJcXFxcYnxcXFxcYlwiKSArIFwiXFxcXGJcIlxuKTtcbmNvbnN0IHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcbmZ1bmN0aW9uIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24obm9kZSwgY29udGV4dCwgYXNQYXJhbXMgPSBmYWxzZSwgYXNSYXdTdGF0ZW1lbnRzID0gZmFsc2UpIHtcbiAgY29uc3QgZXhwID0gbm9kZS5jb250ZW50O1xuICBpZiAoIWV4cC50cmltKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oXG4gICAgICBhc1Jhd1N0YXRlbWVudHMgPyBgICR7ZXhwfSBgIDogYHJldHVybiAke2FzUGFyYW1zID8gYCgke2V4cH0pID0+IHt9YCA6IGAoJHtleHB9KWB9YFxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGUubWVzc2FnZTtcbiAgICBjb25zdCBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCBcIlwiKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICBtZXNzYWdlID0gYGF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiR7a2V5d29yZE1hdGNoWzBdfVwiYDtcbiAgICB9XG4gICAgY29udGV4dC5vbkVycm9yKFxuICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcihcbiAgICAgICAgNDYsXG4gICAgICAgIG5vZGUubG9jLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIG1lc3NhZ2VcbiAgICAgIClcbiAgICApO1xuICB9XG59XG5cbmNvbnN0IHRyYW5zZm9ybUV4cHJlc3Npb24gPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICBpZiAobm9kZS50eXBlID09PSA1KSB7XG4gICAgbm9kZS5jb250ZW50ID0gcHJvY2Vzc0V4cHJlc3Npb24oXG4gICAgICBub2RlLmNvbnRlbnQsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBjb25zdCBtZW1vID0gZmluZERpcihub2RlLCBcIm1lbW9cIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkaXIgPSBub2RlLnByb3BzW2ldO1xuICAgICAgaWYgKGRpci50eXBlID09PSA3ICYmIGRpci5uYW1lICE9PSBcImZvclwiKSB7XG4gICAgICAgIGNvbnN0IGV4cCA9IGRpci5leHA7XG4gICAgICAgIGNvbnN0IGFyZyA9IGRpci5hcmc7XG4gICAgICAgIGlmIChleHAgJiYgZXhwLnR5cGUgPT09IDQgJiYgIShkaXIubmFtZSA9PT0gXCJvblwiICYmIGFyZykgJiYgLy8ga2V5IGhhcyBiZWVuIHByb2Nlc3NlZCBpbiB0cmFuc2Zvcm1Gb3Iodk1lbW8gKyB2Rm9yKVxuICAgICAgICAhKG1lbW8gJiYgYXJnICYmIGFyZy50eXBlID09PSA0ICYmIGFyZy5jb250ZW50ID09PSBcImtleVwiKSkge1xuICAgICAgICAgIGRpci5leHAgPSBwcm9jZXNzRXhwcmVzc2lvbihcbiAgICAgICAgICAgIGV4cCxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAvLyBzbG90IGFyZ3MgbXVzdCBiZSBwcm9jZXNzZWQgYXMgZnVuY3Rpb24gcGFyYW1zXG4gICAgICAgICAgICBkaXIubmFtZSA9PT0gXCJzbG90XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmcgJiYgYXJnLnR5cGUgPT09IDQgJiYgIWFyZy5pc1N0YXRpYykge1xuICAgICAgICAgIGRpci5hcmcgPSBwcm9jZXNzRXhwcmVzc2lvbihhcmcsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gcHJvY2Vzc0V4cHJlc3Npb24obm9kZSwgY29udGV4dCwgYXNQYXJhbXMgPSBmYWxzZSwgYXNSYXdTdGF0ZW1lbnRzID0gZmFsc2UsIGxvY2FsVmFycyA9IE9iamVjdC5jcmVhdGUoY29udGV4dC5pZGVudGlmaWVycykpIHtcbiAge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQsIGFzUGFyYW1zLCBhc1Jhd1N0YXRlbWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gc3RyaW5naWZ5RXhwcmVzc2lvbihleHApIHtcbiAgaWYgKGlzU3RyaW5nKGV4cCkpIHtcbiAgICByZXR1cm4gZXhwO1xuICB9IGVsc2UgaWYgKGV4cC50eXBlID09PSA0KSB7XG4gICAgcmV0dXJuIGV4cC5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHAuY2hpbGRyZW4ubWFwKHN0cmluZ2lmeUV4cHJlc3Npb24pLmpvaW4oXCJcIik7XG4gIH1cbn1cblxuY29uc3QgdHJhbnNmb3JtSWYgPSBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtKFxuICAvXig/OmlmfGVsc2V8ZWxzZS1pZikkLyxcbiAgKG5vZGUsIGRpciwgY29udGV4dCkgPT4ge1xuICAgIHJldHVybiBwcm9jZXNzSWYobm9kZSwgZGlyLCBjb250ZXh0LCAoaWZOb2RlLCBicmFuY2gsIGlzUm9vdCkgPT4ge1xuICAgICAgY29uc3Qgc2libGluZ3MgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcbiAgICAgIGxldCBpID0gc2libGluZ3MuaW5kZXhPZihpZk5vZGUpO1xuICAgICAgbGV0IGtleSA9IDA7XG4gICAgICB3aGlsZSAoaS0tID49IDApIHtcbiAgICAgICAgY29uc3Qgc2libGluZyA9IHNpYmxpbmdzW2ldO1xuICAgICAgICBpZiAoc2libGluZyAmJiBzaWJsaW5nLnR5cGUgPT09IDkpIHtcbiAgICAgICAgICBrZXkgKz0gc2libGluZy5icmFuY2hlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICBpZk5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChcbiAgICAgICAgICAgIGJyYW5jaCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhcmVudENvbmRpdGlvbiA9IGdldFBhcmVudENvbmRpdGlvbihpZk5vZGUuY29kZWdlbk5vZGUpO1xuICAgICAgICAgIHBhcmVudENvbmRpdGlvbi5hbHRlcm5hdGUgPSBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChcbiAgICAgICAgICAgIGJyYW5jaCxcbiAgICAgICAgICAgIGtleSArIGlmTm9kZS5icmFuY2hlcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbik7XG5mdW5jdGlvbiBwcm9jZXNzSWYobm9kZSwgZGlyLCBjb250ZXh0LCBwcm9jZXNzQ29kZWdlbikge1xuICBpZiAoZGlyLm5hbWUgIT09IFwiZWxzZVwiICYmICghZGlyLmV4cCB8fCAhZGlyLmV4cC5jb250ZW50LnRyaW0oKSkpIHtcbiAgICBjb25zdCBsb2MgPSBkaXIuZXhwID8gZGlyLmV4cC5sb2MgOiBub2RlLmxvYztcbiAgICBjb250ZXh0Lm9uRXJyb3IoXG4gICAgICBjcmVhdGVDb21waWxlckVycm9yKDI4LCBkaXIubG9jKVxuICAgICk7XG4gICAgZGlyLmV4cCA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHRydWVgLCBmYWxzZSwgbG9jKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlICYmIGRpci5leHApIHtcbiAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKGRpci5leHAsIGNvbnRleHQpO1xuICB9XG4gIGlmIChkaXIubmFtZSA9PT0gXCJpZlwiKSB7XG4gICAgY29uc3QgYnJhbmNoID0gY3JlYXRlSWZCcmFuY2gobm9kZSwgZGlyKTtcbiAgICBjb25zdCBpZk5vZGUgPSB7XG4gICAgICB0eXBlOiA5LFxuICAgICAgbG9jOiBjbG9uZUxvYyhub2RlLmxvYyksXG4gICAgICBicmFuY2hlczogW2JyYW5jaF1cbiAgICB9O1xuICAgIGNvbnRleHQucmVwbGFjZU5vZGUoaWZOb2RlKTtcbiAgICBpZiAocHJvY2Vzc0NvZGVnZW4pIHtcbiAgICAgIHJldHVybiBwcm9jZXNzQ29kZWdlbihpZk5vZGUsIGJyYW5jaCwgdHJ1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNpYmxpbmdzID0gY29udGV4dC5wYXJlbnQuY2hpbGRyZW47XG4gICAgY29uc3QgY29tbWVudHMgPSBbXTtcbiAgICBsZXQgaSA9IHNpYmxpbmdzLmluZGV4T2Yobm9kZSk7XG4gICAgd2hpbGUgKGktLSA+PSAtMSkge1xuICAgICAgY29uc3Qgc2libGluZyA9IHNpYmxpbmdzW2ldO1xuICAgICAgaWYgKHNpYmxpbmcgJiYgaXNDb21tZW50T3JXaGl0ZXNwYWNlKHNpYmxpbmcpKSB7XG4gICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZShzaWJsaW5nKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2libGluZy50eXBlID09PSAzKSB7XG4gICAgICAgICAgY29tbWVudHMudW5zaGlmdChzaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gOSkge1xuICAgICAgICBpZiAoKGRpci5uYW1lID09PSBcImVsc2UtaWZcIiB8fCBkaXIubmFtZSA9PT0gXCJlbHNlXCIpICYmIHNpYmxpbmcuYnJhbmNoZXNbc2libGluZy5icmFuY2hlcy5sZW5ndGggLSAxXS5jb25kaXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgICAgICAgIGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzAsIG5vZGUubG9jKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5yZW1vdmVOb2RlKCk7XG4gICAgICAgIGNvbnN0IGJyYW5jaCA9IGNyZWF0ZUlmQnJhbmNoKG5vZGUsIGRpcik7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbW1lbnRzLmxlbmd0aCAmJiAvLyAjMzYxOSBpZ25vcmUgY29tbWVudHMgaWYgdGhlIHYtaWYgaXMgZGlyZWN0IGNoaWxkIG9mIDx0cmFuc2l0aW9uPlxuICAgICAgICAhKGNvbnRleHQucGFyZW50ICYmIGNvbnRleHQucGFyZW50LnR5cGUgPT09IDEgJiYgKGNvbnRleHQucGFyZW50LnRhZyA9PT0gXCJ0cmFuc2l0aW9uXCIgfHwgY29udGV4dC5wYXJlbnQudGFnID09PSBcIlRyYW5zaXRpb25cIikpKSB7XG4gICAgICAgICAgYnJhbmNoLmNoaWxkcmVuID0gWy4uLmNvbW1lbnRzLCAuLi5icmFuY2guY2hpbGRyZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZhbHNlKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYnJhbmNoLnVzZXJLZXk7XG4gICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgc2libGluZy5icmFuY2hlcy5mb3JFYWNoKCh7IHVzZXJLZXkgfSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaXNTYW1lS2V5KHVzZXJLZXksIGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoXG4gICAgICAgICAgICAgICAgICBjcmVhdGVDb21waWxlckVycm9yKFxuICAgICAgICAgICAgICAgICAgICAyOSxcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoLnVzZXJLZXkubG9jXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpYmxpbmcuYnJhbmNoZXMucHVzaChicmFuY2gpO1xuICAgICAgICBjb25zdCBvbkV4aXQgPSBwcm9jZXNzQ29kZWdlbiAmJiBwcm9jZXNzQ29kZWdlbihzaWJsaW5nLCBicmFuY2gsIGZhbHNlKTtcbiAgICAgICAgdHJhdmVyc2VOb2RlKGJyYW5jaCwgY29udGV4dCk7XG4gICAgICAgIGlmIChvbkV4aXQpIG9uRXhpdCgpO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgICAgICBjcmVhdGVDb21waWxlckVycm9yKDMwLCBub2RlLmxvYylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlSWZCcmFuY2gobm9kZSwgZGlyKSB7XG4gIGNvbnN0IGlzVGVtcGxhdGVJZiA9IG5vZGUudGFnVHlwZSA9PT0gMztcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxMCxcbiAgICBsb2M6IG5vZGUubG9jLFxuICAgIGNvbmRpdGlvbjogZGlyLm5hbWUgPT09IFwiZWxzZVwiID8gdm9pZCAwIDogZGlyLmV4cCxcbiAgICBjaGlsZHJlbjogaXNUZW1wbGF0ZUlmICYmICFmaW5kRGlyKG5vZGUsIFwiZm9yXCIpID8gbm9kZS5jaGlsZHJlbiA6IFtub2RlXSxcbiAgICB1c2VyS2V5OiBmaW5kUHJvcChub2RlLCBga2V5YCksXG4gICAgaXNUZW1wbGF0ZUlmXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSB7XG4gIGlmIChicmFuY2guY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbihcbiAgICAgIGJyYW5jaC5jb25kaXRpb24sXG4gICAgICBjcmVhdGVDaGlsZHJlbkNvZGVnZW5Ob2RlKGJyYW5jaCwga2V5SW5kZXgsIGNvbnRleHQpLFxuICAgICAgLy8gbWFrZSBzdXJlIHRvIHBhc3MgaW4gYXNCbG9jazogdHJ1ZSBzbyB0aGF0IHRoZSBjb21tZW50IG5vZGUgY2FsbFxuICAgICAgLy8gY2xvc2VzIHRoZSBjdXJyZW50IGJsb2NrLlxuICAgICAgY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoQ1JFQVRFX0NPTU1FTlQpLCBbXG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyAnXCJ2LWlmXCInIDogJ1wiXCInLFxuICAgICAgICBcInRydWVcIlxuICAgICAgXSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVDaGlsZHJlbkNvZGVnZW5Ob2RlKGJyYW5jaCwga2V5SW5kZXgsIGNvbnRleHQpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDaGlsZHJlbkNvZGVnZW5Ob2RlKGJyYW5jaCwga2V5SW5kZXgsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBoZWxwZXIgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IGtleVByb3BlcnR5ID0gY3JlYXRlT2JqZWN0UHJvcGVydHkoXG4gICAgYGtleWAsXG4gICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihcbiAgICAgIGAke2tleUluZGV4fWAsXG4gICAgICBmYWxzZSxcbiAgICAgIGxvY1N0dWIsXG4gICAgICAyXG4gICAgKVxuICApO1xuICBjb25zdCB7IGNoaWxkcmVuIH0gPSBicmFuY2g7XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBjaGlsZHJlblswXTtcbiAgY29uc3QgbmVlZEZyYWdtZW50V3JhcHBlciA9IGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBmaXJzdENoaWxkLnR5cGUgIT09IDE7XG4gIGlmIChuZWVkRnJhZ21lbnRXcmFwcGVyKSB7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBmaXJzdENoaWxkLnR5cGUgPT09IDExKSB7XG4gICAgICBjb25zdCB2bm9kZUNhbGwgPSBmaXJzdENoaWxkLmNvZGVnZW5Ob2RlO1xuICAgICAgaW5qZWN0UHJvcCh2bm9kZUNhbGwsIGtleVByb3BlcnR5LCBjb250ZXh0KTtcbiAgICAgIHJldHVybiB2bm9kZUNhbGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXRjaEZsYWcgPSA2NDtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFicmFuY2guaXNUZW1wbGF0ZUlmICYmIGNoaWxkcmVuLmZpbHRlcigoYykgPT4gYy50eXBlICE9PSAzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcGF0Y2hGbGFnIHw9IDIwNDg7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlVk5vZGVDYWxsKFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBoZWxwZXIoRlJBR01FTlQpLFxuICAgICAgICBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtrZXlQcm9wZXJ0eV0pLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgcGF0Y2hGbGFnLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBicmFuY2gubG9jXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZXQgPSBmaXJzdENoaWxkLmNvZGVnZW5Ob2RlO1xuICAgIGNvbnN0IHZub2RlQ2FsbCA9IGdldE1lbW9lZFZOb2RlQ2FsbChyZXQpO1xuICAgIGlmICh2bm9kZUNhbGwudHlwZSA9PT0gMTMpIHtcbiAgICAgIGNvbnZlcnRUb0Jsb2NrKHZub2RlQ2FsbCwgY29udGV4dCk7XG4gICAgfVxuICAgIGluamVjdFByb3Aodm5vZGVDYWxsLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuZnVuY3Rpb24gaXNTYW1lS2V5KGEsIGIpIHtcbiAgaWYgKCFhIHx8IGEudHlwZSAhPT0gYi50eXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhLnR5cGUgPT09IDYpIHtcbiAgICBpZiAoYS52YWx1ZS5jb250ZW50ICE9PSBiLnZhbHVlLmNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZXhwID0gYS5leHA7XG4gICAgY29uc3QgYnJhbmNoRXhwID0gYi5leHA7XG4gICAgaWYgKGV4cC50eXBlICE9PSBicmFuY2hFeHAudHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZXhwLnR5cGUgIT09IDQgfHwgZXhwLmlzU3RhdGljICE9PSBicmFuY2hFeHAuaXNTdGF0aWMgfHwgZXhwLmNvbnRlbnQgIT09IGJyYW5jaEV4cC5jb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50Q29uZGl0aW9uKG5vZGUpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAxOSkge1xuICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09IDE5KSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmFsdGVybmF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyMCkge1xuICAgICAgbm9kZSA9IG5vZGUudmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHRyYW5zZm9ybUZvciA9IGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0oXG4gIFwiZm9yXCIsXG4gIChub2RlLCBkaXIsIGNvbnRleHQpID0+IHtcbiAgICBjb25zdCB7IGhlbHBlciwgcmVtb3ZlSGVscGVyIH0gPSBjb250ZXh0O1xuICAgIHJldHVybiBwcm9jZXNzRm9yKG5vZGUsIGRpciwgY29udGV4dCwgKGZvck5vZGUpID0+IHtcbiAgICAgIGNvbnN0IHJlbmRlckV4cCA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGhlbHBlcihSRU5ERVJfTElTVCksIFtcbiAgICAgICAgZm9yTm9kZS5zb3VyY2VcbiAgICAgIF0pO1xuICAgICAgY29uc3QgaXNUZW1wbGF0ZSA9IGlzVGVtcGxhdGVOb2RlKG5vZGUpO1xuICAgICAgY29uc3QgbWVtbyA9IGZpbmREaXIobm9kZSwgXCJtZW1vXCIpO1xuICAgICAgY29uc3Qga2V5UHJvcCA9IGZpbmRQcm9wKG5vZGUsIGBrZXlgLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICBrZXlQcm9wICYmIGtleVByb3AudHlwZSA9PT0gNztcbiAgICAgIGxldCBrZXlFeHAgPSBrZXlQcm9wICYmIChrZXlQcm9wLnR5cGUgPT09IDYgPyBrZXlQcm9wLnZhbHVlID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihrZXlQcm9wLnZhbHVlLmNvbnRlbnQsIHRydWUpIDogdm9pZCAwIDoga2V5UHJvcC5leHApO1xuICAgICAgY29uc3Qga2V5UHJvcGVydHkgPSBrZXlQcm9wICYmIGtleUV4cCA/IGNyZWF0ZU9iamVjdFByb3BlcnR5KGBrZXlgLCBrZXlFeHApIDogbnVsbDtcbiAgICAgIGNvbnN0IGlzU3RhYmxlRnJhZ21lbnQgPSBmb3JOb2RlLnNvdXJjZS50eXBlID09PSA0ICYmIGZvck5vZGUuc291cmNlLmNvbnN0VHlwZSA+IDA7XG4gICAgICBjb25zdCBmcmFnbWVudEZsYWcgPSBpc1N0YWJsZUZyYWdtZW50ID8gNjQgOiBrZXlQcm9wID8gMTI4IDogMjU2O1xuICAgICAgZm9yTm9kZS5jb2RlZ2VuTm9kZSA9IGNyZWF0ZVZOb2RlQ2FsbChcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgaGVscGVyKEZSQUdNRU5UKSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICByZW5kZXJFeHAsXG4gICAgICAgIGZyYWdtZW50RmxhZyxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHRydWUsXG4gICAgICAgICFpc1N0YWJsZUZyYWdtZW50LFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgbm9kZS5sb2NcbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsZXQgY2hpbGRCbG9jaztcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gZm9yTm9kZTtcbiAgICAgICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IGZhbHNlKSAmJiBpc1RlbXBsYXRlKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi5zb21lKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoYy50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGtleSA9IGZpbmRQcm9wKGMsIFwia2V5XCIpO1xuICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKFxuICAgICAgICAgICAgICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgMzMsXG4gICAgICAgICAgICAgICAgICAgIGtleS5sb2NcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmVlZEZyYWdtZW50V3JhcHBlciA9IGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBjaGlsZHJlblswXS50eXBlICE9PSAxO1xuICAgICAgICBjb25zdCBzbG90T3V0bGV0ID0gaXNTbG90T3V0bGV0KG5vZGUpID8gbm9kZSA6IGlzVGVtcGxhdGUgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgaXNTbG90T3V0bGV0KG5vZGUuY2hpbGRyZW5bMF0pID8gbm9kZS5jaGlsZHJlblswXSA6IG51bGw7XG4gICAgICAgIGlmIChzbG90T3V0bGV0KSB7XG4gICAgICAgICAgY2hpbGRCbG9jayA9IHNsb3RPdXRsZXQuY29kZWdlbk5vZGU7XG4gICAgICAgICAgaWYgKGlzVGVtcGxhdGUgJiYga2V5UHJvcGVydHkpIHtcbiAgICAgICAgICAgIGluamVjdFByb3AoY2hpbGRCbG9jaywga2V5UHJvcGVydHksIGNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuZWVkRnJhZ21lbnRXcmFwcGVyKSB7XG4gICAgICAgICAgY2hpbGRCbG9jayA9IGNyZWF0ZVZOb2RlQ2FsbChcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBoZWxwZXIoRlJBR01FTlQpLFxuICAgICAgICAgICAga2V5UHJvcGVydHkgPyBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtrZXlQcm9wZXJ0eV0pIDogdm9pZCAwLFxuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbixcbiAgICAgICAgICAgIDY0LFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGlsZEJsb2NrID0gY2hpbGRyZW5bMF0uY29kZWdlbk5vZGU7XG4gICAgICAgICAgaWYgKGlzVGVtcGxhdGUgJiYga2V5UHJvcGVydHkpIHtcbiAgICAgICAgICAgIGluamVjdFByb3AoY2hpbGRCbG9jaywga2V5UHJvcGVydHksIGNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hpbGRCbG9jay5pc0Jsb2NrICE9PSAhaXNTdGFibGVGcmFnbWVudCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkQmxvY2suaXNCbG9jaykge1xuICAgICAgICAgICAgICByZW1vdmVIZWxwZXIoT1BFTl9CTE9DSyk7XG4gICAgICAgICAgICAgIHJlbW92ZUhlbHBlcihcbiAgICAgICAgICAgICAgICBnZXRWTm9kZUJsb2NrSGVscGVyKGNvbnRleHQuaW5TU1IsIGNoaWxkQmxvY2suaXNDb21wb25lbnQpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZW1vdmVIZWxwZXIoXG4gICAgICAgICAgICAgICAgZ2V0Vk5vZGVIZWxwZXIoY29udGV4dC5pblNTUiwgY2hpbGRCbG9jay5pc0NvbXBvbmVudClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGRCbG9jay5pc0Jsb2NrID0gIWlzU3RhYmxlRnJhZ21lbnQ7XG4gICAgICAgICAgaWYgKGNoaWxkQmxvY2suaXNCbG9jaykge1xuICAgICAgICAgICAgaGVscGVyKE9QRU5fQkxPQ0spO1xuICAgICAgICAgICAgaGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgY2hpbGRCbG9jay5pc0NvbXBvbmVudCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWxwZXIoZ2V0Vk5vZGVIZWxwZXIoY29udGV4dC5pblNTUiwgY2hpbGRCbG9jay5pc0NvbXBvbmVudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtbykge1xuICAgICAgICAgIGNvbnN0IGxvb3AgPSBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oXG4gICAgICAgICAgICBjcmVhdGVGb3JMb29wUGFyYW1zKGZvck5vZGUucGFyc2VSZXN1bHQsIFtcbiAgICAgICAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgX2NhY2hlZGApXG4gICAgICAgICAgICBdKVxuICAgICAgICAgICk7XG4gICAgICAgICAgbG9vcC5ib2R5ID0gY3JlYXRlQmxvY2tTdGF0ZW1lbnQoW1xuICAgICAgICAgICAgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtgY29uc3QgX21lbW8gPSAoYCwgbWVtby5leHAsIGApYF0pLFxuICAgICAgICAgICAgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcbiAgICAgICAgICAgICAgYGlmIChfY2FjaGVkYCxcbiAgICAgICAgICAgICAgLi4ua2V5RXhwID8gW2AgJiYgX2NhY2hlZC5rZXkgPT09IGAsIGtleUV4cF0gOiBbXSxcbiAgICAgICAgICAgICAgYCAmJiAke2NvbnRleHQuaGVscGVyU3RyaW5nKFxuICAgICAgICAgICAgICAgIElTX01FTU9fU0FNRVxuICAgICAgICAgICAgICApfShfY2FjaGVkLCBfbWVtbykpIHJldHVybiBfY2FjaGVkYFxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW2Bjb25zdCBfaXRlbSA9IGAsIGNoaWxkQmxvY2tdKSxcbiAgICAgICAgICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9pdGVtLm1lbW8gPSBfbWVtb2ApLFxuICAgICAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgcmV0dXJuIF9pdGVtYClcbiAgICAgICAgICBdKTtcbiAgICAgICAgICByZW5kZXJFeHAuYXJndW1lbnRzLnB1c2goXG4gICAgICAgICAgICBsb29wLFxuICAgICAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgX2NhY2hlYCksXG4gICAgICAgICAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKFN0cmluZyhjb250ZXh0LmNhY2hlZC5sZW5ndGgpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGV4dC5jYWNoZWQucHVzaChudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW5kZXJFeHAuYXJndW1lbnRzLnB1c2goXG4gICAgICAgICAgICBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oXG4gICAgICAgICAgICAgIGNyZWF0ZUZvckxvb3BQYXJhbXMoZm9yTm9kZS5wYXJzZVJlc3VsdCksXG4gICAgICAgICAgICAgIGNoaWxkQmxvY2ssXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4pO1xuZnVuY3Rpb24gcHJvY2Vzc0Zvcihub2RlLCBkaXIsIGNvbnRleHQsIHByb2Nlc3NDb2RlZ2VuKSB7XG4gIGlmICghZGlyLmV4cCkge1xuICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgIGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzEsIGRpci5sb2MpXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFyc2VSZXN1bHQgPSBkaXIuZm9yUGFyc2VSZXN1bHQ7XG4gIGlmICghcGFyc2VSZXN1bHQpIHtcbiAgICBjb250ZXh0Lm9uRXJyb3IoXG4gICAgICBjcmVhdGVDb21waWxlckVycm9yKDMyLCBkaXIubG9jKVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZpbmFsaXplRm9yUGFyc2VSZXN1bHQocGFyc2VSZXN1bHQsIGNvbnRleHQpO1xuICBjb25zdCB7IGFkZElkZW50aWZpZXJzLCByZW1vdmVJZGVudGlmaWVycywgc2NvcGVzIH0gPSBjb250ZXh0O1xuICBjb25zdCB7IHNvdXJjZSwgdmFsdWUsIGtleSwgaW5kZXggfSA9IHBhcnNlUmVzdWx0O1xuICBjb25zdCBmb3JOb2RlID0ge1xuICAgIHR5cGU6IDExLFxuICAgIGxvYzogZGlyLmxvYyxcbiAgICBzb3VyY2UsXG4gICAgdmFsdWVBbGlhczogdmFsdWUsXG4gICAga2V5QWxpYXM6IGtleSxcbiAgICBvYmplY3RJbmRleEFsaWFzOiBpbmRleCxcbiAgICBwYXJzZVJlc3VsdCxcbiAgICBjaGlsZHJlbjogaXNUZW1wbGF0ZU5vZGUobm9kZSkgPyBub2RlLmNoaWxkcmVuIDogW25vZGVdXG4gIH07XG4gIGNvbnRleHQucmVwbGFjZU5vZGUoZm9yTm9kZSk7XG4gIHNjb3Blcy52Rm9yKys7XG4gIGNvbnN0IG9uRXhpdCA9IHByb2Nlc3NDb2RlZ2VuICYmIHByb2Nlc3NDb2RlZ2VuKGZvck5vZGUpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHNjb3Blcy52Rm9yLS07XG4gICAgaWYgKG9uRXhpdCkgb25FeGl0KCk7XG4gIH07XG59XG5mdW5jdGlvbiBmaW5hbGl6ZUZvclBhcnNlUmVzdWx0KHJlc3VsdCwgY29udGV4dCkge1xuICBpZiAocmVzdWx0LmZpbmFsaXplZCkgcmV0dXJuO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlKSB7XG4gICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQuc291cmNlLCBjb250ZXh0KTtcbiAgICBpZiAocmVzdWx0LmtleSkge1xuICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihcbiAgICAgICAgcmVzdWx0LmtleSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5pbmRleCkge1xuICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihcbiAgICAgICAgcmVzdWx0LmluZGV4LFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnZhbHVlKSB7XG4gICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKFxuICAgICAgICByZXN1bHQudmFsdWUsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5maW5hbGl6ZWQgPSB0cnVlO1xufVxuZnVuY3Rpb24gY3JlYXRlRm9yTG9vcFBhcmFtcyh7IHZhbHVlLCBrZXksIGluZGV4IH0sIG1lbW9BcmdzID0gW10pIHtcbiAgcmV0dXJuIGNyZWF0ZVBhcmFtc0xpc3QoW3ZhbHVlLCBrZXksIGluZGV4LCAuLi5tZW1vQXJnc10pO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFyYW1zTGlzdChhcmdzKSB7XG4gIGxldCBpID0gYXJncy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoYXJnc1tpXSkgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGFyZ3Muc2xpY2UoMCwgaSArIDEpLm1hcCgoYXJnLCBpMikgPT4gYXJnIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9gLnJlcGVhdChpMiArIDEpLCBmYWxzZSkpO1xufVxuXG5jb25zdCBkZWZhdWx0RmFsbGJhY2sgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB1bmRlZmluZWRgLCBmYWxzZSk7XG5jb25zdCB0cmFja1Nsb3RTY29wZXMgPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICBpZiAobm9kZS50eXBlID09PSAxICYmIChub2RlLnRhZ1R5cGUgPT09IDEgfHwgbm9kZS50YWdUeXBlID09PSAzKSkge1xuICAgIGNvbnN0IHZTbG90ID0gZmluZERpcihub2RlLCBcInNsb3RcIik7XG4gICAgaWYgKHZTbG90KSB7XG4gICAgICB2U2xvdC5leHA7XG4gICAgICBjb250ZXh0LnNjb3Blcy52U2xvdCsrO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QtLTtcbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuY29uc3QgdHJhY2tWRm9yU2xvdFNjb3BlcyA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gIGxldCB2Rm9yO1xuICBpZiAoaXNUZW1wbGF0ZU5vZGUobm9kZSkgJiYgbm9kZS5wcm9wcy5zb21lKGlzVlNsb3QpICYmICh2Rm9yID0gZmluZERpcihub2RlLCBcImZvclwiKSkpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2Rm9yLmZvclBhcnNlUmVzdWx0O1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGZpbmFsaXplRm9yUGFyc2VSZXN1bHQocmVzdWx0LCBjb250ZXh0KTtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGtleSwgaW5kZXggfSA9IHJlc3VsdDtcbiAgICAgIGNvbnN0IHsgYWRkSWRlbnRpZmllcnMsIHJlbW92ZUlkZW50aWZpZXJzIH0gPSBjb250ZXh0O1xuICAgICAgdmFsdWUgJiYgYWRkSWRlbnRpZmllcnModmFsdWUpO1xuICAgICAga2V5ICYmIGFkZElkZW50aWZpZXJzKGtleSk7XG4gICAgICBpbmRleCAmJiBhZGRJZGVudGlmaWVycyhpbmRleCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB2YWx1ZSAmJiByZW1vdmVJZGVudGlmaWVycyh2YWx1ZSk7XG4gICAgICAgIGtleSAmJiByZW1vdmVJZGVudGlmaWVycyhrZXkpO1xuICAgICAgICBpbmRleCAmJiByZW1vdmVJZGVudGlmaWVycyhpbmRleCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGJ1aWxkQ2xpZW50U2xvdEZuID0gKHByb3BzLCBfdkZvckV4cCwgY2hpbGRyZW4sIGxvYykgPT4gY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKFxuICBwcm9wcyxcbiAgY2hpbGRyZW4sXG4gIGZhbHNlLFxuICB0cnVlLFxuICBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlblswXS5sb2MgOiBsb2Ncbik7XG5mdW5jdGlvbiBidWlsZFNsb3RzKG5vZGUsIGNvbnRleHQsIGJ1aWxkU2xvdEZuID0gYnVpbGRDbGllbnRTbG90Rm4pIHtcbiAgY29udGV4dC5oZWxwZXIoV0lUSF9DVFgpO1xuICBjb25zdCB7IGNoaWxkcmVuLCBsb2MgfSA9IG5vZGU7XG4gIGNvbnN0IHNsb3RzUHJvcGVydGllcyA9IFtdO1xuICBjb25zdCBkeW5hbWljU2xvdHMgPSBbXTtcbiAgbGV0IGhhc0R5bmFtaWNTbG90cyA9IGNvbnRleHQuc2NvcGVzLnZTbG90ID4gMCB8fCBjb250ZXh0LnNjb3Blcy52Rm9yID4gMDtcbiAgY29uc3Qgb25Db21wb25lbnRTbG90ID0gZmluZERpcihub2RlLCBcInNsb3RcIiwgdHJ1ZSk7XG4gIGlmIChvbkNvbXBvbmVudFNsb3QpIHtcbiAgICBjb25zdCB7IGFyZywgZXhwIH0gPSBvbkNvbXBvbmVudFNsb3Q7XG4gICAgaWYgKGFyZyAmJiAhaXNTdGF0aWNFeHAoYXJnKSkge1xuICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcbiAgICB9XG4gICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goXG4gICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShcbiAgICAgICAgYXJnIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oXCJkZWZhdWx0XCIsIHRydWUpLFxuICAgICAgICBidWlsZFNsb3RGbihleHAsIHZvaWQgMCwgY2hpbGRyZW4sIGxvYylcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGxldCBoYXNUZW1wbGF0ZVNsb3RzID0gZmFsc2U7XG4gIGxldCBoYXNOYW1lZERlZmF1bHRTbG90ID0gZmFsc2U7XG4gIGNvbnN0IGltcGxpY2l0RGVmYXVsdENoaWxkcmVuID0gW107XG4gIGNvbnN0IHNlZW5TbG90TmFtZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgY29uZGl0aW9uYWxCcmFuY2hJbmRleCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbG90RWxlbWVudCA9IGNoaWxkcmVuW2ldO1xuICAgIGxldCBzbG90RGlyO1xuICAgIGlmICghaXNUZW1wbGF0ZU5vZGUoc2xvdEVsZW1lbnQpIHx8ICEoc2xvdERpciA9IGZpbmREaXIoc2xvdEVsZW1lbnQsIFwic2xvdFwiLCB0cnVlKSkpIHtcbiAgICAgIGlmIChzbG90RWxlbWVudC50eXBlICE9PSAzKSB7XG4gICAgICAgIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuLnB1c2goc2xvdEVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChvbkNvbXBvbmVudFNsb3QpIHtcbiAgICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcigzNywgc2xvdERpci5sb2MpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGhhc1RlbXBsYXRlU2xvdHMgPSB0cnVlO1xuICAgIGNvbnN0IHsgY2hpbGRyZW46IHNsb3RDaGlsZHJlbiwgbG9jOiBzbG90TG9jIH0gPSBzbG90RWxlbWVudDtcbiAgICBjb25zdCB7XG4gICAgICBhcmc6IHNsb3ROYW1lID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgZGVmYXVsdGAsIHRydWUpLFxuICAgICAgZXhwOiBzbG90UHJvcHMsXG4gICAgICBsb2M6IGRpckxvY1xuICAgIH0gPSBzbG90RGlyO1xuICAgIGxldCBzdGF0aWNTbG90TmFtZTtcbiAgICBpZiAoaXNTdGF0aWNFeHAoc2xvdE5hbWUpKSB7XG4gICAgICBzdGF0aWNTbG90TmFtZSA9IHNsb3ROYW1lID8gc2xvdE5hbWUuY29udGVudCA6IGBkZWZhdWx0YDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgdkZvciA9IGZpbmREaXIoc2xvdEVsZW1lbnQsIFwiZm9yXCIpO1xuICAgIGNvbnN0IHNsb3RGdW5jdGlvbiA9IGJ1aWxkU2xvdEZuKHNsb3RQcm9wcywgdkZvciwgc2xvdENoaWxkcmVuLCBzbG90TG9jKTtcbiAgICBsZXQgdklmO1xuICAgIGxldCB2RWxzZTtcbiAgICBpZiAodklmID0gZmluZERpcihzbG90RWxlbWVudCwgXCJpZlwiKSkge1xuICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcbiAgICAgIGR5bmFtaWNTbG90cy5wdXNoKFxuICAgICAgICBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24oXG4gICAgICAgICAgdklmLmV4cCxcbiAgICAgICAgICBidWlsZER5bmFtaWNTbG90KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24sIGNvbmRpdGlvbmFsQnJhbmNoSW5kZXgrKyksXG4gICAgICAgICAgZGVmYXVsdEZhbGxiYWNrXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh2RWxzZSA9IGZpbmREaXIoXG4gICAgICBzbG90RWxlbWVudCxcbiAgICAgIC9eZWxzZSg/Oi1pZik/JC8sXG4gICAgICB0cnVlXG4gICAgICAvKiBhbGxvd0VtcHR5ICovXG4gICAgKSkge1xuICAgICAgbGV0IGogPSBpO1xuICAgICAgbGV0IHByZXY7XG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIHByZXYgPSBjaGlsZHJlbltqXTtcbiAgICAgICAgaWYgKCFpc0NvbW1lbnRPcldoaXRlc3BhY2UocHJldikpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByZXYgJiYgaXNUZW1wbGF0ZU5vZGUocHJldikgJiYgZmluZERpcihwcmV2LCAvXig/OmVsc2UtKT9pZiQvKSkge1xuICAgICAgICBsZXQgY29uZGl0aW9uYWwgPSBkeW5hbWljU2xvdHNbZHluYW1pY1Nsb3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICB3aGlsZSAoY29uZGl0aW9uYWwuYWx0ZXJuYXRlLnR5cGUgPT09IDE5KSB7XG4gICAgICAgICAgY29uZGl0aW9uYWwgPSBjb25kaXRpb25hbC5hbHRlcm5hdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uZGl0aW9uYWwuYWx0ZXJuYXRlID0gdkVsc2UuZXhwID8gY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uKFxuICAgICAgICAgIHZFbHNlLmV4cCxcbiAgICAgICAgICBidWlsZER5bmFtaWNTbG90KFxuICAgICAgICAgICAgc2xvdE5hbWUsXG4gICAgICAgICAgICBzbG90RnVuY3Rpb24sXG4gICAgICAgICAgICBjb25kaXRpb25hbEJyYW5jaEluZGV4KytcbiAgICAgICAgICApLFxuICAgICAgICAgIGRlZmF1bHRGYWxsYmFja1xuICAgICAgICApIDogYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uLCBjb25kaXRpb25hbEJyYW5jaEluZGV4KyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKFxuICAgICAgICAgIGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzAsIHZFbHNlLmxvYylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZGb3IpIHtcbiAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XG4gICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHZGb3IuZm9yUGFyc2VSZXN1bHQ7XG4gICAgICBpZiAocGFyc2VSZXN1bHQpIHtcbiAgICAgICAgZmluYWxpemVGb3JQYXJzZVJlc3VsdChwYXJzZVJlc3VsdCwgY29udGV4dCk7XG4gICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKFxuICAgICAgICAgIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFTkRFUl9MSVNUKSwgW1xuICAgICAgICAgICAgcGFyc2VSZXN1bHQuc291cmNlLFxuICAgICAgICAgICAgY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKFxuICAgICAgICAgICAgICBjcmVhdGVGb3JMb29wUGFyYW1zKHBhcnNlUmVzdWx0KSxcbiAgICAgICAgICAgICAgYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKSxcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIF0pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoXG4gICAgICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcihcbiAgICAgICAgICAgIDMyLFxuICAgICAgICAgICAgdkZvci5sb2NcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0aWNTbG90TmFtZSkge1xuICAgICAgICBpZiAoc2VlblNsb3ROYW1lcy5oYXMoc3RhdGljU2xvdE5hbWUpKSB7XG4gICAgICAgICAgY29udGV4dC5vbkVycm9yKFxuICAgICAgICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcihcbiAgICAgICAgICAgICAgMzgsXG4gICAgICAgICAgICAgIGRpckxvY1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc2VlblNsb3ROYW1lcy5hZGQoc3RhdGljU2xvdE5hbWUpO1xuICAgICAgICBpZiAoc3RhdGljU2xvdE5hbWUgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgaGFzTmFtZWREZWZhdWx0U2xvdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNsb3RzUHJvcGVydGllcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24pKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFvbkNvbXBvbmVudFNsb3QpIHtcbiAgICBjb25zdCBidWlsZERlZmF1bHRTbG90UHJvcGVydHkgPSAocHJvcHMsIGNoaWxkcmVuMikgPT4ge1xuICAgICAgY29uc3QgZm4gPSBidWlsZFNsb3RGbihwcm9wcywgdm9pZCAwLCBjaGlsZHJlbjIsIGxvYyk7XG4gICAgICBpZiAoY29udGV4dC5jb21wYXRDb25maWcpIHtcbiAgICAgICAgZm4uaXNOb25TY29wZWRTbG90ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVPYmplY3RQcm9wZXJ0eShgZGVmYXVsdGAsIGZuKTtcbiAgICB9O1xuICAgIGlmICghaGFzVGVtcGxhdGVTbG90cykge1xuICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goYnVpbGREZWZhdWx0U2xvdFByb3BlcnR5KHZvaWQgMCwgY2hpbGRyZW4pKTtcbiAgICB9IGVsc2UgaWYgKGltcGxpY2l0RGVmYXVsdENoaWxkcmVuLmxlbmd0aCAmJiAvLyAjMzc2NlxuICAgIC8vIHdpdGggd2hpdGVzcGFjZTogJ3ByZXNlcnZlJywgd2hpdGVzcGFjZXMgYmV0d2VlbiBzbG90cyB3aWxsIGVuZCB1cCBpblxuICAgIC8vIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuLiBJZ25vcmUgaWYgYWxsIGltcGxpY2l0IGNoaWxkcmVuIGFyZSB3aGl0ZXNwYWNlcy5cbiAgICAhaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4uZXZlcnkoaXNXaGl0ZXNwYWNlVGV4dCkpIHtcbiAgICAgIGlmIChoYXNOYW1lZERlZmF1bHRTbG90KSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgICAgICBjcmVhdGVDb21waWxlckVycm9yKFxuICAgICAgICAgICAgMzksXG4gICAgICAgICAgICBpbXBsaWNpdERlZmF1bHRDaGlsZHJlblswXS5sb2NcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChcbiAgICAgICAgICBidWlsZERlZmF1bHRTbG90UHJvcGVydHkodm9pZCAwLCBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3Qgc2xvdEZsYWcgPSBoYXNEeW5hbWljU2xvdHMgPyAyIDogaGFzRm9yd2FyZGVkU2xvdHMobm9kZS5jaGlsZHJlbikgPyAzIDogMTtcbiAgbGV0IHNsb3RzID0gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihcbiAgICBzbG90c1Byb3BlcnRpZXMuY29uY2F0KFxuICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoXG4gICAgICAgIGBfYCxcbiAgICAgICAgLy8gMiA9IGNvbXBpbGVkIGJ1dCBkeW5hbWljID0gY2FuIHNraXAgbm9ybWFsaXphdGlvbiwgYnV0IG11c3QgcnVuIGRpZmZcbiAgICAgICAgLy8gMSA9IGNvbXBpbGVkIGFuZCBzdGF0aWMgPSBjYW4gc2tpcCBub3JtYWxpemF0aW9uIEFORCBkaWZmIGFzIG9wdGltaXplZFxuICAgICAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKFxuICAgICAgICAgIHNsb3RGbGFnICsgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgIC8qICR7c2xvdEZsYWdzVGV4dFtzbG90RmxhZ119ICovYCA6IGBgKSxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApXG4gICAgICApXG4gICAgKSxcbiAgICBsb2NcbiAgKTtcbiAgaWYgKGR5bmFtaWNTbG90cy5sZW5ndGgpIHtcbiAgICBzbG90cyA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKENSRUFURV9TTE9UUyksIFtcbiAgICAgIHNsb3RzLFxuICAgICAgY3JlYXRlQXJyYXlFeHByZXNzaW9uKGR5bmFtaWNTbG90cylcbiAgICBdKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNsb3RzLFxuICAgIGhhc0R5bmFtaWNTbG90c1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGREeW5hbWljU2xvdChuYW1lLCBmbiwgaW5kZXgpIHtcbiAgY29uc3QgcHJvcHMgPSBbXG4gICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoYG5hbWVgLCBuYW1lKSxcbiAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShgZm5gLCBmbilcbiAgXTtcbiAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICBwcm9wcy5wdXNoKFxuICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoYGtleWAsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oU3RyaW5nKGluZGV4KSwgdHJ1ZSkpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihwcm9wcyk7XG59XG5mdW5jdGlvbiBoYXNGb3J3YXJkZWRTbG90cyhjaGlsZHJlbikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBzd2l0Y2ggKGNoaWxkLnR5cGUpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKGNoaWxkLnRhZ1R5cGUgPT09IDIgfHwgaGFzRm9yd2FyZGVkU2xvdHMoY2hpbGQuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDk6XG4gICAgICAgIGlmIChoYXNGb3J3YXJkZWRTbG90cyhjaGlsZC5icmFuY2hlcykpIHJldHVybiB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTA6XG4gICAgICBjYXNlIDExOlxuICAgICAgICBpZiAoaGFzRm9yd2FyZGVkU2xvdHMoY2hpbGQuY2hpbGRyZW4pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgZGlyZWN0aXZlSW1wb3J0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCB0cmFuc2Zvcm1FbGVtZW50ID0gKG5vZGUsIGNvbnRleHQpID0+IHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBvc3RUcmFuc2Zvcm1FbGVtZW50KCkge1xuICAgIG5vZGUgPSBjb250ZXh0LmN1cnJlbnROb2RlO1xuICAgIGlmICghKG5vZGUudHlwZSA9PT0gMSAmJiAobm9kZS50YWdUeXBlID09PSAwIHx8IG5vZGUudGFnVHlwZSA9PT0gMSkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgdGFnLCBwcm9wcyB9ID0gbm9kZTtcbiAgICBjb25zdCBpc0NvbXBvbmVudCA9IG5vZGUudGFnVHlwZSA9PT0gMTtcbiAgICBsZXQgdm5vZGVUYWcgPSBpc0NvbXBvbmVudCA/IHJlc29sdmVDb21wb25lbnRUeXBlKG5vZGUsIGNvbnRleHQpIDogYFwiJHt0YWd9XCJgO1xuICAgIGNvbnN0IGlzRHluYW1pY0NvbXBvbmVudCA9IGlzT2JqZWN0KHZub2RlVGFnKSAmJiB2bm9kZVRhZy5jYWxsZWUgPT09IFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQ7XG4gICAgbGV0IHZub2RlUHJvcHM7XG4gICAgbGV0IHZub2RlQ2hpbGRyZW47XG4gICAgbGV0IHBhdGNoRmxhZyA9IDA7XG4gICAgbGV0IHZub2RlRHluYW1pY1Byb3BzO1xuICAgIGxldCBkeW5hbWljUHJvcE5hbWVzO1xuICAgIGxldCB2bm9kZURpcmVjdGl2ZXM7XG4gICAgbGV0IHNob3VsZFVzZUJsb2NrID0gKFxuICAgICAgLy8gZHluYW1pYyBjb21wb25lbnQgbWF5IHJlc29sdmUgdG8gcGxhaW4gZWxlbWVudHNcbiAgICAgIGlzRHluYW1pY0NvbXBvbmVudCB8fCB2bm9kZVRhZyA9PT0gVEVMRVBPUlQgfHwgdm5vZGVUYWcgPT09IFNVU1BFTlNFIHx8ICFpc0NvbXBvbmVudCAmJiAvLyA8c3ZnPiBhbmQgPGZvcmVpZ25PYmplY3Q+IG11c3QgYmUgZm9yY2VkIGludG8gYmxvY2tzIHNvIHRoYXQgYmxvY2tcbiAgICAgIC8vIHVwZGF0ZXMgaW5zaWRlIGdldCBwcm9wZXIgaXNTVkcgZmxhZyBhdCBydW50aW1lLiAoIzYzOSwgIzY0MylcbiAgICAgIC8vIFRoaXMgaXMgdGVjaG5pY2FsbHkgd2ViLXNwZWNpZmljLCBidXQgc3BsaXR0aW5nIHRoZSBsb2dpYyBvdXQgb2YgY29yZVxuICAgICAgLy8gbGVhZHMgdG8gdG9vIG11Y2ggdW5uZWNlc3NhcnkgY29tcGxleGl0eS5cbiAgICAgICh0YWcgPT09IFwic3ZnXCIgfHwgdGFnID09PSBcImZvcmVpZ25PYmplY3RcIiB8fCB0YWcgPT09IFwibWF0aFwiKVxuICAgICk7XG4gICAgaWYgKHByb3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHByb3BzQnVpbGRSZXN1bHQgPSBidWlsZFByb3BzKFxuICAgICAgICBub2RlLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIGlzQ29tcG9uZW50LFxuICAgICAgICBpc0R5bmFtaWNDb21wb25lbnRcbiAgICAgICk7XG4gICAgICB2bm9kZVByb3BzID0gcHJvcHNCdWlsZFJlc3VsdC5wcm9wcztcbiAgICAgIHBhdGNoRmxhZyA9IHByb3BzQnVpbGRSZXN1bHQucGF0Y2hGbGFnO1xuICAgICAgZHluYW1pY1Byb3BOYW1lcyA9IHByb3BzQnVpbGRSZXN1bHQuZHluYW1pY1Byb3BOYW1lcztcbiAgICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSBwcm9wc0J1aWxkUmVzdWx0LmRpcmVjdGl2ZXM7XG4gICAgICB2bm9kZURpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMubGVuZ3RoID8gY3JlYXRlQXJyYXlFeHByZXNzaW9uKFxuICAgICAgICBkaXJlY3RpdmVzLm1hcCgoZGlyKSA9PiBidWlsZERpcmVjdGl2ZUFyZ3MoZGlyLCBjb250ZXh0KSlcbiAgICAgICkgOiB2b2lkIDA7XG4gICAgICBpZiAocHJvcHNCdWlsZFJlc3VsdC5zaG91bGRVc2VCbG9jaykge1xuICAgICAgICBzaG91bGRVc2VCbG9jayA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh2bm9kZVRhZyA9PT0gS0VFUF9BTElWRSkge1xuICAgICAgICBzaG91bGRVc2VCbG9jayA9IHRydWU7XG4gICAgICAgIHBhdGNoRmxhZyB8PSAxMDI0O1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoXG4gICAgICAgICAgICBjcmVhdGVDb21waWxlckVycm9yKDQ3LCB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBub2RlLmNoaWxkcmVuWzBdLmxvYy5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubG9jLmVuZCxcbiAgICAgICAgICAgICAgc291cmNlOiBcIlwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHNob3VsZEJ1aWxkQXNTbG90cyA9IGlzQ29tcG9uZW50ICYmIC8vIFRlbGVwb3J0IGlzIG5vdCBhIHJlYWwgY29tcG9uZW50IGFuZCBoYXMgZGVkaWNhdGVkIHJ1bnRpbWUgaGFuZGxpbmdcbiAgICAgIHZub2RlVGFnICE9PSBURUxFUE9SVCAmJiAvLyBleHBsYWluZWQgYWJvdmUuXG4gICAgICB2bm9kZVRhZyAhPT0gS0VFUF9BTElWRTtcbiAgICAgIGlmIChzaG91bGRCdWlsZEFzU2xvdHMpIHtcbiAgICAgICAgY29uc3QgeyBzbG90cywgaGFzRHluYW1pY1Nsb3RzIH0gPSBidWlsZFNsb3RzKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICB2bm9kZUNoaWxkcmVuID0gc2xvdHM7XG4gICAgICAgIGlmIChoYXNEeW5hbWljU2xvdHMpIHtcbiAgICAgICAgICBwYXRjaEZsYWcgfD0gMTAyNDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiB2bm9kZVRhZyAhPT0gVEVMRVBPUlQpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICBjb25zdCB0eXBlID0gY2hpbGQudHlwZTtcbiAgICAgICAgY29uc3QgaGFzRHluYW1pY1RleHRDaGlsZCA9IHR5cGUgPT09IDUgfHwgdHlwZSA9PT0gODtcbiAgICAgICAgaWYgKGhhc0R5bmFtaWNUZXh0Q2hpbGQgJiYgZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KSA9PT0gMCkge1xuICAgICAgICAgIHBhdGNoRmxhZyB8PSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNEeW5hbWljVGV4dENoaWxkIHx8IHR5cGUgPT09IDIpIHtcbiAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gY2hpbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlQ2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZHluYW1pY1Byb3BOYW1lcyAmJiBkeW5hbWljUHJvcE5hbWVzLmxlbmd0aCkge1xuICAgICAgdm5vZGVEeW5hbWljUHJvcHMgPSBzdHJpbmdpZnlEeW5hbWljUHJvcE5hbWVzKGR5bmFtaWNQcm9wTmFtZXMpO1xuICAgIH1cbiAgICBub2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlVk5vZGVDYWxsKFxuICAgICAgY29udGV4dCxcbiAgICAgIHZub2RlVGFnLFxuICAgICAgdm5vZGVQcm9wcyxcbiAgICAgIHZub2RlQ2hpbGRyZW4sXG4gICAgICBwYXRjaEZsYWcgPT09IDAgPyB2b2lkIDAgOiBwYXRjaEZsYWcsXG4gICAgICB2bm9kZUR5bmFtaWNQcm9wcyxcbiAgICAgIHZub2RlRGlyZWN0aXZlcyxcbiAgICAgICEhc2hvdWxkVXNlQmxvY2ssXG4gICAgICBmYWxzZSxcbiAgICAgIGlzQ29tcG9uZW50LFxuICAgICAgbm9kZS5sb2NcbiAgICApO1xuICB9O1xufTtcbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRUeXBlKG5vZGUsIGNvbnRleHQsIHNzciA9IGZhbHNlKSB7XG4gIGxldCB7IHRhZyB9ID0gbm9kZTtcbiAgY29uc3QgaXNFeHBsaWNpdER5bmFtaWMgPSBpc0NvbXBvbmVudFRhZyh0YWcpO1xuICBjb25zdCBpc1Byb3AgPSBmaW5kUHJvcChcbiAgICBub2RlLFxuICAgIFwiaXNcIixcbiAgICBmYWxzZSxcbiAgICB0cnVlXG4gICAgLyogYWxsb3cgZW1wdHkgKi9cbiAgKTtcbiAgaWYgKGlzUHJvcCkge1xuICAgIGlmIChpc0V4cGxpY2l0RHluYW1pYyB8fCBpc0NvbXBhdEVuYWJsZWQoXG4gICAgICBcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIixcbiAgICAgIGNvbnRleHRcbiAgICApKSB7XG4gICAgICBsZXQgZXhwO1xuICAgICAgaWYgKGlzUHJvcC50eXBlID09PSA2KSB7XG4gICAgICAgIGV4cCA9IGlzUHJvcC52YWx1ZSAmJiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGlzUHJvcC52YWx1ZS5jb250ZW50LCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cCA9IGlzUHJvcC5leHA7XG4gICAgICAgIGlmICghZXhwKSB7XG4gICAgICAgICAgZXhwID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgaXNgLCBmYWxzZSwgaXNQcm9wLmFyZy5sb2MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZXhwKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UKSwgW1xuICAgICAgICAgIGV4cFxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJvcC50eXBlID09PSA2ICYmIGlzUHJvcC52YWx1ZS5jb250ZW50LnN0YXJ0c1dpdGgoXCJ2dWU6XCIpKSB7XG4gICAgICB0YWcgPSBpc1Byb3AudmFsdWUuY29udGVudC5zbGljZSg0KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgYnVpbHRJbiA9IGlzQ29yZUNvbXBvbmVudCh0YWcpIHx8IGNvbnRleHQuaXNCdWlsdEluQ29tcG9uZW50KHRhZyk7XG4gIGlmIChidWlsdEluKSB7XG4gICAgaWYgKCFzc3IpIGNvbnRleHQuaGVscGVyKGJ1aWx0SW4pO1xuICAgIHJldHVybiBidWlsdEluO1xuICB9XG4gIGNvbnRleHQuaGVscGVyKFJFU09MVkVfQ09NUE9ORU5UKTtcbiAgY29udGV4dC5jb21wb25lbnRzLmFkZCh0YWcpO1xuICByZXR1cm4gdG9WYWxpZEFzc2V0SWQodGFnLCBgY29tcG9uZW50YCk7XG59XG5mdW5jdGlvbiBidWlsZFByb3BzKG5vZGUsIGNvbnRleHQsIHByb3BzID0gbm9kZS5wcm9wcywgaXNDb21wb25lbnQsIGlzRHluYW1pY0NvbXBvbmVudCwgc3NyID0gZmFsc2UpIHtcbiAgY29uc3QgeyB0YWcsIGxvYzogZWxlbWVudExvYywgY2hpbGRyZW4gfSA9IG5vZGU7XG4gIGxldCBwcm9wZXJ0aWVzID0gW107XG4gIGNvbnN0IG1lcmdlQXJncyA9IFtdO1xuICBjb25zdCBydW50aW1lRGlyZWN0aXZlcyA9IFtdO1xuICBjb25zdCBoYXNDaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aCA+IDA7XG4gIGxldCBzaG91bGRVc2VCbG9jayA9IGZhbHNlO1xuICBsZXQgcGF0Y2hGbGFnID0gMDtcbiAgbGV0IGhhc1JlZiA9IGZhbHNlO1xuICBsZXQgaGFzQ2xhc3NCaW5kaW5nID0gZmFsc2U7XG4gIGxldCBoYXNTdHlsZUJpbmRpbmcgPSBmYWxzZTtcbiAgbGV0IGhhc0h5ZHJhdGlvbkV2ZW50QmluZGluZyA9IGZhbHNlO1xuICBsZXQgaGFzRHluYW1pY0tleXMgPSBmYWxzZTtcbiAgbGV0IGhhc1Zub2RlSG9vayA9IGZhbHNlO1xuICBjb25zdCBkeW5hbWljUHJvcE5hbWVzID0gW107XG4gIGNvbnN0IHB1c2hNZXJnZUFyZyA9IChhcmcpID0+IHtcbiAgICBpZiAocHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgIG1lcmdlQXJncy5wdXNoKFxuICAgICAgICBjcmVhdGVPYmplY3RFeHByZXNzaW9uKGRlZHVwZVByb3BlcnRpZXMocHJvcGVydGllcyksIGVsZW1lbnRMb2MpXG4gICAgICApO1xuICAgICAgcHJvcGVydGllcyA9IFtdO1xuICAgIH1cbiAgICBpZiAoYXJnKSBtZXJnZUFyZ3MucHVzaChhcmcpO1xuICB9O1xuICBjb25zdCBwdXNoUmVmVkZvck1hcmtlciA9ICgpID0+IHtcbiAgICBpZiAoY29udGV4dC5zY29wZXMudkZvciA+IDApIHtcbiAgICAgIHByb3BlcnRpZXMucHVzaChcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoXG4gICAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihcInJlZl9mb3JcIiwgdHJ1ZSksXG4gICAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihcInRydWVcIilcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGFuYWx5emVQYXRjaEZsYWcgPSAoeyBrZXksIHZhbHVlIH0pID0+IHtcbiAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xuICAgICAgY29uc3QgbmFtZSA9IGtleS5jb250ZW50O1xuICAgICAgY29uc3QgaXNFdmVudEhhbmRsZXIgPSBpc09uKG5hbWUpO1xuICAgICAgaWYgKGlzRXZlbnRIYW5kbGVyICYmICghaXNDb21wb25lbnQgfHwgaXNEeW5hbWljQ29tcG9uZW50KSAmJiAvLyBvbWl0IHRoZSBmbGFnIGZvciBjbGljayBoYW5kbGVycyBiZWNhdXNlIGh5ZHJhdGlvbiBnaXZlcyBjbGlja1xuICAgICAgLy8gZGVkaWNhdGVkIGZhc3QgcGF0aC5cbiAgICAgIG5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvbmNsaWNrXCIgJiYgLy8gb21pdCB2LW1vZGVsIGhhbmRsZXJzXG4gICAgICBuYW1lICE9PSBcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIiAmJiAvLyBvbWl0IG9uVm5vZGVYWFggaG9va3NcbiAgICAgICFpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xuICAgICAgICBoYXNIeWRyYXRpb25FdmVudEJpbmRpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzRXZlbnRIYW5kbGVyICYmIGlzUmVzZXJ2ZWRQcm9wKG5hbWUpKSB7XG4gICAgICAgIGhhc1Zub2RlSG9vayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNFdmVudEhhbmRsZXIgJiYgdmFsdWUudHlwZSA9PT0gMTQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5hcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUudHlwZSA9PT0gMjAgfHwgKHZhbHVlLnR5cGUgPT09IDQgfHwgdmFsdWUudHlwZSA9PT0gOCkgJiYgZ2V0Q29uc3RhbnRUeXBlKHZhbHVlLCBjb250ZXh0KSA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09IFwicmVmXCIpIHtcbiAgICAgICAgaGFzUmVmID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgIGhhc0NsYXNzQmluZGluZyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic3R5bGVcIikge1xuICAgICAgICBoYXNTdHlsZUJpbmRpbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChuYW1lICE9PSBcImtleVwiICYmICFkeW5hbWljUHJvcE5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAgIGR5bmFtaWNQcm9wTmFtZXMucHVzaChuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0NvbXBvbmVudCAmJiAobmFtZSA9PT0gXCJjbGFzc1wiIHx8IG5hbWUgPT09IFwic3R5bGVcIikgJiYgIWR5bmFtaWNQcm9wTmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgZHluYW1pY1Byb3BOYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoYXNEeW5hbWljS2V5cyA9IHRydWU7XG4gICAgfVxuICB9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgIGlmIChwcm9wLnR5cGUgPT09IDYpIHtcbiAgICAgIGNvbnN0IHsgbG9jLCBuYW1lLCBuYW1lTG9jLCB2YWx1ZSB9ID0gcHJvcDtcbiAgICAgIGxldCBpc1N0YXRpYyA9IHRydWU7XG4gICAgICBpZiAobmFtZSA9PT0gXCJyZWZcIikge1xuICAgICAgICBoYXNSZWYgPSB0cnVlO1xuICAgICAgICBwdXNoUmVmVkZvck1hcmtlcigpO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgPT09IFwiaXNcIiAmJiAoaXNDb21wb25lbnRUYWcodGFnKSB8fCB2YWx1ZSAmJiB2YWx1ZS5jb250ZW50LnN0YXJ0c1dpdGgoXCJ2dWU6XCIpIHx8IGlzQ29tcGF0RW5hYmxlZChcbiAgICAgICAgXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcHJvcGVydGllcy5wdXNoKFxuICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShcbiAgICAgICAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKG5hbWUsIHRydWUsIG5hbWVMb2MpLFxuICAgICAgICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oXG4gICAgICAgICAgICB2YWx1ZSA/IHZhbHVlLmNvbnRlbnQgOiBcIlwiLFxuICAgICAgICAgICAgaXNTdGF0aWMsXG4gICAgICAgICAgICB2YWx1ZSA/IHZhbHVlLmxvYyA6IGxvY1xuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBuYW1lLCBhcmcsIGV4cCwgbG9jLCBtb2RpZmllcnMgfSA9IHByb3A7XG4gICAgICBjb25zdCBpc1ZCaW5kID0gbmFtZSA9PT0gXCJiaW5kXCI7XG4gICAgICBjb25zdCBpc1ZPbiA9IG5hbWUgPT09IFwib25cIjtcbiAgICAgIGlmIChuYW1lID09PSBcInNsb3RcIikge1xuICAgICAgICBpZiAoIWlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgY29udGV4dC5vbkVycm9yKFxuICAgICAgICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcig0MCwgbG9jKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobmFtZSA9PT0gXCJvbmNlXCIgfHwgbmFtZSA9PT0gXCJtZW1vXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobmFtZSA9PT0gXCJpc1wiIHx8IGlzVkJpbmQgJiYgaXNTdGF0aWNBcmdPZihhcmcsIFwiaXNcIikgJiYgKGlzQ29tcG9uZW50VGFnKHRhZykgfHwgaXNDb21wYXRFbmFibGVkKFxuICAgICAgICBcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIixcbiAgICAgICAgY29udGV4dFxuICAgICAgKSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNWT24gJiYgc3NyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICAvLyAjOTM4OiBlbGVtZW50cyB3aXRoIGR5bmFtaWMga2V5cyBzaG91bGQgYmUgZm9yY2VkIGludG8gYmxvY2tzXG4gICAgICAgIGlzVkJpbmQgJiYgaXNTdGF0aWNBcmdPZihhcmcsIFwia2V5XCIpIHx8IC8vIGlubGluZSBiZWZvcmUtdXBkYXRlIGhvb2tzIG5lZWQgdG8gZm9yY2UgYmxvY2sgc28gdGhhdCBpdCBpcyBpbnZva2VkXG4gICAgICAgIC8vIGJlZm9yZSBjaGlsZHJlblxuICAgICAgICBpc1ZPbiAmJiBoYXNDaGlsZHJlbiAmJiBpc1N0YXRpY0FyZ09mKGFyZywgXCJ2dWU6YmVmb3JlLXVwZGF0ZVwiKVxuICAgICAgKSB7XG4gICAgICAgIHNob3VsZFVzZUJsb2NrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1ZCaW5kICYmIGlzU3RhdGljQXJnT2YoYXJnLCBcInJlZlwiKSkge1xuICAgICAgICBwdXNoUmVmVkZvck1hcmtlcigpO1xuICAgICAgfVxuICAgICAgaWYgKCFhcmcgJiYgKGlzVkJpbmQgfHwgaXNWT24pKSB7XG4gICAgICAgIGhhc0R5bmFtaWNLZXlzID0gdHJ1ZTtcbiAgICAgICAgaWYgKGV4cCkge1xuICAgICAgICAgIGlmIChpc1ZCaW5kKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHB1c2hNZXJnZUFyZygpO1xuICAgICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc092ZXJyaWRhYmxlS2V5cyA9IG1lcmdlQXJncy5zb21lKChhcmcyKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoYXJnMi50eXBlID09PSAxNSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnMi5wcm9wZXJ0aWVzLnNvbWUoKHsga2V5IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnR5cGUgIT09IDQgfHwgIWtleS5pc1N0YXRpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkuY29udGVudCAhPT0gXCJjbGFzc1wiICYmIGtleS5jb250ZW50ICE9PSBcInN0eWxlXCIgJiYgIWlzT24oa2V5LmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChoYXNPdmVycmlkYWJsZUtleXMpIHtcbiAgICAgICAgICAgICAgICAgIGNoZWNrQ29tcGF0RW5hYmxlZChcbiAgICAgICAgICAgICAgICAgICAgXCJDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGxvY1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0RW5hYmxlZChcbiAgICAgICAgICAgICAgICBcIkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVJcIixcbiAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZUFyZ3MudW5zaGlmdChleHApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwdXNoUmVmVkZvck1hcmtlcigpO1xuICAgICAgICAgICAgcHVzaE1lcmdlQXJnKCk7XG4gICAgICAgICAgICBtZXJnZUFyZ3MucHVzaChleHApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdXNoTWVyZ2VBcmcoe1xuICAgICAgICAgICAgICB0eXBlOiAxNCxcbiAgICAgICAgICAgICAgbG9jLFxuICAgICAgICAgICAgICBjYWxsZWU6IGNvbnRleHQuaGVscGVyKFRPX0hBTkRMRVJTKSxcbiAgICAgICAgICAgICAgYXJndW1lbnRzOiBpc0NvbXBvbmVudCA/IFtleHBdIDogW2V4cCwgYHRydWVgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgICAgICAgIGNyZWF0ZUNvbXBpbGVyRXJyb3IoXG4gICAgICAgICAgICAgIGlzVkJpbmQgPyAzNCA6IDM1LFxuICAgICAgICAgICAgICBsb2NcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzVkJpbmQgJiYgbW9kaWZpZXJzLnNvbWUoKG1vZCkgPT4gbW9kLmNvbnRlbnQgPT09IFwicHJvcFwiKSkge1xuICAgICAgICBwYXRjaEZsYWcgfD0gMzI7XG4gICAgICB9XG4gICAgICBjb25zdCBkaXJlY3RpdmVUcmFuc2Zvcm0gPSBjb250ZXh0LmRpcmVjdGl2ZVRyYW5zZm9ybXNbbmFtZV07XG4gICAgICBpZiAoZGlyZWN0aXZlVHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHM6IHByb3BzMiwgbmVlZFJ1bnRpbWUgfSA9IGRpcmVjdGl2ZVRyYW5zZm9ybShwcm9wLCBub2RlLCBjb250ZXh0KTtcbiAgICAgICAgIXNzciAmJiBwcm9wczIuZm9yRWFjaChhbmFseXplUGF0Y2hGbGFnKTtcbiAgICAgICAgaWYgKGlzVk9uICYmIGFyZyAmJiAhaXNTdGF0aWNFeHAoYXJnKSkge1xuICAgICAgICAgIHB1c2hNZXJnZUFyZyhjcmVhdGVPYmplY3RFeHByZXNzaW9uKHByb3BzMiwgZWxlbWVudExvYykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BlcnRpZXMucHVzaCguLi5wcm9wczIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgICAgIHJ1bnRpbWVEaXJlY3RpdmVzLnB1c2gocHJvcCk7XG4gICAgICAgICAgaWYgKGlzU3ltYm9sKG5lZWRSdW50aW1lKSkge1xuICAgICAgICAgICAgZGlyZWN0aXZlSW1wb3J0TWFwLnNldChwcm9wLCBuZWVkUnVudGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc0J1aWx0SW5EaXJlY3RpdmUobmFtZSkpIHtcbiAgICAgICAgcnVudGltZURpcmVjdGl2ZXMucHVzaChwcm9wKTtcbiAgICAgICAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgICAgICAgc2hvdWxkVXNlQmxvY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBwcm9wc0V4cHJlc3Npb24gPSB2b2lkIDA7XG4gIGlmIChtZXJnZUFyZ3MubGVuZ3RoKSB7XG4gICAgcHVzaE1lcmdlQXJnKCk7XG4gICAgaWYgKG1lcmdlQXJncy5sZW5ndGggPiAxKSB7XG4gICAgICBwcm9wc0V4cHJlc3Npb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihcbiAgICAgICAgY29udGV4dC5oZWxwZXIoTUVSR0VfUFJPUFMpLFxuICAgICAgICBtZXJnZUFyZ3MsXG4gICAgICAgIGVsZW1lbnRMb2NcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzRXhwcmVzc2lvbiA9IG1lcmdlQXJnc1swXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICBwcm9wc0V4cHJlc3Npb24gPSBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFxuICAgICAgZGVkdXBlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSxcbiAgICAgIGVsZW1lbnRMb2NcbiAgICApO1xuICB9XG4gIGlmIChoYXNEeW5hbWljS2V5cykge1xuICAgIHBhdGNoRmxhZyB8PSAxNjtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaGFzQ2xhc3NCaW5kaW5nICYmICFpc0NvbXBvbmVudCkge1xuICAgICAgcGF0Y2hGbGFnIHw9IDI7XG4gICAgfVxuICAgIGlmIChoYXNTdHlsZUJpbmRpbmcgJiYgIWlzQ29tcG9uZW50KSB7XG4gICAgICBwYXRjaEZsYWcgfD0gNDtcbiAgICB9XG4gICAgaWYgKGR5bmFtaWNQcm9wTmFtZXMubGVuZ3RoKSB7XG4gICAgICBwYXRjaEZsYWcgfD0gODtcbiAgICB9XG4gICAgaWYgKGhhc0h5ZHJhdGlvbkV2ZW50QmluZGluZykge1xuICAgICAgcGF0Y2hGbGFnIHw9IDMyO1xuICAgIH1cbiAgfVxuICBpZiAoIXNob3VsZFVzZUJsb2NrICYmIChwYXRjaEZsYWcgPT09IDAgfHwgcGF0Y2hGbGFnID09PSAzMikgJiYgKGhhc1JlZiB8fCBoYXNWbm9kZUhvb2sgfHwgcnVudGltZURpcmVjdGl2ZXMubGVuZ3RoID4gMCkpIHtcbiAgICBwYXRjaEZsYWcgfD0gNTEyO1xuICB9XG4gIGlmICghY29udGV4dC5pblNTUiAmJiBwcm9wc0V4cHJlc3Npb24pIHtcbiAgICBzd2l0Y2ggKHByb3BzRXhwcmVzc2lvbi50eXBlKSB7XG4gICAgICBjYXNlIDE1OlxuICAgICAgICBsZXQgY2xhc3NLZXlJbmRleCA9IC0xO1xuICAgICAgICBsZXQgc3R5bGVLZXlJbmRleCA9IC0xO1xuICAgICAgICBsZXQgaGFzRHluYW1pY0tleSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzRXhwcmVzc2lvbi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXNbaV0ua2V5O1xuICAgICAgICAgIGlmIChpc1N0YXRpY0V4cChrZXkpKSB7XG4gICAgICAgICAgICBpZiAoa2V5LmNvbnRlbnQgPT09IFwiY2xhc3NcIikge1xuICAgICAgICAgICAgICBjbGFzc0tleUluZGV4ID0gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5LmNvbnRlbnQgPT09IFwic3R5bGVcIikge1xuICAgICAgICAgICAgICBzdHlsZUtleUluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFrZXkuaXNIYW5kbGVyS2V5KSB7XG4gICAgICAgICAgICBoYXNEeW5hbWljS2V5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xhc3NQcm9wID0gcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXNbY2xhc3NLZXlJbmRleF07XG4gICAgICAgIGNvbnN0IHN0eWxlUHJvcCA9IHByb3BzRXhwcmVzc2lvbi5wcm9wZXJ0aWVzW3N0eWxlS2V5SW5kZXhdO1xuICAgICAgICBpZiAoIWhhc0R5bmFtaWNLZXkpIHtcbiAgICAgICAgICBpZiAoY2xhc3NQcm9wICYmICFpc1N0YXRpY0V4cChjbGFzc1Byb3AudmFsdWUpKSB7XG4gICAgICAgICAgICBjbGFzc1Byb3AudmFsdWUgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoTk9STUFMSVpFX0NMQVNTKSxcbiAgICAgICAgICAgICAgW2NsYXNzUHJvcC52YWx1ZV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHlsZVByb3AgJiYgLy8gdGhlIHN0YXRpYyBzdHlsZSBpcyBjb21waWxlZCBpbnRvIGFuIG9iamVjdCxcbiAgICAgICAgICAvLyBzbyB1c2UgYGhhc1N0eWxlQmluZGluZ2AgdG8gZW5zdXJlIHRoYXQgaXQgaXMgYSBkeW5hbWljIHN0eWxlIGJpbmRpbmdcbiAgICAgICAgICAoaGFzU3R5bGVCaW5kaW5nIHx8IHN0eWxlUHJvcC52YWx1ZS50eXBlID09PSA0ICYmIHN0eWxlUHJvcC52YWx1ZS5jb250ZW50LnRyaW0oKVswXSA9PT0gYFtgIHx8IC8vIHYtYmluZDpzdHlsZSBhbmQgc3R5bGUgYm90aCBleGlzdCxcbiAgICAgICAgICAvLyB2LWJpbmQ6c3R5bGUgd2l0aCBzdGF0aWMgbGl0ZXJhbCBvYmplY3RcbiAgICAgICAgICBzdHlsZVByb3AudmFsdWUudHlwZSA9PT0gMTcpKSB7XG4gICAgICAgICAgICBzdHlsZVByb3AudmFsdWUgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoTk9STUFMSVpFX1NUWUxFKSxcbiAgICAgICAgICAgICAgW3N0eWxlUHJvcC52YWx1ZV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoTk9STUFMSVpFX1BST1BTKSxcbiAgICAgICAgICAgIFtwcm9wc0V4cHJlc3Npb25dXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oXG4gICAgICAgICAgY29udGV4dC5oZWxwZXIoTk9STUFMSVpFX1BST1BTKSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihHVUFSRF9SRUFDVElWRV9QUk9QUyksIFtcbiAgICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIF1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcHJvcHM6IHByb3BzRXhwcmVzc2lvbixcbiAgICBkaXJlY3RpdmVzOiBydW50aW1lRGlyZWN0aXZlcyxcbiAgICBwYXRjaEZsYWcsXG4gICAgZHluYW1pY1Byb3BOYW1lcyxcbiAgICBzaG91bGRVc2VCbG9ja1xuICB9O1xufVxuZnVuY3Rpb24gZGVkdXBlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IGtub3duUHJvcHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBkZWR1cGVkID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByb3AgPSBwcm9wZXJ0aWVzW2ldO1xuICAgIGlmIChwcm9wLmtleS50eXBlID09PSA4IHx8ICFwcm9wLmtleS5pc1N0YXRpYykge1xuICAgICAgZGVkdXBlZC5wdXNoKHByb3ApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBwcm9wLmtleS5jb250ZW50O1xuICAgIGNvbnN0IGV4aXN0aW5nID0ga25vd25Qcm9wcy5nZXQobmFtZSk7XG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJzdHlsZVwiIHx8IG5hbWUgPT09IFwiY2xhc3NcIiB8fCBpc09uKG5hbWUpKSB7XG4gICAgICAgIG1lcmdlQXNBcnJheShleGlzdGluZywgcHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtub3duUHJvcHMuc2V0KG5hbWUsIHByb3ApO1xuICAgICAgZGVkdXBlZC5wdXNoKHByb3ApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVkdXBlZDtcbn1cbmZ1bmN0aW9uIG1lcmdlQXNBcnJheShleGlzdGluZywgaW5jb21pbmcpIHtcbiAgaWYgKGV4aXN0aW5nLnZhbHVlLnR5cGUgPT09IDE3KSB7XG4gICAgZXhpc3RpbmcudmFsdWUuZWxlbWVudHMucHVzaChpbmNvbWluZy52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZXhpc3RpbmcudmFsdWUgPSBjcmVhdGVBcnJheUV4cHJlc3Npb24oXG4gICAgICBbZXhpc3RpbmcudmFsdWUsIGluY29taW5nLnZhbHVlXSxcbiAgICAgIGV4aXN0aW5nLmxvY1xuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRGlyZWN0aXZlQXJncyhkaXIsIGNvbnRleHQpIHtcbiAgY29uc3QgZGlyQXJncyA9IFtdO1xuICBjb25zdCBydW50aW1lID0gZGlyZWN0aXZlSW1wb3J0TWFwLmdldChkaXIpO1xuICBpZiAocnVudGltZSkge1xuICAgIGRpckFyZ3MucHVzaChjb250ZXh0LmhlbHBlclN0cmluZyhydW50aW1lKSk7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgY29udGV4dC5oZWxwZXIoUkVTT0xWRV9ESVJFQ1RJVkUpO1xuICAgICAgY29udGV4dC5kaXJlY3RpdmVzLmFkZChkaXIubmFtZSk7XG4gICAgICBkaXJBcmdzLnB1c2godG9WYWxpZEFzc2V0SWQoZGlyLm5hbWUsIGBkaXJlY3RpdmVgKSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHsgbG9jIH0gPSBkaXI7XG4gIGlmIChkaXIuZXhwKSBkaXJBcmdzLnB1c2goZGlyLmV4cCk7XG4gIGlmIChkaXIuYXJnKSB7XG4gICAgaWYgKCFkaXIuZXhwKSB7XG4gICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xuICAgIH1cbiAgICBkaXJBcmdzLnB1c2goZGlyLmFyZyk7XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMpLmxlbmd0aCkge1xuICAgIGlmICghZGlyLmFyZykge1xuICAgICAgaWYgKCFkaXIuZXhwKSB7XG4gICAgICAgIGRpckFyZ3MucHVzaChgdm9pZCAwYCk7XG4gICAgICB9XG4gICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xuICAgIH1cbiAgICBjb25zdCB0cnVlRXhwcmVzc2lvbiA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHRydWVgLCBmYWxzZSwgbG9jKTtcbiAgICBkaXJBcmdzLnB1c2goXG4gICAgICBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFxuICAgICAgICBkaXIubW9kaWZpZXJzLm1hcChcbiAgICAgICAgICAobW9kaWZpZXIpID0+IGNyZWF0ZU9iamVjdFByb3BlcnR5KG1vZGlmaWVyLCB0cnVlRXhwcmVzc2lvbilcbiAgICAgICAgKSxcbiAgICAgICAgbG9jXG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQXJyYXlFeHByZXNzaW9uKGRpckFyZ3MsIGRpci5sb2MpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5RHluYW1pY1Byb3BOYW1lcyhwcm9wcykge1xuICBsZXQgcHJvcHNOYW1lc1N0cmluZyA9IGBbYDtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBwcm9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwcm9wc05hbWVzU3RyaW5nICs9IEpTT04uc3RyaW5naWZ5KHByb3BzW2ldKTtcbiAgICBpZiAoaSA8IGwgLSAxKSBwcm9wc05hbWVzU3RyaW5nICs9IFwiLCBcIjtcbiAgfVxuICByZXR1cm4gcHJvcHNOYW1lc1N0cmluZyArIGBdYDtcbn1cbmZ1bmN0aW9uIGlzQ29tcG9uZW50VGFnKHRhZykge1xuICByZXR1cm4gdGFnID09PSBcImNvbXBvbmVudFwiIHx8IHRhZyA9PT0gXCJDb21wb25lbnRcIjtcbn1cblxuY29uc3QgdHJhbnNmb3JtU2xvdE91dGxldCA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gIGlmIChpc1Nsb3RPdXRsZXQobm9kZSkpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBsb2MgfSA9IG5vZGU7XG4gICAgY29uc3QgeyBzbG90TmFtZSwgc2xvdFByb3BzIH0gPSBwcm9jZXNzU2xvdE91dGxldChub2RlLCBjb250ZXh0KTtcbiAgICBjb25zdCBzbG90QXJncyA9IFtcbiAgICAgIGNvbnRleHQucHJlZml4SWRlbnRpZmllcnMgPyBgX2N0eC4kc2xvdHNgIDogYCRzbG90c2AsXG4gICAgICBzbG90TmFtZSxcbiAgICAgIFwie31cIixcbiAgICAgIFwidW5kZWZpbmVkXCIsXG4gICAgICBcInRydWVcIlxuICAgIF07XG4gICAgbGV0IGV4cGVjdGVkTGVuID0gMjtcbiAgICBpZiAoc2xvdFByb3BzKSB7XG4gICAgICBzbG90QXJnc1syXSA9IHNsb3RQcm9wcztcbiAgICAgIGV4cGVjdGVkTGVuID0gMztcbiAgICB9XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgc2xvdEFyZ3NbM10gPSBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oW10sIGNoaWxkcmVuLCBmYWxzZSwgZmFsc2UsIGxvYyk7XG4gICAgICBleHBlY3RlZExlbiA9IDQ7XG4gICAgfVxuICAgIGlmIChjb250ZXh0LnNjb3BlSWQgJiYgIWNvbnRleHQuc2xvdHRlZCkge1xuICAgICAgZXhwZWN0ZWRMZW4gPSA1O1xuICAgIH1cbiAgICBzbG90QXJncy5zcGxpY2UoZXhwZWN0ZWRMZW4pO1xuICAgIG5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihcbiAgICAgIGNvbnRleHQuaGVscGVyKFJFTkRFUl9TTE9UKSxcbiAgICAgIHNsb3RBcmdzLFxuICAgICAgbG9jXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHByb2Nlc3NTbG90T3V0bGV0KG5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IHNsb3ROYW1lID0gYFwiZGVmYXVsdFwiYDtcbiAgbGV0IHNsb3RQcm9wcyA9IHZvaWQgMDtcbiAgY29uc3Qgbm9uTmFtZVByb3BzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xuICAgIGlmIChwLnR5cGUgPT09IDYpIHtcbiAgICAgIGlmIChwLnZhbHVlKSB7XG4gICAgICAgIGlmIChwLm5hbWUgPT09IFwibmFtZVwiKSB7XG4gICAgICAgICAgc2xvdE5hbWUgPSBKU09OLnN0cmluZ2lmeShwLnZhbHVlLmNvbnRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHAubmFtZSA9IGNhbWVsaXplKHAubmFtZSk7XG4gICAgICAgICAgbm9uTmFtZVByb3BzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHAubmFtZSA9PT0gXCJiaW5kXCIgJiYgaXNTdGF0aWNBcmdPZihwLmFyZywgXCJuYW1lXCIpKSB7XG4gICAgICAgIGlmIChwLmV4cCkge1xuICAgICAgICAgIHNsb3ROYW1lID0gcC5leHA7XG4gICAgICAgIH0gZWxzZSBpZiAocC5hcmcgJiYgcC5hcmcudHlwZSA9PT0gNCkge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBjYW1lbGl6ZShwLmFyZy5jb250ZW50KTtcbiAgICAgICAgICBzbG90TmFtZSA9IHAuZXhwID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihuYW1lLCBmYWxzZSwgcC5hcmcubG9jKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHAubmFtZSA9PT0gXCJiaW5kXCIgJiYgcC5hcmcgJiYgaXNTdGF0aWNFeHAocC5hcmcpKSB7XG4gICAgICAgICAgcC5hcmcuY29udGVudCA9IGNhbWVsaXplKHAuYXJnLmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIG5vbk5hbWVQcm9wcy5wdXNoKHApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobm9uTmFtZVByb3BzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCB7IHByb3BzLCBkaXJlY3RpdmVzIH0gPSBidWlsZFByb3BzKFxuICAgICAgbm9kZSxcbiAgICAgIGNvbnRleHQsXG4gICAgICBub25OYW1lUHJvcHMsXG4gICAgICBmYWxzZSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICBzbG90UHJvcHMgPSBwcm9wcztcbiAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgICAgY3JlYXRlQ29tcGlsZXJFcnJvcihcbiAgICAgICAgICAzNixcbiAgICAgICAgICBkaXJlY3RpdmVzWzBdLmxvY1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNsb3ROYW1lLFxuICAgIHNsb3RQcm9wc1xuICB9O1xufVxuXG5jb25zdCB0cmFuc2Zvcm1PbiA9IChkaXIsIG5vZGUsIGNvbnRleHQsIGF1Z21lbnRvcikgPT4ge1xuICBjb25zdCB7IGxvYywgbW9kaWZpZXJzLCBhcmcgfSA9IGRpcjtcbiAgaWYgKCFkaXIuZXhwICYmICFtb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzUsIGxvYykpO1xuICB9XG4gIGxldCBldmVudE5hbWU7XG4gIGlmIChhcmcudHlwZSA9PT0gNCkge1xuICAgIGlmIChhcmcuaXNTdGF0aWMpIHtcbiAgICAgIGxldCByYXdOYW1lID0gYXJnLmNvbnRlbnQ7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByYXdOYW1lLnN0YXJ0c1dpdGgoXCJ2bm9kZVwiKSkge1xuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig1MiwgYXJnLmxvYykpO1xuICAgICAgfVxuICAgICAgaWYgKHJhd05hbWUuc3RhcnRzV2l0aChcInZ1ZTpcIikpIHtcbiAgICAgICAgcmF3TmFtZSA9IGB2bm9kZS0ke3Jhd05hbWUuc2xpY2UoNCl9YDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV2ZW50U3RyaW5nID0gbm9kZS50YWdUeXBlICE9PSAwIHx8IHJhd05hbWUuc3RhcnRzV2l0aChcInZub2RlXCIpIHx8ICEvW0EtWl0vLnRlc3QocmF3TmFtZSkgPyAoXG4gICAgICAgIC8vIGZvciBub24tZWxlbWVudCBhbmQgdm5vZGUgbGlmZWN5Y2xlIGV2ZW50IGxpc3RlbmVycywgYXV0byBjb252ZXJ0XG4gICAgICAgIC8vIGl0IHRvIGNhbWVsQ2FzZS4gU2VlIGlzc3VlICMyMjQ5XG4gICAgICAgIHRvSGFuZGxlcktleShjYW1lbGl6ZShyYXdOYW1lKSlcbiAgICAgICkgOiAoXG4gICAgICAgIC8vIHByZXNlcnZlIGNhc2UgZm9yIHBsYWluIGVsZW1lbnQgbGlzdGVuZXJzIHRoYXQgaGF2ZSB1cHBlcmNhc2VcbiAgICAgICAgLy8gbGV0dGVycywgYXMgdGhlc2UgbWF5IGJlIGN1c3RvbSBlbGVtZW50cycgY3VzdG9tIGV2ZW50c1xuICAgICAgICBgb246JHtyYXdOYW1lfWBcbiAgICAgICk7XG4gICAgICBldmVudE5hbWUgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGV2ZW50U3RyaW5nLCB0cnVlLCBhcmcubG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnROYW1lID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcbiAgICAgICAgYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoVE9fSEFORExFUl9LRVkpfShgLFxuICAgICAgICBhcmcsXG4gICAgICAgIGApYFxuICAgICAgXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGV2ZW50TmFtZSA9IGFyZztcbiAgICBldmVudE5hbWUuY2hpbGRyZW4udW5zaGlmdChgJHtjb250ZXh0LmhlbHBlclN0cmluZyhUT19IQU5ETEVSX0tFWSl9KGApO1xuICAgIGV2ZW50TmFtZS5jaGlsZHJlbi5wdXNoKGApYCk7XG4gIH1cbiAgbGV0IGV4cCA9IGRpci5leHA7XG4gIGlmIChleHAgJiYgIWV4cC5jb250ZW50LnRyaW0oKSkge1xuICAgIGV4cCA9IHZvaWQgMDtcbiAgfVxuICBsZXQgc2hvdWxkQ2FjaGUgPSBjb250ZXh0LmNhY2hlSGFuZGxlcnMgJiYgIWV4cCAmJiAhY29udGV4dC5pblZPbmNlO1xuICBpZiAoZXhwKSB7XG4gICAgY29uc3QgaXNNZW1iZXJFeHAgPSBpc01lbWJlckV4cHJlc3Npb24oZXhwKTtcbiAgICBjb25zdCBpc0lubGluZVN0YXRlbWVudCA9ICEoaXNNZW1iZXJFeHAgfHwgaXNGbkV4cHJlc3Npb24oZXhwKSk7XG4gICAgY29uc3QgaGFzTXVsdGlwbGVTdGF0ZW1lbnRzID0gZXhwLmNvbnRlbnQuaW5jbHVkZXMoYDtgKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB0cnVlKSB7XG4gICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKFxuICAgICAgICBleHAsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBoYXNNdWx0aXBsZVN0YXRlbWVudHNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc0lubGluZVN0YXRlbWVudCB8fCBzaG91bGRDYWNoZSAmJiBpc01lbWJlckV4cCkge1xuICAgICAgZXhwID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcbiAgICAgICAgYCR7aXNJbmxpbmVTdGF0ZW1lbnQgPyBgJGV2ZW50YCA6IGAke2BgfSguLi5hcmdzKWB9ID0+ICR7aGFzTXVsdGlwbGVTdGF0ZW1lbnRzID8gYHtgIDogYChgfWAsXG4gICAgICAgIGV4cCxcbiAgICAgICAgaGFzTXVsdGlwbGVTdGF0ZW1lbnRzID8gYH1gIDogYClgXG4gICAgICBdKTtcbiAgICB9XG4gIH1cbiAgbGV0IHJldCA9IHtcbiAgICBwcm9wczogW1xuICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoXG4gICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgZXhwIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYCgpID0+IHt9YCwgZmFsc2UsIGxvYylcbiAgICAgIClcbiAgICBdXG4gIH07XG4gIGlmIChhdWdtZW50b3IpIHtcbiAgICByZXQgPSBhdWdtZW50b3IocmV0KTtcbiAgfVxuICBpZiAoc2hvdWxkQ2FjaGUpIHtcbiAgICByZXQucHJvcHNbMF0udmFsdWUgPSBjb250ZXh0LmNhY2hlKHJldC5wcm9wc1swXS52YWx1ZSk7XG4gIH1cbiAgcmV0LnByb3BzLmZvckVhY2goKHApID0+IHAua2V5LmlzSGFuZGxlcktleSA9IHRydWUpO1xuICByZXR1cm4gcmV0O1xufTtcblxuY29uc3QgdHJhbnNmb3JtQmluZCA9IChkaXIsIF9ub2RlLCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHsgbW9kaWZpZXJzLCBsb2MgfSA9IGRpcjtcbiAgY29uc3QgYXJnID0gZGlyLmFyZztcbiAgbGV0IHsgZXhwIH0gPSBkaXI7XG4gIGlmIChleHAgJiYgZXhwLnR5cGUgPT09IDQgJiYgIWV4cC5jb250ZW50LnRyaW0oKSkge1xuICAgIHtcbiAgICAgIGV4cCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKGFyZy50eXBlICE9PSA0KSB7XG4gICAgYXJnLmNoaWxkcmVuLnVuc2hpZnQoYChgKTtcbiAgICBhcmcuY2hpbGRyZW4ucHVzaChgKSB8fCBcIlwiYCk7XG4gIH0gZWxzZSBpZiAoIWFyZy5pc1N0YXRpYykge1xuICAgIGFyZy5jb250ZW50ID0gYXJnLmNvbnRlbnQgPyBgJHthcmcuY29udGVudH0gfHwgXCJcImAgOiBgXCJcImA7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5zb21lKChtb2QpID0+IG1vZC5jb250ZW50ID09PSBcImNhbWVsXCIpKSB7XG4gICAgaWYgKGFyZy50eXBlID09PSA0KSB7XG4gICAgICBpZiAoYXJnLmlzU3RhdGljKSB7XG4gICAgICAgIGFyZy5jb250ZW50ID0gY2FtZWxpemUoYXJnLmNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJnLmNvbnRlbnQgPSBgJHtjb250ZXh0LmhlbHBlclN0cmluZyhDQU1FTElaRSl9KCR7YXJnLmNvbnRlbnR9KWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZy5jaGlsZHJlbi51bnNoaWZ0KGAke2NvbnRleHQuaGVscGVyU3RyaW5nKENBTUVMSVpFKX0oYCk7XG4gICAgICBhcmcuY2hpbGRyZW4ucHVzaChgKWApO1xuICAgIH1cbiAgfVxuICBpZiAoIWNvbnRleHQuaW5TU1IpIHtcbiAgICBpZiAobW9kaWZpZXJzLnNvbWUoKG1vZCkgPT4gbW9kLmNvbnRlbnQgPT09IFwicHJvcFwiKSkge1xuICAgICAgaW5qZWN0UHJlZml4KGFyZywgXCIuXCIpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLnNvbWUoKG1vZCkgPT4gbW9kLmNvbnRlbnQgPT09IFwiYXR0clwiKSkge1xuICAgICAgaW5qZWN0UHJlZml4KGFyZywgXCJeXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHByb3BzOiBbY3JlYXRlT2JqZWN0UHJvcGVydHkoYXJnLCBleHApXVxuICB9O1xufTtcbmNvbnN0IGluamVjdFByZWZpeCA9IChhcmcsIHByZWZpeCkgPT4ge1xuICBpZiAoYXJnLnR5cGUgPT09IDQpIHtcbiAgICBpZiAoYXJnLmlzU3RhdGljKSB7XG4gICAgICBhcmcuY29udGVudCA9IHByZWZpeCArIGFyZy5jb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmcuY29udGVudCA9IGBcXGAke3ByZWZpeH1cXCR7JHthcmcuY29udGVudH19XFxgYDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXJnLmNoaWxkcmVuLnVuc2hpZnQoYCcke3ByZWZpeH0nICsgKGApO1xuICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApYCk7XG4gIH1cbn07XG5cbmNvbnN0IHRyYW5zZm9ybVRleHQgPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICBpZiAobm9kZS50eXBlID09PSAwIHx8IG5vZGUudHlwZSA9PT0gMSB8fCBub2RlLnR5cGUgPT09IDExIHx8IG5vZGUudHlwZSA9PT0gMTApIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgbGV0IGN1cnJlbnRDb250YWluZXIgPSB2b2lkIDA7XG4gICAgICBsZXQgaGFzVGV4dCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoaXNUZXh0JDEoY2hpbGQpKSB7XG4gICAgICAgICAgaGFzVGV4dCA9IHRydWU7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBjaGlsZHJlbltqXTtcbiAgICAgICAgICAgIGlmIChpc1RleHQkMShuZXh0KSkge1xuICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gY2hpbGRyZW5baV0gPSBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oXG4gICAgICAgICAgICAgICAgICBbY2hpbGRdLFxuICAgICAgICAgICAgICAgICAgY2hpbGQubG9jXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLmNoaWxkcmVuLnB1c2goYCArIGAsIG5leHQpO1xuICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFoYXNUZXh0IHx8IC8vIGlmIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IHdpdGggYSBzaW5nbGUgdGV4dCBjaGlsZCwgbGVhdmUgaXRcbiAgICAgIC8vIGFzLWlzIHNpbmNlIHRoZSBydW50aW1lIGhhcyBkZWRpY2F0ZWQgZmFzdCBwYXRoIGZvciB0aGlzIGJ5IGRpcmVjdGx5XG4gICAgICAvLyBzZXR0aW5nIHRleHRDb250ZW50IG9mIHRoZSBlbGVtZW50LlxuICAgICAgLy8gZm9yIGNvbXBvbmVudCByb290IGl0J3MgYWx3YXlzIG5vcm1hbGl6ZWQgYW55d2F5LlxuICAgICAgY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIChub2RlLnR5cGUgPT09IDAgfHwgbm9kZS50eXBlID09PSAxICYmIG5vZGUudGFnVHlwZSA9PT0gMCAmJiAvLyAjMzc1NlxuICAgICAgLy8gY3VzdG9tIGRpcmVjdGl2ZXMgY2FuIHBvdGVudGlhbGx5IGFkZCBET00gZWxlbWVudHMgYXJiaXRyYXJpbHksXG4gICAgICAvLyB3ZSBuZWVkIHRvIGF2b2lkIHNldHRpbmcgdGV4dENvbnRlbnQgb2YgdGhlIGVsZW1lbnQgYXQgcnVudGltZVxuICAgICAgLy8gdG8gYXZvaWQgYWNjaWRlbnRhbGx5IG92ZXJ3cml0aW5nIHRoZSBET00gZWxlbWVudHMgYWRkZWRcbiAgICAgIC8vIGJ5IHRoZSB1c2VyIHRocm91Z2ggY3VzdG9tIGRpcmVjdGl2ZXMuXG4gICAgICAhbm9kZS5wcm9wcy5maW5kKFxuICAgICAgICAocCkgPT4gcC50eXBlID09PSA3ICYmICFjb250ZXh0LmRpcmVjdGl2ZVRyYW5zZm9ybXNbcC5uYW1lXVxuICAgICAgKSAmJiAvLyBpbiBjb21wYXQgbW9kZSwgPHRlbXBsYXRlPiB0YWdzIHdpdGggbm8gc3BlY2lhbCBkaXJlY3RpdmVzXG4gICAgICAvLyB3aWxsIGJlIHJlbmRlcmVkIGFzIGEgZnJhZ21lbnQgc28gaXRzIGNoaWxkcmVuIG11c3QgYmVcbiAgICAgIC8vIGNvbnZlcnRlZCBpbnRvIHZub2Rlcy5cbiAgICAgICEobm9kZS50YWcgPT09IFwidGVtcGxhdGVcIikpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGlzVGV4dCQxKGNoaWxkKSB8fCBjaGlsZC50eXBlID09PSA4KSB7XG4gICAgICAgICAgY29uc3QgY2FsbEFyZ3MgPSBbXTtcbiAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gMiB8fCBjaGlsZC5jb250ZW50ICE9PSBcIiBcIikge1xuICAgICAgICAgICAgY2FsbEFyZ3MucHVzaChjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY29udGV4dC5zc3IgJiYgZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KSA9PT0gMCkge1xuICAgICAgICAgICAgY2FsbEFyZ3MucHVzaChcbiAgICAgICAgICAgICAgMSArICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYCAvKiAke1BhdGNoRmxhZ05hbWVzWzFdfSAqL2AgOiBgYClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoaWxkcmVuW2ldID0ge1xuICAgICAgICAgICAgdHlwZTogMTIsXG4gICAgICAgICAgICBjb250ZW50OiBjaGlsZCxcbiAgICAgICAgICAgIGxvYzogY2hpbGQubG9jLFxuICAgICAgICAgICAgY29kZWdlbk5vZGU6IGNyZWF0ZUNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcihDUkVBVEVfVEVYVCksXG4gICAgICAgICAgICAgIGNhbGxBcmdzXG4gICAgICAgICAgICApXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbmNvbnN0IHNlZW4kMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuY29uc3QgdHJhbnNmb3JtT25jZSA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEgJiYgZmluZERpcihub2RlLCBcIm9uY2VcIiwgdHJ1ZSkpIHtcbiAgICBpZiAoc2VlbiQxLmhhcyhub2RlKSB8fCBjb250ZXh0LmluVk9uY2UgfHwgY29udGV4dC5pblNTUikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWVuJDEuYWRkKG5vZGUpO1xuICAgIGNvbnRleHQuaW5WT25jZSA9IHRydWU7XG4gICAgY29udGV4dC5oZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29udGV4dC5pblZPbmNlID0gZmFsc2U7XG4gICAgICBjb25zdCBjdXIgPSBjb250ZXh0LmN1cnJlbnROb2RlO1xuICAgICAgaWYgKGN1ci5jb2RlZ2VuTm9kZSkge1xuICAgICAgICBjdXIuY29kZWdlbk5vZGUgPSBjb250ZXh0LmNhY2hlKFxuICAgICAgICAgIGN1ci5jb2RlZ2VuTm9kZSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG5jb25zdCB0cmFuc2Zvcm1Nb2RlbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcbiAgY29uc3QgeyBleHAsIGFyZyB9ID0gZGlyO1xuICBpZiAoIWV4cCkge1xuICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgIGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDEsIGRpci5sb2MpXG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlVHJhbnNmb3JtUHJvcHMoKTtcbiAgfVxuICBjb25zdCByYXdFeHAgPSBleHAubG9jLnNvdXJjZS50cmltKCk7XG4gIGNvbnN0IGV4cFN0cmluZyA9IGV4cC50eXBlID09PSA0ID8gZXhwLmNvbnRlbnQgOiByYXdFeHA7XG4gIGNvbnN0IGJpbmRpbmdUeXBlID0gY29udGV4dC5iaW5kaW5nTWV0YWRhdGFbcmF3RXhwXTtcbiAgaWYgKGJpbmRpbmdUeXBlID09PSBcInByb3BzXCIgfHwgYmluZGluZ1R5cGUgPT09IFwicHJvcHMtYWxpYXNlZFwiKSB7XG4gICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDQsIGV4cC5sb2MpKTtcbiAgICByZXR1cm4gY3JlYXRlVHJhbnNmb3JtUHJvcHMoKTtcbiAgfVxuICBpZiAoYmluZGluZ1R5cGUgPT09IFwibGl0ZXJhbC1jb25zdFwiIHx8IGJpbmRpbmdUeXBlID09PSBcInNldHVwLWNvbnN0XCIpIHtcbiAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0NSwgZXhwLmxvYykpO1xuICAgIHJldHVybiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcygpO1xuICB9XG4gIGlmICghZXhwU3RyaW5nLnRyaW0oKSB8fCAhaXNNZW1iZXJFeHByZXNzaW9uKGV4cCkgJiYgdHJ1ZSkge1xuICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgIGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDIsIGV4cC5sb2MpXG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlVHJhbnNmb3JtUHJvcHMoKTtcbiAgfVxuICBjb25zdCBwcm9wTmFtZSA9IGFyZyA/IGFyZyA6IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oXCJtb2RlbFZhbHVlXCIsIHRydWUpO1xuICBjb25zdCBldmVudE5hbWUgPSBhcmcgPyBpc1N0YXRpY0V4cChhcmcpID8gYG9uVXBkYXRlOiR7Y2FtZWxpemUoYXJnLmNvbnRlbnQpfWAgOiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oWydcIm9uVXBkYXRlOlwiICsgJywgYXJnXSkgOiBgb25VcGRhdGU6bW9kZWxWYWx1ZWA7XG4gIGxldCBhc3NpZ25tZW50RXhwO1xuICBjb25zdCBldmVudEFyZyA9IGNvbnRleHQuaXNUUyA/IGAoJGV2ZW50OiBhbnkpYCA6IGAkZXZlbnRgO1xuICB7XG4gICAgYXNzaWdubWVudEV4cCA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXG4gICAgICBgJHtldmVudEFyZ30gPT4gKChgLFxuICAgICAgZXhwLFxuICAgICAgYCkgPSAkZXZlbnQpYFxuICAgIF0pO1xuICB9XG4gIGNvbnN0IHByb3BzID0gW1xuICAgIC8vIG1vZGVsVmFsdWU6IGZvb1xuICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KHByb3BOYW1lLCBkaXIuZXhwKSxcbiAgICAvLyBcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIjogJGV2ZW50ID0+IChmb28gPSAkZXZlbnQpXG4gICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoZXZlbnROYW1lLCBhc3NpZ25tZW50RXhwKVxuICBdO1xuICBpZiAoZGlyLm1vZGlmaWVycy5sZW5ndGggJiYgbm9kZS50YWdUeXBlID09PSAxKSB7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycy5tYXAoKG0pID0+IG0uY29udGVudCkubWFwKChtKSA9PiAoaXNTaW1wbGVJZGVudGlmaWVyKG0pID8gbSA6IEpTT04uc3RyaW5naWZ5KG0pKSArIGA6IHRydWVgKS5qb2luKGAsIGApO1xuICAgIGNvbnN0IG1vZGlmaWVyc0tleSA9IGFyZyA/IGlzU3RhdGljRXhwKGFyZykgPyBgJHthcmcuY29udGVudH1Nb2RpZmllcnNgIDogY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFthcmcsICcgKyBcIk1vZGlmaWVyc1wiJ10pIDogYG1vZGVsTW9kaWZpZXJzYDtcbiAgICBwcm9wcy5wdXNoKFxuICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoXG4gICAgICAgIG1vZGlmaWVyc0tleSxcbiAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihcbiAgICAgICAgICBgeyAke21vZGlmaWVyc30gfWAsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgZGlyLmxvYyxcbiAgICAgICAgICAyXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcyhwcm9wcyk7XG59O1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtUHJvcHMocHJvcHMgPSBbXSkge1xuICByZXR1cm4geyBwcm9wcyB9O1xufVxuXG5jb25zdCB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuY29uc3QgdHJhbnNmb3JtRmlsdGVyID0gKG5vZGUsIGNvbnRleHQpID0+IHtcbiAgaWYgKCFpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9GSUxURVJTXCIsIGNvbnRleHQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDUpIHtcbiAgICByZXdyaXRlRmlsdGVyKG5vZGUuY29udGVudCwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgbm9kZS5wcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBpZiAocHJvcC50eXBlID09PSA3ICYmIHByb3AubmFtZSAhPT0gXCJmb3JcIiAmJiBwcm9wLmV4cCkge1xuICAgICAgICByZXdyaXRlRmlsdGVyKHByb3AuZXhwLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJld3JpdGVGaWx0ZXIobm9kZSwgY29udGV4dCkge1xuICBpZiAobm9kZS50eXBlID09PSA0KSB7XG4gICAgcGFyc2VGaWx0ZXIobm9kZSwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSBcIm9iamVjdFwiKSBjb250aW51ZTtcbiAgICAgIGlmIChjaGlsZC50eXBlID09PSA0KSB7XG4gICAgICAgIHBhcnNlRmlsdGVyKGNoaWxkLCBjb250ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gOCkge1xuICAgICAgICByZXdyaXRlRmlsdGVyKG5vZGUsIGNvbnRleHQpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC50eXBlID09PSA1KSB7XG4gICAgICAgIHJld3JpdGVGaWx0ZXIoY2hpbGQuY29udGVudCwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwYXJzZUZpbHRlcihub2RlLCBjb250ZXh0KSB7XG4gIGNvbnN0IGV4cCA9IG5vZGUuY29udGVudDtcbiAgbGV0IGluU2luZ2xlID0gZmFsc2U7XG4gIGxldCBpbkRvdWJsZSA9IGZhbHNlO1xuICBsZXQgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICBsZXQgaW5SZWdleCA9IGZhbHNlO1xuICBsZXQgY3VybHkgPSAwO1xuICBsZXQgc3F1YXJlID0gMDtcbiAgbGV0IHBhcmVuID0gMDtcbiAgbGV0IGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIGxldCBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMzkgJiYgcHJldiAhPT0gOTIpIGluU2luZ2xlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDM0ICYmIHByZXYgIT09IDkyKSBpbkRvdWJsZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgaWYgKGMgPT09IDk2ICYmIHByZXYgIT09IDkyKSBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gNDcgJiYgcHJldiAhPT0gOTIpIGluUmVnZXggPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDEyNCAmJiAvLyBwaXBlXG4gICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAxMjQgJiYgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAxMjQgJiYgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgaW5Eb3VibGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgIGluU2luZ2xlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDk2OlxuICAgICAgICAgIGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBgXG4gICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgcGFyZW4rKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDQxOlxuICAgICAgICAgIHBhcmVuLS07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIClcbiAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgICBzcXVhcmUrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDkzOlxuICAgICAgICAgIHNxdWFyZS0tO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMTIzOlxuICAgICAgICAgIGN1cmx5Kys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgY3VybHktLTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChjID09PSA0Nykge1xuICAgICAgICBsZXQgaiA9IGkgLSAxO1xuICAgICAgICBsZXQgcDtcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09IFwiIFwiKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChleHByZXNzaW9uID09PSB2b2lkIDApIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cbiAgZnVuY3Rpb24gcHVzaEZpbHRlcigpIHtcbiAgICBmaWx0ZXJzLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuICBpZiAoZmlsdGVycy5sZW5ndGgpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm5EZXByZWNhdGlvbihcbiAgICAgIFwiQ09NUElMRVJfRklMVEVSU1wiLFxuICAgICAgY29udGV4dCxcbiAgICAgIG5vZGUubG9jXG4gICAgKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSwgY29udGV4dCk7XG4gICAgfVxuICAgIG5vZGUuY29udGVudCA9IGV4cHJlc3Npb247XG4gICAgbm9kZS5hc3QgPSB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIoZXhwLCBmaWx0ZXIsIGNvbnRleHQpIHtcbiAgY29udGV4dC5oZWxwZXIoUkVTT0xWRV9GSUxURVIpO1xuICBjb25zdCBpID0gZmlsdGVyLmluZGV4T2YoXCIoXCIpO1xuICBpZiAoaSA8IDApIHtcbiAgICBjb250ZXh0LmZpbHRlcnMuYWRkKGZpbHRlcik7XG4gICAgcmV0dXJuIGAke3RvVmFsaWRBc3NldElkKGZpbHRlciwgXCJmaWx0ZXJcIil9KCR7ZXhwfSlgO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgY29uc3QgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgY29udGV4dC5maWx0ZXJzLmFkZChuYW1lKTtcbiAgICByZXR1cm4gYCR7dG9WYWxpZEFzc2V0SWQobmFtZSwgXCJmaWx0ZXJcIil9KCR7ZXhwfSR7YXJncyAhPT0gXCIpXCIgPyBcIixcIiArIGFyZ3MgOiBhcmdzfWA7XG4gIH1cbn1cblxuY29uc3Qgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuY29uc3QgdHJhbnNmb3JtTWVtbyA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBjb25zdCBkaXIgPSBmaW5kRGlyKG5vZGUsIFwibWVtb1wiKTtcbiAgICBpZiAoIWRpciB8fCBzZWVuLmhhcyhub2RlKSB8fCBjb250ZXh0LmluU1NSKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlZW4uYWRkKG5vZGUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IG5vZGUuY29kZWdlbk5vZGUgfHwgY29udGV4dC5jdXJyZW50Tm9kZS5jb2RlZ2VuTm9kZTtcbiAgICAgIGlmIChjb2RlZ2VuTm9kZSAmJiBjb2RlZ2VuTm9kZS50eXBlID09PSAxMykge1xuICAgICAgICBpZiAobm9kZS50YWdUeXBlICE9PSAxKSB7XG4gICAgICAgICAgY29udmVydFRvQmxvY2soY29kZWdlbk5vZGUsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihXSVRIX01FTU8pLCBbXG4gICAgICAgICAgZGlyLmV4cCxcbiAgICAgICAgICBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24odm9pZCAwLCBjb2RlZ2VuTm9kZSksXG4gICAgICAgICAgYF9jYWNoZWAsXG4gICAgICAgICAgU3RyaW5nKGNvbnRleHQuY2FjaGVkLmxlbmd0aClcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnRleHQuY2FjaGVkLnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuY29uc3QgdHJhbnNmb3JtVkJpbmRTaG9ydGhhbmQgPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIG5vZGUucHJvcHMpIHtcbiAgICAgIGlmIChwcm9wLnR5cGUgPT09IDcgJiYgcHJvcC5uYW1lID09PSBcImJpbmRcIiAmJiAoIXByb3AuZXhwIHx8IC8vICMxMzkzMCA6Zm9vIGluIGluLURPTSB0ZW1wbGF0ZXMgd2lsbCBiZSBwYXJzZWQgaW50byA6Zm9vPVwiXCIgYnkgYnJvd3NlclxuICAgICAgcHJvcC5leHAudHlwZSA9PT0gNCAmJiAhcHJvcC5leHAuY29udGVudC50cmltKCkpICYmIHByb3AuYXJnKSB7XG4gICAgICAgIGNvbnN0IGFyZyA9IHByb3AuYXJnO1xuICAgICAgICBpZiAoYXJnLnR5cGUgIT09IDQgfHwgIWFyZy5pc1N0YXRpYykge1xuICAgICAgICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgICAgICAgIGNyZWF0ZUNvbXBpbGVyRXJyb3IoXG4gICAgICAgICAgICAgIDUzLFxuICAgICAgICAgICAgICBhcmcubG9jXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwcm9wLmV4cCA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oXCJcIiwgdHJ1ZSwgYXJnLmxvYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSBjYW1lbGl6ZShhcmcuY29udGVudCk7XG4gICAgICAgICAgaWYgKHZhbGlkRmlyc3RJZGVudENoYXJSRS50ZXN0KHByb3BOYW1lWzBdKSB8fCAvLyBhbGxvdyBoeXBoZW4gZmlyc3QgY2hhciBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL2xhbmd1YWdlLXRvb2xzL3B1bGwvMzQyNFxuICAgICAgICAgIHByb3BOYW1lWzBdID09PSBcIi1cIikge1xuICAgICAgICAgICAgcHJvcC5leHAgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKHByb3BOYW1lLCBmYWxzZSwgYXJnLmxvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0KHByZWZpeElkZW50aWZpZXJzKSB7XG4gIHJldHVybiBbXG4gICAgW1xuICAgICAgdHJhbnNmb3JtVkJpbmRTaG9ydGhhbmQsXG4gICAgICB0cmFuc2Zvcm1PbmNlLFxuICAgICAgdHJhbnNmb3JtSWYsXG4gICAgICB0cmFuc2Zvcm1NZW1vLFxuICAgICAgdHJhbnNmb3JtRm9yLFxuICAgICAgLi4uW3RyYW5zZm9ybUZpbHRlcl0gLFxuICAgICAgLi4uISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IFt0cmFuc2Zvcm1FeHByZXNzaW9uXSA6IFtdLFxuICAgICAgdHJhbnNmb3JtU2xvdE91dGxldCxcbiAgICAgIHRyYW5zZm9ybUVsZW1lbnQsXG4gICAgICB0cmFja1Nsb3RTY29wZXMsXG4gICAgICB0cmFuc2Zvcm1UZXh0XG4gICAgXSxcbiAgICB7XG4gICAgICBvbjogdHJhbnNmb3JtT24sXG4gICAgICBiaW5kOiB0cmFuc2Zvcm1CaW5kLFxuICAgICAgbW9kZWw6IHRyYW5zZm9ybU1vZGVsXG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24gYmFzZUNvbXBpbGUoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgb25FcnJvciA9IG9wdGlvbnMub25FcnJvciB8fCBkZWZhdWx0T25FcnJvcjtcbiAgY29uc3QgaXNNb2R1bGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSBcIm1vZHVsZVwiO1xuICB7XG4gICAgaWYgKG9wdGlvbnMucHJlZml4SWRlbnRpZmllcnMgPT09IHRydWUpIHtcbiAgICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0OCkpO1xuICAgIH0gZWxzZSBpZiAoaXNNb2R1bGVNb2RlKSB7XG4gICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDkpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcHJlZml4SWRlbnRpZmllcnMgPSBmYWxzZTtcbiAgaWYgKG9wdGlvbnMuY2FjaGVIYW5kbGVycykge1xuICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig1MCkpO1xuICB9XG4gIGlmIChvcHRpb25zLnNjb3BlSWQgJiYgIWlzTW9kdWxlTW9kZSkge1xuICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig1MSkpO1xuICB9XG4gIGNvbnN0IHJlc29sdmVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgIHByZWZpeElkZW50aWZpZXJzXG4gIH0pO1xuICBjb25zdCBhc3QgPSBpc1N0cmluZyhzb3VyY2UpID8gYmFzZVBhcnNlKHNvdXJjZSwgcmVzb2x2ZWRPcHRpb25zKSA6IHNvdXJjZTtcbiAgY29uc3QgW25vZGVUcmFuc2Zvcm1zLCBkaXJlY3RpdmVUcmFuc2Zvcm1zXSA9IGdldEJhc2VUcmFuc2Zvcm1QcmVzZXQoKTtcbiAgdHJhbnNmb3JtKFxuICAgIGFzdCxcbiAgICBleHRlbmQoe30sIHJlc29sdmVkT3B0aW9ucywge1xuICAgICAgbm9kZVRyYW5zZm9ybXM6IFtcbiAgICAgICAgLi4ubm9kZVRyYW5zZm9ybXMsXG4gICAgICAgIC4uLm9wdGlvbnMubm9kZVRyYW5zZm9ybXMgfHwgW11cbiAgICAgICAgLy8gdXNlciB0cmFuc2Zvcm1zXG4gICAgICBdLFxuICAgICAgZGlyZWN0aXZlVHJhbnNmb3JtczogZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgZGlyZWN0aXZlVHJhbnNmb3JtcyxcbiAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVUcmFuc2Zvcm1zIHx8IHt9XG4gICAgICAgIC8vIHVzZXIgdHJhbnNmb3Jtc1xuICAgICAgKVxuICAgIH0pXG4gICk7XG4gIHJldHVybiBnZW5lcmF0ZShhc3QsIHJlc29sdmVkT3B0aW9ucyk7XG59XG5cbmNvbnN0IEJpbmRpbmdUeXBlcyA9IHtcbiAgXCJEQVRBXCI6IFwiZGF0YVwiLFxuICBcIlBST1BTXCI6IFwicHJvcHNcIixcbiAgXCJQUk9QU19BTElBU0VEXCI6IFwicHJvcHMtYWxpYXNlZFwiLFxuICBcIlNFVFVQX0xFVFwiOiBcInNldHVwLWxldFwiLFxuICBcIlNFVFVQX0NPTlNUXCI6IFwic2V0dXAtY29uc3RcIixcbiAgXCJTRVRVUF9SRUFDVElWRV9DT05TVFwiOiBcInNldHVwLXJlYWN0aXZlLWNvbnN0XCIsXG4gIFwiU0VUVVBfTUFZQkVfUkVGXCI6IFwic2V0dXAtbWF5YmUtcmVmXCIsXG4gIFwiU0VUVVBfUkVGXCI6IFwic2V0dXAtcmVmXCIsXG4gIFwiT1BUSU9OU1wiOiBcIm9wdGlvbnNcIixcbiAgXCJMSVRFUkFMX0NPTlNUXCI6IFwibGl0ZXJhbC1jb25zdFwiXG59O1xuXG5jb25zdCBub29wRGlyZWN0aXZlVHJhbnNmb3JtID0gKCkgPT4gKHsgcHJvcHM6IFtdIH0pO1xuXG5leHBvcnQgeyBCQVNFX1RSQU5TSVRJT04sIEJpbmRpbmdUeXBlcywgQ0FNRUxJWkUsIENBUElUQUxJWkUsIENSRUFURV9CTE9DSywgQ1JFQVRFX0NPTU1FTlQsIENSRUFURV9FTEVNRU5UX0JMT0NLLCBDUkVBVEVfRUxFTUVOVF9WTk9ERSwgQ1JFQVRFX1NMT1RTLCBDUkVBVEVfU1RBVElDLCBDUkVBVEVfVEVYVCwgQ1JFQVRFX1ZOT0RFLCBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMsIENvbnN0YW50VHlwZXMsIEVsZW1lbnRUeXBlcywgRXJyb3JDb2RlcywgRlJBR01FTlQsIEdVQVJEX1JFQUNUSVZFX1BST1BTLCBJU19NRU1PX1NBTUUsIElTX1JFRiwgS0VFUF9BTElWRSwgTUVSR0VfUFJPUFMsIE5PUk1BTElaRV9DTEFTUywgTk9STUFMSVpFX1BST1BTLCBOT1JNQUxJWkVfU1RZTEUsIE5hbWVzcGFjZXMsIE5vZGVUeXBlcywgT1BFTl9CTE9DSywgUE9QX1NDT1BFX0lELCBQVVNIX1NDT1BFX0lELCBSRU5ERVJfTElTVCwgUkVOREVSX1NMT1QsIFJFU09MVkVfQ09NUE9ORU5ULCBSRVNPTFZFX0RJUkVDVElWRSwgUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVCwgUkVTT0xWRV9GSUxURVIsIFNFVF9CTE9DS19UUkFDS0lORywgU1VTUEVOU0UsIFRFTEVQT1JULCBUT19ESVNQTEFZX1NUUklORywgVE9fSEFORExFUlMsIFRPX0hBTkRMRVJfS0VZLCBUU19OT0RFX1RZUEVTLCBVTlJFRiwgV0lUSF9DVFgsIFdJVEhfRElSRUNUSVZFUywgV0lUSF9NRU1PLCBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUsIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbiwgYXNzZXJ0LCBiYXNlQ29tcGlsZSwgYmFzZVBhcnNlLCBidWlsZERpcmVjdGl2ZUFyZ3MsIGJ1aWxkUHJvcHMsIGJ1aWxkU2xvdHMsIGNoZWNrQ29tcGF0RW5hYmxlZCwgY29udmVydFRvQmxvY2ssIGNyZWF0ZUFycmF5RXhwcmVzc2lvbiwgY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24sIGNyZWF0ZUJsb2NrU3RhdGVtZW50LCBjcmVhdGVDYWNoZUV4cHJlc3Npb24sIGNyZWF0ZUNhbGxFeHByZXNzaW9uLCBjcmVhdGVDb21waWxlckVycm9yLCBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24sIGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbiwgY3JlYXRlRm9yTG9vcFBhcmFtcywgY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uLCBjcmVhdGVJZlN0YXRlbWVudCwgY3JlYXRlSW50ZXJwb2xhdGlvbiwgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbiwgY3JlYXRlT2JqZWN0UHJvcGVydHksIGNyZWF0ZVJldHVyblN0YXRlbWVudCwgY3JlYXRlUm9vdCwgY3JlYXRlU2VxdWVuY2VFeHByZXNzaW9uLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uLCBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtLCBjcmVhdGVUZW1wbGF0ZUxpdGVyYWwsIGNyZWF0ZVRyYW5zZm9ybUNvbnRleHQsIGNyZWF0ZVZOb2RlQ2FsbCwgZXJyb3JNZXNzYWdlcywgZXh0cmFjdElkZW50aWZpZXJzLCBmaW5kRGlyLCBmaW5kUHJvcCwgZm9yQWxpYXNSRSwgZ2VuZXJhdGUsIGdldEJhc2VUcmFuc2Zvcm1QcmVzZXQsIGdldENvbnN0YW50VHlwZSwgZ2V0TWVtb2VkVk5vZGVDYWxsLCBnZXRWTm9kZUJsb2NrSGVscGVyLCBnZXRWTm9kZUhlbHBlciwgaGFzRHluYW1pY0tleVZCaW5kLCBoYXNTY29wZVJlZiwgaGVscGVyTmFtZU1hcCwgaW5qZWN0UHJvcCwgaXNBbGxXaGl0ZXNwYWNlLCBpc0NvbW1lbnRPcldoaXRlc3BhY2UsIGlzQ29yZUNvbXBvbmVudCwgaXNGbkV4cHJlc3Npb24sIGlzRm5FeHByZXNzaW9uQnJvd3NlciwgaXNGbkV4cHJlc3Npb25Ob2RlLCBpc0Z1bmN0aW9uVHlwZSwgaXNJbkRlc3RydWN0dXJlQXNzaWdubWVudCwgaXNJbk5ld0V4cHJlc3Npb24sIGlzTWVtYmVyRXhwcmVzc2lvbiwgaXNNZW1iZXJFeHByZXNzaW9uQnJvd3NlciwgaXNNZW1iZXJFeHByZXNzaW9uTm9kZSwgaXNSZWZlcmVuY2VkSWRlbnRpZmllciwgaXNTaW1wbGVJZGVudGlmaWVyLCBpc1Nsb3RPdXRsZXQsIGlzU3RhdGljQXJnT2YsIGlzU3RhdGljRXhwLCBpc1N0YXRpY1Byb3BlcnR5LCBpc1N0YXRpY1Byb3BlcnR5S2V5LCBpc1RlbXBsYXRlTm9kZSwgaXNUZXh0JDEgYXMgaXNUZXh0LCBpc1ZQcmUsIGlzVlNsb3QsIGlzV2hpdGVzcGFjZVRleHQsIGxvY1N0dWIsIG5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0sIHByb2Nlc3NFeHByZXNzaW9uLCBwcm9jZXNzRm9yLCBwcm9jZXNzSWYsIHByb2Nlc3NTbG90T3V0bGV0LCByZWdpc3RlclJ1bnRpbWVIZWxwZXJzLCByZXNvbHZlQ29tcG9uZW50VHlwZSwgc3RyaW5naWZ5RXhwcmVzc2lvbiwgdG9WYWxpZEFzc2V0SWQsIHRyYWNrU2xvdFNjb3BlcywgdHJhY2tWRm9yU2xvdFNjb3BlcywgdHJhbnNmb3JtLCB0cmFuc2Zvcm1CaW5kLCB0cmFuc2Zvcm1FbGVtZW50LCB0cmFuc2Zvcm1FeHByZXNzaW9uLCB0cmFuc2Zvcm1Nb2RlbCwgdHJhbnNmb3JtT24sIHRyYW5zZm9ybVZCaW5kU2hvcnRoYW5kLCB0cmF2ZXJzZU5vZGUsIHVud3JhcFRTTm9kZSwgdmFsaWRGaXJzdElkZW50Q2hhclJFLCB3YWxrQmxvY2tEZWNsYXJhdGlvbnMsIHdhbGtGdW5jdGlvblBhcmFtcywgd2Fsa0lkZW50aWZpZXJzLCB3YXJuRGVwcmVjYXRpb24gfTtcbiIsIi8qKlxuKiBAdnVlL2NvbXBpbGVyLWRvbSB2My41LjI2XG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5pbXBvcnQgeyByZWdpc3RlclJ1bnRpbWVIZWxwZXJzLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uLCBjcmVhdGVDb21waWxlckVycm9yLCBjcmVhdGVPYmplY3RQcm9wZXJ0eSwgY3JlYXRlQ2FsbEV4cHJlc3Npb24sIGdldENvbnN0YW50VHlwZSwgVE9fRElTUExBWV9TVFJJTkcsIHRyYW5zZm9ybU1vZGVsIGFzIHRyYW5zZm9ybU1vZGVsJDEsIGZpbmRQcm9wLCBoYXNEeW5hbWljS2V5VkJpbmQsIGZpbmREaXIsIGlzU3RhdGljQXJnT2YsIHRyYW5zZm9ybU9uIGFzIHRyYW5zZm9ybU9uJDEsIGlzU3RhdGljRXhwLCBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24sIGNoZWNrQ29tcGF0RW5hYmxlZCwgaXNDb21tZW50T3JXaGl0ZXNwYWNlLCBub29wRGlyZWN0aXZlVHJhbnNmb3JtLCBiYXNlQ29tcGlsZSwgYmFzZVBhcnNlIH0gZnJvbSAnQHZ1ZS9jb21waWxlci1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvY29tcGlsZXItY29yZSc7XG5pbXBvcnQgeyBpc0hUTUxUYWcsIGlzU1ZHVGFnLCBpc01hdGhNTFRhZywgaXNWb2lkVGFnLCBwYXJzZVN0cmluZ1N0eWxlLCBtYWtlTWFwLCBjYXBpdGFsaXplLCBleHRlbmQgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IFZfTU9ERUxfUkFESU8gPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgdk1vZGVsUmFkaW9gIDogYGApO1xuY29uc3QgVl9NT0RFTF9DSEVDS0JPWCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgdk1vZGVsQ2hlY2tib3hgIDogYGBcbik7XG5jb25zdCBWX01PREVMX1RFWFQgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgdk1vZGVsVGV4dGAgOiBgYCk7XG5jb25zdCBWX01PREVMX1NFTEVDVCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgdk1vZGVsU2VsZWN0YCA6IGBgXG4pO1xuY29uc3QgVl9NT0RFTF9EWU5BTUlDID0gLyogQF9fUFVSRV9fICovIFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGB2TW9kZWxEeW5hbWljYCA6IGBgXG4pO1xuY29uc3QgVl9PTl9XSVRIX01PRElGSUVSUyA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgdk9uTW9kaWZpZXJzR3VhcmRgIDogYGBcbik7XG5jb25zdCBWX09OX1dJVEhfS0VZUyA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgdk9uS2V5c0d1YXJkYCA6IGBgXG4pO1xuY29uc3QgVl9TSE9XID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gYHZTaG93YCA6IGBgKTtcbmNvbnN0IFRSQU5TSVRJT04gPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBgVHJhbnNpdGlvbmAgOiBgYCk7XG5jb25zdCBUUkFOU0lUSU9OX0dST1VQID0gLyogQF9fUFVSRV9fICovIFN5bWJvbChcbiAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGBUcmFuc2l0aW9uR3JvdXBgIDogYGBcbik7XG5yZWdpc3RlclJ1bnRpbWVIZWxwZXJzKHtcbiAgW1ZfTU9ERUxfUkFESU9dOiBgdk1vZGVsUmFkaW9gLFxuICBbVl9NT0RFTF9DSEVDS0JPWF06IGB2TW9kZWxDaGVja2JveGAsXG4gIFtWX01PREVMX1RFWFRdOiBgdk1vZGVsVGV4dGAsXG4gIFtWX01PREVMX1NFTEVDVF06IGB2TW9kZWxTZWxlY3RgLFxuICBbVl9NT0RFTF9EWU5BTUlDXTogYHZNb2RlbER5bmFtaWNgLFxuICBbVl9PTl9XSVRIX01PRElGSUVSU106IGB3aXRoTW9kaWZpZXJzYCxcbiAgW1ZfT05fV0lUSF9LRVlTXTogYHdpdGhLZXlzYCxcbiAgW1ZfU0hPV106IGB2U2hvd2AsXG4gIFtUUkFOU0lUSU9OXTogYFRyYW5zaXRpb25gLFxuICBbVFJBTlNJVElPTl9HUk9VUF06IGBUcmFuc2l0aW9uR3JvdXBgXG59KTtcblxubGV0IGRlY29kZXI7XG5mdW5jdGlvbiBkZWNvZGVIdG1sQnJvd3NlcihyYXcsIGFzQXR0ciA9IGZhbHNlKSB7XG4gIGlmICghZGVjb2Rlcikge1xuICAgIGRlY29kZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB9XG4gIGlmIChhc0F0dHIpIHtcbiAgICBkZWNvZGVyLmlubmVySFRNTCA9IGA8ZGl2IGZvbz1cIiR7cmF3LnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpfVwiPmA7XG4gICAgcmV0dXJuIGRlY29kZXIuY2hpbGRyZW5bMF0uZ2V0QXR0cmlidXRlKFwiZm9vXCIpO1xuICB9IGVsc2Uge1xuICAgIGRlY29kZXIuaW5uZXJIVE1MID0gcmF3O1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50O1xuICB9XG59XG5cbmNvbnN0IHBhcnNlck9wdGlvbnMgPSB7XG4gIHBhcnNlTW9kZTogXCJodG1sXCIsXG4gIGlzVm9pZFRhZyxcbiAgaXNOYXRpdmVUYWc6ICh0YWcpID0+IGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHVGFnKHRhZykgfHwgaXNNYXRoTUxUYWcodGFnKSxcbiAgaXNQcmVUYWc6ICh0YWcpID0+IHRhZyA9PT0gXCJwcmVcIixcbiAgaXNJZ25vcmVOZXdsaW5lVGFnOiAodGFnKSA9PiB0YWcgPT09IFwicHJlXCIgfHwgdGFnID09PSBcInRleHRhcmVhXCIsXG4gIGRlY29kZUVudGl0aWVzOiBkZWNvZGVIdG1sQnJvd3NlciAsXG4gIGlzQnVpbHRJbkNvbXBvbmVudDogKHRhZykgPT4ge1xuICAgIGlmICh0YWcgPT09IFwiVHJhbnNpdGlvblwiIHx8IHRhZyA9PT0gXCJ0cmFuc2l0aW9uXCIpIHtcbiAgICAgIHJldHVybiBUUkFOU0lUSU9OO1xuICAgIH0gZWxzZSBpZiAodGFnID09PSBcIlRyYW5zaXRpb25Hcm91cFwiIHx8IHRhZyA9PT0gXCJ0cmFuc2l0aW9uLWdyb3VwXCIpIHtcbiAgICAgIHJldHVybiBUUkFOU0lUSU9OX0dST1VQO1xuICAgIH1cbiAgfSxcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI3RyZWUtY29uc3RydWN0aW9uLWRpc3BhdGNoZXJcbiAgZ2V0TmFtZXNwYWNlKHRhZywgcGFyZW50LCByb290TmFtZXNwYWNlKSB7XG4gICAgbGV0IG5zID0gcGFyZW50ID8gcGFyZW50Lm5zIDogcm9vdE5hbWVzcGFjZTtcbiAgICBpZiAocGFyZW50ICYmIG5zID09PSAyKSB7XG4gICAgICBpZiAocGFyZW50LnRhZyA9PT0gXCJhbm5vdGF0aW9uLXhtbFwiKSB7XG4gICAgICAgIGlmICh0YWcgPT09IFwic3ZnXCIpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50LnByb3BzLnNvbWUoXG4gICAgICAgICAgKGEpID0+IGEudHlwZSA9PT0gNiAmJiBhLm5hbWUgPT09IFwiZW5jb2RpbmdcIiAmJiBhLnZhbHVlICE9IG51bGwgJiYgKGEudmFsdWUuY29udGVudCA9PT0gXCJ0ZXh0L2h0bWxcIiB8fCBhLnZhbHVlLmNvbnRlbnQgPT09IFwiYXBwbGljYXRpb24veGh0bWwreG1sXCIpXG4gICAgICAgICkpIHtcbiAgICAgICAgICBucyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoL15tKD86W2lvbnNdfHRleHQpJC8udGVzdChwYXJlbnQudGFnKSAmJiB0YWcgIT09IFwibWdseXBoXCIgJiYgdGFnICE9PSBcIm1hbGlnbm1hcmtcIikge1xuICAgICAgICBucyA9IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJlbnQgJiYgbnMgPT09IDEpIHtcbiAgICAgIGlmIChwYXJlbnQudGFnID09PSBcImZvcmVpZ25PYmplY3RcIiB8fCBwYXJlbnQudGFnID09PSBcImRlc2NcIiB8fCBwYXJlbnQudGFnID09PSBcInRpdGxlXCIpIHtcbiAgICAgICAgbnMgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobnMgPT09IDApIHtcbiAgICAgIGlmICh0YWcgPT09IFwic3ZnXCIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAodGFnID09PSBcIm1hdGhcIikge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5zO1xuICB9XG59O1xuXG5jb25zdCB0cmFuc2Zvcm1TdHlsZSA9IChub2RlKSA9PiB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBub2RlLnByb3BzLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgIGlmIChwLnR5cGUgPT09IDYgJiYgcC5uYW1lID09PSBcInN0eWxlXCIgJiYgcC52YWx1ZSkge1xuICAgICAgICBub2RlLnByb3BzW2ldID0ge1xuICAgICAgICAgIHR5cGU6IDcsXG4gICAgICAgICAgbmFtZTogYGJpbmRgLFxuICAgICAgICAgIGFyZzogY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgc3R5bGVgLCB0cnVlLCBwLmxvYyksXG4gICAgICAgICAgZXhwOiBwYXJzZUlubGluZUNTUyhwLnZhbHVlLmNvbnRlbnQsIHAubG9jKSxcbiAgICAgICAgICBtb2RpZmllcnM6IFtdLFxuICAgICAgICAgIGxvYzogcC5sb2NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmNvbnN0IHBhcnNlSW5saW5lQ1NTID0gKGNzc1RleHQsIGxvYykgPT4ge1xuICBjb25zdCBub3JtYWxpemVkID0gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KTtcbiAgcmV0dXJuIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oXG4gICAgSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZCksXG4gICAgZmFsc2UsXG4gICAgbG9jLFxuICAgIDNcbiAgKTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoY29kZSwgbG9jKSB7XG4gIHJldHVybiBjcmVhdGVDb21waWxlckVycm9yKFxuICAgIGNvZGUsXG4gICAgbG9jLFxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgZmFsc2UgPyBET01FcnJvck1lc3NhZ2VzIDogdm9pZCAwXG4gICk7XG59XG5jb25zdCBET01FcnJvckNvZGVzID0ge1xuICBcIlhfVl9IVE1MX05PX0VYUFJFU1NJT05cIjogNTQsXG4gIFwiNTRcIjogXCJYX1ZfSFRNTF9OT19FWFBSRVNTSU9OXCIsXG4gIFwiWF9WX0hUTUxfV0lUSF9DSElMRFJFTlwiOiA1NSxcbiAgXCI1NVwiOiBcIlhfVl9IVE1MX1dJVEhfQ0hJTERSRU5cIixcbiAgXCJYX1ZfVEVYVF9OT19FWFBSRVNTSU9OXCI6IDU2LFxuICBcIjU2XCI6IFwiWF9WX1RFWFRfTk9fRVhQUkVTU0lPTlwiLFxuICBcIlhfVl9URVhUX1dJVEhfQ0hJTERSRU5cIjogNTcsXG4gIFwiNTdcIjogXCJYX1ZfVEVYVF9XSVRIX0NISUxEUkVOXCIsXG4gIFwiWF9WX01PREVMX09OX0lOVkFMSURfRUxFTUVOVFwiOiA1OCxcbiAgXCI1OFwiOiBcIlhfVl9NT0RFTF9PTl9JTlZBTElEX0VMRU1FTlRcIixcbiAgXCJYX1ZfTU9ERUxfQVJHX09OX0VMRU1FTlRcIjogNTksXG4gIFwiNTlcIjogXCJYX1ZfTU9ERUxfQVJHX09OX0VMRU1FTlRcIixcbiAgXCJYX1ZfTU9ERUxfT05fRklMRV9JTlBVVF9FTEVNRU5UXCI6IDYwLFxuICBcIjYwXCI6IFwiWF9WX01PREVMX09OX0ZJTEVfSU5QVVRfRUxFTUVOVFwiLFxuICBcIlhfVl9NT0RFTF9VTk5FQ0VTU0FSWV9WQUxVRVwiOiA2MSxcbiAgXCI2MVwiOiBcIlhfVl9NT0RFTF9VTk5FQ0VTU0FSWV9WQUxVRVwiLFxuICBcIlhfVl9TSE9XX05PX0VYUFJFU1NJT05cIjogNjIsXG4gIFwiNjJcIjogXCJYX1ZfU0hPV19OT19FWFBSRVNTSU9OXCIsXG4gIFwiWF9UUkFOU0lUSU9OX0lOVkFMSURfQ0hJTERSRU5cIjogNjMsXG4gIFwiNjNcIjogXCJYX1RSQU5TSVRJT05fSU5WQUxJRF9DSElMRFJFTlwiLFxuICBcIlhfSUdOT1JFRF9TSURFX0VGRkVDVF9UQUdcIjogNjQsXG4gIFwiNjRcIjogXCJYX0lHTk9SRURfU0lERV9FRkZFQ1RfVEFHXCIsXG4gIFwiX19FWFRFTkRfUE9JTlRfX1wiOiA2NSxcbiAgXCI2NVwiOiBcIl9fRVhURU5EX1BPSU5UX19cIlxufTtcbmNvbnN0IERPTUVycm9yTWVzc2FnZXMgPSB7XG4gIFs1NF06IGB2LWh0bWwgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXG4gIFs1NV06IGB2LWh0bWwgd2lsbCBvdmVycmlkZSBlbGVtZW50IGNoaWxkcmVuLmAsXG4gIFs1Nl06IGB2LXRleHQgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXG4gIFs1N106IGB2LXRleHQgd2lsbCBvdmVycmlkZSBlbGVtZW50IGNoaWxkcmVuLmAsXG4gIFs1OF06IGB2LW1vZGVsIGNhbiBvbmx5IGJlIHVzZWQgb24gPGlucHV0PiwgPHRleHRhcmVhPiBhbmQgPHNlbGVjdD4gZWxlbWVudHMuYCxcbiAgWzU5XTogYHYtbW9kZWwgYXJndW1lbnQgaXMgbm90IHN1cHBvcnRlZCBvbiBwbGFpbiBlbGVtZW50cy5gLFxuICBbNjBdOiBgdi1tb2RlbCBjYW5ub3QgYmUgdXNlZCBvbiBmaWxlIGlucHV0cyBzaW5jZSB0aGV5IGFyZSByZWFkLW9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuYCxcbiAgWzYxXTogYFVubmVjZXNzYXJ5IHZhbHVlIGJpbmRpbmcgdXNlZCBhbG9uZ3NpZGUgdi1tb2RlbC4gSXQgd2lsbCBpbnRlcmZlcmUgd2l0aCB2LW1vZGVsJ3MgYmVoYXZpb3IuYCxcbiAgWzYyXTogYHYtc2hvdyBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcbiAgWzYzXTogYDxUcmFuc2l0aW9uPiBleHBlY3RzIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQgb3IgY29tcG9uZW50LmAsXG4gIFs2NF06IGBUYWdzIHdpdGggc2lkZSBlZmZlY3QgKDxzY3JpcHQ+IGFuZCA8c3R5bGU+KSBhcmUgaWdub3JlZCBpbiBjbGllbnQgY29tcG9uZW50IHRlbXBsYXRlcy5gXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1WSHRtbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcbiAgY29uc3QgeyBleHAsIGxvYyB9ID0gZGlyO1xuICBpZiAoIWV4cCkge1xuICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTQsIGxvYylcbiAgICApO1xuICB9XG4gIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTUsIGxvYylcbiAgICApO1xuICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHByb3BzOiBbXG4gICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShcbiAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgaW5uZXJIVE1MYCwgdHJ1ZSwgbG9jKSxcbiAgICAgICAgZXhwIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oXCJcIiwgdHJ1ZSlcbiAgICAgIClcbiAgICBdXG4gIH07XG59O1xuXG5jb25zdCB0cmFuc2Zvcm1WVGV4dCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcbiAgY29uc3QgeyBleHAsIGxvYyB9ID0gZGlyO1xuICBpZiAoIWV4cCkge1xuICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTYsIGxvYylcbiAgICApO1xuICB9XG4gIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTcsIGxvYylcbiAgICApO1xuICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHByb3BzOiBbXG4gICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShcbiAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdGV4dENvbnRlbnRgLCB0cnVlKSxcbiAgICAgICAgZXhwID8gZ2V0Q29uc3RhbnRUeXBlKGV4cCwgY29udGV4dCkgPiAwID8gZXhwIDogY3JlYXRlQ2FsbEV4cHJlc3Npb24oXG4gICAgICAgICAgY29udGV4dC5oZWxwZXJTdHJpbmcoVE9fRElTUExBWV9TVFJJTkcpLFxuICAgICAgICAgIFtleHBdLFxuICAgICAgICAgIGxvY1xuICAgICAgICApIDogY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihcIlwiLCB0cnVlKVxuICAgICAgKVxuICAgIF1cbiAgfTtcbn07XG5cbmNvbnN0IHRyYW5zZm9ybU1vZGVsID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xuICBjb25zdCBiYXNlUmVzdWx0ID0gdHJhbnNmb3JtTW9kZWwkMShkaXIsIG5vZGUsIGNvbnRleHQpO1xuICBpZiAoIWJhc2VSZXN1bHQucHJvcHMubGVuZ3RoIHx8IG5vZGUudGFnVHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBiYXNlUmVzdWx0O1xuICB9XG4gIGlmIChkaXIuYXJnKSB7XG4gICAgY29udGV4dC5vbkVycm9yKFxuICAgICAgY3JlYXRlRE9NQ29tcGlsZXJFcnJvcihcbiAgICAgICAgNTksXG4gICAgICAgIGRpci5hcmcubG9jXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGZpbmREaXIobm9kZSwgXCJiaW5kXCIpO1xuICAgIGlmICh2YWx1ZSAmJiBpc1N0YXRpY0FyZ09mKHZhbHVlLmFyZywgXCJ2YWx1ZVwiKSkge1xuICAgICAgY29udGV4dC5vbkVycm9yKFxuICAgICAgICBjcmVhdGVET01Db21waWxlckVycm9yKFxuICAgICAgICAgIDYxLFxuICAgICAgICAgIHZhbHVlLmxvY1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCB7IHRhZyB9ID0gbm9kZTtcbiAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gY29udGV4dC5pc0N1c3RvbUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZyA9PT0gXCJpbnB1dFwiIHx8IHRhZyA9PT0gXCJ0ZXh0YXJlYVwiIHx8IHRhZyA9PT0gXCJzZWxlY3RcIiB8fCBpc0N1c3RvbUVsZW1lbnQpIHtcbiAgICBsZXQgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX1RFWFQ7XG4gICAgbGV0IGlzSW52YWxpZFR5cGUgPSBmYWxzZTtcbiAgICBpZiAodGFnID09PSBcImlucHV0XCIgfHwgaXNDdXN0b21FbGVtZW50KSB7XG4gICAgICBjb25zdCB0eXBlID0gZmluZFByb3Aobm9kZSwgYHR5cGVgKTtcbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlLnR5cGUgPT09IDcpIHtcbiAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfRFlOQU1JQztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLnZhbHVlKSB7XG4gICAgICAgICAgc3dpdGNoICh0eXBlLnZhbHVlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJyYWRpb1wiOlxuICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfUkFESU87XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9DSEVDS0JPWDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICAgICAgICBpc0ludmFsaWRUeXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKFxuICAgICAgICAgICAgICAgIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoXG4gICAgICAgICAgICAgICAgICA2MCxcbiAgICAgICAgICAgICAgICAgIGRpci5sb2NcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGFzRHluYW1pY0tleVZCaW5kKG5vZGUpKSB7XG4gICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9EWU5BTUlDO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGFnID09PSBcInNlbGVjdFwiKSB7XG4gICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfU0VMRUNUO1xuICAgIH0gZWxzZSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrRHVwbGljYXRlZFZhbHVlKCk7XG4gICAgfVxuICAgIGlmICghaXNJbnZhbGlkVHlwZSkge1xuICAgICAgYmFzZVJlc3VsdC5uZWVkUnVudGltZSA9IGNvbnRleHQuaGVscGVyKGRpcmVjdGl2ZVRvVXNlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5vbkVycm9yKFxuICAgICAgY3JlYXRlRE9NQ29tcGlsZXJFcnJvcihcbiAgICAgICAgNTgsXG4gICAgICAgIGRpci5sb2NcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGJhc2VSZXN1bHQucHJvcHMgPSBiYXNlUmVzdWx0LnByb3BzLmZpbHRlcihcbiAgICAocCkgPT4gIShwLmtleS50eXBlID09PSA0ICYmIHAua2V5LmNvbnRlbnQgPT09IFwibW9kZWxWYWx1ZVwiKVxuICApO1xuICByZXR1cm4gYmFzZVJlc3VsdDtcbn07XG5cbmNvbnN0IGlzRXZlbnRPcHRpb25Nb2RpZmllciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKGBwYXNzaXZlLG9uY2UsY2FwdHVyZWApO1xuY29uc3QgaXNOb25LZXlNb2RpZmllciA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFxuICAvLyBldmVudCBwcm9wYWdhdGlvbiBtYW5hZ2VtZW50XG4gIGBzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0LG1pZGRsZWBcbik7XG5jb25zdCBtYXliZUtleU1vZGlmaWVyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXCJsZWZ0LHJpZ2h0XCIpO1xuY29uc3QgaXNLZXlib2FyZEV2ZW50ID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoYG9ua2V5dXAsb25rZXlkb3duLG9ua2V5cHJlc3NgKTtcbmNvbnN0IHJlc29sdmVNb2RpZmllcnMgPSAoa2V5LCBtb2RpZmllcnMsIGNvbnRleHQsIGxvYykgPT4ge1xuICBjb25zdCBrZXlNb2RpZmllcnMgPSBbXTtcbiAgY29uc3Qgbm9uS2V5TW9kaWZpZXJzID0gW107XG4gIGNvbnN0IGV2ZW50T3B0aW9uTW9kaWZpZXJzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbW9kaWZpZXIgPSBtb2RpZmllcnNbaV0uY29udGVudDtcbiAgICBpZiAobW9kaWZpZXIgPT09IFwibmF0aXZlXCIgJiYgY2hlY2tDb21wYXRFbmFibGVkKFxuICAgICAgXCJDT01QSUxFUl9WX09OX05BVElWRVwiLFxuICAgICAgY29udGV4dCxcbiAgICAgIGxvY1xuICAgICkpIHtcbiAgICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgIH0gZWxzZSBpZiAoaXNFdmVudE9wdGlvbk1vZGlmaWVyKG1vZGlmaWVyKSkge1xuICAgICAgZXZlbnRPcHRpb25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXliZUtleU1vZGlmaWVyKG1vZGlmaWVyKSkge1xuICAgICAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xuICAgICAgICAgIGlmIChpc0tleWJvYXJkRXZlbnQoa2V5LmNvbnRlbnQudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIGtleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNOb25LZXlNb2RpZmllcihtb2RpZmllcikpIHtcbiAgICAgICAgICBub25LZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAga2V5TW9kaWZpZXJzLFxuICAgIG5vbktleU1vZGlmaWVycyxcbiAgICBldmVudE9wdGlvbk1vZGlmaWVyc1xuICB9O1xufTtcbmNvbnN0IHRyYW5zZm9ybUNsaWNrID0gKGtleSwgZXZlbnQpID0+IHtcbiAgY29uc3QgaXNTdGF0aWNDbGljayA9IGlzU3RhdGljRXhwKGtleSkgJiYga2V5LmNvbnRlbnQudG9Mb3dlckNhc2UoKSA9PT0gXCJvbmNsaWNrXCI7XG4gIHJldHVybiBpc1N0YXRpY0NsaWNrID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihldmVudCwgdHJ1ZSkgOiBrZXkudHlwZSAhPT0gNCA/IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXG4gICAgYChgLFxuICAgIGtleSxcbiAgICBgKSA9PT0gXCJvbkNsaWNrXCIgPyBcIiR7ZXZlbnR9XCIgOiAoYCxcbiAgICBrZXksXG4gICAgYClgXG4gIF0pIDoga2V5O1xufTtcbmNvbnN0IHRyYW5zZm9ybU9uID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xuICByZXR1cm4gdHJhbnNmb3JtT24kMShkaXIsIG5vZGUsIGNvbnRleHQsIChiYXNlUmVzdWx0KSA9PiB7XG4gICAgY29uc3QgeyBtb2RpZmllcnMgfSA9IGRpcjtcbiAgICBpZiAoIW1vZGlmaWVycy5sZW5ndGgpIHJldHVybiBiYXNlUmVzdWx0O1xuICAgIGxldCB7IGtleSwgdmFsdWU6IGhhbmRsZXJFeHAgfSA9IGJhc2VSZXN1bHQucHJvcHNbMF07XG4gICAgY29uc3QgeyBrZXlNb2RpZmllcnMsIG5vbktleU1vZGlmaWVycywgZXZlbnRPcHRpb25Nb2RpZmllcnMgfSA9IHJlc29sdmVNb2RpZmllcnMoa2V5LCBtb2RpZmllcnMsIGNvbnRleHQsIGRpci5sb2MpO1xuICAgIGlmIChub25LZXlNb2RpZmllcnMuaW5jbHVkZXMoXCJyaWdodFwiKSkge1xuICAgICAga2V5ID0gdHJhbnNmb3JtQ2xpY2soa2V5LCBgb25Db250ZXh0bWVudWApO1xuICAgIH1cbiAgICBpZiAobm9uS2V5TW9kaWZpZXJzLmluY2x1ZGVzKFwibWlkZGxlXCIpKSB7XG4gICAgICBrZXkgPSB0cmFuc2Zvcm1DbGljayhrZXksIGBvbk1vdXNldXBgKTtcbiAgICB9XG4gICAgaWYgKG5vbktleU1vZGlmaWVycy5sZW5ndGgpIHtcbiAgICAgIGhhbmRsZXJFeHAgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihWX09OX1dJVEhfTU9ESUZJRVJTKSwgW1xuICAgICAgICBoYW5kbGVyRXhwLFxuICAgICAgICBKU09OLnN0cmluZ2lmeShub25LZXlNb2RpZmllcnMpXG4gICAgICBdKTtcbiAgICB9XG4gICAgaWYgKGtleU1vZGlmaWVycy5sZW5ndGggJiYgLy8gaWYgZXZlbnQgbmFtZSBpcyBkeW5hbWljLCBhbHdheXMgd3JhcCB3aXRoIGtleXMgZ3VhcmRcbiAgICAoIWlzU3RhdGljRXhwKGtleSkgfHwgaXNLZXlib2FyZEV2ZW50KGtleS5jb250ZW50LnRvTG93ZXJDYXNlKCkpKSkge1xuICAgICAgaGFuZGxlckV4cCA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFZfT05fV0lUSF9LRVlTKSwgW1xuICAgICAgICBoYW5kbGVyRXhwLFxuICAgICAgICBKU09OLnN0cmluZ2lmeShrZXlNb2RpZmllcnMpXG4gICAgICBdKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50T3B0aW9uTW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgY29uc3QgbW9kaWZpZXJQb3N0Zml4ID0gZXZlbnRPcHRpb25Nb2RpZmllcnMubWFwKGNhcGl0YWxpemUpLmpvaW4oXCJcIik7XG4gICAgICBrZXkgPSBpc1N0YXRpY0V4cChrZXkpID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgJHtrZXkuY29udGVudH0ke21vZGlmaWVyUG9zdGZpeH1gLCB0cnVlKSA6IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYChgLCBrZXksIGApICsgXCIke21vZGlmaWVyUG9zdGZpeH1cImBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3BzOiBbY3JlYXRlT2JqZWN0UHJvcGVydHkoa2V5LCBoYW5kbGVyRXhwKV1cbiAgICB9O1xuICB9KTtcbn07XG5cbmNvbnN0IHRyYW5zZm9ybVNob3cgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcbiAgaWYgKCFleHApIHtcbiAgICBjb250ZXh0Lm9uRXJyb3IoXG4gICAgICBjcmVhdGVET01Db21waWxlckVycm9yKDYyLCBsb2MpXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHByb3BzOiBbXSxcbiAgICBuZWVkUnVudGltZTogY29udGV4dC5oZWxwZXIoVl9TSE9XKVxuICB9O1xufTtcblxuY29uc3QgdHJhbnNmb3JtVHJhbnNpdGlvbiA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEgJiYgbm9kZS50YWdUeXBlID09PSAxKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gY29udGV4dC5pc0J1aWx0SW5Db21wb25lbnQobm9kZS50YWcpO1xuICAgIGlmIChjb21wb25lbnQgPT09IFRSQU5TSVRJT04pIHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc011bHRpcGxlQ2hpbGRyZW4obm9kZSkpIHtcbiAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoXG4gICAgICAgICAgICBjcmVhdGVET01Db21waWxlckVycm9yKFxuICAgICAgICAgICAgICA2MyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBub2RlLmNoaWxkcmVuWzBdLmxvYy5zdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXS5sb2MuZW5kLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogXCJcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAxKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwIG9mIGNoaWxkLnByb3BzKSB7XG4gICAgICAgICAgICBpZiAocC50eXBlID09PSA3ICYmIHAubmFtZSA9PT0gXCJzaG93XCIpIHtcbiAgICAgICAgICAgICAgbm9kZS5wcm9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiA2LFxuICAgICAgICAgICAgICAgIG5hbWU6IFwicGVyc2lzdGVkXCIsXG4gICAgICAgICAgICAgICAgbmFtZUxvYzogbm9kZS5sb2MsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBsb2M6IG5vZGUubG9jXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBoYXNNdWx0aXBsZUNoaWxkcmVuKG5vZGUpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5maWx0ZXIoXG4gICAgKGMpID0+ICFpc0NvbW1lbnRPcldoaXRlc3BhY2UoYylcbiAgKTtcbiAgY29uc3QgY2hpbGQgPSBjaGlsZHJlblswXTtcbiAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBjaGlsZC50eXBlID09PSAxMSB8fCBjaGlsZC50eXBlID09PSA5ICYmIGNoaWxkLmJyYW5jaGVzLnNvbWUoaGFzTXVsdGlwbGVDaGlsZHJlbik7XG59XG5cbmNvbnN0IGlnbm9yZVNpZGVFZmZlY3RUYWdzID0gKG5vZGUsIGNvbnRleHQpID0+IHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSAmJiBub2RlLnRhZ1R5cGUgPT09IDAgJiYgKG5vZGUudGFnID09PSBcInNjcmlwdFwiIHx8IG5vZGUudGFnID09PSBcInN0eWxlXCIpKSB7XG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjb250ZXh0Lm9uRXJyb3IoXG4gICAgICBjcmVhdGVET01Db21waWxlckVycm9yKFxuICAgICAgICA2NCxcbiAgICAgICAgbm9kZS5sb2NcbiAgICAgIClcbiAgICApO1xuICAgIGNvbnRleHQucmVtb3ZlTm9kZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpc1ZhbGlkSFRNTE5lc3RpbmcocGFyZW50LCBjaGlsZCkge1xuICBpZiAocGFyZW50ID09PSBcInRlbXBsYXRlXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocGFyZW50IGluIG9ubHlWYWxpZENoaWxkcmVuKSB7XG4gICAgcmV0dXJuIG9ubHlWYWxpZENoaWxkcmVuW3BhcmVudF0uaGFzKGNoaWxkKTtcbiAgfVxuICBpZiAoY2hpbGQgaW4gb25seVZhbGlkUGFyZW50cykge1xuICAgIHJldHVybiBvbmx5VmFsaWRQYXJlbnRzW2NoaWxkXS5oYXMocGFyZW50KTtcbiAgfVxuICBpZiAocGFyZW50IGluIGtub3duSW52YWxpZENoaWxkcmVuKSB7XG4gICAgaWYgKGtub3duSW52YWxpZENoaWxkcmVuW3BhcmVudF0uaGFzKGNoaWxkKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjaGlsZCBpbiBrbm93bkludmFsaWRQYXJlbnRzKSB7XG4gICAgaWYgKGtub3duSW52YWxpZFBhcmVudHNbY2hpbGRdLmhhcyhwYXJlbnQpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBoZWFkaW5ncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImgxXCIsIFwiaDJcIiwgXCJoM1wiLCBcImg0XCIsIFwiaDVcIiwgXCJoNlwiXSk7XG5jb25zdCBlbXB0eVNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtdKTtcbmNvbnN0IG9ubHlWYWxpZENoaWxkcmVuID0ge1xuICBoZWFkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gICAgXCJiYXNlXCIsXG4gICAgXCJiYXNlZnJvbnRcIixcbiAgICBcImJnc291bmRcIixcbiAgICBcImxpbmtcIixcbiAgICBcIm1ldGFcIixcbiAgICBcInRpdGxlXCIsXG4gICAgXCJub3NjcmlwdFwiLFxuICAgIFwibm9mcmFtZXNcIixcbiAgICBcInN0eWxlXCIsXG4gICAgXCJzY3JpcHRcIixcbiAgICBcInRlbXBsYXRlXCJcbiAgXSksXG4gIG9wdGdyb3VwOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJvcHRpb25cIl0pLFxuICBzZWxlY3Q6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIm9wdGdyb3VwXCIsIFwib3B0aW9uXCIsIFwiaHJcIl0pLFxuICAvLyB0YWJsZVxuICB0YWJsZTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiY2FwdGlvblwiLCBcImNvbGdyb3VwXCIsIFwidGJvZHlcIiwgXCJ0Zm9vdFwiLCBcInRoZWFkXCJdKSxcbiAgdHI6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRkXCIsIFwidGhcIl0pLFxuICBjb2xncm91cDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiY29sXCJdKSxcbiAgdGJvZHk6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRyXCJdKSxcbiAgdGhlYWQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRyXCJdKSxcbiAgdGZvb3Q6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRyXCJdKSxcbiAgLy8gdGhlc2UgZWxlbWVudHMgY2FuIG5vdCBoYXZlIGFueSBjaGlsZHJlbiBlbGVtZW50c1xuICBzY3JpcHQ6IGVtcHR5U2V0LFxuICBpZnJhbWU6IGVtcHR5U2V0LFxuICBvcHRpb246IGVtcHR5U2V0LFxuICB0ZXh0YXJlYTogZW1wdHlTZXQsXG4gIHN0eWxlOiBlbXB0eVNldCxcbiAgdGl0bGU6IGVtcHR5U2V0XG59O1xuY29uc3Qgb25seVZhbGlkUGFyZW50cyA9IHtcbiAgLy8gc2VjdGlvbnNcbiAgaHRtbDogZW1wdHlTZXQsXG4gIGJvZHk6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImh0bWxcIl0pLFxuICBoZWFkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJodG1sXCJdKSxcbiAgLy8gdGFibGVcbiAgdGQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRyXCJdKSxcbiAgY29sZ3JvdXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRhYmxlXCJdKSxcbiAgY2FwdGlvbjogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widGFibGVcIl0pLFxuICB0Ym9keTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widGFibGVcIl0pLFxuICB0Zm9vdDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widGFibGVcIl0pLFxuICBjb2w6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImNvbGdyb3VwXCJdKSxcbiAgdGg6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRyXCJdKSxcbiAgdGhlYWQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRhYmxlXCJdKSxcbiAgdHI6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRib2R5XCIsIFwidGhlYWRcIiwgXCJ0Zm9vdFwiXSksXG4gIC8vIGRhdGEgbGlzdFxuICBkZDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZGxcIiwgXCJkaXZcIl0pLFxuICBkdDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZGxcIiwgXCJkaXZcIl0pLFxuICAvLyBvdGhlclxuICBmaWdjYXB0aW9uOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJmaWd1cmVcIl0pLFxuICAvLyBsaTogbmV3IFNldChbXCJ1bFwiLCBcIm9sXCJdKSxcbiAgc3VtbWFyeTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZGV0YWlsc1wiXSksXG4gIGFyZWE6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIm1hcFwiXSlcbn07XG5jb25zdCBrbm93bkludmFsaWRDaGlsZHJlbiA9IHtcbiAgcDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgIFwiYWRkcmVzc1wiLFxuICAgIFwiYXJ0aWNsZVwiLFxuICAgIFwiYXNpZGVcIixcbiAgICBcImJsb2NrcXVvdGVcIixcbiAgICBcImNlbnRlclwiLFxuICAgIFwiZGV0YWlsc1wiLFxuICAgIFwiZGlhbG9nXCIsXG4gICAgXCJkaXJcIixcbiAgICBcImRpdlwiLFxuICAgIFwiZGxcIixcbiAgICBcImZpZWxkc2V0XCIsXG4gICAgXCJmaWd1cmVcIixcbiAgICBcImZvb3RlclwiLFxuICAgIFwiZm9ybVwiLFxuICAgIFwiaDFcIixcbiAgICBcImgyXCIsXG4gICAgXCJoM1wiLFxuICAgIFwiaDRcIixcbiAgICBcImg1XCIsXG4gICAgXCJoNlwiLFxuICAgIFwiaGVhZGVyXCIsXG4gICAgXCJoZ3JvdXBcIixcbiAgICBcImhyXCIsXG4gICAgXCJsaVwiLFxuICAgIFwibWFpblwiLFxuICAgIFwibmF2XCIsXG4gICAgXCJtZW51XCIsXG4gICAgXCJvbFwiLFxuICAgIFwicFwiLFxuICAgIFwicHJlXCIsXG4gICAgXCJzZWN0aW9uXCIsXG4gICAgXCJ0YWJsZVwiLFxuICAgIFwidWxcIlxuICBdKSxcbiAgc3ZnOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gICAgXCJiXCIsXG4gICAgXCJibG9ja3F1b3RlXCIsXG4gICAgXCJiclwiLFxuICAgIFwiY29kZVwiLFxuICAgIFwiZGRcIixcbiAgICBcImRpdlwiLFxuICAgIFwiZGxcIixcbiAgICBcImR0XCIsXG4gICAgXCJlbVwiLFxuICAgIFwiZW1iZWRcIixcbiAgICBcImgxXCIsXG4gICAgXCJoMlwiLFxuICAgIFwiaDNcIixcbiAgICBcImg0XCIsXG4gICAgXCJoNVwiLFxuICAgIFwiaDZcIixcbiAgICBcImhyXCIsXG4gICAgXCJpXCIsXG4gICAgXCJpbWdcIixcbiAgICBcImxpXCIsXG4gICAgXCJtZW51XCIsXG4gICAgXCJtZXRhXCIsXG4gICAgXCJvbFwiLFxuICAgIFwicFwiLFxuICAgIFwicHJlXCIsXG4gICAgXCJydWJ5XCIsXG4gICAgXCJzXCIsXG4gICAgXCJzbWFsbFwiLFxuICAgIFwic3BhblwiLFxuICAgIFwic3Ryb25nXCIsXG4gICAgXCJzdWJcIixcbiAgICBcInN1cFwiLFxuICAgIFwidGFibGVcIixcbiAgICBcInVcIixcbiAgICBcInVsXCIsXG4gICAgXCJ2YXJcIlxuICBdKVxufTtcbmNvbnN0IGtub3duSW52YWxpZFBhcmVudHMgPSB7XG4gIGE6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImFcIl0pLFxuICBidXR0b246IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImJ1dHRvblwiXSksXG4gIGRkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJkZFwiLCBcImR0XCJdKSxcbiAgZHQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImRkXCIsIFwiZHRcIl0pLFxuICBmb3JtOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJmb3JtXCJdKSxcbiAgbGk6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImxpXCJdKSxcbiAgaDE6IGhlYWRpbmdzLFxuICBoMjogaGVhZGluZ3MsXG4gIGgzOiBoZWFkaW5ncyxcbiAgaDQ6IGhlYWRpbmdzLFxuICBoNTogaGVhZGluZ3MsXG4gIGg2OiBoZWFkaW5nc1xufTtcblxuY29uc3QgdmFsaWRhdGVIdG1sTmVzdGluZyA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEgJiYgbm9kZS50YWdUeXBlID09PSAwICYmIGNvbnRleHQucGFyZW50ICYmIGNvbnRleHQucGFyZW50LnR5cGUgPT09IDEgJiYgY29udGV4dC5wYXJlbnQudGFnVHlwZSA9PT0gMCAmJiAhaXNWYWxpZEhUTUxOZXN0aW5nKGNvbnRleHQucGFyZW50LnRhZywgbm9kZS50YWcpKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgPCR7bm9kZS50YWd9PiBjYW5ub3QgYmUgY2hpbGQgb2YgPCR7Y29udGV4dC5wYXJlbnQudGFnfT4sIGFjY29yZGluZyB0byBIVE1MIHNwZWNpZmljYXRpb25zLiBUaGlzIGNhbiBjYXVzZSBoeWRyYXRpb24gZXJyb3JzIG9yIHBvdGVudGlhbGx5IGRpc3J1cHQgZnV0dXJlIGZ1bmN0aW9uYWxpdHkuYFxuICAgICk7XG4gICAgZXJyb3IubG9jID0gbm9kZS5sb2M7XG4gICAgY29udGV4dC5vbldhcm4oZXJyb3IpO1xuICB9XG59O1xuXG5jb25zdCBET01Ob2RlVHJhbnNmb3JtcyA9IFtcbiAgdHJhbnNmb3JtU3R5bGUsXG4gIC4uLiEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBbdHJhbnNmb3JtVHJhbnNpdGlvbiwgdmFsaWRhdGVIdG1sTmVzdGluZ10gOiBbXVxuXTtcbmNvbnN0IERPTURpcmVjdGl2ZVRyYW5zZm9ybXMgPSB7XG4gIGNsb2FrOiBub29wRGlyZWN0aXZlVHJhbnNmb3JtLFxuICBodG1sOiB0cmFuc2Zvcm1WSHRtbCxcbiAgdGV4dDogdHJhbnNmb3JtVlRleHQsXG4gIG1vZGVsOiB0cmFuc2Zvcm1Nb2RlbCxcbiAgLy8gb3ZlcnJpZGUgY29tcGlsZXItY29yZVxuICBvbjogdHJhbnNmb3JtT24sXG4gIC8vIG92ZXJyaWRlIGNvbXBpbGVyLWNvcmVcbiAgc2hvdzogdHJhbnNmb3JtU2hvd1xufTtcbmZ1bmN0aW9uIGNvbXBpbGUoc3JjLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIGJhc2VDb21waWxlKFxuICAgIHNyYyxcbiAgICBleHRlbmQoe30sIHBhcnNlck9wdGlvbnMsIG9wdGlvbnMsIHtcbiAgICAgIG5vZGVUcmFuc2Zvcm1zOiBbXG4gICAgICAgIC8vIGlnbm9yZSA8c2NyaXB0PiBhbmQgPHRhZz5cbiAgICAgICAgLy8gdGhpcyBpcyBub3QgcHV0IGluc2lkZSBET01Ob2RlVHJhbnNmb3JtcyBiZWNhdXNlIHRoYXQgbGlzdCBpcyB1c2VkXG4gICAgICAgIC8vIGJ5IGNvbXBpbGVyLXNzciB0byBnZW5lcmF0ZSB2bm9kZSBmYWxsYmFjayBicmFuY2hlc1xuICAgICAgICBpZ25vcmVTaWRlRWZmZWN0VGFncyxcbiAgICAgICAgLi4uRE9NTm9kZVRyYW5zZm9ybXMsXG4gICAgICAgIC4uLm9wdGlvbnMubm9kZVRyYW5zZm9ybXMgfHwgW11cbiAgICAgIF0sXG4gICAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zOiBleHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICBET01EaXJlY3RpdmVUcmFuc2Zvcm1zLFxuICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZVRyYW5zZm9ybXMgfHwge31cbiAgICAgICksXG4gICAgICB0cmFuc2Zvcm1Ib2lzdDogbnVsbCBcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gYmFzZVBhcnNlKHRlbXBsYXRlLCBleHRlbmQoe30sIHBhcnNlck9wdGlvbnMsIG9wdGlvbnMpKTtcbn1cblxuZXhwb3J0IHsgRE9NRGlyZWN0aXZlVHJhbnNmb3JtcywgRE9NRXJyb3JDb2RlcywgRE9NRXJyb3JNZXNzYWdlcywgRE9NTm9kZVRyYW5zZm9ybXMsIFRSQU5TSVRJT04sIFRSQU5TSVRJT05fR1JPVVAsIFZfTU9ERUxfQ0hFQ0tCT1gsIFZfTU9ERUxfRFlOQU1JQywgVl9NT0RFTF9SQURJTywgVl9NT0RFTF9TRUxFQ1QsIFZfTU9ERUxfVEVYVCwgVl9PTl9XSVRIX0tFWVMsIFZfT05fV0lUSF9NT0RJRklFUlMsIFZfU0hPVywgY29tcGlsZSwgY3JlYXRlRE9NQ29tcGlsZXJFcnJvciwgcGFyc2UsIHBhcnNlck9wdGlvbnMsIHRyYW5zZm9ybVN0eWxlIH07XG4iLCJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXNtID0gKGZuLCByZXMpID0+IGZ1bmN0aW9uIF9faW5pdCgpIHtcbiAgcmV0dXJuIGZuICYmIChyZXMgPSAoMCwgZm5bX19nZXRPd25Qcm9wTmFtZXMoZm4pWzBdXSkoZm4gPSAwKSksIHJlcztcbn07XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0MjIpID0+ICh0YXJnZXQyMiA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0MjIsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQyMixcbiAgbW9kXG4pKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3RzdXBAOC40LjBfQG1pY3Jvc29mdCthcGktZXh0cmFjdG9yQDcuNTEuMV9AdHlwZXMrbm9kZUAyMi4xMy4xNF9faml0aUAyLjQuMl9wb3N0Y3NzQDguNV85NmViMDVhOWQ2NTM0MzAyMWU1Mzc5MWRkODNmMzc3My9ub2RlX21vZHVsZXMvdHN1cC9hc3NldHMvZXNtX3NoaW1zLmpzXG52YXIgaW5pdF9lc21fc2hpbXMgPSBfX2VzbSh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3RzdXBAOC40LjBfQG1pY3Jvc29mdCthcGktZXh0cmFjdG9yQDcuNTEuMV9AdHlwZXMrbm9kZUAyMi4xMy4xNF9faml0aUAyLjQuMl9wb3N0Y3NzQDguNV85NmViMDVhOWQ2NTM0MzAyMWU1Mzc5MWRkODNmMzc3My9ub2RlX21vZHVsZXMvdHN1cC9hc3NldHMvZXNtX3NoaW1zLmpzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3BlYWtpbmd1cmxAMTQuMC4xL25vZGVfbW9kdWxlcy9zcGVha2luZ3VybC9saWIvc3BlYWtpbmd1cmwuanNcbnZhciByZXF1aXJlX3NwZWFraW5ndXJsID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NwZWFraW5ndXJsQDE0LjAuMS9ub2RlX21vZHVsZXMvc3BlYWtpbmd1cmwvbGliL3NwZWFraW5ndXJsLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9lc21fc2hpbXMoKTtcbiAgICAoZnVuY3Rpb24ocm9vdCkge1xuICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICB2YXIgY2hhck1hcCA9IHtcbiAgICAgICAgLy8gbGF0aW5cbiAgICAgICAgXCJcXHhDMFwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDMVwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDMlwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDM1wiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDNFwiOiBcIkFlXCIsXG4gICAgICAgIFwiXFx4QzVcIjogXCJBXCIsXG4gICAgICAgIFwiXFx4QzZcIjogXCJBRVwiLFxuICAgICAgICBcIlxceEM3XCI6IFwiQ1wiLFxuICAgICAgICBcIlxceEM4XCI6IFwiRVwiLFxuICAgICAgICBcIlxceEM5XCI6IFwiRVwiLFxuICAgICAgICBcIlxceENBXCI6IFwiRVwiLFxuICAgICAgICBcIlxceENCXCI6IFwiRVwiLFxuICAgICAgICBcIlxceENDXCI6IFwiSVwiLFxuICAgICAgICBcIlxceENEXCI6IFwiSVwiLFxuICAgICAgICBcIlxceENFXCI6IFwiSVwiLFxuICAgICAgICBcIlxceENGXCI6IFwiSVwiLFxuICAgICAgICBcIlxceEQwXCI6IFwiRFwiLFxuICAgICAgICBcIlxceEQxXCI6IFwiTlwiLFxuICAgICAgICBcIlxceEQyXCI6IFwiT1wiLFxuICAgICAgICBcIlxceEQzXCI6IFwiT1wiLFxuICAgICAgICBcIlxceEQ0XCI6IFwiT1wiLFxuICAgICAgICBcIlxceEQ1XCI6IFwiT1wiLFxuICAgICAgICBcIlxceEQ2XCI6IFwiT2VcIixcbiAgICAgICAgXCJcXHUwMTUwXCI6IFwiT1wiLFxuICAgICAgICBcIlxceEQ4XCI6IFwiT1wiLFxuICAgICAgICBcIlxceEQ5XCI6IFwiVVwiLFxuICAgICAgICBcIlxceERBXCI6IFwiVVwiLFxuICAgICAgICBcIlxceERCXCI6IFwiVVwiLFxuICAgICAgICBcIlxceERDXCI6IFwiVWVcIixcbiAgICAgICAgXCJcXHUwMTcwXCI6IFwiVVwiLFxuICAgICAgICBcIlxceEREXCI6IFwiWVwiLFxuICAgICAgICBcIlxceERFXCI6IFwiVEhcIixcbiAgICAgICAgXCJcXHhERlwiOiBcInNzXCIsXG4gICAgICAgIFwiXFx4RTBcIjogXCJhXCIsXG4gICAgICAgIFwiXFx4RTFcIjogXCJhXCIsXG4gICAgICAgIFwiXFx4RTJcIjogXCJhXCIsXG4gICAgICAgIFwiXFx4RTNcIjogXCJhXCIsXG4gICAgICAgIFwiXFx4RTRcIjogXCJhZVwiLFxuICAgICAgICBcIlxceEU1XCI6IFwiYVwiLFxuICAgICAgICBcIlxceEU2XCI6IFwiYWVcIixcbiAgICAgICAgXCJcXHhFN1wiOiBcImNcIixcbiAgICAgICAgXCJcXHhFOFwiOiBcImVcIixcbiAgICAgICAgXCJcXHhFOVwiOiBcImVcIixcbiAgICAgICAgXCJcXHhFQVwiOiBcImVcIixcbiAgICAgICAgXCJcXHhFQlwiOiBcImVcIixcbiAgICAgICAgXCJcXHhFQ1wiOiBcImlcIixcbiAgICAgICAgXCJcXHhFRFwiOiBcImlcIixcbiAgICAgICAgXCJcXHhFRVwiOiBcImlcIixcbiAgICAgICAgXCJcXHhFRlwiOiBcImlcIixcbiAgICAgICAgXCJcXHhGMFwiOiBcImRcIixcbiAgICAgICAgXCJcXHhGMVwiOiBcIm5cIixcbiAgICAgICAgXCJcXHhGMlwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGM1wiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGNFwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGNVwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGNlwiOiBcIm9lXCIsXG4gICAgICAgIFwiXFx1MDE1MVwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGOFwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGOVwiOiBcInVcIixcbiAgICAgICAgXCJcXHhGQVwiOiBcInVcIixcbiAgICAgICAgXCJcXHhGQlwiOiBcInVcIixcbiAgICAgICAgXCJcXHhGQ1wiOiBcInVlXCIsXG4gICAgICAgIFwiXFx1MDE3MVwiOiBcInVcIixcbiAgICAgICAgXCJcXHhGRFwiOiBcInlcIixcbiAgICAgICAgXCJcXHhGRVwiOiBcInRoXCIsXG4gICAgICAgIFwiXFx4RkZcIjogXCJ5XCIsXG4gICAgICAgIFwiXFx1MUU5RVwiOiBcIlNTXCIsXG4gICAgICAgIC8vIGxhbmd1YWdlIHNwZWNpZmljXG4gICAgICAgIC8vIEFyYWJpY1xuICAgICAgICBcIlxcdTA2MjdcIjogXCJhXCIsXG4gICAgICAgIFwiXFx1MDYyM1wiOiBcImFcIixcbiAgICAgICAgXCJcXHUwNjI1XCI6IFwiaVwiLFxuICAgICAgICBcIlxcdTA2MjJcIjogXCJhYVwiLFxuICAgICAgICBcIlxcdTA2MjRcIjogXCJ1XCIsXG4gICAgICAgIFwiXFx1MDYyNlwiOiBcImVcIixcbiAgICAgICAgXCJcXHUwNjIxXCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTA2MjhcIjogXCJiXCIsXG4gICAgICAgIFwiXFx1MDYyQVwiOiBcInRcIixcbiAgICAgICAgXCJcXHUwNjJCXCI6IFwidGhcIixcbiAgICAgICAgXCJcXHUwNjJDXCI6IFwialwiLFxuICAgICAgICBcIlxcdTA2MkRcIjogXCJoXCIsXG4gICAgICAgIFwiXFx1MDYyRVwiOiBcImtoXCIsXG4gICAgICAgIFwiXFx1MDYyRlwiOiBcImRcIixcbiAgICAgICAgXCJcXHUwNjMwXCI6IFwidGhcIixcbiAgICAgICAgXCJcXHUwNjMxXCI6IFwiclwiLFxuICAgICAgICBcIlxcdTA2MzJcIjogXCJ6XCIsXG4gICAgICAgIFwiXFx1MDYzM1wiOiBcInNcIixcbiAgICAgICAgXCJcXHUwNjM0XCI6IFwic2hcIixcbiAgICAgICAgXCJcXHUwNjM1XCI6IFwic1wiLFxuICAgICAgICBcIlxcdTA2MzZcIjogXCJkaFwiLFxuICAgICAgICBcIlxcdTA2MzdcIjogXCJ0XCIsXG4gICAgICAgIFwiXFx1MDYzOFwiOiBcInpcIixcbiAgICAgICAgXCJcXHUwNjM5XCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTA2M0FcIjogXCJnaFwiLFxuICAgICAgICBcIlxcdTA2NDFcIjogXCJmXCIsXG4gICAgICAgIFwiXFx1MDY0MlwiOiBcInFcIixcbiAgICAgICAgXCJcXHUwNjQzXCI6IFwia1wiLFxuICAgICAgICBcIlxcdTA2NDRcIjogXCJsXCIsXG4gICAgICAgIFwiXFx1MDY0NVwiOiBcIm1cIixcbiAgICAgICAgXCJcXHUwNjQ2XCI6IFwiblwiLFxuICAgICAgICBcIlxcdTA2NDdcIjogXCJoXCIsXG4gICAgICAgIFwiXFx1MDY0OFwiOiBcIndcIixcbiAgICAgICAgXCJcXHUwNjRBXCI6IFwieVwiLFxuICAgICAgICBcIlxcdTA2NDlcIjogXCJhXCIsXG4gICAgICAgIFwiXFx1MDYyOVwiOiBcImhcIixcbiAgICAgICAgXCJcXHVGRUZCXCI6IFwibGFcIixcbiAgICAgICAgXCJcXHVGRUY3XCI6IFwibGFhXCIsXG4gICAgICAgIFwiXFx1RkVGOVwiOiBcImxhaVwiLFxuICAgICAgICBcIlxcdUZFRjVcIjogXCJsYWFcIixcbiAgICAgICAgLy8gUGVyc2lhbiBhZGRpdGlvbmFsIGNoYXJhY3RlcnMgdGhhbiBBcmFiaWNcbiAgICAgICAgXCJcXHUwNkFGXCI6IFwiZ1wiLFxuICAgICAgICBcIlxcdTA2ODZcIjogXCJjaFwiLFxuICAgICAgICBcIlxcdTA2N0VcIjogXCJwXCIsXG4gICAgICAgIFwiXFx1MDY5OFwiOiBcInpoXCIsXG4gICAgICAgIFwiXFx1MDZBOVwiOiBcImtcIixcbiAgICAgICAgXCJcXHUwNkNDXCI6IFwieVwiLFxuICAgICAgICAvLyBBcmFiaWMgZGlhY3RyaWNzXG4gICAgICAgIFwiXFx1MDY0RVwiOiBcImFcIixcbiAgICAgICAgXCJcXHUwNjRCXCI6IFwiYW5cIixcbiAgICAgICAgXCJcXHUwNjUwXCI6IFwiZVwiLFxuICAgICAgICBcIlxcdTA2NERcIjogXCJlblwiLFxuICAgICAgICBcIlxcdTA2NEZcIjogXCJ1XCIsXG4gICAgICAgIFwiXFx1MDY0Q1wiOiBcIm9uXCIsXG4gICAgICAgIFwiXFx1MDY1MlwiOiBcIlwiLFxuICAgICAgICAvLyBBcmFiaWMgbnVtYmVyc1xuICAgICAgICBcIlxcdTA2NjBcIjogXCIwXCIsXG4gICAgICAgIFwiXFx1MDY2MVwiOiBcIjFcIixcbiAgICAgICAgXCJcXHUwNjYyXCI6IFwiMlwiLFxuICAgICAgICBcIlxcdTA2NjNcIjogXCIzXCIsXG4gICAgICAgIFwiXFx1MDY2NFwiOiBcIjRcIixcbiAgICAgICAgXCJcXHUwNjY1XCI6IFwiNVwiLFxuICAgICAgICBcIlxcdTA2NjZcIjogXCI2XCIsXG4gICAgICAgIFwiXFx1MDY2N1wiOiBcIjdcIixcbiAgICAgICAgXCJcXHUwNjY4XCI6IFwiOFwiLFxuICAgICAgICBcIlxcdTA2NjlcIjogXCI5XCIsXG4gICAgICAgIC8vIFBlcnNpYW4gbnVtYmVyc1xuICAgICAgICBcIlxcdTA2RjBcIjogXCIwXCIsXG4gICAgICAgIFwiXFx1MDZGMVwiOiBcIjFcIixcbiAgICAgICAgXCJcXHUwNkYyXCI6IFwiMlwiLFxuICAgICAgICBcIlxcdTA2RjNcIjogXCIzXCIsXG4gICAgICAgIFwiXFx1MDZGNFwiOiBcIjRcIixcbiAgICAgICAgXCJcXHUwNkY1XCI6IFwiNVwiLFxuICAgICAgICBcIlxcdTA2RjZcIjogXCI2XCIsXG4gICAgICAgIFwiXFx1MDZGN1wiOiBcIjdcIixcbiAgICAgICAgXCJcXHUwNkY4XCI6IFwiOFwiLFxuICAgICAgICBcIlxcdTA2RjlcIjogXCI5XCIsXG4gICAgICAgIC8vIEJ1cm1lc2UgY29uc29uYW50c1xuICAgICAgICBcIlxcdTEwMDBcIjogXCJrXCIsXG4gICAgICAgIFwiXFx1MTAwMVwiOiBcImtoXCIsXG4gICAgICAgIFwiXFx1MTAwMlwiOiBcImdcIixcbiAgICAgICAgXCJcXHUxMDAzXCI6IFwiZ2FcIixcbiAgICAgICAgXCJcXHUxMDA0XCI6IFwibmdcIixcbiAgICAgICAgXCJcXHUxMDA1XCI6IFwic1wiLFxuICAgICAgICBcIlxcdTEwMDZcIjogXCJzYVwiLFxuICAgICAgICBcIlxcdTEwMDdcIjogXCJ6XCIsXG4gICAgICAgIFwiXFx1MTAwNVxcdTEwM0JcIjogXCJ6YVwiLFxuICAgICAgICBcIlxcdTEwMEFcIjogXCJueVwiLFxuICAgICAgICBcIlxcdTEwMEJcIjogXCJ0XCIsXG4gICAgICAgIFwiXFx1MTAwQ1wiOiBcInRhXCIsXG4gICAgICAgIFwiXFx1MTAwRFwiOiBcImRcIixcbiAgICAgICAgXCJcXHUxMDBFXCI6IFwiZGFcIixcbiAgICAgICAgXCJcXHUxMDBGXCI6IFwibmFcIixcbiAgICAgICAgXCJcXHUxMDEwXCI6IFwidFwiLFxuICAgICAgICBcIlxcdTEwMTFcIjogXCJ0YVwiLFxuICAgICAgICBcIlxcdTEwMTJcIjogXCJkXCIsXG4gICAgICAgIFwiXFx1MTAxM1wiOiBcImRhXCIsXG4gICAgICAgIFwiXFx1MTAxNFwiOiBcIm5cIixcbiAgICAgICAgXCJcXHUxMDE1XCI6IFwicFwiLFxuICAgICAgICBcIlxcdTEwMTZcIjogXCJwYVwiLFxuICAgICAgICBcIlxcdTEwMTdcIjogXCJiXCIsXG4gICAgICAgIFwiXFx1MTAxOFwiOiBcImJhXCIsXG4gICAgICAgIFwiXFx1MTAxOVwiOiBcIm1cIixcbiAgICAgICAgXCJcXHUxMDFBXCI6IFwieVwiLFxuICAgICAgICBcIlxcdTEwMUJcIjogXCJ5YVwiLFxuICAgICAgICBcIlxcdTEwMUNcIjogXCJsXCIsXG4gICAgICAgIFwiXFx1MTAxRFwiOiBcIndcIixcbiAgICAgICAgXCJcXHUxMDFFXCI6IFwidGhcIixcbiAgICAgICAgXCJcXHUxMDFGXCI6IFwiaFwiLFxuICAgICAgICBcIlxcdTEwMjBcIjogXCJsYVwiLFxuICAgICAgICBcIlxcdTEwMjFcIjogXCJhXCIsXG4gICAgICAgIC8vIGNvbnNvbmFudCBjaGFyYWN0ZXIgY29tYm9zXG4gICAgICAgIFwiXFx1MTAzQ1wiOiBcInlcIixcbiAgICAgICAgXCJcXHUxMDNCXCI6IFwieWFcIixcbiAgICAgICAgXCJcXHUxMDNEXCI6IFwid1wiLFxuICAgICAgICBcIlxcdTEwM0NcXHUxMDNEXCI6IFwieXdcIixcbiAgICAgICAgXCJcXHUxMDNCXFx1MTAzRFwiOiBcInl3YVwiLFxuICAgICAgICBcIlxcdTEwM0VcIjogXCJoXCIsXG4gICAgICAgIC8vIGluZGVwZW5kZW50IHZvd2Vsc1xuICAgICAgICBcIlxcdTEwMjdcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MTA0RlwiOiBcIi1lXCIsXG4gICAgICAgIFwiXFx1MTAyM1wiOiBcImlcIixcbiAgICAgICAgXCJcXHUxMDI0XCI6IFwiLWlcIixcbiAgICAgICAgXCJcXHUxMDA5XCI6IFwidVwiLFxuICAgICAgICBcIlxcdTEwMjZcIjogXCItdVwiLFxuICAgICAgICBcIlxcdTEwMjlcIjogXCJhd1wiLFxuICAgICAgICBcIlxcdTEwMUVcXHUxMDNDXFx1MTAzMVxcdTEwMkNcIjogXCJhd1wiLFxuICAgICAgICBcIlxcdTEwMkFcIjogXCJhd1wiLFxuICAgICAgICAvLyBudW1iZXJzXG4gICAgICAgIFwiXFx1MTA0MFwiOiBcIjBcIixcbiAgICAgICAgXCJcXHUxMDQxXCI6IFwiMVwiLFxuICAgICAgICBcIlxcdTEwNDJcIjogXCIyXCIsXG4gICAgICAgIFwiXFx1MTA0M1wiOiBcIjNcIixcbiAgICAgICAgXCJcXHUxMDQ0XCI6IFwiNFwiLFxuICAgICAgICBcIlxcdTEwNDVcIjogXCI1XCIsXG4gICAgICAgIFwiXFx1MTA0NlwiOiBcIjZcIixcbiAgICAgICAgXCJcXHUxMDQ3XCI6IFwiN1wiLFxuICAgICAgICBcIlxcdTEwNDhcIjogXCI4XCIsXG4gICAgICAgIFwiXFx1MTA0OVwiOiBcIjlcIixcbiAgICAgICAgLy8gdmlyYW1hIGFuZCB0b25lIG1hcmtzIHdoaWNoIGFyZSBzaWxlbnQgaW4gdHJhbnNsaXRlcmF0aW9uXG4gICAgICAgIFwiXFx1MTAzOVwiOiBcIlwiLFxuICAgICAgICBcIlxcdTEwMzdcIjogXCJcIixcbiAgICAgICAgXCJcXHUxMDM4XCI6IFwiXCIsXG4gICAgICAgIC8vIEN6ZWNoXG4gICAgICAgIFwiXFx1MDEwRFwiOiBcImNcIixcbiAgICAgICAgXCJcXHUwMTBGXCI6IFwiZFwiLFxuICAgICAgICBcIlxcdTAxMUJcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MDE0OFwiOiBcIm5cIixcbiAgICAgICAgXCJcXHUwMTU5XCI6IFwiclwiLFxuICAgICAgICBcIlxcdTAxNjFcIjogXCJzXCIsXG4gICAgICAgIFwiXFx1MDE2NVwiOiBcInRcIixcbiAgICAgICAgXCJcXHUwMTZGXCI6IFwidVwiLFxuICAgICAgICBcIlxcdTAxN0VcIjogXCJ6XCIsXG4gICAgICAgIFwiXFx1MDEwQ1wiOiBcIkNcIixcbiAgICAgICAgXCJcXHUwMTBFXCI6IFwiRFwiLFxuICAgICAgICBcIlxcdTAxMUFcIjogXCJFXCIsXG4gICAgICAgIFwiXFx1MDE0N1wiOiBcIk5cIixcbiAgICAgICAgXCJcXHUwMTU4XCI6IFwiUlwiLFxuICAgICAgICBcIlxcdTAxNjBcIjogXCJTXCIsXG4gICAgICAgIFwiXFx1MDE2NFwiOiBcIlRcIixcbiAgICAgICAgXCJcXHUwMTZFXCI6IFwiVVwiLFxuICAgICAgICBcIlxcdTAxN0RcIjogXCJaXCIsXG4gICAgICAgIC8vIERoaXZlaGlcbiAgICAgICAgXCJcXHUwNzgwXCI6IFwiaFwiLFxuICAgICAgICBcIlxcdTA3ODFcIjogXCJzaFwiLFxuICAgICAgICBcIlxcdTA3ODJcIjogXCJuXCIsXG4gICAgICAgIFwiXFx1MDc4M1wiOiBcInJcIixcbiAgICAgICAgXCJcXHUwNzg0XCI6IFwiYlwiLFxuICAgICAgICBcIlxcdTA3ODVcIjogXCJsaFwiLFxuICAgICAgICBcIlxcdTA3ODZcIjogXCJrXCIsXG4gICAgICAgIFwiXFx1MDc4N1wiOiBcImFcIixcbiAgICAgICAgXCJcXHUwNzg4XCI6IFwidlwiLFxuICAgICAgICBcIlxcdTA3ODlcIjogXCJtXCIsXG4gICAgICAgIFwiXFx1MDc4QVwiOiBcImZcIixcbiAgICAgICAgXCJcXHUwNzhCXCI6IFwiZGhcIixcbiAgICAgICAgXCJcXHUwNzhDXCI6IFwidGhcIixcbiAgICAgICAgXCJcXHUwNzhEXCI6IFwibFwiLFxuICAgICAgICBcIlxcdTA3OEVcIjogXCJnXCIsXG4gICAgICAgIFwiXFx1MDc4RlwiOiBcImduXCIsXG4gICAgICAgIFwiXFx1MDc5MFwiOiBcInNcIixcbiAgICAgICAgXCJcXHUwNzkxXCI6IFwiZFwiLFxuICAgICAgICBcIlxcdTA3OTJcIjogXCJ6XCIsXG4gICAgICAgIFwiXFx1MDc5M1wiOiBcInRcIixcbiAgICAgICAgXCJcXHUwNzk0XCI6IFwieVwiLFxuICAgICAgICBcIlxcdTA3OTVcIjogXCJwXCIsXG4gICAgICAgIFwiXFx1MDc5NlwiOiBcImpcIixcbiAgICAgICAgXCJcXHUwNzk3XCI6IFwiY2hcIixcbiAgICAgICAgXCJcXHUwNzk4XCI6IFwidHRcIixcbiAgICAgICAgXCJcXHUwNzk5XCI6IFwiaGhcIixcbiAgICAgICAgXCJcXHUwNzlBXCI6IFwia2hcIixcbiAgICAgICAgXCJcXHUwNzlCXCI6IFwidGhcIixcbiAgICAgICAgXCJcXHUwNzlDXCI6IFwielwiLFxuICAgICAgICBcIlxcdTA3OURcIjogXCJzaFwiLFxuICAgICAgICBcIlxcdTA3OUVcIjogXCJzXCIsXG4gICAgICAgIFwiXFx1MDc5RlwiOiBcImRcIixcbiAgICAgICAgXCJcXHUwN0EwXCI6IFwidFwiLFxuICAgICAgICBcIlxcdTA3QTFcIjogXCJ6XCIsXG4gICAgICAgIFwiXFx1MDdBMlwiOiBcImFcIixcbiAgICAgICAgXCJcXHUwN0EzXCI6IFwiZ2hcIixcbiAgICAgICAgXCJcXHUwN0E0XCI6IFwicVwiLFxuICAgICAgICBcIlxcdTA3QTVcIjogXCJ3XCIsXG4gICAgICAgIFwiXFx1MDdBNlwiOiBcImFcIixcbiAgICAgICAgXCJcXHUwN0E3XCI6IFwiYWFcIixcbiAgICAgICAgXCJcXHUwN0E4XCI6IFwiaVwiLFxuICAgICAgICBcIlxcdTA3QTlcIjogXCJlZVwiLFxuICAgICAgICBcIlxcdTA3QUFcIjogXCJ1XCIsXG4gICAgICAgIFwiXFx1MDdBQlwiOiBcIm9vXCIsXG4gICAgICAgIFwiXFx1MDdBQ1wiOiBcImVcIixcbiAgICAgICAgXCJcXHUwN0FEXCI6IFwiZXlcIixcbiAgICAgICAgXCJcXHUwN0FFXCI6IFwib1wiLFxuICAgICAgICBcIlxcdTA3QUZcIjogXCJvYVwiLFxuICAgICAgICBcIlxcdTA3QjBcIjogXCJcIixcbiAgICAgICAgLy8gR2VvcmdpYW4gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm9tYW5pemF0aW9uX29mX0dlb3JnaWFuXG4gICAgICAgIC8vIE5hdGlvbmFsIHN5c3RlbSAoMjAwMilcbiAgICAgICAgXCJcXHUxMEQwXCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTEwRDFcIjogXCJiXCIsXG4gICAgICAgIFwiXFx1MTBEMlwiOiBcImdcIixcbiAgICAgICAgXCJcXHUxMEQzXCI6IFwiZFwiLFxuICAgICAgICBcIlxcdTEwRDRcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MTBENVwiOiBcInZcIixcbiAgICAgICAgXCJcXHUxMEQ2XCI6IFwielwiLFxuICAgICAgICBcIlxcdTEwRDdcIjogXCJ0XCIsXG4gICAgICAgIFwiXFx1MTBEOFwiOiBcImlcIixcbiAgICAgICAgXCJcXHUxMEQ5XCI6IFwia1wiLFxuICAgICAgICBcIlxcdTEwREFcIjogXCJsXCIsXG4gICAgICAgIFwiXFx1MTBEQlwiOiBcIm1cIixcbiAgICAgICAgXCJcXHUxMERDXCI6IFwiblwiLFxuICAgICAgICBcIlxcdTEwRERcIjogXCJvXCIsXG4gICAgICAgIFwiXFx1MTBERVwiOiBcInBcIixcbiAgICAgICAgXCJcXHUxMERGXCI6IFwiemhcIixcbiAgICAgICAgXCJcXHUxMEUwXCI6IFwiclwiLFxuICAgICAgICBcIlxcdTEwRTFcIjogXCJzXCIsXG4gICAgICAgIFwiXFx1MTBFMlwiOiBcInRcIixcbiAgICAgICAgXCJcXHUxMEUzXCI6IFwidVwiLFxuICAgICAgICBcIlxcdTEwRTRcIjogXCJwXCIsXG4gICAgICAgIFwiXFx1MTBFNVwiOiBcImtcIixcbiAgICAgICAgXCJcXHUxMEU2XCI6IFwiZ2hcIixcbiAgICAgICAgXCJcXHUxMEU3XCI6IFwicVwiLFxuICAgICAgICBcIlxcdTEwRThcIjogXCJzaFwiLFxuICAgICAgICBcIlxcdTEwRTlcIjogXCJjaFwiLFxuICAgICAgICBcIlxcdTEwRUFcIjogXCJ0c1wiLFxuICAgICAgICBcIlxcdTEwRUJcIjogXCJkelwiLFxuICAgICAgICBcIlxcdTEwRUNcIjogXCJ0c1wiLFxuICAgICAgICBcIlxcdTEwRURcIjogXCJjaFwiLFxuICAgICAgICBcIlxcdTEwRUVcIjogXCJraFwiLFxuICAgICAgICBcIlxcdTEwRUZcIjogXCJqXCIsXG4gICAgICAgIFwiXFx1MTBGMFwiOiBcImhcIixcbiAgICAgICAgLy8gR3JlZWtcbiAgICAgICAgXCJcXHUwM0IxXCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTAzQjJcIjogXCJ2XCIsXG4gICAgICAgIFwiXFx1MDNCM1wiOiBcImdcIixcbiAgICAgICAgXCJcXHUwM0I0XCI6IFwiZFwiLFxuICAgICAgICBcIlxcdTAzQjVcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MDNCNlwiOiBcInpcIixcbiAgICAgICAgXCJcXHUwM0I3XCI6IFwiaVwiLFxuICAgICAgICBcIlxcdTAzQjhcIjogXCJ0aFwiLFxuICAgICAgICBcIlxcdTAzQjlcIjogXCJpXCIsXG4gICAgICAgIFwiXFx1MDNCQVwiOiBcImtcIixcbiAgICAgICAgXCJcXHUwM0JCXCI6IFwibFwiLFxuICAgICAgICBcIlxcdTAzQkNcIjogXCJtXCIsXG4gICAgICAgIFwiXFx1MDNCRFwiOiBcIm5cIixcbiAgICAgICAgXCJcXHUwM0JFXCI6IFwia3NcIixcbiAgICAgICAgXCJcXHUwM0JGXCI6IFwib1wiLFxuICAgICAgICBcIlxcdTAzQzBcIjogXCJwXCIsXG4gICAgICAgIFwiXFx1MDNDMVwiOiBcInJcIixcbiAgICAgICAgXCJcXHUwM0MzXCI6IFwic1wiLFxuICAgICAgICBcIlxcdTAzQzRcIjogXCJ0XCIsXG4gICAgICAgIFwiXFx1MDNDNVwiOiBcInlcIixcbiAgICAgICAgXCJcXHUwM0M2XCI6IFwiZlwiLFxuICAgICAgICBcIlxcdTAzQzdcIjogXCJ4XCIsXG4gICAgICAgIFwiXFx1MDNDOFwiOiBcInBzXCIsXG4gICAgICAgIFwiXFx1MDNDOVwiOiBcIm9cIixcbiAgICAgICAgXCJcXHUwM0FDXCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTAzQURcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MDNBRlwiOiBcImlcIixcbiAgICAgICAgXCJcXHUwM0NDXCI6IFwib1wiLFxuICAgICAgICBcIlxcdTAzQ0RcIjogXCJ5XCIsXG4gICAgICAgIFwiXFx1MDNBRVwiOiBcImlcIixcbiAgICAgICAgXCJcXHUwM0NFXCI6IFwib1wiLFxuICAgICAgICBcIlxcdTAzQzJcIjogXCJzXCIsXG4gICAgICAgIFwiXFx1MDNDQVwiOiBcImlcIixcbiAgICAgICAgXCJcXHUwM0IwXCI6IFwieVwiLFxuICAgICAgICBcIlxcdTAzQ0JcIjogXCJ5XCIsXG4gICAgICAgIFwiXFx1MDM5MFwiOiBcImlcIixcbiAgICAgICAgXCJcXHUwMzkxXCI6IFwiQVwiLFxuICAgICAgICBcIlxcdTAzOTJcIjogXCJCXCIsXG4gICAgICAgIFwiXFx1MDM5M1wiOiBcIkdcIixcbiAgICAgICAgXCJcXHUwMzk0XCI6IFwiRFwiLFxuICAgICAgICBcIlxcdTAzOTVcIjogXCJFXCIsXG4gICAgICAgIFwiXFx1MDM5NlwiOiBcIlpcIixcbiAgICAgICAgXCJcXHUwMzk3XCI6IFwiSVwiLFxuICAgICAgICBcIlxcdTAzOThcIjogXCJUSFwiLFxuICAgICAgICBcIlxcdTAzOTlcIjogXCJJXCIsXG4gICAgICAgIFwiXFx1MDM5QVwiOiBcIktcIixcbiAgICAgICAgXCJcXHUwMzlCXCI6IFwiTFwiLFxuICAgICAgICBcIlxcdTAzOUNcIjogXCJNXCIsXG4gICAgICAgIFwiXFx1MDM5RFwiOiBcIk5cIixcbiAgICAgICAgXCJcXHUwMzlFXCI6IFwiS1NcIixcbiAgICAgICAgXCJcXHUwMzlGXCI6IFwiT1wiLFxuICAgICAgICBcIlxcdTAzQTBcIjogXCJQXCIsXG4gICAgICAgIFwiXFx1MDNBMVwiOiBcIlJcIixcbiAgICAgICAgXCJcXHUwM0EzXCI6IFwiU1wiLFxuICAgICAgICBcIlxcdTAzQTRcIjogXCJUXCIsXG4gICAgICAgIFwiXFx1MDNBNVwiOiBcIllcIixcbiAgICAgICAgXCJcXHUwM0E2XCI6IFwiRlwiLFxuICAgICAgICBcIlxcdTAzQTdcIjogXCJYXCIsXG4gICAgICAgIFwiXFx1MDNBOFwiOiBcIlBTXCIsXG4gICAgICAgIFwiXFx1MDNBOVwiOiBcIk9cIixcbiAgICAgICAgXCJcXHUwMzg2XCI6IFwiQVwiLFxuICAgICAgICBcIlxcdTAzODhcIjogXCJFXCIsXG4gICAgICAgIFwiXFx1MDM4QVwiOiBcIklcIixcbiAgICAgICAgXCJcXHUwMzhDXCI6IFwiT1wiLFxuICAgICAgICBcIlxcdTAzOEVcIjogXCJZXCIsXG4gICAgICAgIFwiXFx1MDM4OVwiOiBcIklcIixcbiAgICAgICAgXCJcXHUwMzhGXCI6IFwiT1wiLFxuICAgICAgICBcIlxcdTAzQUFcIjogXCJJXCIsXG4gICAgICAgIFwiXFx1MDNBQlwiOiBcIllcIixcbiAgICAgICAgLy8gTGF0dmlhblxuICAgICAgICBcIlxcdTAxMDFcIjogXCJhXCIsXG4gICAgICAgIC8vICfEjSc6ICdjJywgLy8gZHVwbGljYXRlXG4gICAgICAgIFwiXFx1MDExM1wiOiBcImVcIixcbiAgICAgICAgXCJcXHUwMTIzXCI6IFwiZ1wiLFxuICAgICAgICBcIlxcdTAxMkJcIjogXCJpXCIsXG4gICAgICAgIFwiXFx1MDEzN1wiOiBcImtcIixcbiAgICAgICAgXCJcXHUwMTNDXCI6IFwibFwiLFxuICAgICAgICBcIlxcdTAxNDZcIjogXCJuXCIsXG4gICAgICAgIC8vICfFoSc6ICdzJywgLy8gZHVwbGljYXRlXG4gICAgICAgIFwiXFx1MDE2QlwiOiBcInVcIixcbiAgICAgICAgLy8gJ8W+JzogJ3onLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgXCJcXHUwMTAwXCI6IFwiQVwiLFxuICAgICAgICAvLyAnxIwnOiAnQycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICBcIlxcdTAxMTJcIjogXCJFXCIsXG4gICAgICAgIFwiXFx1MDEyMlwiOiBcIkdcIixcbiAgICAgICAgXCJcXHUwMTJBXCI6IFwiSVwiLFxuICAgICAgICBcIlxcdTAxMzZcIjogXCJrXCIsXG4gICAgICAgIFwiXFx1MDEzQlwiOiBcIkxcIixcbiAgICAgICAgXCJcXHUwMTQ1XCI6IFwiTlwiLFxuICAgICAgICAvLyAnxaAnOiAnUycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICBcIlxcdTAxNkFcIjogXCJVXCIsXG4gICAgICAgIC8vICfFvSc6ICdaJywgLy8gZHVwbGljYXRlXG4gICAgICAgIC8vIE1hY2Vkb25pYW5cbiAgICAgICAgXCJcXHUwNDBDXCI6IFwiS2pcIixcbiAgICAgICAgXCJcXHUwNDVDXCI6IFwia2pcIixcbiAgICAgICAgXCJcXHUwNDA5XCI6IFwiTGpcIixcbiAgICAgICAgXCJcXHUwNDU5XCI6IFwibGpcIixcbiAgICAgICAgXCJcXHUwNDBBXCI6IFwiTmpcIixcbiAgICAgICAgXCJcXHUwNDVBXCI6IFwibmpcIixcbiAgICAgICAgXCJcXHUwNDIyXFx1MDQ0MVwiOiBcIlRzXCIsXG4gICAgICAgIFwiXFx1MDQ0MlxcdTA0NDFcIjogXCJ0c1wiLFxuICAgICAgICAvLyBQb2xpc2hcbiAgICAgICAgXCJcXHUwMTA1XCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTAxMDdcIjogXCJjXCIsXG4gICAgICAgIFwiXFx1MDExOVwiOiBcImVcIixcbiAgICAgICAgXCJcXHUwMTQyXCI6IFwibFwiLFxuICAgICAgICBcIlxcdTAxNDRcIjogXCJuXCIsXG4gICAgICAgIC8vICfDsyc6ICdvJywgLy8gZHVwbGljYXRlXG4gICAgICAgIFwiXFx1MDE1QlwiOiBcInNcIixcbiAgICAgICAgXCJcXHUwMTdBXCI6IFwielwiLFxuICAgICAgICBcIlxcdTAxN0NcIjogXCJ6XCIsXG4gICAgICAgIFwiXFx1MDEwNFwiOiBcIkFcIixcbiAgICAgICAgXCJcXHUwMTA2XCI6IFwiQ1wiLFxuICAgICAgICBcIlxcdTAxMThcIjogXCJFXCIsXG4gICAgICAgIFwiXFx1MDE0MVwiOiBcIkxcIixcbiAgICAgICAgXCJcXHUwMTQzXCI6IFwiTlwiLFxuICAgICAgICBcIlxcdTAxNUFcIjogXCJTXCIsXG4gICAgICAgIFwiXFx1MDE3OVwiOiBcIlpcIixcbiAgICAgICAgXCJcXHUwMTdCXCI6IFwiWlwiLFxuICAgICAgICAvLyBVa3JhbmlhblxuICAgICAgICBcIlxcdTA0MDRcIjogXCJZZVwiLFxuICAgICAgICBcIlxcdTA0MDZcIjogXCJJXCIsXG4gICAgICAgIFwiXFx1MDQwN1wiOiBcIllpXCIsXG4gICAgICAgIFwiXFx1MDQ5MFwiOiBcIkdcIixcbiAgICAgICAgXCJcXHUwNDU0XCI6IFwieWVcIixcbiAgICAgICAgXCJcXHUwNDU2XCI6IFwiaVwiLFxuICAgICAgICBcIlxcdTA0NTdcIjogXCJ5aVwiLFxuICAgICAgICBcIlxcdTA0OTFcIjogXCJnXCIsXG4gICAgICAgIC8vIFJvbWFuaWFuXG4gICAgICAgIFwiXFx1MDEwM1wiOiBcImFcIixcbiAgICAgICAgXCJcXHUwMTAyXCI6IFwiQVwiLFxuICAgICAgICBcIlxcdTAyMTlcIjogXCJzXCIsXG4gICAgICAgIFwiXFx1MDIxOFwiOiBcIlNcIixcbiAgICAgICAgLy8gJ8WfJzogJ3MnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgLy8gJ8WeJzogJ1MnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgXCJcXHUwMjFCXCI6IFwidFwiLFxuICAgICAgICBcIlxcdTAyMUFcIjogXCJUXCIsXG4gICAgICAgIFwiXFx1MDE2M1wiOiBcInRcIixcbiAgICAgICAgXCJcXHUwMTYyXCI6IFwiVFwiLFxuICAgICAgICAvLyBSdXNzaWFuIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JvbWFuaXphdGlvbl9vZl9SdXNzaWFuXG4gICAgICAgIC8vIElDQU9cbiAgICAgICAgXCJcXHUwNDMwXCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTA0MzFcIjogXCJiXCIsXG4gICAgICAgIFwiXFx1MDQzMlwiOiBcInZcIixcbiAgICAgICAgXCJcXHUwNDMzXCI6IFwiZ1wiLFxuICAgICAgICBcIlxcdTA0MzRcIjogXCJkXCIsXG4gICAgICAgIFwiXFx1MDQzNVwiOiBcImVcIixcbiAgICAgICAgXCJcXHUwNDUxXCI6IFwieW9cIixcbiAgICAgICAgXCJcXHUwNDM2XCI6IFwiemhcIixcbiAgICAgICAgXCJcXHUwNDM3XCI6IFwielwiLFxuICAgICAgICBcIlxcdTA0MzhcIjogXCJpXCIsXG4gICAgICAgIFwiXFx1MDQzOVwiOiBcImlcIixcbiAgICAgICAgXCJcXHUwNDNBXCI6IFwia1wiLFxuICAgICAgICBcIlxcdTA0M0JcIjogXCJsXCIsXG4gICAgICAgIFwiXFx1MDQzQ1wiOiBcIm1cIixcbiAgICAgICAgXCJcXHUwNDNEXCI6IFwiblwiLFxuICAgICAgICBcIlxcdTA0M0VcIjogXCJvXCIsXG4gICAgICAgIFwiXFx1MDQzRlwiOiBcInBcIixcbiAgICAgICAgXCJcXHUwNDQwXCI6IFwiclwiLFxuICAgICAgICBcIlxcdTA0NDFcIjogXCJzXCIsXG4gICAgICAgIFwiXFx1MDQ0MlwiOiBcInRcIixcbiAgICAgICAgXCJcXHUwNDQzXCI6IFwidVwiLFxuICAgICAgICBcIlxcdTA0NDRcIjogXCJmXCIsXG4gICAgICAgIFwiXFx1MDQ0NVwiOiBcImtoXCIsXG4gICAgICAgIFwiXFx1MDQ0NlwiOiBcImNcIixcbiAgICAgICAgXCJcXHUwNDQ3XCI6IFwiY2hcIixcbiAgICAgICAgXCJcXHUwNDQ4XCI6IFwic2hcIixcbiAgICAgICAgXCJcXHUwNDQ5XCI6IFwic2hcIixcbiAgICAgICAgXCJcXHUwNDRBXCI6IFwiXCIsXG4gICAgICAgIFwiXFx1MDQ0QlwiOiBcInlcIixcbiAgICAgICAgXCJcXHUwNDRDXCI6IFwiXCIsXG4gICAgICAgIFwiXFx1MDQ0RFwiOiBcImVcIixcbiAgICAgICAgXCJcXHUwNDRFXCI6IFwieXVcIixcbiAgICAgICAgXCJcXHUwNDRGXCI6IFwieWFcIixcbiAgICAgICAgXCJcXHUwNDEwXCI6IFwiQVwiLFxuICAgICAgICBcIlxcdTA0MTFcIjogXCJCXCIsXG4gICAgICAgIFwiXFx1MDQxMlwiOiBcIlZcIixcbiAgICAgICAgXCJcXHUwNDEzXCI6IFwiR1wiLFxuICAgICAgICBcIlxcdTA0MTRcIjogXCJEXCIsXG4gICAgICAgIFwiXFx1MDQxNVwiOiBcIkVcIixcbiAgICAgICAgXCJcXHUwNDAxXCI6IFwiWW9cIixcbiAgICAgICAgXCJcXHUwNDE2XCI6IFwiWmhcIixcbiAgICAgICAgXCJcXHUwNDE3XCI6IFwiWlwiLFxuICAgICAgICBcIlxcdTA0MThcIjogXCJJXCIsXG4gICAgICAgIFwiXFx1MDQxOVwiOiBcIklcIixcbiAgICAgICAgXCJcXHUwNDFBXCI6IFwiS1wiLFxuICAgICAgICBcIlxcdTA0MUJcIjogXCJMXCIsXG4gICAgICAgIFwiXFx1MDQxQ1wiOiBcIk1cIixcbiAgICAgICAgXCJcXHUwNDFEXCI6IFwiTlwiLFxuICAgICAgICBcIlxcdTA0MUVcIjogXCJPXCIsXG4gICAgICAgIFwiXFx1MDQxRlwiOiBcIlBcIixcbiAgICAgICAgXCJcXHUwNDIwXCI6IFwiUlwiLFxuICAgICAgICBcIlxcdTA0MjFcIjogXCJTXCIsXG4gICAgICAgIFwiXFx1MDQyMlwiOiBcIlRcIixcbiAgICAgICAgXCJcXHUwNDIzXCI6IFwiVVwiLFxuICAgICAgICBcIlxcdTA0MjRcIjogXCJGXCIsXG4gICAgICAgIFwiXFx1MDQyNVwiOiBcIktoXCIsXG4gICAgICAgIFwiXFx1MDQyNlwiOiBcIkNcIixcbiAgICAgICAgXCJcXHUwNDI3XCI6IFwiQ2hcIixcbiAgICAgICAgXCJcXHUwNDI4XCI6IFwiU2hcIixcbiAgICAgICAgXCJcXHUwNDI5XCI6IFwiU2hcIixcbiAgICAgICAgXCJcXHUwNDJBXCI6IFwiXCIsXG4gICAgICAgIFwiXFx1MDQyQlwiOiBcIllcIixcbiAgICAgICAgXCJcXHUwNDJDXCI6IFwiXCIsXG4gICAgICAgIFwiXFx1MDQyRFwiOiBcIkVcIixcbiAgICAgICAgXCJcXHUwNDJFXCI6IFwiWXVcIixcbiAgICAgICAgXCJcXHUwNDJGXCI6IFwiWWFcIixcbiAgICAgICAgLy8gU2VyYmlhblxuICAgICAgICBcIlxcdTA0NTJcIjogXCJkalwiLFxuICAgICAgICBcIlxcdTA0NThcIjogXCJqXCIsXG4gICAgICAgIC8vICfRmSc6ICdsaicsICAvLyBkdXBsaWNhdGVcbiAgICAgICAgLy8gJ9GaJzogJ25qJywgLy8gZHVwbGljYXRlXG4gICAgICAgIFwiXFx1MDQ1QlwiOiBcImNcIixcbiAgICAgICAgXCJcXHUwNDVGXCI6IFwiZHpcIixcbiAgICAgICAgXCJcXHUwNDAyXCI6IFwiRGpcIixcbiAgICAgICAgXCJcXHUwNDA4XCI6IFwialwiLFxuICAgICAgICAvLyAn0IknOiAnTGonLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgLy8gJ9CKJzogJ05qJywgLy8gZHVwbGljYXRlXG4gICAgICAgIFwiXFx1MDQwQlwiOiBcIkNcIixcbiAgICAgICAgXCJcXHUwNDBGXCI6IFwiRHpcIixcbiAgICAgICAgLy8gU2xvdmFrXG4gICAgICAgIFwiXFx1MDEzRVwiOiBcImxcIixcbiAgICAgICAgXCJcXHUwMTNBXCI6IFwibFwiLFxuICAgICAgICBcIlxcdTAxNTVcIjogXCJyXCIsXG4gICAgICAgIFwiXFx1MDEzRFwiOiBcIkxcIixcbiAgICAgICAgXCJcXHUwMTM5XCI6IFwiTFwiLFxuICAgICAgICBcIlxcdTAxNTRcIjogXCJSXCIsXG4gICAgICAgIC8vIFR1cmtpc2hcbiAgICAgICAgXCJcXHUwMTVGXCI6IFwic1wiLFxuICAgICAgICBcIlxcdTAxNUVcIjogXCJTXCIsXG4gICAgICAgIFwiXFx1MDEzMVwiOiBcImlcIixcbiAgICAgICAgXCJcXHUwMTMwXCI6IFwiSVwiLFxuICAgICAgICAvLyAnw6cnOiAnYycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAvLyAnw4cnOiAnQycsIC8vIGR1cGxpY2F0ZVxuICAgICAgICAvLyAnw7wnOiAndScsIC8vIGR1cGxpY2F0ZSwgc2VlIGxhbmdDaGFyTWFwXG4gICAgICAgIC8vICfDnCc6ICdVJywgLy8gZHVwbGljYXRlLCBzZWUgbGFuZ0NoYXJNYXBcbiAgICAgICAgLy8gJ8O2JzogJ28nLCAvLyBkdXBsaWNhdGUsIHNlZSBsYW5nQ2hhck1hcFxuICAgICAgICAvLyAnw5YnOiAnTycsIC8vIGR1cGxpY2F0ZSwgc2VlIGxhbmdDaGFyTWFwXG4gICAgICAgIFwiXFx1MDExRlwiOiBcImdcIixcbiAgICAgICAgXCJcXHUwMTFFXCI6IFwiR1wiLFxuICAgICAgICAvLyBWaWV0bmFtZXNlXG4gICAgICAgIFwiXFx1MUVBM1wiOiBcImFcIixcbiAgICAgICAgXCJcXHUxRUEyXCI6IFwiQVwiLFxuICAgICAgICBcIlxcdTFFQjNcIjogXCJhXCIsXG4gICAgICAgIFwiXFx1MUVCMlwiOiBcIkFcIixcbiAgICAgICAgXCJcXHUxRUE5XCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTFFQThcIjogXCJBXCIsXG4gICAgICAgIFwiXFx1MDExMVwiOiBcImRcIixcbiAgICAgICAgXCJcXHUwMTEwXCI6IFwiRFwiLFxuICAgICAgICBcIlxcdTFFQjlcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MUVCOFwiOiBcIkVcIixcbiAgICAgICAgXCJcXHUxRUJEXCI6IFwiZVwiLFxuICAgICAgICBcIlxcdTFFQkNcIjogXCJFXCIsXG4gICAgICAgIFwiXFx1MUVCQlwiOiBcImVcIixcbiAgICAgICAgXCJcXHUxRUJBXCI6IFwiRVwiLFxuICAgICAgICBcIlxcdTFFQkZcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MUVCRVwiOiBcIkVcIixcbiAgICAgICAgXCJcXHUxRUMxXCI6IFwiZVwiLFxuICAgICAgICBcIlxcdTFFQzBcIjogXCJFXCIsXG4gICAgICAgIFwiXFx1MUVDN1wiOiBcImVcIixcbiAgICAgICAgXCJcXHUxRUM2XCI6IFwiRVwiLFxuICAgICAgICBcIlxcdTFFQzVcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MUVDNFwiOiBcIkVcIixcbiAgICAgICAgXCJcXHUxRUMzXCI6IFwiZVwiLFxuICAgICAgICBcIlxcdTFFQzJcIjogXCJFXCIsXG4gICAgICAgIFwiXFx1MUVDRlwiOiBcIm9cIixcbiAgICAgICAgXCJcXHUxRUNEXCI6IFwib1wiLFxuICAgICAgICBcIlxcdTFFQ0NcIjogXCJvXCIsXG4gICAgICAgIFwiXFx1MUVEMVwiOiBcIm9cIixcbiAgICAgICAgXCJcXHUxRUQwXCI6IFwiT1wiLFxuICAgICAgICBcIlxcdTFFRDNcIjogXCJvXCIsXG4gICAgICAgIFwiXFx1MUVEMlwiOiBcIk9cIixcbiAgICAgICAgXCJcXHUxRUQ1XCI6IFwib1wiLFxuICAgICAgICBcIlxcdTFFRDRcIjogXCJPXCIsXG4gICAgICAgIFwiXFx1MUVEOVwiOiBcIm9cIixcbiAgICAgICAgXCJcXHUxRUQ4XCI6IFwiT1wiLFxuICAgICAgICBcIlxcdTFFRDdcIjogXCJvXCIsXG4gICAgICAgIFwiXFx1MUVENlwiOiBcIk9cIixcbiAgICAgICAgXCJcXHUwMUExXCI6IFwib1wiLFxuICAgICAgICBcIlxcdTAxQTBcIjogXCJPXCIsXG4gICAgICAgIFwiXFx1MUVEQlwiOiBcIm9cIixcbiAgICAgICAgXCJcXHUxRURBXCI6IFwiT1wiLFxuICAgICAgICBcIlxcdTFFRERcIjogXCJvXCIsXG4gICAgICAgIFwiXFx1MUVEQ1wiOiBcIk9cIixcbiAgICAgICAgXCJcXHUxRUUzXCI6IFwib1wiLFxuICAgICAgICBcIlxcdTFFRTJcIjogXCJPXCIsXG4gICAgICAgIFwiXFx1MUVFMVwiOiBcIm9cIixcbiAgICAgICAgXCJcXHUxRUUwXCI6IFwiT1wiLFxuICAgICAgICBcIlxcdTFFREVcIjogXCJvXCIsXG4gICAgICAgIFwiXFx1MUVERlwiOiBcIm9cIixcbiAgICAgICAgXCJcXHUxRUNCXCI6IFwiaVwiLFxuICAgICAgICBcIlxcdTFFQ0FcIjogXCJJXCIsXG4gICAgICAgIFwiXFx1MDEyOVwiOiBcImlcIixcbiAgICAgICAgXCJcXHUwMTI4XCI6IFwiSVwiLFxuICAgICAgICBcIlxcdTFFQzlcIjogXCJpXCIsXG4gICAgICAgIFwiXFx1MUVDOFwiOiBcImlcIixcbiAgICAgICAgXCJcXHUxRUU3XCI6IFwidVwiLFxuICAgICAgICBcIlxcdTFFRTZcIjogXCJVXCIsXG4gICAgICAgIFwiXFx1MUVFNVwiOiBcInVcIixcbiAgICAgICAgXCJcXHUxRUU0XCI6IFwiVVwiLFxuICAgICAgICBcIlxcdTAxNjlcIjogXCJ1XCIsXG4gICAgICAgIFwiXFx1MDE2OFwiOiBcIlVcIixcbiAgICAgICAgXCJcXHUwMUIwXCI6IFwidVwiLFxuICAgICAgICBcIlxcdTAxQUZcIjogXCJVXCIsXG4gICAgICAgIFwiXFx1MUVFOVwiOiBcInVcIixcbiAgICAgICAgXCJcXHUxRUU4XCI6IFwiVVwiLFxuICAgICAgICBcIlxcdTFFRUJcIjogXCJ1XCIsXG4gICAgICAgIFwiXFx1MUVFQVwiOiBcIlVcIixcbiAgICAgICAgXCJcXHUxRUYxXCI6IFwidVwiLFxuICAgICAgICBcIlxcdTFFRjBcIjogXCJVXCIsXG4gICAgICAgIFwiXFx1MUVFRlwiOiBcInVcIixcbiAgICAgICAgXCJcXHUxRUVFXCI6IFwiVVwiLFxuICAgICAgICBcIlxcdTFFRURcIjogXCJ1XCIsXG4gICAgICAgIFwiXFx1MUVFQ1wiOiBcIlxcdTAxQjBcIixcbiAgICAgICAgXCJcXHUxRUY3XCI6IFwieVwiLFxuICAgICAgICBcIlxcdTFFRjZcIjogXCJ5XCIsXG4gICAgICAgIFwiXFx1MUVGM1wiOiBcInlcIixcbiAgICAgICAgXCJcXHUxRUYyXCI6IFwiWVwiLFxuICAgICAgICBcIlxcdTFFRjVcIjogXCJ5XCIsXG4gICAgICAgIFwiXFx1MUVGNFwiOiBcIllcIixcbiAgICAgICAgXCJcXHUxRUY5XCI6IFwieVwiLFxuICAgICAgICBcIlxcdTFFRjhcIjogXCJZXCIsXG4gICAgICAgIFwiXFx1MUVBMVwiOiBcImFcIixcbiAgICAgICAgXCJcXHUxRUEwXCI6IFwiQVwiLFxuICAgICAgICBcIlxcdTFFQTVcIjogXCJhXCIsXG4gICAgICAgIFwiXFx1MUVBNFwiOiBcIkFcIixcbiAgICAgICAgXCJcXHUxRUE3XCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTFFQTZcIjogXCJBXCIsXG4gICAgICAgIFwiXFx1MUVBRFwiOiBcImFcIixcbiAgICAgICAgXCJcXHUxRUFDXCI6IFwiQVwiLFxuICAgICAgICBcIlxcdTFFQUJcIjogXCJhXCIsXG4gICAgICAgIFwiXFx1MUVBQVwiOiBcIkFcIixcbiAgICAgICAgLy8gJ8SDJzogJ2EnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgLy8gJ8SCJzogJ0EnLCAvLyBkdXBsaWNhdGVcbiAgICAgICAgXCJcXHUxRUFGXCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTFFQUVcIjogXCJBXCIsXG4gICAgICAgIFwiXFx1MUVCMVwiOiBcImFcIixcbiAgICAgICAgXCJcXHUxRUIwXCI6IFwiQVwiLFxuICAgICAgICBcIlxcdTFFQjdcIjogXCJhXCIsXG4gICAgICAgIFwiXFx1MUVCNlwiOiBcIkFcIixcbiAgICAgICAgXCJcXHUxRUI1XCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTFFQjRcIjogXCJBXCIsXG4gICAgICAgIFwiXFx1MjRFQVwiOiBcIjBcIixcbiAgICAgICAgXCJcXHUyNDYwXCI6IFwiMVwiLFxuICAgICAgICBcIlxcdTI0NjFcIjogXCIyXCIsXG4gICAgICAgIFwiXFx1MjQ2MlwiOiBcIjNcIixcbiAgICAgICAgXCJcXHUyNDYzXCI6IFwiNFwiLFxuICAgICAgICBcIlxcdTI0NjRcIjogXCI1XCIsXG4gICAgICAgIFwiXFx1MjQ2NVwiOiBcIjZcIixcbiAgICAgICAgXCJcXHUyNDY2XCI6IFwiN1wiLFxuICAgICAgICBcIlxcdTI0NjdcIjogXCI4XCIsXG4gICAgICAgIFwiXFx1MjQ2OFwiOiBcIjlcIixcbiAgICAgICAgXCJcXHUyNDY5XCI6IFwiMTBcIixcbiAgICAgICAgXCJcXHUyNDZBXCI6IFwiMTFcIixcbiAgICAgICAgXCJcXHUyNDZCXCI6IFwiMTJcIixcbiAgICAgICAgXCJcXHUyNDZDXCI6IFwiMTNcIixcbiAgICAgICAgXCJcXHUyNDZEXCI6IFwiMTRcIixcbiAgICAgICAgXCJcXHUyNDZFXCI6IFwiMTVcIixcbiAgICAgICAgXCJcXHUyNDZGXCI6IFwiMTZcIixcbiAgICAgICAgXCJcXHUyNDcwXCI6IFwiMTdcIixcbiAgICAgICAgXCJcXHUyNDcxXCI6IFwiMThcIixcbiAgICAgICAgXCJcXHUyNDcyXCI6IFwiMThcIixcbiAgICAgICAgXCJcXHUyNDczXCI6IFwiMThcIixcbiAgICAgICAgXCJcXHUyNEY1XCI6IFwiMVwiLFxuICAgICAgICBcIlxcdTI0RjZcIjogXCIyXCIsXG4gICAgICAgIFwiXFx1MjRGN1wiOiBcIjNcIixcbiAgICAgICAgXCJcXHUyNEY4XCI6IFwiNFwiLFxuICAgICAgICBcIlxcdTI0RjlcIjogXCI1XCIsXG4gICAgICAgIFwiXFx1MjRGQVwiOiBcIjZcIixcbiAgICAgICAgXCJcXHUyNEZCXCI6IFwiN1wiLFxuICAgICAgICBcIlxcdTI0RkNcIjogXCI4XCIsXG4gICAgICAgIFwiXFx1MjRGRFwiOiBcIjlcIixcbiAgICAgICAgXCJcXHUyNEZFXCI6IFwiMTBcIixcbiAgICAgICAgXCJcXHUyNEZGXCI6IFwiMFwiLFxuICAgICAgICBcIlxcdTI0RUJcIjogXCIxMVwiLFxuICAgICAgICBcIlxcdTI0RUNcIjogXCIxMlwiLFxuICAgICAgICBcIlxcdTI0RURcIjogXCIxM1wiLFxuICAgICAgICBcIlxcdTI0RUVcIjogXCIxNFwiLFxuICAgICAgICBcIlxcdTI0RUZcIjogXCIxNVwiLFxuICAgICAgICBcIlxcdTI0RjBcIjogXCIxNlwiLFxuICAgICAgICBcIlxcdTI0RjFcIjogXCIxN1wiLFxuICAgICAgICBcIlxcdTI0RjJcIjogXCIxOFwiLFxuICAgICAgICBcIlxcdTI0RjNcIjogXCIxOVwiLFxuICAgICAgICBcIlxcdTI0RjRcIjogXCIyMFwiLFxuICAgICAgICBcIlxcdTI0QjZcIjogXCJBXCIsXG4gICAgICAgIFwiXFx1MjRCN1wiOiBcIkJcIixcbiAgICAgICAgXCJcXHUyNEI4XCI6IFwiQ1wiLFxuICAgICAgICBcIlxcdTI0QjlcIjogXCJEXCIsXG4gICAgICAgIFwiXFx1MjRCQVwiOiBcIkVcIixcbiAgICAgICAgXCJcXHUyNEJCXCI6IFwiRlwiLFxuICAgICAgICBcIlxcdTI0QkNcIjogXCJHXCIsXG4gICAgICAgIFwiXFx1MjRCRFwiOiBcIkhcIixcbiAgICAgICAgXCJcXHUyNEJFXCI6IFwiSVwiLFxuICAgICAgICBcIlxcdTI0QkZcIjogXCJKXCIsXG4gICAgICAgIFwiXFx1MjRDMFwiOiBcIktcIixcbiAgICAgICAgXCJcXHUyNEMxXCI6IFwiTFwiLFxuICAgICAgICBcIlxcdTI0QzJcIjogXCJNXCIsXG4gICAgICAgIFwiXFx1MjRDM1wiOiBcIk5cIixcbiAgICAgICAgXCJcXHUyNEM0XCI6IFwiT1wiLFxuICAgICAgICBcIlxcdTI0QzVcIjogXCJQXCIsXG4gICAgICAgIFwiXFx1MjRDNlwiOiBcIlFcIixcbiAgICAgICAgXCJcXHUyNEM3XCI6IFwiUlwiLFxuICAgICAgICBcIlxcdTI0QzhcIjogXCJTXCIsXG4gICAgICAgIFwiXFx1MjRDOVwiOiBcIlRcIixcbiAgICAgICAgXCJcXHUyNENBXCI6IFwiVVwiLFxuICAgICAgICBcIlxcdTI0Q0JcIjogXCJWXCIsXG4gICAgICAgIFwiXFx1MjRDQ1wiOiBcIldcIixcbiAgICAgICAgXCJcXHUyNENEXCI6IFwiWFwiLFxuICAgICAgICBcIlxcdTI0Q0VcIjogXCJZXCIsXG4gICAgICAgIFwiXFx1MjRDRlwiOiBcIlpcIixcbiAgICAgICAgXCJcXHUyNEQwXCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTI0RDFcIjogXCJiXCIsXG4gICAgICAgIFwiXFx1MjREMlwiOiBcImNcIixcbiAgICAgICAgXCJcXHUyNEQzXCI6IFwiZFwiLFxuICAgICAgICBcIlxcdTI0RDRcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MjRENVwiOiBcImZcIixcbiAgICAgICAgXCJcXHUyNEQ2XCI6IFwiZ1wiLFxuICAgICAgICBcIlxcdTI0RDdcIjogXCJoXCIsXG4gICAgICAgIFwiXFx1MjREOFwiOiBcImlcIixcbiAgICAgICAgXCJcXHUyNEQ5XCI6IFwialwiLFxuICAgICAgICBcIlxcdTI0REFcIjogXCJrXCIsXG4gICAgICAgIFwiXFx1MjREQlwiOiBcImxcIixcbiAgICAgICAgXCJcXHUyNERDXCI6IFwibVwiLFxuICAgICAgICBcIlxcdTI0RERcIjogXCJuXCIsXG4gICAgICAgIFwiXFx1MjRERVwiOiBcIm9cIixcbiAgICAgICAgXCJcXHUyNERGXCI6IFwicFwiLFxuICAgICAgICBcIlxcdTI0RTBcIjogXCJxXCIsXG4gICAgICAgIFwiXFx1MjRFMVwiOiBcInJcIixcbiAgICAgICAgXCJcXHUyNEUyXCI6IFwic1wiLFxuICAgICAgICBcIlxcdTI0RTNcIjogXCJ0XCIsXG4gICAgICAgIFwiXFx1MjRFNFwiOiBcInVcIixcbiAgICAgICAgXCJcXHUyNEU2XCI6IFwidlwiLFxuICAgICAgICBcIlxcdTI0RTVcIjogXCJ3XCIsXG4gICAgICAgIFwiXFx1MjRFN1wiOiBcInhcIixcbiAgICAgICAgXCJcXHUyNEU4XCI6IFwieVwiLFxuICAgICAgICBcIlxcdTI0RTlcIjogXCJ6XCIsXG4gICAgICAgIC8vIHN5bWJvbHNcbiAgICAgICAgXCJcXHUyMDFDXCI6ICdcIicsXG4gICAgICAgIFwiXFx1MjAxRFwiOiAnXCInLFxuICAgICAgICBcIlxcdTIwMThcIjogXCInXCIsXG4gICAgICAgIFwiXFx1MjAxOVwiOiBcIidcIixcbiAgICAgICAgXCJcXHUyMjAyXCI6IFwiZFwiLFxuICAgICAgICBcIlxcdTAxOTJcIjogXCJmXCIsXG4gICAgICAgIFwiXFx1MjEyMlwiOiBcIihUTSlcIixcbiAgICAgICAgXCJcXHhBOVwiOiBcIihDKVwiLFxuICAgICAgICBcIlxcdTAxNTNcIjogXCJvZVwiLFxuICAgICAgICBcIlxcdTAxNTJcIjogXCJPRVwiLFxuICAgICAgICBcIlxceEFFXCI6IFwiKFIpXCIsXG4gICAgICAgIFwiXFx1MjAyMFwiOiBcIitcIixcbiAgICAgICAgXCJcXHUyMTIwXCI6IFwiKFNNKVwiLFxuICAgICAgICBcIlxcdTIwMjZcIjogXCIuLi5cIixcbiAgICAgICAgXCJcXHUwMkRBXCI6IFwib1wiLFxuICAgICAgICBcIlxceEJBXCI6IFwib1wiLFxuICAgICAgICBcIlxceEFBXCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTIwMjJcIjogXCIqXCIsXG4gICAgICAgIFwiXFx1MTA0QVwiOiBcIixcIixcbiAgICAgICAgXCJcXHUxMDRCXCI6IFwiLlwiLFxuICAgICAgICAvLyBjdXJyZW5jeVxuICAgICAgICBcIiRcIjogXCJVU0RcIixcbiAgICAgICAgXCJcXHUyMEFDXCI6IFwiRVVSXCIsXG4gICAgICAgIFwiXFx1MjBBMlwiOiBcIkJSTlwiLFxuICAgICAgICBcIlxcdTIwQTNcIjogXCJGUkZcIixcbiAgICAgICAgXCJcXHhBM1wiOiBcIkdCUFwiLFxuICAgICAgICBcIlxcdTIwQTRcIjogXCJJVExcIixcbiAgICAgICAgXCJcXHUyMEE2XCI6IFwiTkdOXCIsXG4gICAgICAgIFwiXFx1MjBBN1wiOiBcIkVTUFwiLFxuICAgICAgICBcIlxcdTIwQTlcIjogXCJLUldcIixcbiAgICAgICAgXCJcXHUyMEFBXCI6IFwiSUxTXCIsXG4gICAgICAgIFwiXFx1MjBBQlwiOiBcIlZORFwiLFxuICAgICAgICBcIlxcdTIwQURcIjogXCJMQUtcIixcbiAgICAgICAgXCJcXHUyMEFFXCI6IFwiTU5UXCIsXG4gICAgICAgIFwiXFx1MjBBRlwiOiBcIkdSRFwiLFxuICAgICAgICBcIlxcdTIwQjFcIjogXCJBUlNcIixcbiAgICAgICAgXCJcXHUyMEIyXCI6IFwiUFlHXCIsXG4gICAgICAgIFwiXFx1MjBCM1wiOiBcIkFSQVwiLFxuICAgICAgICBcIlxcdTIwQjRcIjogXCJVQUhcIixcbiAgICAgICAgXCJcXHUyMEI1XCI6IFwiR0hTXCIsXG4gICAgICAgIFwiXFx4QTJcIjogXCJjZW50XCIsXG4gICAgICAgIFwiXFx4QTVcIjogXCJDTllcIixcbiAgICAgICAgXCJcXHU1MTQzXCI6IFwiQ05ZXCIsXG4gICAgICAgIFwiXFx1NTE4NlwiOiBcIllFTlwiLFxuICAgICAgICBcIlxcdUZERkNcIjogXCJJUlJcIixcbiAgICAgICAgXCJcXHUyMEEwXCI6IFwiRVdFXCIsXG4gICAgICAgIFwiXFx1MEUzRlwiOiBcIlRIQlwiLFxuICAgICAgICBcIlxcdTIwQThcIjogXCJJTlJcIixcbiAgICAgICAgXCJcXHUyMEI5XCI6IFwiSU5SXCIsXG4gICAgICAgIFwiXFx1MjBCMFwiOiBcIlBGXCIsXG4gICAgICAgIFwiXFx1MjBCQVwiOiBcIlRSWVwiLFxuICAgICAgICBcIlxcdTA2MEJcIjogXCJBRk5cIixcbiAgICAgICAgXCJcXHUyMEJDXCI6IFwiQVpOXCIsXG4gICAgICAgIFwiXFx1MDQzQlxcdTA0MzJcIjogXCJCR05cIixcbiAgICAgICAgXCJcXHUxN0RCXCI6IFwiS0hSXCIsXG4gICAgICAgIFwiXFx1MjBBMVwiOiBcIkNSQ1wiLFxuICAgICAgICBcIlxcdTIwQjhcIjogXCJLWlRcIixcbiAgICAgICAgXCJcXHUwNDM0XFx1MDQzNVxcdTA0M0RcIjogXCJNS0RcIixcbiAgICAgICAgXCJ6XFx1MDE0MlwiOiBcIlBMTlwiLFxuICAgICAgICBcIlxcdTIwQkRcIjogXCJSVUJcIixcbiAgICAgICAgXCJcXHUyMEJFXCI6IFwiR0VMXCJcbiAgICAgIH07XG4gICAgICB2YXIgbG9va0FoZWFkQ2hhckFycmF5ID0gW1xuICAgICAgICAvLyBidXJtZXNlXG4gICAgICAgIFwiXFx1MTAzQVwiLFxuICAgICAgICAvLyBEaGl2ZWhpXG4gICAgICAgIFwiXFx1MDdCMFwiXG4gICAgICBdO1xuICAgICAgdmFyIGRpYXRyaWNNYXAgPSB7XG4gICAgICAgIC8vIEJ1cm1lc2VcbiAgICAgICAgLy8gZGVwZW5kZW50IHZvd2Vsc1xuICAgICAgICBcIlxcdTEwMkNcIjogXCJhXCIsXG4gICAgICAgIFwiXFx1MTAyQlwiOiBcImFcIixcbiAgICAgICAgXCJcXHUxMDMxXCI6IFwiZVwiLFxuICAgICAgICBcIlxcdTEwMzJcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MTAyRFwiOiBcImlcIixcbiAgICAgICAgXCJcXHUxMDJFXCI6IFwiaVwiLFxuICAgICAgICBcIlxcdTEwMkRcXHUxMDJGXCI6IFwib1wiLFxuICAgICAgICBcIlxcdTEwMkZcIjogXCJ1XCIsXG4gICAgICAgIFwiXFx1MTAzMFwiOiBcInVcIixcbiAgICAgICAgXCJcXHUxMDMxXFx1MTAyQlxcdTEwMDRcXHUxMDNBXCI6IFwiYXVuZ1wiLFxuICAgICAgICBcIlxcdTEwMzFcXHUxMDJDXCI6IFwiYXdcIixcbiAgICAgICAgXCJcXHUxMDMxXFx1MTAyQ1xcdTEwM0FcIjogXCJhd1wiLFxuICAgICAgICBcIlxcdTEwMzFcXHUxMDJCXCI6IFwiYXdcIixcbiAgICAgICAgXCJcXHUxMDMxXFx1MTAyQlxcdTEwM0FcIjogXCJhd1wiLFxuICAgICAgICBcIlxcdTEwM0FcIjogXCJcXHUxMDNBXCIsXG4gICAgICAgIC8vIHRoaXMgaXMgc3BlY2lhbCBjYXNlIGJ1dCB0aGUgY2hhcmFjdGVyIHdpbGwgYmUgY29udmVydGVkIHRvIGxhdGluIGluIHRoZSBjb2RlXG4gICAgICAgIFwiXFx1MTAwMFxcdTEwM0FcIjogXCJldFwiLFxuICAgICAgICBcIlxcdTEwMkRcXHUxMDJGXFx1MTAwMFxcdTEwM0FcIjogXCJhaWtcIixcbiAgICAgICAgXCJcXHUxMDMxXFx1MTAyQ1xcdTEwMDBcXHUxMDNBXCI6IFwiYXVrXCIsXG4gICAgICAgIFwiXFx1MTAwNFxcdTEwM0FcIjogXCJpblwiLFxuICAgICAgICBcIlxcdTEwMkRcXHUxMDJGXFx1MTAwNFxcdTEwM0FcIjogXCJhaW5nXCIsXG4gICAgICAgIFwiXFx1MTAzMVxcdTEwMkNcXHUxMDA0XFx1MTAzQVwiOiBcImF1bmdcIixcbiAgICAgICAgXCJcXHUxMDA1XFx1MTAzQVwiOiBcIml0XCIsXG4gICAgICAgIFwiXFx1MTAwQVxcdTEwM0FcIjogXCJpXCIsXG4gICAgICAgIFwiXFx1MTAxMFxcdTEwM0FcIjogXCJhdFwiLFxuICAgICAgICBcIlxcdTEwMkRcXHUxMDEwXFx1MTAzQVwiOiBcImVpa1wiLFxuICAgICAgICBcIlxcdTEwMkZcXHUxMDEwXFx1MTAzQVwiOiBcIm9rXCIsXG4gICAgICAgIFwiXFx1MTAzRFxcdTEwMTBcXHUxMDNBXCI6IFwidXRcIixcbiAgICAgICAgXCJcXHUxMDMxXFx1MTAxMFxcdTEwM0FcIjogXCJpdFwiLFxuICAgICAgICBcIlxcdTEwMTJcXHUxMDNBXCI6IFwiZFwiLFxuICAgICAgICBcIlxcdTEwMkRcXHUxMDJGXFx1MTAxMlxcdTEwM0FcIjogXCJva1wiLFxuICAgICAgICBcIlxcdTEwMkZcXHUxMDEyXFx1MTAzQVwiOiBcImFpdFwiLFxuICAgICAgICBcIlxcdTEwMTRcXHUxMDNBXCI6IFwiYW5cIixcbiAgICAgICAgXCJcXHUxMDJDXFx1MTAxNFxcdTEwM0FcIjogXCJhblwiLFxuICAgICAgICBcIlxcdTEwMkRcXHUxMDE0XFx1MTAzQVwiOiBcImVpblwiLFxuICAgICAgICBcIlxcdTEwMkZcXHUxMDE0XFx1MTAzQVwiOiBcIm9uXCIsXG4gICAgICAgIFwiXFx1MTAzRFxcdTEwMTRcXHUxMDNBXCI6IFwidW5cIixcbiAgICAgICAgXCJcXHUxMDE1XFx1MTAzQVwiOiBcImF0XCIsXG4gICAgICAgIFwiXFx1MTAyRFxcdTEwMTVcXHUxMDNBXCI6IFwiZWlrXCIsXG4gICAgICAgIFwiXFx1MTAyRlxcdTEwMTVcXHUxMDNBXCI6IFwib2tcIixcbiAgICAgICAgXCJcXHUxMDNEXFx1MTAxNVxcdTEwM0FcIjogXCJ1dFwiLFxuICAgICAgICBcIlxcdTEwMTRcXHUxMDNBXFx1MTAyRlxcdTEwMTVcXHUxMDNBXCI6IFwibnViXCIsXG4gICAgICAgIFwiXFx1MTAxOVxcdTEwM0FcIjogXCJhblwiLFxuICAgICAgICBcIlxcdTEwMkRcXHUxMDE5XFx1MTAzQVwiOiBcImVpblwiLFxuICAgICAgICBcIlxcdTEwMkZcXHUxMDE5XFx1MTAzQVwiOiBcIm9uXCIsXG4gICAgICAgIFwiXFx1MTAzRFxcdTEwMTlcXHUxMDNBXCI6IFwidW5cIixcbiAgICAgICAgXCJcXHUxMDFBXFx1MTAzQVwiOiBcImVcIixcbiAgICAgICAgXCJcXHUxMDJEXFx1MTAyRlxcdTEwMUNcXHUxMDNBXCI6IFwib2xcIixcbiAgICAgICAgXCJcXHUxMDA5XFx1MTAzQVwiOiBcImluXCIsXG4gICAgICAgIFwiXFx1MTAzNlwiOiBcImFuXCIsXG4gICAgICAgIFwiXFx1MTAyRFxcdTEwMzZcIjogXCJlaW5cIixcbiAgICAgICAgXCJcXHUxMDJGXFx1MTAzNlwiOiBcIm9uXCIsXG4gICAgICAgIC8vIERoaXZlaGlcbiAgICAgICAgXCJcXHUwN0E2XFx1MDc4N1xcdTA3QjBcIjogXCJhaFwiLFxuICAgICAgICBcIlxcdTA3QTZcXHUwNzgxXFx1MDdCMFwiOiBcImFoXCJcbiAgICAgIH07XG4gICAgICB2YXIgbGFuZ0NoYXJNYXAgPSB7XG4gICAgICAgIFwiZW5cIjoge30sXG4gICAgICAgIC8vIGRlZmF1bHQgbGFuZ3VhZ2VcbiAgICAgICAgXCJhelwiOiB7XG4gICAgICAgICAgLy8gQXplcmJhaWphbmlcbiAgICAgICAgICBcIlxceEU3XCI6IFwiY1wiLFxuICAgICAgICAgIFwiXFx1MDI1OVwiOiBcImVcIixcbiAgICAgICAgICBcIlxcdTAxMUZcIjogXCJnXCIsXG4gICAgICAgICAgXCJcXHUwMTMxXCI6IFwiaVwiLFxuICAgICAgICAgIFwiXFx4RjZcIjogXCJvXCIsXG4gICAgICAgICAgXCJcXHUwMTVGXCI6IFwic1wiLFxuICAgICAgICAgIFwiXFx4RkNcIjogXCJ1XCIsXG4gICAgICAgICAgXCJcXHhDN1wiOiBcIkNcIixcbiAgICAgICAgICBcIlxcdTAxOEZcIjogXCJFXCIsXG4gICAgICAgICAgXCJcXHUwMTFFXCI6IFwiR1wiLFxuICAgICAgICAgIFwiXFx1MDEzMFwiOiBcIklcIixcbiAgICAgICAgICBcIlxceEQ2XCI6IFwiT1wiLFxuICAgICAgICAgIFwiXFx1MDE1RVwiOiBcIlNcIixcbiAgICAgICAgICBcIlxceERDXCI6IFwiVVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY3NcIjoge1xuICAgICAgICAgIC8vIEN6ZWNoXG4gICAgICAgICAgXCJcXHUwMTBEXCI6IFwiY1wiLFxuICAgICAgICAgIFwiXFx1MDEwRlwiOiBcImRcIixcbiAgICAgICAgICBcIlxcdTAxMUJcIjogXCJlXCIsXG4gICAgICAgICAgXCJcXHUwMTQ4XCI6IFwiblwiLFxuICAgICAgICAgIFwiXFx1MDE1OVwiOiBcInJcIixcbiAgICAgICAgICBcIlxcdTAxNjFcIjogXCJzXCIsXG4gICAgICAgICAgXCJcXHUwMTY1XCI6IFwidFwiLFxuICAgICAgICAgIFwiXFx1MDE2RlwiOiBcInVcIixcbiAgICAgICAgICBcIlxcdTAxN0VcIjogXCJ6XCIsXG4gICAgICAgICAgXCJcXHUwMTBDXCI6IFwiQ1wiLFxuICAgICAgICAgIFwiXFx1MDEwRVwiOiBcIkRcIixcbiAgICAgICAgICBcIlxcdTAxMUFcIjogXCJFXCIsXG4gICAgICAgICAgXCJcXHUwMTQ3XCI6IFwiTlwiLFxuICAgICAgICAgIFwiXFx1MDE1OFwiOiBcIlJcIixcbiAgICAgICAgICBcIlxcdTAxNjBcIjogXCJTXCIsXG4gICAgICAgICAgXCJcXHUwMTY0XCI6IFwiVFwiLFxuICAgICAgICAgIFwiXFx1MDE2RVwiOiBcIlVcIixcbiAgICAgICAgICBcIlxcdTAxN0RcIjogXCJaXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJmaVwiOiB7XG4gICAgICAgICAgLy8gRmlubmlzaFxuICAgICAgICAgIC8vICfDpSc6ICdhJywgZHVwbGljYXRlIHNlZSBjaGFyTWFwL2xhdGluXG4gICAgICAgICAgLy8gJ8OFJzogJ0EnLCBkdXBsaWNhdGUgc2VlIGNoYXJNYXAvbGF0aW5cbiAgICAgICAgICBcIlxceEU0XCI6IFwiYVwiLFxuICAgICAgICAgIC8vIG9rXG4gICAgICAgICAgXCJcXHhDNFwiOiBcIkFcIixcbiAgICAgICAgICAvLyBva1xuICAgICAgICAgIFwiXFx4RjZcIjogXCJvXCIsXG4gICAgICAgICAgLy8gb2tcbiAgICAgICAgICBcIlxceEQ2XCI6IFwiT1wiXG4gICAgICAgICAgLy8gb2tcbiAgICAgICAgfSxcbiAgICAgICAgXCJodVwiOiB7XG4gICAgICAgICAgLy8gSHVuZ2FyaWFuXG4gICAgICAgICAgXCJcXHhFNFwiOiBcImFcIixcbiAgICAgICAgICAvLyBva1xuICAgICAgICAgIFwiXFx4QzRcIjogXCJBXCIsXG4gICAgICAgICAgLy8gb2tcbiAgICAgICAgICAvLyAnw6EnOiAnYScsIGR1cGxpY2F0ZSBzZWUgY2hhck1hcC9sYXRpblxuICAgICAgICAgIC8vICfDgSc6ICdBJywgZHVwbGljYXRlIHNlZSBjaGFyTWFwL2xhdGluXG4gICAgICAgICAgXCJcXHhGNlwiOiBcIm9cIixcbiAgICAgICAgICAvLyBva1xuICAgICAgICAgIFwiXFx4RDZcIjogXCJPXCIsXG4gICAgICAgICAgLy8gb2tcbiAgICAgICAgICAvLyAnxZEnOiAnbycsIGR1cGxpY2F0ZSBzZWUgY2hhck1hcC9sYXRpblxuICAgICAgICAgIC8vICfFkCc6ICdPJywgZHVwbGljYXRlIHNlZSBjaGFyTWFwL2xhdGluXG4gICAgICAgICAgXCJcXHhGQ1wiOiBcInVcIixcbiAgICAgICAgICBcIlxceERDXCI6IFwiVVwiLFxuICAgICAgICAgIFwiXFx1MDE3MVwiOiBcInVcIixcbiAgICAgICAgICBcIlxcdTAxNzBcIjogXCJVXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJsdFwiOiB7XG4gICAgICAgICAgLy8gTGl0aHVhbmlhblxuICAgICAgICAgIFwiXFx1MDEwNVwiOiBcImFcIixcbiAgICAgICAgICBcIlxcdTAxMERcIjogXCJjXCIsXG4gICAgICAgICAgXCJcXHUwMTE5XCI6IFwiZVwiLFxuICAgICAgICAgIFwiXFx1MDExN1wiOiBcImVcIixcbiAgICAgICAgICBcIlxcdTAxMkZcIjogXCJpXCIsXG4gICAgICAgICAgXCJcXHUwMTYxXCI6IFwic1wiLFxuICAgICAgICAgIFwiXFx1MDE3M1wiOiBcInVcIixcbiAgICAgICAgICBcIlxcdTAxNkJcIjogXCJ1XCIsXG4gICAgICAgICAgXCJcXHUwMTdFXCI6IFwielwiLFxuICAgICAgICAgIFwiXFx1MDEwNFwiOiBcIkFcIixcbiAgICAgICAgICBcIlxcdTAxMENcIjogXCJDXCIsXG4gICAgICAgICAgXCJcXHUwMTE4XCI6IFwiRVwiLFxuICAgICAgICAgIFwiXFx1MDExNlwiOiBcIkVcIixcbiAgICAgICAgICBcIlxcdTAxMkVcIjogXCJJXCIsXG4gICAgICAgICAgXCJcXHUwMTYwXCI6IFwiU1wiLFxuICAgICAgICAgIFwiXFx1MDE3MlwiOiBcIlVcIixcbiAgICAgICAgICBcIlxcdTAxNkFcIjogXCJVXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJsdlwiOiB7XG4gICAgICAgICAgLy8gTGF0dmlhblxuICAgICAgICAgIFwiXFx1MDEwMVwiOiBcImFcIixcbiAgICAgICAgICBcIlxcdTAxMERcIjogXCJjXCIsXG4gICAgICAgICAgXCJcXHUwMTEzXCI6IFwiZVwiLFxuICAgICAgICAgIFwiXFx1MDEyM1wiOiBcImdcIixcbiAgICAgICAgICBcIlxcdTAxMkJcIjogXCJpXCIsXG4gICAgICAgICAgXCJcXHUwMTM3XCI6IFwia1wiLFxuICAgICAgICAgIFwiXFx1MDEzQ1wiOiBcImxcIixcbiAgICAgICAgICBcIlxcdTAxNDZcIjogXCJuXCIsXG4gICAgICAgICAgXCJcXHUwMTYxXCI6IFwic1wiLFxuICAgICAgICAgIFwiXFx1MDE2QlwiOiBcInVcIixcbiAgICAgICAgICBcIlxcdTAxN0VcIjogXCJ6XCIsXG4gICAgICAgICAgXCJcXHUwMTAwXCI6IFwiQVwiLFxuICAgICAgICAgIFwiXFx1MDEwQ1wiOiBcIkNcIixcbiAgICAgICAgICBcIlxcdTAxMTJcIjogXCJFXCIsXG4gICAgICAgICAgXCJcXHUwMTIyXCI6IFwiR1wiLFxuICAgICAgICAgIFwiXFx1MDEyQVwiOiBcImlcIixcbiAgICAgICAgICBcIlxcdTAxMzZcIjogXCJrXCIsXG4gICAgICAgICAgXCJcXHUwMTNCXCI6IFwiTFwiLFxuICAgICAgICAgIFwiXFx1MDE0NVwiOiBcIk5cIixcbiAgICAgICAgICBcIlxcdTAxNjBcIjogXCJTXCIsXG4gICAgICAgICAgXCJcXHUwMTZBXCI6IFwidVwiLFxuICAgICAgICAgIFwiXFx1MDE3RFwiOiBcIlpcIlxuICAgICAgICB9LFxuICAgICAgICBcInBsXCI6IHtcbiAgICAgICAgICAvLyBQb2xpc2hcbiAgICAgICAgICBcIlxcdTAxMDVcIjogXCJhXCIsXG4gICAgICAgICAgXCJcXHUwMTA3XCI6IFwiY1wiLFxuICAgICAgICAgIFwiXFx1MDExOVwiOiBcImVcIixcbiAgICAgICAgICBcIlxcdTAxNDJcIjogXCJsXCIsXG4gICAgICAgICAgXCJcXHUwMTQ0XCI6IFwiblwiLFxuICAgICAgICAgIFwiXFx4RjNcIjogXCJvXCIsXG4gICAgICAgICAgXCJcXHUwMTVCXCI6IFwic1wiLFxuICAgICAgICAgIFwiXFx1MDE3QVwiOiBcInpcIixcbiAgICAgICAgICBcIlxcdTAxN0NcIjogXCJ6XCIsXG4gICAgICAgICAgXCJcXHUwMTA0XCI6IFwiQVwiLFxuICAgICAgICAgIFwiXFx1MDEwNlwiOiBcIkNcIixcbiAgICAgICAgICBcIlxcdTAxMThcIjogXCJlXCIsXG4gICAgICAgICAgXCJcXHUwMTQxXCI6IFwiTFwiLFxuICAgICAgICAgIFwiXFx1MDE0M1wiOiBcIk5cIixcbiAgICAgICAgICBcIlxceEQzXCI6IFwiT1wiLFxuICAgICAgICAgIFwiXFx1MDE1QVwiOiBcIlNcIixcbiAgICAgICAgICBcIlxcdTAxNzlcIjogXCJaXCIsXG4gICAgICAgICAgXCJcXHUwMTdCXCI6IFwiWlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3ZcIjoge1xuICAgICAgICAgIC8vIFN3ZWRpc2hcbiAgICAgICAgICAvLyAnw6UnOiAnYScsIGR1cGxpY2F0ZSBzZWUgY2hhck1hcC9sYXRpblxuICAgICAgICAgIC8vICfDhSc6ICdBJywgZHVwbGljYXRlIHNlZSBjaGFyTWFwL2xhdGluXG4gICAgICAgICAgXCJcXHhFNFwiOiBcImFcIixcbiAgICAgICAgICAvLyBva1xuICAgICAgICAgIFwiXFx4QzRcIjogXCJBXCIsXG4gICAgICAgICAgLy8gb2tcbiAgICAgICAgICBcIlxceEY2XCI6IFwib1wiLFxuICAgICAgICAgIC8vIG9rXG4gICAgICAgICAgXCJcXHhENlwiOiBcIk9cIlxuICAgICAgICAgIC8vIG9rXG4gICAgICAgIH0sXG4gICAgICAgIFwic2tcIjoge1xuICAgICAgICAgIC8vIFNsb3Zha1xuICAgICAgICAgIFwiXFx4RTRcIjogXCJhXCIsXG4gICAgICAgICAgXCJcXHhDNFwiOiBcIkFcIlxuICAgICAgICB9LFxuICAgICAgICBcInNyXCI6IHtcbiAgICAgICAgICAvLyBTZXJiaWFuXG4gICAgICAgICAgXCJcXHUwNDU5XCI6IFwibGpcIixcbiAgICAgICAgICBcIlxcdTA0NUFcIjogXCJualwiLFxuICAgICAgICAgIFwiXFx1MDQwOVwiOiBcIkxqXCIsXG4gICAgICAgICAgXCJcXHUwNDBBXCI6IFwiTmpcIixcbiAgICAgICAgICBcIlxcdTAxMTFcIjogXCJkalwiLFxuICAgICAgICAgIFwiXFx1MDExMFwiOiBcIkRqXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0clwiOiB7XG4gICAgICAgICAgLy8gVHVya2lzaFxuICAgICAgICAgIFwiXFx4RENcIjogXCJVXCIsXG4gICAgICAgICAgXCJcXHhENlwiOiBcIk9cIixcbiAgICAgICAgICBcIlxceEZDXCI6IFwidVwiLFxuICAgICAgICAgIFwiXFx4RjZcIjogXCJvXCJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBzeW1ib2xNYXAgPSB7XG4gICAgICAgIFwiYXJcIjoge1xuICAgICAgICAgIFwiXFx1MjIwNlwiOiBcImRlbHRhXCIsXG4gICAgICAgICAgXCJcXHUyMjFFXCI6IFwibGEtbmloYXlhXCIsXG4gICAgICAgICAgXCJcXHUyNjY1XCI6IFwiaG9iXCIsXG4gICAgICAgICAgXCImXCI6IFwid2FcIixcbiAgICAgICAgICBcInxcIjogXCJhd1wiLFxuICAgICAgICAgIFwiPFwiOiBcImFxYWwtbWVuXCIsXG4gICAgICAgICAgXCI+XCI6IFwiYWtiYXItbWVuXCIsXG4gICAgICAgICAgXCJcXHUyMjExXCI6IFwibWFqbW91XCIsXG4gICAgICAgICAgXCJcXHhBNFwiOiBcIm9tbGFcIlxuICAgICAgICB9LFxuICAgICAgICBcImF6XCI6IHt9LFxuICAgICAgICBcImNhXCI6IHtcbiAgICAgICAgICBcIlxcdTIyMDZcIjogXCJkZWx0YVwiLFxuICAgICAgICAgIFwiXFx1MjIxRVwiOiBcImluZmluaXRcIixcbiAgICAgICAgICBcIlxcdTI2NjVcIjogXCJhbW9yXCIsXG4gICAgICAgICAgXCImXCI6IFwiaVwiLFxuICAgICAgICAgIFwifFwiOiBcIm9cIixcbiAgICAgICAgICBcIjxcIjogXCJtZW55cyBxdWVcIixcbiAgICAgICAgICBcIj5cIjogXCJtZXMgcXVlXCIsXG4gICAgICAgICAgXCJcXHUyMjExXCI6IFwic3VtYSBkZWxzXCIsXG4gICAgICAgICAgXCJcXHhBNFwiOiBcIm1vbmVkYVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiY3NcIjoge1xuICAgICAgICAgIFwiXFx1MjIwNlwiOiBcImRlbHRhXCIsXG4gICAgICAgICAgXCJcXHUyMjFFXCI6IFwibmVrb25lY25vXCIsXG4gICAgICAgICAgXCJcXHUyNjY1XCI6IFwibGFza2FcIixcbiAgICAgICAgICBcIiZcIjogXCJhXCIsXG4gICAgICAgICAgXCJ8XCI6IFwibmVib1wiLFxuICAgICAgICAgIFwiPFwiOiBcIm1lbnNpIG5lelwiLFxuICAgICAgICAgIFwiPlwiOiBcInZldHNpIG5lelwiLFxuICAgICAgICAgIFwiXFx1MjIxMVwiOiBcInNvdWNldFwiLFxuICAgICAgICAgIFwiXFx4QTRcIjogXCJtZW5hXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkZVwiOiB7XG4gICAgICAgICAgXCJcXHUyMjA2XCI6IFwiZGVsdGFcIixcbiAgICAgICAgICBcIlxcdTIyMUVcIjogXCJ1bmVuZGxpY2hcIixcbiAgICAgICAgICBcIlxcdTI2NjVcIjogXCJMaWViZVwiLFxuICAgICAgICAgIFwiJlwiOiBcInVuZFwiLFxuICAgICAgICAgIFwifFwiOiBcIm9kZXJcIixcbiAgICAgICAgICBcIjxcIjogXCJrbGVpbmVyIGFsc1wiLFxuICAgICAgICAgIFwiPlwiOiBcImdyb2Vzc2VyIGFsc1wiLFxuICAgICAgICAgIFwiXFx1MjIxMVwiOiBcIlN1bW1lIHZvblwiLFxuICAgICAgICAgIFwiXFx4QTRcIjogXCJXYWVocnVuZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZHZcIjoge1xuICAgICAgICAgIFwiXFx1MjIwNlwiOiBcImRlbHRhXCIsXG4gICAgICAgICAgXCJcXHUyMjFFXCI6IFwia29sdW51bGFhXCIsXG4gICAgICAgICAgXCJcXHUyNjY1XCI6IFwibG9hYmlcIixcbiAgICAgICAgICBcIiZcIjogXCJhYWlcIixcbiAgICAgICAgICBcInxcIjogXCJub29uZWVcIixcbiAgICAgICAgICBcIjxcIjogXCJhaCB2dXJlIGt1ZGFcIixcbiAgICAgICAgICBcIj5cIjogXCJhaCB2dXJlIGJvZHVcIixcbiAgICAgICAgICBcIlxcdTIyMTFcIjogXCJqdW11bGFcIixcbiAgICAgICAgICBcIlxceEE0XCI6IFwiZmFpc2FhXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJlblwiOiB7XG4gICAgICAgICAgXCJcXHUyMjA2XCI6IFwiZGVsdGFcIixcbiAgICAgICAgICBcIlxcdTIyMUVcIjogXCJpbmZpbml0eVwiLFxuICAgICAgICAgIFwiXFx1MjY2NVwiOiBcImxvdmVcIixcbiAgICAgICAgICBcIiZcIjogXCJhbmRcIixcbiAgICAgICAgICBcInxcIjogXCJvclwiLFxuICAgICAgICAgIFwiPFwiOiBcImxlc3MgdGhhblwiLFxuICAgICAgICAgIFwiPlwiOiBcImdyZWF0ZXIgdGhhblwiLFxuICAgICAgICAgIFwiXFx1MjIxMVwiOiBcInN1bVwiLFxuICAgICAgICAgIFwiXFx4QTRcIjogXCJjdXJyZW5jeVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXNcIjoge1xuICAgICAgICAgIFwiXFx1MjIwNlwiOiBcImRlbHRhXCIsXG4gICAgICAgICAgXCJcXHUyMjFFXCI6IFwiaW5maW5pdG9cIixcbiAgICAgICAgICBcIlxcdTI2NjVcIjogXCJhbW9yXCIsXG4gICAgICAgICAgXCImXCI6IFwieVwiLFxuICAgICAgICAgIFwifFwiOiBcInVcIixcbiAgICAgICAgICBcIjxcIjogXCJtZW5vcyBxdWVcIixcbiAgICAgICAgICBcIj5cIjogXCJtYXMgcXVlXCIsXG4gICAgICAgICAgXCJcXHUyMjExXCI6IFwic3VtYSBkZSBsb3NcIixcbiAgICAgICAgICBcIlxceEE0XCI6IFwibW9uZWRhXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJmYVwiOiB7XG4gICAgICAgICAgXCJcXHUyMjA2XCI6IFwiZGVsdGFcIixcbiAgICAgICAgICBcIlxcdTIyMUVcIjogXCJiaS1uYWhheWF0XCIsXG4gICAgICAgICAgXCJcXHUyNjY1XCI6IFwiZXNoZ2hcIixcbiAgICAgICAgICBcIiZcIjogXCJ2YVwiLFxuICAgICAgICAgIFwifFwiOiBcInlhXCIsXG4gICAgICAgICAgXCI8XCI6IFwia2FtdGFyLWF6XCIsXG4gICAgICAgICAgXCI+XCI6IFwiYmlzaHRhci1helwiLFxuICAgICAgICAgIFwiXFx1MjIxMVwiOiBcIm1ham1vb2VcIixcbiAgICAgICAgICBcIlxceEE0XCI6IFwidmFoZWRcIlxuICAgICAgICB9LFxuICAgICAgICBcImZpXCI6IHtcbiAgICAgICAgICBcIlxcdTIyMDZcIjogXCJkZWx0YVwiLFxuICAgICAgICAgIFwiXFx1MjIxRVwiOiBcImFhcmV0dG9teXlzXCIsXG4gICAgICAgICAgXCJcXHUyNjY1XCI6IFwicmFra2F1c1wiLFxuICAgICAgICAgIFwiJlwiOiBcImphXCIsXG4gICAgICAgICAgXCJ8XCI6IFwidGFpXCIsXG4gICAgICAgICAgXCI8XCI6IFwicGllbmVtcGkga3VpblwiLFxuICAgICAgICAgIFwiPlwiOiBcInN1dXJlbXBpIGt1aW5cIixcbiAgICAgICAgICBcIlxcdTIyMTFcIjogXCJzdW1tYVwiLFxuICAgICAgICAgIFwiXFx4QTRcIjogXCJ2YWx1dXR0YVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZnJcIjoge1xuICAgICAgICAgIFwiXFx1MjIwNlwiOiBcImRlbHRhXCIsXG4gICAgICAgICAgXCJcXHUyMjFFXCI6IFwiaW5maW5pbWVudFwiLFxuICAgICAgICAgIFwiXFx1MjY2NVwiOiBcIkFtb3VyXCIsXG4gICAgICAgICAgXCImXCI6IFwiZXRcIixcbiAgICAgICAgICBcInxcIjogXCJvdVwiLFxuICAgICAgICAgIFwiPFwiOiBcIm1vaW5zIHF1ZVwiLFxuICAgICAgICAgIFwiPlwiOiBcInN1cGVyaWV1cmUgYVwiLFxuICAgICAgICAgIFwiXFx1MjIxMVwiOiBcInNvbW1lIGRlc1wiLFxuICAgICAgICAgIFwiXFx4QTRcIjogXCJtb25uYWllXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJnZVwiOiB7XG4gICAgICAgICAgXCJcXHUyMjA2XCI6IFwiZGVsdGFcIixcbiAgICAgICAgICBcIlxcdTIyMUVcIjogXCJ1c2FzcnVsb2JhXCIsXG4gICAgICAgICAgXCJcXHUyNjY1XCI6IFwic2lxdmFydWxpXCIsXG4gICAgICAgICAgXCImXCI6IFwiZGFcIixcbiAgICAgICAgICBcInxcIjogXCJhblwiLFxuICAgICAgICAgIFwiPFwiOiBcIm5ha2xlYmlcIixcbiAgICAgICAgICBcIj5cIjogXCJtZXRpXCIsXG4gICAgICAgICAgXCJcXHUyMjExXCI6IFwiamFtaVwiLFxuICAgICAgICAgIFwiXFx4QTRcIjogXCJ2YWx1dGFcIlxuICAgICAgICB9LFxuICAgICAgICBcImdyXCI6IHt9LFxuICAgICAgICBcImh1XCI6IHtcbiAgICAgICAgICBcIlxcdTIyMDZcIjogXCJkZWx0YVwiLFxuICAgICAgICAgIFwiXFx1MjIxRVwiOiBcInZlZ3RlbGVuXCIsXG4gICAgICAgICAgXCJcXHUyNjY1XCI6IFwic3plcmVsZW1cIixcbiAgICAgICAgICBcIiZcIjogXCJlc1wiLFxuICAgICAgICAgIFwifFwiOiBcInZhZ3lcIixcbiAgICAgICAgICBcIjxcIjogXCJraXNlYmIgbWludFwiLFxuICAgICAgICAgIFwiPlwiOiBcIm5hZ3lvYmIgbWludFwiLFxuICAgICAgICAgIFwiXFx1MjIxMVwiOiBcInN6dW1tYVwiLFxuICAgICAgICAgIFwiXFx4QTRcIjogXCJwZW56bmVtXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpdFwiOiB7XG4gICAgICAgICAgXCJcXHUyMjA2XCI6IFwiZGVsdGFcIixcbiAgICAgICAgICBcIlxcdTIyMUVcIjogXCJpbmZpbml0b1wiLFxuICAgICAgICAgIFwiXFx1MjY2NVwiOiBcImFtb3JlXCIsXG4gICAgICAgICAgXCImXCI6IFwiZVwiLFxuICAgICAgICAgIFwifFwiOiBcIm9cIixcbiAgICAgICAgICBcIjxcIjogXCJtaW5vcmUgZGlcIixcbiAgICAgICAgICBcIj5cIjogXCJtYWdnaW9yZSBkaVwiLFxuICAgICAgICAgIFwiXFx1MjIxMVwiOiBcInNvbW1hXCIsXG4gICAgICAgICAgXCJcXHhBNFwiOiBcIm1vbmV0YVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibHRcIjoge1xuICAgICAgICAgIFwiXFx1MjIwNlwiOiBcImRlbHRhXCIsXG4gICAgICAgICAgXCJcXHUyMjFFXCI6IFwiYmVnYWx5YmVcIixcbiAgICAgICAgICBcIlxcdTI2NjVcIjogXCJtZWlsZVwiLFxuICAgICAgICAgIFwiJlwiOiBcImlyXCIsXG4gICAgICAgICAgXCJ8XCI6IFwiYXJcIixcbiAgICAgICAgICBcIjxcIjogXCJtYXppYXUgbmVpXCIsXG4gICAgICAgICAgXCI+XCI6IFwiZGF1Z2lhdSBuZWlcIixcbiAgICAgICAgICBcIlxcdTIyMTFcIjogXCJzdW1hXCIsXG4gICAgICAgICAgXCJcXHhBNFwiOiBcInZhbGl1dGFcIlxuICAgICAgICB9LFxuICAgICAgICBcImx2XCI6IHtcbiAgICAgICAgICBcIlxcdTIyMDZcIjogXCJkZWx0YVwiLFxuICAgICAgICAgIFwiXFx1MjIxRVwiOiBcImJlemdhbGliYVwiLFxuICAgICAgICAgIFwiXFx1MjY2NVwiOiBcIm1pbGVzdGliYVwiLFxuICAgICAgICAgIFwiJlwiOiBcInVuXCIsXG4gICAgICAgICAgXCJ8XCI6IFwidmFpXCIsXG4gICAgICAgICAgXCI8XCI6IFwibWF6YWsgbmVrYVwiLFxuICAgICAgICAgIFwiPlwiOiBcImxpZWxha3MgbmVrYVwiLFxuICAgICAgICAgIFwiXFx1MjIxMVwiOiBcInN1bW1hXCIsXG4gICAgICAgICAgXCJcXHhBNFwiOiBcInZhbHV0YVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibXlcIjoge1xuICAgICAgICAgIFwiXFx1MjIwNlwiOiBcImt3YWhraHlhZXRcIixcbiAgICAgICAgICBcIlxcdTIyMUVcIjogXCJhc2FvbmFzbWVcIixcbiAgICAgICAgICBcIlxcdTI2NjVcIjogXCJha2h5YWl0XCIsXG4gICAgICAgICAgXCImXCI6IFwibmhpblwiLFxuICAgICAgICAgIFwifFwiOiBcInRob1wiLFxuICAgICAgICAgIFwiPFwiOiBcIm5nZXRoYXdcIixcbiAgICAgICAgICBcIj5cIjogXCJreWl0aGF3XCIsXG4gICAgICAgICAgXCJcXHUyMjExXCI6IFwicGF1bmdsZFwiLFxuICAgICAgICAgIFwiXFx4QTRcIjogXCJuZ3dla3llXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJta1wiOiB7fSxcbiAgICAgICAgXCJubFwiOiB7XG4gICAgICAgICAgXCJcXHUyMjA2XCI6IFwiZGVsdGFcIixcbiAgICAgICAgICBcIlxcdTIyMUVcIjogXCJvbmVpbmRpZ1wiLFxuICAgICAgICAgIFwiXFx1MjY2NVwiOiBcImxpZWZkZVwiLFxuICAgICAgICAgIFwiJlwiOiBcImVuXCIsXG4gICAgICAgICAgXCJ8XCI6IFwib2ZcIixcbiAgICAgICAgICBcIjxcIjogXCJrbGVpbmVyIGRhblwiLFxuICAgICAgICAgIFwiPlwiOiBcImdyb3RlciBkYW5cIixcbiAgICAgICAgICBcIlxcdTIyMTFcIjogXCJzb21cIixcbiAgICAgICAgICBcIlxceEE0XCI6IFwidmFsdXRhXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJwbFwiOiB7XG4gICAgICAgICAgXCJcXHUyMjA2XCI6IFwiZGVsdGFcIixcbiAgICAgICAgICBcIlxcdTIyMUVcIjogXCJuaWVza29uY3pvbm9zY1wiLFxuICAgICAgICAgIFwiXFx1MjY2NVwiOiBcIm1pbG9zY1wiLFxuICAgICAgICAgIFwiJlwiOiBcImlcIixcbiAgICAgICAgICBcInxcIjogXCJsdWJcIixcbiAgICAgICAgICBcIjxcIjogXCJtbmllanN6ZSBuaXpcIixcbiAgICAgICAgICBcIj5cIjogXCJ3aWVrc3plIG5pelwiLFxuICAgICAgICAgIFwiXFx1MjIxMVwiOiBcInN1bWFcIixcbiAgICAgICAgICBcIlxceEE0XCI6IFwid2FsdXRhXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJwdFwiOiB7XG4gICAgICAgICAgXCJcXHUyMjA2XCI6IFwiZGVsdGFcIixcbiAgICAgICAgICBcIlxcdTIyMUVcIjogXCJpbmZpbml0b1wiLFxuICAgICAgICAgIFwiXFx1MjY2NVwiOiBcImFtb3JcIixcbiAgICAgICAgICBcIiZcIjogXCJlXCIsXG4gICAgICAgICAgXCJ8XCI6IFwib3VcIixcbiAgICAgICAgICBcIjxcIjogXCJtZW5vciBxdWVcIixcbiAgICAgICAgICBcIj5cIjogXCJtYWlvciBxdWVcIixcbiAgICAgICAgICBcIlxcdTIyMTFcIjogXCJzb21hXCIsXG4gICAgICAgICAgXCJcXHhBNFwiOiBcIm1vZWRhXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyb1wiOiB7XG4gICAgICAgICAgXCJcXHUyMjA2XCI6IFwiZGVsdGFcIixcbiAgICAgICAgICBcIlxcdTIyMUVcIjogXCJpbmZpbml0XCIsXG4gICAgICAgICAgXCJcXHUyNjY1XCI6IFwiZHJhZ29zdGVcIixcbiAgICAgICAgICBcIiZcIjogXCJzaVwiLFxuICAgICAgICAgIFwifFwiOiBcInNhdVwiLFxuICAgICAgICAgIFwiPFwiOiBcIm1haSBtaWMgY2FcIixcbiAgICAgICAgICBcIj5cIjogXCJtYWkgbWFyZSBjYVwiLFxuICAgICAgICAgIFwiXFx1MjIxMVwiOiBcInN1bWFcIixcbiAgICAgICAgICBcIlxceEE0XCI6IFwidmFsdXRhXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJydVwiOiB7XG4gICAgICAgICAgXCJcXHUyMjA2XCI6IFwiZGVsdGFcIixcbiAgICAgICAgICBcIlxcdTIyMUVcIjogXCJiZXNrb25lY2hub1wiLFxuICAgICAgICAgIFwiXFx1MjY2NVwiOiBcImx1Ym92XCIsXG4gICAgICAgICAgXCImXCI6IFwiaVwiLFxuICAgICAgICAgIFwifFwiOiBcImlsaVwiLFxuICAgICAgICAgIFwiPFwiOiBcIm1lbnNoZVwiLFxuICAgICAgICAgIFwiPlwiOiBcImJvbHNoZVwiLFxuICAgICAgICAgIFwiXFx1MjIxMVwiOiBcInN1bW1hXCIsXG4gICAgICAgICAgXCJcXHhBNFwiOiBcInZhbGp1dGFcIlxuICAgICAgICB9LFxuICAgICAgICBcInNrXCI6IHtcbiAgICAgICAgICBcIlxcdTIyMDZcIjogXCJkZWx0YVwiLFxuICAgICAgICAgIFwiXFx1MjIxRVwiOiBcIm5la29uZWNub1wiLFxuICAgICAgICAgIFwiXFx1MjY2NVwiOiBcImxhc2thXCIsXG4gICAgICAgICAgXCImXCI6IFwiYVwiLFxuICAgICAgICAgIFwifFwiOiBcImFsZWJvXCIsXG4gICAgICAgICAgXCI8XCI6IFwibWVuZWogYWtvXCIsXG4gICAgICAgICAgXCI+XCI6IFwidmlhYyBha29cIixcbiAgICAgICAgICBcIlxcdTIyMTFcIjogXCJzdWNldFwiLFxuICAgICAgICAgIFwiXFx4QTRcIjogXCJtZW5hXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzclwiOiB7fSxcbiAgICAgICAgXCJ0clwiOiB7XG4gICAgICAgICAgXCJcXHUyMjA2XCI6IFwiZGVsdGFcIixcbiAgICAgICAgICBcIlxcdTIyMUVcIjogXCJzb25zdXpsdWtcIixcbiAgICAgICAgICBcIlxcdTI2NjVcIjogXCJhc2tcIixcbiAgICAgICAgICBcIiZcIjogXCJ2ZVwiLFxuICAgICAgICAgIFwifFwiOiBcInZleWFcIixcbiAgICAgICAgICBcIjxcIjogXCJrdWN1a3R1clwiLFxuICAgICAgICAgIFwiPlwiOiBcImJ1eXVrdHVyXCIsXG4gICAgICAgICAgXCJcXHUyMjExXCI6IFwidG9wbGFtXCIsXG4gICAgICAgICAgXCJcXHhBNFwiOiBcInBhcmEgYmlyaW1pXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ1a1wiOiB7XG4gICAgICAgICAgXCJcXHUyMjA2XCI6IFwiZGVsdGFcIixcbiAgICAgICAgICBcIlxcdTIyMUVcIjogXCJiZXpraW5lY2huaXN0XCIsXG4gICAgICAgICAgXCJcXHUyNjY1XCI6IFwibHVib3ZcIixcbiAgICAgICAgICBcIiZcIjogXCJpXCIsXG4gICAgICAgICAgXCJ8XCI6IFwiYWJvXCIsXG4gICAgICAgICAgXCI8XCI6IFwibWVuc2hlXCIsXG4gICAgICAgICAgXCI+XCI6IFwiYmlsc2hlXCIsXG4gICAgICAgICAgXCJcXHUyMjExXCI6IFwic3VtYVwiLFxuICAgICAgICAgIFwiXFx4QTRcIjogXCJ2YWxqdXRhXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ2blwiOiB7XG4gICAgICAgICAgXCJcXHUyMjA2XCI6IFwiZGVsdGFcIixcbiAgICAgICAgICBcIlxcdTIyMUVcIjogXCJ2byBjdWNcIixcbiAgICAgICAgICBcIlxcdTI2NjVcIjogXCJ5ZXVcIixcbiAgICAgICAgICBcIiZcIjogXCJ2YVwiLFxuICAgICAgICAgIFwifFwiOiBcImhvYWNcIixcbiAgICAgICAgICBcIjxcIjogXCJuaG8gaG9uXCIsXG4gICAgICAgICAgXCI+XCI6IFwibG9uIGhvblwiLFxuICAgICAgICAgIFwiXFx1MjIxMVwiOiBcInRvbmdcIixcbiAgICAgICAgICBcIlxceEE0XCI6IFwidGllbiB0ZVwiXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgdXJpY0NoYXJzID0gW1wiO1wiLCBcIj9cIiwgXCI6XCIsIFwiQFwiLCBcIiZcIiwgXCI9XCIsIFwiK1wiLCBcIiRcIiwgXCIsXCIsIFwiL1wiXS5qb2luKFwiXCIpO1xuICAgICAgdmFyIHVyaWNOb1NsYXNoQ2hhcnMgPSBbXCI7XCIsIFwiP1wiLCBcIjpcIiwgXCJAXCIsIFwiJlwiLCBcIj1cIiwgXCIrXCIsIFwiJFwiLCBcIixcIl0uam9pbihcIlwiKTtcbiAgICAgIHZhciBtYXJrQ2hhcnMgPSBbXCIuXCIsIFwiIVwiLCBcIn5cIiwgXCIqXCIsIFwiJ1wiLCBcIihcIiwgXCIpXCJdLmpvaW4oXCJcIik7XG4gICAgICB2YXIgZ2V0U2x1ZyA9IGZ1bmN0aW9uIGdldFNsdWcyKGlucHV0LCBvcHRzKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBcIi1cIjtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIHZhciBkaWF0cmljU3RyaW5nID0gXCJcIjtcbiAgICAgICAgdmFyIGNvbnZlcnRTeW1ib2xzID0gdHJ1ZTtcbiAgICAgICAgdmFyIGN1c3RvbVJlcGxhY2VtZW50cyA9IHt9O1xuICAgICAgICB2YXIgbWFpbnRhaW5DYXNlO1xuICAgICAgICB2YXIgdGl0bGVDYXNlO1xuICAgICAgICB2YXIgdHJ1bmNhdGU7XG4gICAgICAgIHZhciB1cmljRmxhZztcbiAgICAgICAgdmFyIHVyaWNOb1NsYXNoRmxhZztcbiAgICAgICAgdmFyIG1hcmtGbGFnO1xuICAgICAgICB2YXIgc3ltYm9sO1xuICAgICAgICB2YXIgbGFuZ0NoYXI7XG4gICAgICAgIHZhciBsdWNreTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBjaDtcbiAgICAgICAgdmFyIGw7XG4gICAgICAgIHZhciBsYXN0Q2hhcldhc1N5bWJvbDtcbiAgICAgICAgdmFyIGxhc3RDaGFyV2FzRGlhdHJpYztcbiAgICAgICAgdmFyIGFsbG93ZWRDaGFycyA9IFwiXCI7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBzZXBhcmF0b3IgPSBvcHRzO1xuICAgICAgICB9XG4gICAgICAgIHN5bWJvbCA9IHN5bWJvbE1hcC5lbjtcbiAgICAgICAgbGFuZ0NoYXIgPSBsYW5nQ2hhck1hcC5lbjtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgbWFpbnRhaW5DYXNlID0gb3B0cy5tYWludGFpbkNhc2UgfHwgZmFsc2U7XG4gICAgICAgICAgY3VzdG9tUmVwbGFjZW1lbnRzID0gb3B0cy5jdXN0b20gJiYgdHlwZW9mIG9wdHMuY3VzdG9tID09PSBcIm9iamVjdFwiID8gb3B0cy5jdXN0b20gOiBjdXN0b21SZXBsYWNlbWVudHM7XG4gICAgICAgICAgdHJ1bmNhdGUgPSArb3B0cy50cnVuY2F0ZSA+IDEgJiYgb3B0cy50cnVuY2F0ZSB8fCBmYWxzZTtcbiAgICAgICAgICB1cmljRmxhZyA9IG9wdHMudXJpYyB8fCBmYWxzZTtcbiAgICAgICAgICB1cmljTm9TbGFzaEZsYWcgPSBvcHRzLnVyaWNOb1NsYXNoIHx8IGZhbHNlO1xuICAgICAgICAgIG1hcmtGbGFnID0gb3B0cy5tYXJrIHx8IGZhbHNlO1xuICAgICAgICAgIGNvbnZlcnRTeW1ib2xzID0gb3B0cy5zeW1ib2xzID09PSBmYWxzZSB8fCBvcHRzLmxhbmcgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICAgIHNlcGFyYXRvciA9IG9wdHMuc2VwYXJhdG9yIHx8IHNlcGFyYXRvcjtcbiAgICAgICAgICBpZiAodXJpY0ZsYWcpIHtcbiAgICAgICAgICAgIGFsbG93ZWRDaGFycyArPSB1cmljQ2hhcnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1cmljTm9TbGFzaEZsYWcpIHtcbiAgICAgICAgICAgIGFsbG93ZWRDaGFycyArPSB1cmljTm9TbGFzaENoYXJzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWFya0ZsYWcpIHtcbiAgICAgICAgICAgIGFsbG93ZWRDaGFycyArPSBtYXJrQ2hhcnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN5bWJvbCA9IG9wdHMubGFuZyAmJiBzeW1ib2xNYXBbb3B0cy5sYW5nXSAmJiBjb252ZXJ0U3ltYm9scyA/IHN5bWJvbE1hcFtvcHRzLmxhbmddIDogY29udmVydFN5bWJvbHMgPyBzeW1ib2xNYXAuZW4gOiB7fTtcbiAgICAgICAgICBsYW5nQ2hhciA9IG9wdHMubGFuZyAmJiBsYW5nQ2hhck1hcFtvcHRzLmxhbmddID8gbGFuZ0NoYXJNYXBbb3B0cy5sYW5nXSA6IG9wdHMubGFuZyA9PT0gZmFsc2UgfHwgb3B0cy5sYW5nID09PSB0cnVlID8ge30gOiBsYW5nQ2hhck1hcC5lbjtcbiAgICAgICAgICBpZiAob3B0cy50aXRsZUNhc2UgJiYgdHlwZW9mIG9wdHMudGl0bGVDYXNlLmxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBBcnJheS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvcHRzLnRpdGxlQ2FzZSkpIHtcbiAgICAgICAgICAgIG9wdHMudGl0bGVDYXNlLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICBjdXN0b21SZXBsYWNlbWVudHNbdiArIFwiXCJdID0gdiArIFwiXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRpdGxlQ2FzZSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpdGxlQ2FzZSA9ICEhb3B0cy50aXRsZUNhc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLmN1c3RvbSAmJiB0eXBlb2Ygb3B0cy5jdXN0b20ubGVuZ3RoID09PSBcIm51bWJlclwiICYmIEFycmF5LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9wdHMuY3VzdG9tKSkge1xuICAgICAgICAgICAgb3B0cy5jdXN0b20uZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIGN1c3RvbVJlcGxhY2VtZW50c1t2ICsgXCJcIl0gPSB2ICsgXCJcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3Qua2V5cyhjdXN0b21SZXBsYWNlbWVudHMpLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgICAgICAgdmFyIHI7XG4gICAgICAgICAgICBpZiAodi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHIgPSBuZXcgUmVnRXhwKFwiXFxcXGJcIiArIGVzY2FwZUNoYXJzKHYpICsgXCJcXFxcYlwiLCBcImdpXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgciA9IG5ldyBSZWdFeHAoZXNjYXBlQ2hhcnModiksIFwiZ2lcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UociwgY3VzdG9tUmVwbGFjZW1lbnRzW3ZdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGNoIGluIGN1c3RvbVJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgYWxsb3dlZENoYXJzICs9IGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhbGxvd2VkQ2hhcnMgKz0gc2VwYXJhdG9yO1xuICAgICAgICBhbGxvd2VkQ2hhcnMgPSBlc2NhcGVDaGFycyhhbGxvd2VkQ2hhcnMpO1xuICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoLyheXFxzK3xcXHMrJCkvZywgXCJcIik7XG4gICAgICAgIGxhc3RDaGFyV2FzU3ltYm9sID0gZmFsc2U7XG4gICAgICAgIGxhc3RDaGFyV2FzRGlhdHJpYyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gaW5wdXQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY2ggPSBpbnB1dFtpXTtcbiAgICAgICAgICBpZiAoaXNSZXBsYWNlZEN1c3RvbUNoYXIoY2gsIGN1c3RvbVJlcGxhY2VtZW50cykpIHtcbiAgICAgICAgICAgIGxhc3RDaGFyV2FzU3ltYm9sID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChsYW5nQ2hhcltjaF0pIHtcbiAgICAgICAgICAgIGNoID0gbGFzdENoYXJXYXNTeW1ib2wgJiYgbGFuZ0NoYXJbY2hdLm1hdGNoKC9bQS1aYS16MC05XS8pID8gXCIgXCIgKyBsYW5nQ2hhcltjaF0gOiBsYW5nQ2hhcltjaF07XG4gICAgICAgICAgICBsYXN0Q2hhcldhc1N5bWJvbCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggaW4gY2hhck1hcCkge1xuICAgICAgICAgICAgaWYgKGkgKyAxIDwgbCAmJiBsb29rQWhlYWRDaGFyQXJyYXkuaW5kZXhPZihpbnB1dFtpICsgMV0pID49IDApIHtcbiAgICAgICAgICAgICAgZGlhdHJpY1N0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgY2ggPSBcIlwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0Q2hhcldhc0RpYXRyaWMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgY2ggPSBkaWF0cmljTWFwW2RpYXRyaWNTdHJpbmddICsgY2hhck1hcFtjaF07XG4gICAgICAgICAgICAgIGRpYXRyaWNTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2ggPSBsYXN0Q2hhcldhc1N5bWJvbCAmJiBjaGFyTWFwW2NoXS5tYXRjaCgvW0EtWmEtejAtOV0vKSA/IFwiIFwiICsgY2hhck1hcFtjaF0gOiBjaGFyTWFwW2NoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RDaGFyV2FzU3ltYm9sID0gZmFsc2U7XG4gICAgICAgICAgICBsYXN0Q2hhcldhc0RpYXRyaWMgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoIGluIGRpYXRyaWNNYXApIHtcbiAgICAgICAgICAgIGRpYXRyaWNTdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICBjaCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoaSA9PT0gbCAtIDEpIHtcbiAgICAgICAgICAgICAgY2ggPSBkaWF0cmljTWFwW2RpYXRyaWNTdHJpbmddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENoYXJXYXNEaWF0cmljID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgLy8gcHJvY2VzcyBzeW1ib2wgY2hhcnNcbiAgICAgICAgICAgIHN5bWJvbFtjaF0gJiYgISh1cmljRmxhZyAmJiB1cmljQ2hhcnMuaW5kZXhPZihjaCkgIT09IC0xKSAmJiAhKHVyaWNOb1NsYXNoRmxhZyAmJiB1cmljTm9TbGFzaENoYXJzLmluZGV4T2YoY2gpICE9PSAtMSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNoID0gbGFzdENoYXJXYXNTeW1ib2wgfHwgcmVzdWx0LnN1YnN0cigtMSkubWF0Y2goL1tBLVphLXowLTldLykgPyBzZXBhcmF0b3IgKyBzeW1ib2xbY2hdIDogc3ltYm9sW2NoXTtcbiAgICAgICAgICAgIGNoICs9IGlucHV0W2kgKyAxXSAhPT0gdm9pZCAwICYmIGlucHV0W2kgKyAxXS5tYXRjaCgvW0EtWmEtejAtOV0vKSA/IHNlcGFyYXRvciA6IFwiXCI7XG4gICAgICAgICAgICBsYXN0Q2hhcldhc1N5bWJvbCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsYXN0Q2hhcldhc0RpYXRyaWMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgY2ggPSBkaWF0cmljTWFwW2RpYXRyaWNTdHJpbmddICsgY2g7XG4gICAgICAgICAgICAgIGRpYXRyaWNTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgICBsYXN0Q2hhcldhc0RpYXRyaWMgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdENoYXJXYXNTeW1ib2wgJiYgKC9bQS1aYS16MC05XS8udGVzdChjaCkgfHwgcmVzdWx0LnN1YnN0cigtMSkubWF0Y2goL0EtWmEtejAtOV0vKSkpIHtcbiAgICAgICAgICAgICAgY2ggPSBcIiBcIiArIGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENoYXJXYXNTeW1ib2wgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ICs9IGNoLnJlcGxhY2UobmV3IFJlZ0V4cChcIlteXFxcXHdcXFxcc1wiICsgYWxsb3dlZENoYXJzICsgXCJfLV1cIiwgXCJnXCIpLCBzZXBhcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aXRsZUNhc2UpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvKFxcdykoXFxTKikvZywgZnVuY3Rpb24oXywgaTIsIHIpIHtcbiAgICAgICAgICAgIHZhciBqID0gaTIudG9VcHBlckNhc2UoKSArIChyICE9PSBudWxsID8gciA6IFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGN1c3RvbVJlcGxhY2VtZW50cykuaW5kZXhPZihqLnRvTG93ZXJDYXNlKCkpIDwgMCA/IGogOiBqLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1xccysvZywgc2VwYXJhdG9yKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxcXCIgKyBzZXBhcmF0b3IgKyBcIitcIiwgXCJnXCIpLCBzZXBhcmF0b3IpLnJlcGxhY2UobmV3IFJlZ0V4cChcIiheXFxcXFwiICsgc2VwYXJhdG9yICsgXCIrfFxcXFxcIiArIHNlcGFyYXRvciArIFwiKyQpXCIsIFwiZ1wiKSwgXCJcIik7XG4gICAgICAgIGlmICh0cnVuY2F0ZSAmJiByZXN1bHQubGVuZ3RoID4gdHJ1bmNhdGUpIHtcbiAgICAgICAgICBsdWNreSA9IHJlc3VsdC5jaGFyQXQodHJ1bmNhdGUpID09PSBzZXBhcmF0b3I7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIHRydW5jYXRlKTtcbiAgICAgICAgICBpZiAoIWx1Y2t5KSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgcmVzdWx0Lmxhc3RJbmRleE9mKHNlcGFyYXRvcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1haW50YWluQ2FzZSAmJiAhdGl0bGVDYXNlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICB2YXIgY3JlYXRlU2x1ZyA9IGZ1bmN0aW9uIGNyZWF0ZVNsdWcyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGdldFNsdWdXaXRoQ29uZmlnKGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIGdldFNsdWcoaW5wdXQsIG9wdHMpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHZhciBlc2NhcGVDaGFycyA9IGZ1bmN0aW9uIGVzY2FwZUNoYXJzMihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvWy1cXFxcXiQqKz8uKCl8W1xcXXt9XFwvXS9nLCBcIlxcXFwkJlwiKTtcbiAgICAgIH07XG4gICAgICB2YXIgaXNSZXBsYWNlZEN1c3RvbUNoYXIgPSBmdW5jdGlvbihjaCwgY3VzdG9tUmVwbGFjZW1lbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGMgaW4gY3VzdG9tUmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgaWYgKGN1c3RvbVJlcGxhY2VtZW50c1tjXSA9PT0gY2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZ2V0U2x1ZztcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMuY3JlYXRlU2x1ZyA9IGNyZWF0ZVNsdWc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBnZXRTbHVnO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHJvb3QuZ2V0U2x1ZyB8fCByb290LmNyZWF0ZVNsdWcpIHtcbiAgICAgICAgICAgIHRocm93IFwic3BlYWtpbmd1cmw6IGdsb2JhbHMgZXhpc3RzIC8oZ2V0U2x1Z3xjcmVhdGVTbHVnKS9cIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm9vdC5nZXRTbHVnID0gZ2V0U2x1ZztcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlU2x1ZyA9IGNyZWF0ZVNsdWc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KShleHBvcnRzKTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zcGVha2luZ3VybEAxNC4wLjEvbm9kZV9tb2R1bGVzL3NwZWFraW5ndXJsL2luZGV4LmpzXG52YXIgcmVxdWlyZV9zcGVha2luZ3VybDIgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3BlYWtpbmd1cmxAMTQuMC4xL25vZGVfbW9kdWxlcy9zcGVha2luZ3VybC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfZXNtX3NoaW1zKCk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX3NwZWFraW5ndXJsKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy9jb3JlL2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgaXNOdXh0QXBwLCB0YXJnZXQgYXMgdGFyZ2V0MTMgfSBmcm9tIFwiQHZ1ZS9kZXZ0b29scy1zaGFyZWRcIjtcblxuLy8gc3JjL2NvbXBhdC9pbmRleC50c1xuaW5pdF9lc21fc2hpbXMoKTtcbmltcG9ydCB7IHRhcmdldCB9IGZyb20gXCJAdnVlL2RldnRvb2xzLXNoYXJlZFwiO1xuZnVuY3Rpb24gb25MZWdhY3lEZXZUb29sc1BsdWdpbkFwaUF2YWlsYWJsZShjYikge1xuICBpZiAodGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX1BMVUdJTl9BUElfQVZBSUxBQkxFX18pIHtcbiAgICBjYigpO1xuICAgIHJldHVybjtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBcIl9fVlVFX0RFVlRPT0xTX1BMVUdJTl9BUElfQVZBSUxBQkxFX19cIiwge1xuICAgIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKVxuICAgICAgICBjYigpO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBzcmMvY3R4L2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgdGFyZ2V0IGFzIHRhcmdldDExIH0gZnJvbSBcIkB2dWUvZGV2dG9vbHMtc2hhcmVkXCI7XG5cbi8vIHNyYy9jdHgvYXBpLnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgdGFyZ2V0IGFzIHRhcmdldDkgfSBmcm9tIFwiQHZ1ZS9kZXZ0b29scy1zaGFyZWRcIjtcblxuLy8gc3JjL2NvcmUvY29tcG9uZW50LWhpZ2hsaWdodGVyL2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyBzcmMvY29yZS9jb21wb25lbnQvc3RhdGUvYm91bmRpbmctcmVjdC50c1xuaW5pdF9lc21fc2hpbXMoKTtcblxuLy8gc3JjL2NvcmUvY29tcG9uZW50L3V0aWxzL2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgYmFzZW5hbWUsIGNsYXNzaWZ5IH0gZnJvbSBcIkB2dWUvZGV2dG9vbHMtc2hhcmVkXCI7XG5mdW5jdGlvbiBnZXRDb21wb25lbnRUeXBlTmFtZShvcHRpb25zKSB7XG4gIHZhciBfYTI1O1xuICBjb25zdCBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZyB8fCBvcHRpb25zLl9fVlVFX0RFVlRPT0xTX0NPTVBPTkVOVF9HVVNTRURfTkFNRV9fIHx8IG9wdGlvbnMuX19uYW1lO1xuICBpZiAobmFtZSA9PT0gXCJpbmRleFwiICYmICgoX2EyNSA9IG9wdGlvbnMuX19maWxlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyNS5lbmRzV2l0aChcImluZGV4LnZ1ZVwiKSkpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudEZpbGVOYW1lKG9wdGlvbnMpIHtcbiAgY29uc3QgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xuICBpZiAoZmlsZSlcbiAgICByZXR1cm4gY2xhc3NpZnkoYmFzZW5hbWUoZmlsZSwgXCIudnVlXCIpKTtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUob3B0aW9ucykge1xuICBjb25zdCBuYW1lID0gb3B0aW9ucy5kaXNwbGF5TmFtZSB8fCBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICBpZiAobmFtZSlcbiAgICByZXR1cm4gbmFtZTtcbiAgcmV0dXJuIGdldENvbXBvbmVudEZpbGVOYW1lKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gc2F2ZUNvbXBvbmVudEd1c3NlZE5hbWUoaW5zdGFuY2UsIG5hbWUpIHtcbiAgaW5zdGFuY2UudHlwZS5fX1ZVRV9ERVZUT09MU19DT01QT05FTlRfR1VTU0VEX05BTUVfXyA9IG5hbWU7XG4gIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gZ2V0QXBwUmVjb3JkKGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZS5fX1ZVRV9ERVZUT09MU19ORVhUX0FQUF9SRUNPUkRfXylcbiAgICByZXR1cm4gaW5zdGFuY2UuX19WVUVfREVWVE9PTFNfTkVYVF9BUFBfUkVDT1JEX187XG4gIGVsc2UgaWYgKGluc3RhbmNlLnJvb3QpXG4gICAgcmV0dXJuIGluc3RhbmNlLmFwcENvbnRleHQuYXBwLl9fVlVFX0RFVlRPT0xTX05FWFRfQVBQX1JFQ09SRF9fO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0Q29tcG9uZW50SWQob3B0aW9ucykge1xuICBjb25zdCB7IGFwcCwgdWlkLCBpbnN0YW5jZSB9ID0gb3B0aW9ucztcbiAgdHJ5IHtcbiAgICBpZiAoaW5zdGFuY2UuX19WVUVfREVWVE9PTFNfTkVYVF9VSURfXylcbiAgICAgIHJldHVybiBpbnN0YW5jZS5fX1ZVRV9ERVZUT09MU19ORVhUX1VJRF9fO1xuICAgIGNvbnN0IGFwcFJlY29yZCA9IGF3YWl0IGdldEFwcFJlY29yZChhcHApO1xuICAgIGlmICghYXBwUmVjb3JkKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaXNSb290ID0gYXBwUmVjb3JkLnJvb3RJbnN0YW5jZSA9PT0gaW5zdGFuY2U7XG4gICAgcmV0dXJuIGAke2FwcFJlY29yZC5pZH06JHtpc1Jvb3QgPyBcInJvb3RcIiA6IHVpZH1gO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQoaW5zdGFuY2UpIHtcbiAgdmFyIF9hMjUsIF9iMjU7XG4gIGNvbnN0IHN1YlRyZWVUeXBlID0gKF9hMjUgPSBpbnN0YW5jZS5zdWJUcmVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyNS50eXBlO1xuICBjb25zdCBhcHBSZWNvcmQgPSBnZXRBcHBSZWNvcmQoaW5zdGFuY2UpO1xuICBpZiAoYXBwUmVjb3JkKSB7XG4gICAgcmV0dXJuICgoX2IyNSA9IGFwcFJlY29yZCA9PSBudWxsID8gdm9pZCAwIDogYXBwUmVjb3JkLnR5cGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2IyNS5GcmFnbWVudCkgPT09IHN1YlRyZWVUeXBlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQmVpbmdEZXN0cm95ZWQoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLl9pc0JlaW5nRGVzdHJveWVkIHx8IGluc3RhbmNlLmlzVW5tb3VudGVkO1xufVxuZnVuY3Rpb24gZ2V0SW5zdGFuY2VOYW1lKGluc3RhbmNlKSB7XG4gIHZhciBfYTI1LCBfYjI1LCBfYztcbiAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudFR5cGVOYW1lKChpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UudHlwZSkgfHwge30pO1xuICBpZiAobmFtZSlcbiAgICByZXR1cm4gbmFtZTtcbiAgaWYgKChpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2Uucm9vdCkgPT09IGluc3RhbmNlKVxuICAgIHJldHVybiBcIlJvb3RcIjtcbiAgZm9yIChjb25zdCBrZXkgaW4gKF9iMjUgPSAoX2EyNSA9IGluc3RhbmNlLnBhcmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjUudHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMjUuY29tcG9uZW50cykge1xuICAgIGlmIChpbnN0YW5jZS5wYXJlbnQudHlwZS5jb21wb25lbnRzW2tleV0gPT09IChpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UudHlwZSkpXG4gICAgICByZXR1cm4gc2F2ZUNvbXBvbmVudEd1c3NlZE5hbWUoaW5zdGFuY2UsIGtleSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gKF9jID0gaW5zdGFuY2UuYXBwQ29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNvbXBvbmVudHMpIHtcbiAgICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb21wb25lbnRzW2tleV0gPT09IChpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UudHlwZSkpXG4gICAgICByZXR1cm4gc2F2ZUNvbXBvbmVudEd1c3NlZE5hbWUoaW5zdGFuY2UsIGtleSk7XG4gIH1cbiAgY29uc3QgZmlsZU5hbWUgPSBnZXRDb21wb25lbnRGaWxlTmFtZSgoaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLnR5cGUpIHx8IHt9KTtcbiAgaWYgKGZpbGVOYW1lKVxuICAgIHJldHVybiBmaWxlTmFtZTtcbiAgcmV0dXJuIFwiQW5vbnltb3VzIENvbXBvbmVudFwiO1xufVxuZnVuY3Rpb24gZ2V0VW5pcXVlQ29tcG9uZW50SWQoaW5zdGFuY2UpIHtcbiAgdmFyIF9hMjUsIF9iMjUsIF9jO1xuICBjb25zdCBhcHBJZCA9IChfYyA9IChfYjI1ID0gKF9hMjUgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuYXBwQ29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjUuYXBwKSA9PSBudWxsID8gdm9pZCAwIDogX2IyNS5fX1ZVRV9ERVZUT09MU19ORVhUX0FQUF9SRUNPUkRfSURfXykgIT0gbnVsbCA/IF9jIDogMDtcbiAgY29uc3QgaW5zdGFuY2VJZCA9IGluc3RhbmNlID09PSAoaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLnJvb3QpID8gXCJyb290XCIgOiBpbnN0YW5jZS51aWQ7XG4gIHJldHVybiBgJHthcHBJZH06JHtpbnN0YW5jZUlkfWA7XG59XG5mdW5jdGlvbiBnZXRSZW5kZXJLZXkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgcmV0dXJuIFwiXCI7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIHZhbHVlO1xuICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGAnJHt2YWx1ZX0nYDtcbiAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgcmV0dXJuIFwiQXJyYXlcIjtcbiAgZWxzZVxuICAgIHJldHVybiBcIk9iamVjdFwiO1xufVxuZnVuY3Rpb24gcmV0dXJuRXJyb3IoY2IpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY2IoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDb21wb25lbnRJbnN0YW5jZShhcHBSZWNvcmQsIGluc3RhbmNlSWQpIHtcbiAgaW5zdGFuY2VJZCA9IGluc3RhbmNlSWQgfHwgYCR7YXBwUmVjb3JkLmlkfTpyb290YDtcbiAgY29uc3QgaW5zdGFuY2UgPSBhcHBSZWNvcmQuaW5zdGFuY2VNYXAuZ2V0KGluc3RhbmNlSWQpO1xuICByZXR1cm4gaW5zdGFuY2UgfHwgYXBwUmVjb3JkLmluc3RhbmNlTWFwLmdldChcIjpyb290XCIpO1xufVxuZnVuY3Rpb24gZW5zdXJlUHJvcGVydHlFeGlzdHMob2JqLCBrZXksIHNraXBPYmpDaGVjayA9IGZhbHNlKSB7XG4gIHJldHVybiBza2lwT2JqQ2hlY2sgPyBrZXkgaW4gb2JqIDogdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwgPyBrZXkgaW4gb2JqIDogZmFsc2U7XG59XG5cbi8vIHNyYy9jb3JlL2NvbXBvbmVudC9zdGF0ZS9ib3VuZGluZy1yZWN0LnRzXG5mdW5jdGlvbiBjcmVhdGVSZWN0KCkge1xuICBjb25zdCByZWN0ID0ge1xuICAgIHRvcDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICByaWdodDogMCxcbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICByZXR1cm4gcmVjdC5yaWdodCAtIHJlY3QubGVmdDtcbiAgICB9LFxuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICByZXR1cm4gcmVjdC5ib3R0b20gLSByZWN0LnRvcDtcbiAgICB9XG4gIH07XG4gIHJldHVybiByZWN0O1xufVxudmFyIHJhbmdlO1xuZnVuY3Rpb24gZ2V0VGV4dFJlY3Qobm9kZSkge1xuICBpZiAoIXJhbmdlKVxuICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2VsZWN0Tm9kZShub2RlKTtcbiAgcmV0dXJuIHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRSZWN0KHZub2RlKSB7XG4gIGNvbnN0IHJlY3QgPSBjcmVhdGVSZWN0KCk7XG4gIGlmICghdm5vZGUuY2hpbGRyZW4pXG4gICAgcmV0dXJuIHJlY3Q7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGRWbm9kZSA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgIGxldCBjaGlsZFJlY3Q7XG4gICAgaWYgKGNoaWxkVm5vZGUuY29tcG9uZW50KSB7XG4gICAgICBjaGlsZFJlY3QgPSBnZXRDb21wb25lbnRCb3VuZGluZ1JlY3QoY2hpbGRWbm9kZS5jb21wb25lbnQpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRWbm9kZS5lbCkge1xuICAgICAgY29uc3QgZWwgPSBjaGlsZFZub2RlLmVsO1xuICAgICAgaWYgKGVsLm5vZGVUeXBlID09PSAxIHx8IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdClcbiAgICAgICAgY2hpbGRSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBlbHNlIGlmIChlbC5ub2RlVHlwZSA9PT0gMyAmJiBlbC5kYXRhLnRyaW0oKSlcbiAgICAgICAgY2hpbGRSZWN0ID0gZ2V0VGV4dFJlY3QoZWwpO1xuICAgIH1cbiAgICBpZiAoY2hpbGRSZWN0KVxuICAgICAgbWVyZ2VSZWN0cyhyZWN0LCBjaGlsZFJlY3QpO1xuICB9XG4gIHJldHVybiByZWN0O1xufVxuZnVuY3Rpb24gbWVyZ2VSZWN0cyhhLCBiKSB7XG4gIGlmICghYS50b3AgfHwgYi50b3AgPCBhLnRvcClcbiAgICBhLnRvcCA9IGIudG9wO1xuICBpZiAoIWEuYm90dG9tIHx8IGIuYm90dG9tID4gYS5ib3R0b20pXG4gICAgYS5ib3R0b20gPSBiLmJvdHRvbTtcbiAgaWYgKCFhLmxlZnQgfHwgYi5sZWZ0IDwgYS5sZWZ0KVxuICAgIGEubGVmdCA9IGIubGVmdDtcbiAgaWYgKCFhLnJpZ2h0IHx8IGIucmlnaHQgPiBhLnJpZ2h0KVxuICAgIGEucmlnaHQgPSBiLnJpZ2h0O1xuICByZXR1cm4gYTtcbn1cbnZhciBERUZBVUxUX1JFQ1QgPSB7XG4gIHRvcDogMCxcbiAgbGVmdDogMCxcbiAgcmlnaHQ6IDAsXG4gIGJvdHRvbTogMCxcbiAgd2lkdGg6IDAsXG4gIGhlaWdodDogMFxufTtcbmZ1bmN0aW9uIGdldENvbXBvbmVudEJvdW5kaW5nUmVjdChpbnN0YW5jZSkge1xuICBjb25zdCBlbCA9IGluc3RhbmNlLnN1YlRyZWUuZWw7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIERFRkFVTFRfUkVDVDtcbiAgfVxuICBpZiAoaXNGcmFnbWVudChpbnN0YW5jZSkpXG4gICAgcmV0dXJuIGdldEZyYWdtZW50UmVjdChpbnN0YW5jZS5zdWJUcmVlKTtcbiAgZWxzZSBpZiAoKGVsID09IG51bGwgPyB2b2lkIDAgOiBlbC5ub2RlVHlwZSkgPT09IDEpXG4gICAgcmV0dXJuIGVsID09IG51bGwgPyB2b2lkIDAgOiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgZWxzZSBpZiAoaW5zdGFuY2Uuc3ViVHJlZS5jb21wb25lbnQpXG4gICAgcmV0dXJuIGdldENvbXBvbmVudEJvdW5kaW5nUmVjdChpbnN0YW5jZS5zdWJUcmVlLmNvbXBvbmVudCk7XG4gIGVsc2VcbiAgICByZXR1cm4gREVGQVVMVF9SRUNUO1xufVxuXG4vLyBzcmMvY29yZS9jb21wb25lbnQvdHJlZS9lbC50c1xuaW5pdF9lc21fc2hpbXMoKTtcbmZ1bmN0aW9uIGdldFJvb3RFbGVtZW50c0Zyb21Db21wb25lbnRJbnN0YW5jZShpbnN0YW5jZSkge1xuICBpZiAoaXNGcmFnbWVudChpbnN0YW5jZSkpXG4gICAgcmV0dXJuIGdldEZyYWdtZW50Um9vdEVsZW1lbnRzKGluc3RhbmNlLnN1YlRyZWUpO1xuICBpZiAoIWluc3RhbmNlLnN1YlRyZWUpXG4gICAgcmV0dXJuIFtdO1xuICByZXR1cm4gW2luc3RhbmNlLnN1YlRyZWUuZWxdO1xufVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRSb290RWxlbWVudHModm5vZGUpIHtcbiAgaWYgKCF2bm9kZS5jaGlsZHJlbilcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IGxpc3QgPSBbXTtcbiAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGRWbm9kZSkgPT4ge1xuICAgIGlmIChjaGlsZFZub2RlLmNvbXBvbmVudClcbiAgICAgIGxpc3QucHVzaCguLi5nZXRSb290RWxlbWVudHNGcm9tQ29tcG9uZW50SW5zdGFuY2UoY2hpbGRWbm9kZS5jb21wb25lbnQpKTtcbiAgICBlbHNlIGlmIChjaGlsZFZub2RlID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZFZub2RlLmVsKVxuICAgICAgbGlzdC5wdXNoKGNoaWxkVm5vZGUuZWwpO1xuICB9KTtcbiAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIHNyYy9jb3JlL2NvbXBvbmVudC1oaWdobGlnaHRlci9pbmRleC50c1xudmFyIENPTlRBSU5FUl9FTEVNRU5UX0lEID0gXCJfX3Z1ZS1kZXZ0b29scy1jb21wb25lbnQtaW5zcGVjdG9yX19cIjtcbnZhciBDQVJEX0VMRU1FTlRfSUQgPSBcIl9fdnVlLWRldnRvb2xzLWNvbXBvbmVudC1pbnNwZWN0b3JfX2NhcmRfX1wiO1xudmFyIENPTVBPTkVOVF9OQU1FX0VMRU1FTlRfSUQgPSBcIl9fdnVlLWRldnRvb2xzLWNvbXBvbmVudC1pbnNwZWN0b3JfX25hbWVfX1wiO1xudmFyIElORElDQVRPUl9FTEVNRU5UX0lEID0gXCJfX3Z1ZS1kZXZ0b29scy1jb21wb25lbnQtaW5zcGVjdG9yX19pbmRpY2F0b3JfX1wiO1xudmFyIGNvbnRhaW5lclN0eWxlcyA9IHtcbiAgZGlzcGxheTogXCJibG9ja1wiLFxuICB6SW5kZXg6IDIxNDc0ODM2NDAsXG4gIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gIGJhY2tncm91bmRDb2xvcjogXCIjNDJiODgzMjVcIixcbiAgYm9yZGVyOiBcIjFweCBzb2xpZCAjNDJiODgzNTBcIixcbiAgYm9yZGVyUmFkaXVzOiBcIjVweFwiLFxuICB0cmFuc2l0aW9uOiBcImFsbCAwLjFzIGVhc2UtaW5cIixcbiAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbn07XG52YXIgY2FyZFN0eWxlcyA9IHtcbiAgZm9udEZhbWlseTogXCJBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmXCIsXG4gIHBhZGRpbmc6IFwiNXB4IDhweFwiLFxuICBib3JkZXJSYWRpdXM6IFwiNHB4XCIsXG4gIHRleHRBbGlnbjogXCJsZWZ0XCIsXG4gIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gIGxlZnQ6IDAsXG4gIGNvbG9yOiBcIiNlOWU5ZTlcIixcbiAgZm9udFNpemU6IFwiMTRweFwiLFxuICBmb250V2VpZ2h0OiA2MDAsXG4gIGxpbmVIZWlnaHQ6IFwiMjRweFwiLFxuICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzQyYjg4M1wiLFxuICBib3hTaGFkb3c6IFwiMCAxcHggM3B4IDAgcmdiYSgwLCAwLCAwLCAwLjEpLCAwIDFweCAycHggLTFweCByZ2JhKDAsIDAsIDAsIDAuMSlcIlxufTtcbnZhciBpbmRpY2F0b3JTdHlsZXMgPSB7XG4gIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gIGZvbnRXZWlnaHQ6IDQwMCxcbiAgZm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuICBmb250U2l6ZTogXCIxMnB4XCIsXG4gIG9wYWNpdHk6IDAuN1xufTtcbmZ1bmN0aW9uIGdldENvbnRhaW5lckVsZW1lbnQoKSB7XG4gIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChDT05UQUlORVJfRUxFTUVOVF9JRCk7XG59XG5mdW5jdGlvbiBnZXRDYXJkRWxlbWVudCgpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKENBUkRfRUxFTUVOVF9JRCk7XG59XG5mdW5jdGlvbiBnZXRJbmRpY2F0b3JFbGVtZW50KCkge1xuICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoSU5ESUNBVE9SX0VMRU1FTlRfSUQpO1xufVxuZnVuY3Rpb24gZ2V0TmFtZUVsZW1lbnQoKSB7XG4gIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChDT01QT05FTlRfTkFNRV9FTEVNRU5UX0lEKTtcbn1cbmZ1bmN0aW9uIGdldFN0eWxlcyhib3VuZHMpIHtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBgJHtNYXRoLnJvdW5kKGJvdW5kcy5sZWZ0ICogMTAwKSAvIDEwMH1weGAsXG4gICAgdG9wOiBgJHtNYXRoLnJvdW5kKGJvdW5kcy50b3AgKiAxMDApIC8gMTAwfXB4YCxcbiAgICB3aWR0aDogYCR7TWF0aC5yb3VuZChib3VuZHMud2lkdGggKiAxMDApIC8gMTAwfXB4YCxcbiAgICBoZWlnaHQ6IGAke01hdGgucm91bmQoYm91bmRzLmhlaWdodCAqIDEwMCkgLyAxMDB9cHhgXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGUob3B0aW9ucykge1xuICB2YXIgX2EyNTtcbiAgY29uc3QgY29udGFpbmVyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjb250YWluZXJFbC5pZCA9IChfYTI1ID0gb3B0aW9ucy5lbGVtZW50SWQpICE9IG51bGwgPyBfYTI1IDogQ09OVEFJTkVSX0VMRU1FTlRfSUQ7XG4gIE9iamVjdC5hc3NpZ24oY29udGFpbmVyRWwuc3R5bGUsIHtcbiAgICAuLi5jb250YWluZXJTdHlsZXMsXG4gICAgLi4uZ2V0U3R5bGVzKG9wdGlvbnMuYm91bmRzKSxcbiAgICAuLi5vcHRpb25zLnN0eWxlXG4gIH0pO1xuICBjb25zdCBjYXJkRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgY2FyZEVsLmlkID0gQ0FSRF9FTEVNRU5UX0lEO1xuICBPYmplY3QuYXNzaWduKGNhcmRFbC5zdHlsZSwge1xuICAgIC4uLmNhcmRTdHlsZXMsXG4gICAgdG9wOiBvcHRpb25zLmJvdW5kcy50b3AgPCAzNSA/IDAgOiBcIi0zNXB4XCJcbiAgfSk7XG4gIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICBuYW1lRWwuaWQgPSBDT01QT05FTlRfTkFNRV9FTEVNRU5UX0lEO1xuICBuYW1lRWwuaW5uZXJIVE1MID0gYCZsdDske29wdGlvbnMubmFtZX0mZ3Q7Jm5ic3A7Jm5ic3A7YDtcbiAgY29uc3QgaW5kaWNhdG9yRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcbiAgaW5kaWNhdG9yRWwuaWQgPSBJTkRJQ0FUT1JfRUxFTUVOVF9JRDtcbiAgaW5kaWNhdG9yRWwuaW5uZXJIVE1MID0gYCR7TWF0aC5yb3VuZChvcHRpb25zLmJvdW5kcy53aWR0aCAqIDEwMCkgLyAxMDB9IHggJHtNYXRoLnJvdW5kKG9wdGlvbnMuYm91bmRzLmhlaWdodCAqIDEwMCkgLyAxMDB9YDtcbiAgT2JqZWN0LmFzc2lnbihpbmRpY2F0b3JFbC5zdHlsZSwgaW5kaWNhdG9yU3R5bGVzKTtcbiAgY2FyZEVsLmFwcGVuZENoaWxkKG5hbWVFbCk7XG4gIGNhcmRFbC5hcHBlbmRDaGlsZChpbmRpY2F0b3JFbCk7XG4gIGNvbnRhaW5lckVsLmFwcGVuZENoaWxkKGNhcmRFbCk7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyRWwpO1xuICByZXR1cm4gY29udGFpbmVyRWw7XG59XG5mdW5jdGlvbiB1cGRhdGUob3B0aW9ucykge1xuICBjb25zdCBjb250YWluZXJFbCA9IGdldENvbnRhaW5lckVsZW1lbnQoKTtcbiAgY29uc3QgY2FyZEVsID0gZ2V0Q2FyZEVsZW1lbnQoKTtcbiAgY29uc3QgbmFtZUVsID0gZ2V0TmFtZUVsZW1lbnQoKTtcbiAgY29uc3QgaW5kaWNhdG9yRWwgPSBnZXRJbmRpY2F0b3JFbGVtZW50KCk7XG4gIGlmIChjb250YWluZXJFbCkge1xuICAgIE9iamVjdC5hc3NpZ24oY29udGFpbmVyRWwuc3R5bGUsIHtcbiAgICAgIC4uLmNvbnRhaW5lclN0eWxlcyxcbiAgICAgIC4uLmdldFN0eWxlcyhvcHRpb25zLmJvdW5kcylcbiAgICB9KTtcbiAgICBPYmplY3QuYXNzaWduKGNhcmRFbC5zdHlsZSwge1xuICAgICAgdG9wOiBvcHRpb25zLmJvdW5kcy50b3AgPCAzNSA/IDAgOiBcIi0zNXB4XCJcbiAgICB9KTtcbiAgICBuYW1lRWwuaW5uZXJIVE1MID0gYCZsdDske29wdGlvbnMubmFtZX0mZ3Q7Jm5ic3A7Jm5ic3A7YDtcbiAgICBpbmRpY2F0b3JFbC5pbm5lckhUTUwgPSBgJHtNYXRoLnJvdW5kKG9wdGlvbnMuYm91bmRzLndpZHRoICogMTAwKSAvIDEwMH0geCAke01hdGgucm91bmQob3B0aW9ucy5ib3VuZHMuaGVpZ2h0ICogMTAwKSAvIDEwMH1gO1xuICB9XG59XG5mdW5jdGlvbiBoaWdobGlnaHQoaW5zdGFuY2UpIHtcbiAgY29uc3QgYm91bmRzID0gZ2V0Q29tcG9uZW50Qm91bmRpbmdSZWN0KGluc3RhbmNlKTtcbiAgaWYgKCFib3VuZHMud2lkdGggJiYgIWJvdW5kcy5oZWlnaHQpXG4gICAgcmV0dXJuO1xuICBjb25zdCBuYW1lID0gZ2V0SW5zdGFuY2VOYW1lKGluc3RhbmNlKTtcbiAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyRWxlbWVudCgpO1xuICBjb250YWluZXIgPyB1cGRhdGUoeyBib3VuZHMsIG5hbWUgfSkgOiBjcmVhdGUoeyBib3VuZHMsIG5hbWUgfSk7XG59XG5mdW5jdGlvbiB1bmhpZ2hsaWdodCgpIHtcbiAgY29uc3QgZWwgPSBnZXRDb250YWluZXJFbGVtZW50KCk7XG4gIGlmIChlbClcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG59XG52YXIgaW5zcGVjdEluc3RhbmNlID0gbnVsbDtcbmZ1bmN0aW9uIGluc3BlY3RGbihlKSB7XG4gIGNvbnN0IHRhcmdldDIyID0gZS50YXJnZXQ7XG4gIGlmICh0YXJnZXQyMikge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGFyZ2V0MjIuX192dWVQYXJlbnRDb21wb25lbnQ7XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBpbnNwZWN0SW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgIGNvbnN0IGVsID0gaW5zdGFuY2Uudm5vZGUuZWw7XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgY29uc3QgYm91bmRzID0gZ2V0Q29tcG9uZW50Qm91bmRpbmdSZWN0KGluc3RhbmNlKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldEluc3RhbmNlTmFtZShpbnN0YW5jZSk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lckVsZW1lbnQoKTtcbiAgICAgICAgY29udGFpbmVyID8gdXBkYXRlKHsgYm91bmRzLCBuYW1lIH0pIDogY3JlYXRlKHsgYm91bmRzLCBuYW1lIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2VsZWN0Q29tcG9uZW50Rm4oZSwgY2IpIHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICBpZiAoaW5zcGVjdEluc3RhbmNlKSB7XG4gICAgY29uc3QgdW5pcXVlQ29tcG9uZW50SWQgPSBnZXRVbmlxdWVDb21wb25lbnRJZChpbnNwZWN0SW5zdGFuY2UpO1xuICAgIGNiKHVuaXF1ZUNvbXBvbmVudElkKTtcbiAgfVxufVxudmFyIGluc3BlY3RDb21wb25lbnRIaWdoTGlnaHRlclNlbGVjdEZuID0gbnVsbDtcbmZ1bmN0aW9uIGNhbmNlbEluc3BlY3RDb21wb25lbnRIaWdoTGlnaHRlcigpIHtcbiAgdW5oaWdobGlnaHQoKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgaW5zcGVjdEZuKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBpbnNwZWN0Q29tcG9uZW50SGlnaExpZ2h0ZXJTZWxlY3RGbiwgdHJ1ZSk7XG4gIGluc3BlY3RDb21wb25lbnRIaWdoTGlnaHRlclNlbGVjdEZuID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGluc3BlY3RDb21wb25lbnRIaWdoTGlnaHRlcigpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgaW5zcGVjdEZuKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgZnVuY3Rpb24gb25TZWxlY3QoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHNlbGVjdENvbXBvbmVudEZuKGUsIChpZCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uU2VsZWN0LCB0cnVlKTtcbiAgICAgICAgaW5zcGVjdENvbXBvbmVudEhpZ2hMaWdodGVyU2VsZWN0Rm4gPSBudWxsO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCBpbnNwZWN0Rm4pO1xuICAgICAgICBjb25zdCBlbCA9IGdldENvbnRhaW5lckVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGVsKVxuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgcmVzb2x2ZShKU09OLnN0cmluZ2lmeSh7IGlkIH0pKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpbnNwZWN0Q29tcG9uZW50SGlnaExpZ2h0ZXJTZWxlY3RGbiA9IG9uU2VsZWN0O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25TZWxlY3QsIHRydWUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFRvQ29tcG9uZW50KG9wdGlvbnMpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDb21wb25lbnRJbnN0YW5jZShhY3RpdmVBcHBSZWNvcmQudmFsdWUsIG9wdGlvbnMuaWQpO1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBbZWxdID0gZ2V0Um9vdEVsZW1lbnRzRnJvbUNvbXBvbmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICBpZiAodHlwZW9mIGVsLnNjcm9sbEludG9WaWV3ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGVsLnNjcm9sbEludG9WaWV3KHtcbiAgICAgICAgYmVoYXZpb3I6IFwic21vb3RoXCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBib3VuZHMgPSBnZXRDb21wb25lbnRCb3VuZGluZ1JlY3QoaW5zdGFuY2UpO1xuICAgICAgY29uc3Qgc2Nyb2xsVGFyZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnN0IHN0eWxlcyA9IHtcbiAgICAgICAgLi4uZ2V0U3R5bGVzKGJvdW5kcyksXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICAgIH07XG4gICAgICBPYmplY3QuYXNzaWduKHNjcm9sbFRhcmdldC5zdHlsZSwgc3R5bGVzKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2Nyb2xsVGFyZ2V0KTtcbiAgICAgIHNjcm9sbFRhcmdldC5zY3JvbGxJbnRvVmlldyh7XG4gICAgICAgIGJlaGF2aW9yOiBcInNtb290aFwiXG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNjcm9sbFRhcmdldCk7XG4gICAgICB9LCAyZTMpO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnN0IGJvdW5kcyA9IGdldENvbXBvbmVudEJvdW5kaW5nUmVjdChpbnN0YW5jZSk7XG4gICAgICBpZiAoYm91bmRzLndpZHRoIHx8IGJvdW5kcy5oZWlnaHQpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldEluc3RhbmNlTmFtZShpbnN0YW5jZSk7XG4gICAgICAgIGNvbnN0IGVsMiA9IGdldENvbnRhaW5lckVsZW1lbnQoKTtcbiAgICAgICAgZWwyID8gdXBkYXRlKHsgLi4ub3B0aW9ucywgbmFtZSwgYm91bmRzIH0pIDogY3JlYXRlKHsgLi4ub3B0aW9ucywgbmFtZSwgYm91bmRzIH0pO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoZWwyKVxuICAgICAgICAgICAgZWwyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgfSwgMTUwMCk7XG4gICAgICB9XG4gICAgfSwgMTIwMCk7XG4gIH1cbn1cblxuLy8gc3JjL2NvcmUvY29tcG9uZW50LWluc3BlY3Rvci9pbmRleC50c1xuaW5pdF9lc21fc2hpbXMoKTtcbmltcG9ydCB7IHRhcmdldCBhcyB0YXJnZXQyIH0gZnJvbSBcIkB2dWUvZGV2dG9vbHMtc2hhcmVkXCI7XG52YXIgX2EsIF9iO1xuKF9iID0gKF9hID0gdGFyZ2V0MikuX19WVUVfREVWVE9PTFNfQ09NUE9ORU5UX0lOU1BFQ1RPUl9FTkFCTEVEX18pICE9IG51bGwgPyBfYiA6IF9hLl9fVlVFX0RFVlRPT0xTX0NPTVBPTkVOVF9JTlNQRUNUT1JfRU5BQkxFRF9fID0gdHJ1ZTtcbmZ1bmN0aW9uIHRvZ2dsZUNvbXBvbmVudEluc3BlY3RvckVuYWJsZWQoZW5hYmxlZCkge1xuICB0YXJnZXQyLl9fVlVFX0RFVlRPT0xTX0NPTVBPTkVOVF9JTlNQRUNUT1JfRU5BQkxFRF9fID0gZW5hYmxlZDtcbn1cbmZ1bmN0aW9uIHdhaXRGb3JJbnNwZWN0b3JJbml0KGNiKSB7XG4gIGxldCB0b3RhbCA9IDA7XG4gIGNvbnN0IHRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIGlmICh0YXJnZXQyLl9fVlVFX0lOU1BFQ1RPUl9fKSB7XG4gICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgIHRvdGFsICs9IDMwO1xuICAgICAgY2IoKTtcbiAgICB9XG4gICAgaWYgKHRvdGFsID49IC8qIDVzICovXG4gICAgNWUzKVxuICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gIH0sIDMwKTtcbn1cbmZ1bmN0aW9uIHNldHVwSW5zcGVjdG9yKCkge1xuICBjb25zdCBpbnNwZWN0b3IgPSB0YXJnZXQyLl9fVlVFX0lOU1BFQ1RPUl9fO1xuICBjb25zdCBfb3BlbkluRWRpdG9yID0gaW5zcGVjdG9yLm9wZW5JbkVkaXRvcjtcbiAgaW5zcGVjdG9yLm9wZW5JbkVkaXRvciA9IGFzeW5jICguLi5wYXJhbXMpID0+IHtcbiAgICBpbnNwZWN0b3IuZGlzYWJsZSgpO1xuICAgIF9vcGVuSW5FZGl0b3IoLi4ucGFyYW1zKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudEluc3BlY3RvcigpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgICBzZXR1cEluc3BlY3RvcigpO1xuICAgICAgcmVzb2x2ZSh0YXJnZXQyLl9fVlVFX0lOU1BFQ1RPUl9fKTtcbiAgICB9XG4gICAgaWYgKCF0YXJnZXQyLl9fVlVFX0lOU1BFQ1RPUl9fKSB7XG4gICAgICB3YWl0Rm9ySW5zcGVjdG9ySW5pdCgoKSA9PiB7XG4gICAgICAgIHNldHVwKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0dXAoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvY29yZS9jb21wb25lbnQvc3RhdGUvZWRpdG9yLnRzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyBzcmMvc2hhcmVkL3N0dWItdnVlLnRzXG5pbml0X2VzbV9zaGltcygpO1xuZnVuY3Rpb24gaXNSZWFkb25seSh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovXSk7XG59XG5mdW5jdGlvbiBpc1JlYWN0aXZlKHZhbHVlKSB7XG4gIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiIC8qIFJBVyAqL10pO1xuICB9XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi9dKTtcbn1cbmZ1bmN0aW9uIGlzUmVmKHIpIHtcbiAgcmV0dXJuICEhKHIgJiYgci5fX3ZfaXNSZWYgPT09IHRydWUpO1xufVxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcbiAgY29uc3QgcmF3ID0gb2JzZXJ2ZWQgJiYgb2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcbiAgcmV0dXJuIHJhdyA/IHRvUmF3KHJhdykgOiBvYnNlcnZlZDtcbn1cbnZhciBGcmFnbWVudCA9IFN5bWJvbC5mb3IoXCJ2LWZndFwiKTtcblxuLy8gc3JjL2NvcmUvY29tcG9uZW50L3N0YXRlL2VkaXRvci50c1xudmFyIFN0YXRlRWRpdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlZkVkaXRvciA9IG5ldyBSZWZTdGF0ZUVkaXRvcigpO1xuICB9XG4gIHNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjYikge1xuICAgIGNvbnN0IHNlY3Rpb25zID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgICBjb25zdCBtYXJrUmVmID0gZmFsc2U7XG4gICAgd2hpbGUgKHNlY3Rpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IHNlY3Rpb24gPSBzZWN0aW9ucy5zaGlmdCgpO1xuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmdldChzZWN0aW9uKTtcbiAgICAgIGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFNldClcbiAgICAgICAgb2JqZWN0ID0gQXJyYXkuZnJvbShvYmplY3QudmFsdWVzKCkpW3NlY3Rpb25dO1xuICAgICAgZWxzZSBvYmplY3QgPSBvYmplY3Rbc2VjdGlvbl07XG4gICAgICBpZiAodGhpcy5yZWZFZGl0b3IuaXNSZWYob2JqZWN0KSlcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5yZWZFZGl0b3IuZ2V0KG9iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkID0gc2VjdGlvbnNbMF07XG4gICAgY29uc3QgaXRlbSA9IHRoaXMucmVmRWRpdG9yLmdldChvYmplY3QpW2ZpZWxkXTtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKG9iamVjdCwgZmllbGQsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMucmVmRWRpdG9yLmlzUmVmKGl0ZW0pKVxuICAgICAgICB0aGlzLnJlZkVkaXRvci5zZXQoaXRlbSwgdmFsdWUpO1xuICAgICAgZWxzZSBpZiAobWFya1JlZilcbiAgICAgICAgb2JqZWN0W2ZpZWxkXSA9IHZhbHVlO1xuICAgICAgZWxzZVxuICAgICAgICBvYmplY3RbZmllbGRdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIGdldChvYmplY3QsIHBhdGgpIHtcbiAgICBjb25zdCBzZWN0aW9ucyA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdChcIi5cIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmdldChzZWN0aW9uc1tpXSk7XG4gICAgICBlbHNlXG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtzZWN0aW9uc1tpXV07XG4gICAgICBpZiAodGhpcy5yZWZFZGl0b3IuaXNSZWYob2JqZWN0KSlcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5yZWZFZGl0b3IuZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoIW9iamVjdClcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBoYXMob2JqZWN0LCBwYXRoLCBwYXJlbnQgPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHNlY3Rpb25zID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGguc2xpY2UoKSA6IHBhdGguc3BsaXQoXCIuXCIpO1xuICAgIGNvbnN0IHNpemUgPSAhcGFyZW50ID8gMSA6IDI7XG4gICAgd2hpbGUgKG9iamVjdCAmJiBzZWN0aW9ucy5sZW5ndGggPiBzaXplKSB7XG4gICAgICBjb25zdCBzZWN0aW9uID0gc2VjdGlvbnMuc2hpZnQoKTtcbiAgICAgIG9iamVjdCA9IG9iamVjdFtzZWN0aW9uXTtcbiAgICAgIGlmICh0aGlzLnJlZkVkaXRvci5pc1JlZihvYmplY3QpKVxuICAgICAgICBvYmplY3QgPSB0aGlzLnJlZkVkaXRvci5nZXQob2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHNlY3Rpb25zWzBdKTtcbiAgfVxuICBjcmVhdGVEZWZhdWx0U2V0Q2FsbGJhY2soc3RhdGUpIHtcbiAgICByZXR1cm4gKG9iamVjdCwgZmllbGQsIHZhbHVlKSA9PiB7XG4gICAgICBpZiAoc3RhdGUucmVtb3ZlIHx8IHN0YXRlLm5ld0tleSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKVxuICAgICAgICAgIG9iamVjdC5zcGxpY2UoZmllbGQsIDEpO1xuICAgICAgICBlbHNlIGlmICh0b1JhdyhvYmplY3QpIGluc3RhbmNlb2YgTWFwKVxuICAgICAgICAgIG9iamVjdC5kZWxldGUoZmllbGQpO1xuICAgICAgICBlbHNlIGlmICh0b1JhdyhvYmplY3QpIGluc3RhbmNlb2YgU2V0KVxuICAgICAgICAgIG9iamVjdC5kZWxldGUoQXJyYXkuZnJvbShvYmplY3QudmFsdWVzKCkpW2ZpZWxkXSk7XG4gICAgICAgIGVsc2UgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShvYmplY3QsIGZpZWxkKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RhdGUucmVtb3ZlKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldDIyID0gb2JqZWN0W3N0YXRlLm5ld0tleSB8fCBmaWVsZF07XG4gICAgICAgIGlmICh0aGlzLnJlZkVkaXRvci5pc1JlZih0YXJnZXQyMikpXG4gICAgICAgICAgdGhpcy5yZWZFZGl0b3Iuc2V0KHRhcmdldDIyLCB2YWx1ZSk7XG4gICAgICAgIGVsc2UgaWYgKHRvUmF3KG9iamVjdCkgaW5zdGFuY2VvZiBNYXApXG4gICAgICAgICAgb2JqZWN0LnNldChzdGF0ZS5uZXdLZXkgfHwgZmllbGQsIHZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAodG9SYXcob2JqZWN0KSBpbnN0YW5jZW9mIFNldClcbiAgICAgICAgICBvYmplY3QuYWRkKHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9iamVjdFtzdGF0ZS5uZXdLZXkgfHwgZmllbGRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbnZhciBSZWZTdGF0ZUVkaXRvciA9IGNsYXNzIHtcbiAgc2V0KHJlZiwgdmFsdWUpIHtcbiAgICBpZiAoaXNSZWYocmVmKSkge1xuICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiBTZXQgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmVmLmNsZWFyKCk7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHJlZi5hZGQodikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50S2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNLZXlzU2V0MiA9IG5ldyBTZXQocmVmLmtleXMoKSk7XG4gICAgICAgIGN1cnJlbnRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgIHJlZi5zZXQoa2V5LCBSZWZsZWN0LmdldCh2YWx1ZSwga2V5KSk7XG4gICAgICAgICAgcHJldmlvdXNLZXlzU2V0Mi5kZWxldGUoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZpb3VzS2V5c1NldDIuZm9yRWFjaCgoa2V5KSA9PiByZWYuZGVsZXRlKGtleSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aW91c0tleXNTZXQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHJlZikpO1xuICAgICAgY3VycmVudEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIFJlZmxlY3Quc2V0KHJlZiwga2V5LCBSZWZsZWN0LmdldCh2YWx1ZSwga2V5KSk7XG4gICAgICAgIHByZXZpb3VzS2V5c1NldC5kZWxldGUoa2V5KTtcbiAgICAgIH0pO1xuICAgICAgcHJldmlvdXNLZXlzU2V0LmZvckVhY2goKGtleSkgPT4gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShyZWYsIGtleSkpO1xuICAgIH1cbiAgfVxuICBnZXQocmVmKSB7XG4gICAgcmV0dXJuIGlzUmVmKHJlZikgPyByZWYudmFsdWUgOiByZWY7XG4gIH1cbiAgaXNSZWYocmVmKSB7XG4gICAgcmV0dXJuIGlzUmVmKHJlZikgfHwgaXNSZWFjdGl2ZShyZWYpO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gZWRpdENvbXBvbmVudFN0YXRlKHBheWxvYWQsIHN0YXRlRWRpdG9yMikge1xuICBjb25zdCB7IHBhdGgsIG5vZGVJZCwgc3RhdGUsIHR5cGUgfSA9IHBheWxvYWQ7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q29tcG9uZW50SW5zdGFuY2UoYWN0aXZlQXBwUmVjb3JkLnZhbHVlLCBub2RlSWQpO1xuICBpZiAoIWluc3RhbmNlKVxuICAgIHJldHVybjtcbiAgY29uc3QgdGFyZ2V0UGF0aCA9IHBhdGguc2xpY2UoKTtcbiAgbGV0IHRhcmdldDIyO1xuICBpZiAoT2JqZWN0LmtleXMoaW5zdGFuY2UucHJvcHMpLmluY2x1ZGVzKHBhdGhbMF0pKSB7XG4gICAgdGFyZ2V0MjIgPSBpbnN0YW5jZS5wcm9wcztcbiAgfSBlbHNlIGlmIChpbnN0YW5jZS5kZXZ0b29sc1Jhd1NldHVwU3RhdGUgJiYgT2JqZWN0LmtleXMoaW5zdGFuY2UuZGV2dG9vbHNSYXdTZXR1cFN0YXRlKS5pbmNsdWRlcyhwYXRoWzBdKSkge1xuICAgIHRhcmdldDIyID0gaW5zdGFuY2UuZGV2dG9vbHNSYXdTZXR1cFN0YXRlO1xuICB9IGVsc2UgaWYgKGluc3RhbmNlLmRhdGEgJiYgT2JqZWN0LmtleXMoaW5zdGFuY2UuZGF0YSkuaW5jbHVkZXMocGF0aFswXSkpIHtcbiAgICB0YXJnZXQyMiA9IGluc3RhbmNlLmRhdGE7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0MjIgPSBpbnN0YW5jZS5wcm94eTtcbiAgfVxuICBpZiAodGFyZ2V0MjIgJiYgdGFyZ2V0UGF0aCkge1xuICAgIGlmIChzdGF0ZS50eXBlID09PSBcIm9iamVjdFwiICYmIHR5cGUgPT09IFwicmVhY3RpdmVcIikge1xuICAgIH1cbiAgICBzdGF0ZUVkaXRvcjIuc2V0KHRhcmdldDIyLCB0YXJnZXRQYXRoLCBzdGF0ZS52YWx1ZSwgc3RhdGVFZGl0b3IyLmNyZWF0ZURlZmF1bHRTZXRDYWxsYmFjayhzdGF0ZSkpO1xuICB9XG59XG52YXIgc3RhdGVFZGl0b3IgPSBuZXcgU3RhdGVFZGl0b3IoKTtcbmFzeW5jIGZ1bmN0aW9uIGVkaXRTdGF0ZShwYXlsb2FkKSB7XG4gIGVkaXRDb21wb25lbnRTdGF0ZShwYXlsb2FkLCBzdGF0ZUVkaXRvcik7XG59XG5cbi8vIHNyYy9jb3JlL29wZW4taW4tZWRpdG9yL2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgdGFyZ2V0IGFzIHRhcmdldDUgfSBmcm9tIFwiQHZ1ZS9kZXZ0b29scy1zaGFyZWRcIjtcblxuLy8gc3JjL2N0eC9zdGF0ZS50c1xuaW5pdF9lc21fc2hpbXMoKTtcbmltcG9ydCB7IHRhcmdldCBhcyBnbG9iYWwsIGlzVXJsU3RyaW5nIH0gZnJvbSBcIkB2dWUvZGV2dG9vbHMtc2hhcmVkXCI7XG5pbXBvcnQgeyBkZWJvdW5jZSBhcyBkZWJvdW5jZTMgfSBmcm9tIFwicGVyZmVjdC1kZWJvdW5jZVwiO1xuXG4vLyBzcmMvY29yZS90aW1lbGluZS9zdG9yYWdlLnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSBcIkB2dWUvZGV2dG9vbHMtc2hhcmVkXCI7XG52YXIgVElNRUxJTkVfTEFZRVJTX1NUQVRFX1NUT1JBR0VfSUQgPSBcIl9fVlVFX0RFVlRPT0xTX0tJVF9USU1FTElORV9MQVlFUlNfU1RBVEVfX1wiO1xuZnVuY3Rpb24gYWRkVGltZWxpbmVMYXllcnNTdGF0ZVRvU3RvcmFnZShzdGF0ZSkge1xuICBpZiAoIWlzQnJvd3NlciB8fCB0eXBlb2YgbG9jYWxTdG9yYWdlID09PSBcInVuZGVmaW5lZFwiIHx8IGxvY2FsU3RvcmFnZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShUSU1FTElORV9MQVlFUlNfU1RBVEVfU1RPUkFHRV9JRCwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbn1cbmZ1bmN0aW9uIGdldFRpbWVsaW5lTGF5ZXJzU3RhdGVGcm9tU3RvcmFnZSgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgIWlzQnJvd3NlciB8fCB0eXBlb2YgbG9jYWxTdG9yYWdlID09PSBcInVuZGVmaW5lZFwiIHx8IGxvY2FsU3RvcmFnZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWNvcmRpbmdTdGF0ZTogZmFsc2UsXG4gICAgICBtb3VzZUV2ZW50RW5hYmxlZDogZmFsc2UsXG4gICAgICBrZXlib2FyZEV2ZW50RW5hYmxlZDogZmFsc2UsXG4gICAgICBjb21wb25lbnRFdmVudEVuYWJsZWQ6IGZhbHNlLFxuICAgICAgcGVyZm9ybWFuY2VFdmVudEVuYWJsZWQ6IGZhbHNlLFxuICAgICAgc2VsZWN0ZWQ6IFwiXCJcbiAgICB9O1xuICB9XG4gIGNvbnN0IHN0YXRlID0gdHlwZW9mIGxvY2FsU3RvcmFnZS5nZXRJdGVtICE9PSBcInVuZGVmaW5lZFwiID8gbG9jYWxTdG9yYWdlLmdldEl0ZW0oVElNRUxJTkVfTEFZRVJTX1NUQVRFX1NUT1JBR0VfSUQpIDogbnVsbDtcbiAgcmV0dXJuIHN0YXRlID8gSlNPTi5wYXJzZShzdGF0ZSkgOiB7XG4gICAgcmVjb3JkaW5nU3RhdGU6IGZhbHNlLFxuICAgIG1vdXNlRXZlbnRFbmFibGVkOiBmYWxzZSxcbiAgICBrZXlib2FyZEV2ZW50RW5hYmxlZDogZmFsc2UsXG4gICAgY29tcG9uZW50RXZlbnRFbmFibGVkOiBmYWxzZSxcbiAgICBwZXJmb3JtYW5jZUV2ZW50RW5hYmxlZDogZmFsc2UsXG4gICAgc2VsZWN0ZWQ6IFwiXCJcbiAgfTtcbn1cblxuLy8gc3JjL2N0eC9ob29rLnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgY3JlYXRlSG9va3MgfSBmcm9tIFwiaG9va2FibGVcIjtcbmltcG9ydCB7IGRlYm91bmNlIGFzIGRlYm91bmNlMiB9IGZyb20gXCJwZXJmZWN0LWRlYm91bmNlXCI7XG5cbi8vIHNyYy9jdHgvaW5zcGVjdG9yLnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgdGFyZ2V0IGFzIHRhcmdldDQgfSBmcm9tIFwiQHZ1ZS9kZXZ0b29scy1zaGFyZWRcIjtcbmltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSBcInBlcmZlY3QtZGVib3VuY2VcIjtcblxuLy8gc3JjL2N0eC90aW1lbGluZS50c1xuaW5pdF9lc21fc2hpbXMoKTtcbmltcG9ydCB7IHRhcmdldCBhcyB0YXJnZXQzIH0gZnJvbSBcIkB2dWUvZGV2dG9vbHMtc2hhcmVkXCI7XG52YXIgX2EyLCBfYjI7XG4oX2IyID0gKF9hMiA9IHRhcmdldDMpLl9fVlVFX0RFVlRPT0xTX0tJVF9USU1FTElORV9MQVlFUlMpICE9IG51bGwgPyBfYjIgOiBfYTIuX19WVUVfREVWVE9PTFNfS0lUX1RJTUVMSU5FX0xBWUVSUyA9IFtdO1xudmFyIGRldnRvb2xzVGltZWxpbmVMYXllcnMgPSBuZXcgUHJveHkodGFyZ2V0My5fX1ZVRV9ERVZUT09MU19LSVRfVElNRUxJTkVfTEFZRVJTLCB7XG4gIGdldCh0YXJnZXQyMiwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0MjIsIHByb3AsIHJlY2VpdmVyKTtcbiAgfVxufSk7XG5mdW5jdGlvbiBhZGRUaW1lbGluZUxheWVyKG9wdGlvbnMsIGRlc2NyaXB0b3IpIHtcbiAgZGV2dG9vbHNTdGF0ZS50aW1lbGluZUxheWVyc1N0YXRlW2Rlc2NyaXB0b3IuaWRdID0gZmFsc2U7XG4gIGRldnRvb2xzVGltZWxpbmVMYXllcnMucHVzaCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBkZXNjcmlwdG9ySWQ6IGRlc2NyaXB0b3IuaWQsXG4gICAgYXBwUmVjb3JkOiBnZXRBcHBSZWNvcmQoZGVzY3JpcHRvci5hcHApXG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlVGltZWxpbmVMYXllcnNTdGF0ZShzdGF0ZSkge1xuICBjb25zdCB1cGRhdGVkU3RhdGUgPSB7XG4gICAgLi4uZGV2dG9vbHNTdGF0ZS50aW1lbGluZUxheWVyc1N0YXRlLFxuICAgIC4uLnN0YXRlXG4gIH07XG4gIGFkZFRpbWVsaW5lTGF5ZXJzU3RhdGVUb1N0b3JhZ2UodXBkYXRlZFN0YXRlKTtcbiAgdXBkYXRlRGV2VG9vbHNTdGF0ZSh7XG4gICAgdGltZWxpbmVMYXllcnNTdGF0ZTogdXBkYXRlZFN0YXRlXG4gIH0pO1xufVxuXG4vLyBzcmMvY3R4L2luc3BlY3Rvci50c1xudmFyIF9hMywgX2IzO1xuKF9iMyA9IChfYTMgPSB0YXJnZXQ0KS5fX1ZVRV9ERVZUT09MU19LSVRfSU5TUEVDVE9SX18pICE9IG51bGwgPyBfYjMgOiBfYTMuX19WVUVfREVWVE9PTFNfS0lUX0lOU1BFQ1RPUl9fID0gW107XG52YXIgZGV2dG9vbHNJbnNwZWN0b3IgPSBuZXcgUHJveHkodGFyZ2V0NC5fX1ZVRV9ERVZUT09MU19LSVRfSU5TUEVDVE9SX18sIHtcbiAgZ2V0KHRhcmdldDIyLCBwcm9wLCByZWNlaXZlcikge1xuICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQyMiwgcHJvcCwgcmVjZWl2ZXIpO1xuICB9XG59KTtcbnZhciBjYWxsSW5zcGVjdG9yVXBkYXRlZEhvb2sgPSBkZWJvdW5jZSgoKSA9PiB7XG4gIGRldnRvb2xzQ29udGV4dC5ob29rcy5jYWxsSG9vayhcInNlbmRJbnNwZWN0b3JUb0NsaWVudFwiIC8qIFNFTkRfSU5TUEVDVE9SX1RPX0NMSUVOVCAqLywgZ2V0QWN0aXZlSW5zcGVjdG9ycygpKTtcbn0pO1xuZnVuY3Rpb24gYWRkSW5zcGVjdG9yKGluc3BlY3RvciwgZGVzY3JpcHRvcikge1xuICB2YXIgX2EyNSwgX2IyNTtcbiAgZGV2dG9vbHNJbnNwZWN0b3IucHVzaCh7XG4gICAgb3B0aW9uczogaW5zcGVjdG9yLFxuICAgIGRlc2NyaXB0b3IsXG4gICAgdHJlZUZpbHRlclBsYWNlaG9sZGVyOiAoX2EyNSA9IGluc3BlY3Rvci50cmVlRmlsdGVyUGxhY2Vob2xkZXIpICE9IG51bGwgPyBfYTI1IDogXCJTZWFyY2ggdHJlZS4uLlwiLFxuICAgIHN0YXRlRmlsdGVyUGxhY2Vob2xkZXI6IChfYjI1ID0gaW5zcGVjdG9yLnN0YXRlRmlsdGVyUGxhY2Vob2xkZXIpICE9IG51bGwgPyBfYjI1IDogXCJTZWFyY2ggc3RhdGUuLi5cIixcbiAgICB0cmVlRmlsdGVyOiBcIlwiLFxuICAgIHNlbGVjdGVkTm9kZUlkOiBcIlwiLFxuICAgIGFwcFJlY29yZDogZ2V0QXBwUmVjb3JkKGRlc2NyaXB0b3IuYXBwKVxuICB9KTtcbiAgY2FsbEluc3BlY3RvclVwZGF0ZWRIb29rKCk7XG59XG5mdW5jdGlvbiBnZXRBY3RpdmVJbnNwZWN0b3JzKCkge1xuICByZXR1cm4gZGV2dG9vbHNJbnNwZWN0b3IuZmlsdGVyKChpbnNwZWN0b3IpID0+IGluc3BlY3Rvci5kZXNjcmlwdG9yLmFwcCA9PT0gYWN0aXZlQXBwUmVjb3JkLnZhbHVlLmFwcCkuZmlsdGVyKChpbnNwZWN0b3IpID0+IGluc3BlY3Rvci5kZXNjcmlwdG9yLmlkICE9PSBcImNvbXBvbmVudHNcIikubWFwKChpbnNwZWN0b3IpID0+IHtcbiAgICB2YXIgX2EyNTtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gaW5zcGVjdG9yLmRlc2NyaXB0b3I7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGluc3BlY3Rvci5vcHRpb25zO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogb3B0aW9ucy5pZCxcbiAgICAgIGxhYmVsOiBvcHRpb25zLmxhYmVsLFxuICAgICAgbG9nbzogZGVzY3JpcHRvci5sb2dvLFxuICAgICAgaWNvbjogYGN1c3RvbS1pYy1iYXNlbGluZS0keyhfYTI1ID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5pY29uKSA9PSBudWxsID8gdm9pZCAwIDogX2EyNS5yZXBsYWNlKC9fL2csIFwiLVwiKX1gLFxuICAgICAgcGFja2FnZU5hbWU6IGRlc2NyaXB0b3IucGFja2FnZU5hbWUsXG4gICAgICBob21lcGFnZTogZGVzY3JpcHRvci5ob21lcGFnZSxcbiAgICAgIHBsdWdpbklkOiBkZXNjcmlwdG9yLmlkXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRJbnNwZWN0b3JJbmZvKGlkKSB7XG4gIGNvbnN0IGluc3BlY3RvciA9IGdldEluc3BlY3RvcihpZCwgYWN0aXZlQXBwUmVjb3JkLnZhbHVlLmFwcCk7XG4gIGlmICghaW5zcGVjdG9yKVxuICAgIHJldHVybjtcbiAgY29uc3QgZGVzY3JpcHRvciA9IGluc3BlY3Rvci5kZXNjcmlwdG9yO1xuICBjb25zdCBvcHRpb25zID0gaW5zcGVjdG9yLm9wdGlvbnM7XG4gIGNvbnN0IHRpbWVsaW5lTGF5ZXJzID0gZGV2dG9vbHNUaW1lbGluZUxheWVycy5maWx0ZXIoKGxheWVyKSA9PiBsYXllci5kZXNjcmlwdG9ySWQgPT09IGRlc2NyaXB0b3IuaWQpLm1hcCgoaXRlbSkgPT4gKHtcbiAgICBpZDogaXRlbS5pZCxcbiAgICBsYWJlbDogaXRlbS5sYWJlbCxcbiAgICBjb2xvcjogaXRlbS5jb2xvclxuICB9KSk7XG4gIHJldHVybiB7XG4gICAgaWQ6IG9wdGlvbnMuaWQsXG4gICAgbGFiZWw6IG9wdGlvbnMubGFiZWwsXG4gICAgbG9nbzogZGVzY3JpcHRvci5sb2dvLFxuICAgIHBhY2thZ2VOYW1lOiBkZXNjcmlwdG9yLnBhY2thZ2VOYW1lLFxuICAgIGhvbWVwYWdlOiBkZXNjcmlwdG9yLmhvbWVwYWdlLFxuICAgIHRpbWVsaW5lTGF5ZXJzLFxuICAgIHRyZWVGaWx0ZXJQbGFjZWhvbGRlcjogaW5zcGVjdG9yLnRyZWVGaWx0ZXJQbGFjZWhvbGRlcixcbiAgICBzdGF0ZUZpbHRlclBsYWNlaG9sZGVyOiBpbnNwZWN0b3Iuc3RhdGVGaWx0ZXJQbGFjZWhvbGRlclxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW5zcGVjdG9yKGlkLCBhcHApIHtcbiAgcmV0dXJuIGRldnRvb2xzSW5zcGVjdG9yLmZpbmQoKGluc3BlY3RvcikgPT4gaW5zcGVjdG9yLm9wdGlvbnMuaWQgPT09IGlkICYmIChhcHAgPyBpbnNwZWN0b3IuZGVzY3JpcHRvci5hcHAgPT09IGFwcCA6IHRydWUpKTtcbn1cbmZ1bmN0aW9uIGdldEluc3BlY3RvckFjdGlvbnMoaWQpIHtcbiAgY29uc3QgaW5zcGVjdG9yID0gZ2V0SW5zcGVjdG9yKGlkKTtcbiAgcmV0dXJuIGluc3BlY3RvciA9PSBudWxsID8gdm9pZCAwIDogaW5zcGVjdG9yLm9wdGlvbnMuYWN0aW9ucztcbn1cbmZ1bmN0aW9uIGdldEluc3BlY3Rvck5vZGVBY3Rpb25zKGlkKSB7XG4gIGNvbnN0IGluc3BlY3RvciA9IGdldEluc3BlY3RvcihpZCk7XG4gIHJldHVybiBpbnNwZWN0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3BlY3Rvci5vcHRpb25zLm5vZGVBY3Rpb25zO1xufVxuXG4vLyBzcmMvY3R4L2hvb2sudHNcbnZhciBEZXZUb29sc1Y2UGx1Z2luQVBJSG9va0tleXMgPSAvKiBAX19QVVJFX18gKi8gKChEZXZUb29sc1Y2UGx1Z2luQVBJSG9va0tleXMyKSA9PiB7XG4gIERldlRvb2xzVjZQbHVnaW5BUElIb29rS2V5czJbXCJWSVNJVF9DT01QT05FTlRfVFJFRVwiXSA9IFwidmlzaXRDb21wb25lbnRUcmVlXCI7XG4gIERldlRvb2xzVjZQbHVnaW5BUElIb29rS2V5czJbXCJJTlNQRUNUX0NPTVBPTkVOVFwiXSA9IFwiaW5zcGVjdENvbXBvbmVudFwiO1xuICBEZXZUb29sc1Y2UGx1Z2luQVBJSG9va0tleXMyW1wiRURJVF9DT01QT05FTlRfU1RBVEVcIl0gPSBcImVkaXRDb21wb25lbnRTdGF0ZVwiO1xuICBEZXZUb29sc1Y2UGx1Z2luQVBJSG9va0tleXMyW1wiR0VUX0lOU1BFQ1RPUl9UUkVFXCJdID0gXCJnZXRJbnNwZWN0b3JUcmVlXCI7XG4gIERldlRvb2xzVjZQbHVnaW5BUElIb29rS2V5czJbXCJHRVRfSU5TUEVDVE9SX1NUQVRFXCJdID0gXCJnZXRJbnNwZWN0b3JTdGF0ZVwiO1xuICBEZXZUb29sc1Y2UGx1Z2luQVBJSG9va0tleXMyW1wiRURJVF9JTlNQRUNUT1JfU1RBVEVcIl0gPSBcImVkaXRJbnNwZWN0b3JTdGF0ZVwiO1xuICBEZXZUb29sc1Y2UGx1Z2luQVBJSG9va0tleXMyW1wiSU5TUEVDVF9USU1FTElORV9FVkVOVFwiXSA9IFwiaW5zcGVjdFRpbWVsaW5lRXZlbnRcIjtcbiAgRGV2VG9vbHNWNlBsdWdpbkFQSUhvb2tLZXlzMltcIlRJTUVMSU5FX0NMRUFSRURcIl0gPSBcInRpbWVsaW5lQ2xlYXJlZFwiO1xuICBEZXZUb29sc1Y2UGx1Z2luQVBJSG9va0tleXMyW1wiU0VUX1BMVUdJTl9TRVRUSU5HU1wiXSA9IFwic2V0UGx1Z2luU2V0dGluZ3NcIjtcbiAgcmV0dXJuIERldlRvb2xzVjZQbHVnaW5BUElIb29rS2V5czI7XG59KShEZXZUb29sc1Y2UGx1Z2luQVBJSG9va0tleXMgfHwge30pO1xudmFyIERldlRvb2xzQ29udGV4dEhvb2tLZXlzID0gLyogQF9fUFVSRV9fICovICgoRGV2VG9vbHNDb250ZXh0SG9va0tleXMyKSA9PiB7XG4gIERldlRvb2xzQ29udGV4dEhvb2tLZXlzMltcIkFERF9JTlNQRUNUT1JcIl0gPSBcImFkZEluc3BlY3RvclwiO1xuICBEZXZUb29sc0NvbnRleHRIb29rS2V5czJbXCJTRU5EX0lOU1BFQ1RPUl9UUkVFXCJdID0gXCJzZW5kSW5zcGVjdG9yVHJlZVwiO1xuICBEZXZUb29sc0NvbnRleHRIb29rS2V5czJbXCJTRU5EX0lOU1BFQ1RPUl9TVEFURVwiXSA9IFwic2VuZEluc3BlY3RvclN0YXRlXCI7XG4gIERldlRvb2xzQ29udGV4dEhvb2tLZXlzMltcIkNVU1RPTV9JTlNQRUNUT1JfU0VMRUNUX05PREVcIl0gPSBcImN1c3RvbUluc3BlY3RvclNlbGVjdE5vZGVcIjtcbiAgRGV2VG9vbHNDb250ZXh0SG9va0tleXMyW1wiVElNRUxJTkVfTEFZRVJfQURERURcIl0gPSBcInRpbWVsaW5lTGF5ZXJBZGRlZFwiO1xuICBEZXZUb29sc0NvbnRleHRIb29rS2V5czJbXCJUSU1FTElORV9FVkVOVF9BRERFRFwiXSA9IFwidGltZWxpbmVFdmVudEFkZGVkXCI7XG4gIERldlRvb2xzQ29udGV4dEhvb2tLZXlzMltcIkdFVF9DT01QT05FTlRfSU5TVEFOQ0VTXCJdID0gXCJnZXRDb21wb25lbnRJbnN0YW5jZXNcIjtcbiAgRGV2VG9vbHNDb250ZXh0SG9va0tleXMyW1wiR0VUX0NPTVBPTkVOVF9CT1VORFNcIl0gPSBcImdldENvbXBvbmVudEJvdW5kc1wiO1xuICBEZXZUb29sc0NvbnRleHRIb29rS2V5czJbXCJHRVRfQ09NUE9ORU5UX05BTUVcIl0gPSBcImdldENvbXBvbmVudE5hbWVcIjtcbiAgRGV2VG9vbHNDb250ZXh0SG9va0tleXMyW1wiQ09NUE9ORU5UX0hJR0hMSUdIVFwiXSA9IFwiY29tcG9uZW50SGlnaGxpZ2h0XCI7XG4gIERldlRvb2xzQ29udGV4dEhvb2tLZXlzMltcIkNPTVBPTkVOVF9VTkhJR0hMSUdIVFwiXSA9IFwiY29tcG9uZW50VW5oaWdobGlnaHRcIjtcbiAgcmV0dXJuIERldlRvb2xzQ29udGV4dEhvb2tLZXlzMjtcbn0pKERldlRvb2xzQ29udGV4dEhvb2tLZXlzIHx8IHt9KTtcbnZhciBEZXZUb29sc01lc3NhZ2luZ0hvb2tLZXlzID0gLyogQF9fUFVSRV9fICovICgoRGV2VG9vbHNNZXNzYWdpbmdIb29rS2V5czIpID0+IHtcbiAgRGV2VG9vbHNNZXNzYWdpbmdIb29rS2V5czJbXCJTRU5EX0lOU1BFQ1RPUl9UUkVFX1RPX0NMSUVOVFwiXSA9IFwic2VuZEluc3BlY3RvclRyZWVUb0NsaWVudFwiO1xuICBEZXZUb29sc01lc3NhZ2luZ0hvb2tLZXlzMltcIlNFTkRfSU5TUEVDVE9SX1NUQVRFX1RPX0NMSUVOVFwiXSA9IFwic2VuZEluc3BlY3RvclN0YXRlVG9DbGllbnRcIjtcbiAgRGV2VG9vbHNNZXNzYWdpbmdIb29rS2V5czJbXCJTRU5EX1RJTUVMSU5FX0VWRU5UX1RPX0NMSUVOVFwiXSA9IFwic2VuZFRpbWVsaW5lRXZlbnRUb0NsaWVudFwiO1xuICBEZXZUb29sc01lc3NhZ2luZ0hvb2tLZXlzMltcIlNFTkRfSU5TUEVDVE9SX1RPX0NMSUVOVFwiXSA9IFwic2VuZEluc3BlY3RvclRvQ2xpZW50XCI7XG4gIERldlRvb2xzTWVzc2FnaW5nSG9va0tleXMyW1wiU0VORF9BQ1RJVkVfQVBQX1VOTU9VTlRFRF9UT19DTElFTlRcIl0gPSBcInNlbmRBY3RpdmVBcHBVcGRhdGVkVG9DbGllbnRcIjtcbiAgRGV2VG9vbHNNZXNzYWdpbmdIb29rS2V5czJbXCJERVZUT09MU19TVEFURV9VUERBVEVEXCJdID0gXCJkZXZ0b29sc1N0YXRlVXBkYXRlZFwiO1xuICBEZXZUb29sc01lc3NhZ2luZ0hvb2tLZXlzMltcIkRFVlRPT0xTX0NPTk5FQ1RFRF9VUERBVEVEXCJdID0gXCJkZXZ0b29sc0Nvbm5lY3RlZFVwZGF0ZWRcIjtcbiAgRGV2VG9vbHNNZXNzYWdpbmdIb29rS2V5czJbXCJST1VURVJfSU5GT19VUERBVEVEXCJdID0gXCJyb3V0ZXJJbmZvVXBkYXRlZFwiO1xuICByZXR1cm4gRGV2VG9vbHNNZXNzYWdpbmdIb29rS2V5czI7XG59KShEZXZUb29sc01lc3NhZ2luZ0hvb2tLZXlzIHx8IHt9KTtcbmZ1bmN0aW9uIGNyZWF0ZURldlRvb2xzQ3R4SG9va3MoKSB7XG4gIGNvbnN0IGhvb2tzMiA9IGNyZWF0ZUhvb2tzKCk7XG4gIGhvb2tzMi5ob29rKFwiYWRkSW5zcGVjdG9yXCIgLyogQUREX0lOU1BFQ1RPUiAqLywgKHsgaW5zcGVjdG9yLCBwbHVnaW4gfSkgPT4ge1xuICAgIGFkZEluc3BlY3RvcihpbnNwZWN0b3IsIHBsdWdpbi5kZXNjcmlwdG9yKTtcbiAgfSk7XG4gIGNvbnN0IGRlYm91bmNlU2VuZEluc3BlY3RvclRyZWUgPSBkZWJvdW5jZTIoYXN5bmMgKHsgaW5zcGVjdG9ySWQsIHBsdWdpbiB9KSA9PiB7XG4gICAgdmFyIF9hMjU7XG4gICAgaWYgKCFpbnNwZWN0b3JJZCB8fCAhKChfYTI1ID0gcGx1Z2luID09IG51bGwgPyB2b2lkIDAgOiBwbHVnaW4uZGVzY3JpcHRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjUuYXBwKSB8fCBkZXZ0b29sc1N0YXRlLmhpZ2hQZXJmTW9kZUVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaW5zcGVjdG9yID0gZ2V0SW5zcGVjdG9yKGluc3BlY3RvcklkLCBwbHVnaW4uZGVzY3JpcHRvci5hcHApO1xuICAgIGNvbnN0IF9wYXlsb2FkID0ge1xuICAgICAgYXBwOiBwbHVnaW4uZGVzY3JpcHRvci5hcHAsXG4gICAgICBpbnNwZWN0b3JJZCxcbiAgICAgIGZpbHRlcjogKGluc3BlY3RvciA9PSBudWxsID8gdm9pZCAwIDogaW5zcGVjdG9yLnRyZWVGaWx0ZXIpIHx8IFwiXCIsXG4gICAgICByb290Tm9kZXM6IFtdXG4gICAgfTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgaG9va3MyLmNhbGxIb29rV2l0aChhc3luYyAoY2FsbGJhY2tzKSA9PiB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGNhbGxiYWNrcy5tYXAoKGNiKSA9PiBjYihfcGF5bG9hZCkpKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSwgXCJnZXRJbnNwZWN0b3JUcmVlXCIgLyogR0VUX0lOU1BFQ1RPUl9UUkVFICovKTtcbiAgICB9KTtcbiAgICBob29rczIuY2FsbEhvb2tXaXRoKGFzeW5jIChjYWxsYmFja3MpID0+IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGNhbGxiYWNrcy5tYXAoKGNiKSA9PiBjYih7XG4gICAgICAgIGluc3BlY3RvcklkLFxuICAgICAgICByb290Tm9kZXM6IF9wYXlsb2FkLnJvb3ROb2Rlc1xuICAgICAgfSkpKTtcbiAgICB9LCBcInNlbmRJbnNwZWN0b3JUcmVlVG9DbGllbnRcIiAvKiBTRU5EX0lOU1BFQ1RPUl9UUkVFX1RPX0NMSUVOVCAqLyk7XG4gIH0sIDEyMCk7XG4gIGhvb2tzMi5ob29rKFwic2VuZEluc3BlY3RvclRyZWVcIiAvKiBTRU5EX0lOU1BFQ1RPUl9UUkVFICovLCBkZWJvdW5jZVNlbmRJbnNwZWN0b3JUcmVlKTtcbiAgY29uc3QgZGVib3VuY2VTZW5kSW5zcGVjdG9yU3RhdGUgPSBkZWJvdW5jZTIoYXN5bmMgKHsgaW5zcGVjdG9ySWQsIHBsdWdpbiB9KSA9PiB7XG4gICAgdmFyIF9hMjU7XG4gICAgaWYgKCFpbnNwZWN0b3JJZCB8fCAhKChfYTI1ID0gcGx1Z2luID09IG51bGwgPyB2b2lkIDAgOiBwbHVnaW4uZGVzY3JpcHRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjUuYXBwKSB8fCBkZXZ0b29sc1N0YXRlLmhpZ2hQZXJmTW9kZUVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaW5zcGVjdG9yID0gZ2V0SW5zcGVjdG9yKGluc3BlY3RvcklkLCBwbHVnaW4uZGVzY3JpcHRvci5hcHApO1xuICAgIGNvbnN0IF9wYXlsb2FkID0ge1xuICAgICAgYXBwOiBwbHVnaW4uZGVzY3JpcHRvci5hcHAsXG4gICAgICBpbnNwZWN0b3JJZCxcbiAgICAgIG5vZGVJZDogKGluc3BlY3RvciA9PSBudWxsID8gdm9pZCAwIDogaW5zcGVjdG9yLnNlbGVjdGVkTm9kZUlkKSB8fCBcIlwiLFxuICAgICAgc3RhdGU6IG51bGxcbiAgICB9O1xuICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgIGN1cnJlbnRUYWI6IGBjdXN0b20taW5zcGVjdG9yOiR7aW5zcGVjdG9ySWR9YFxuICAgIH07XG4gICAgaWYgKF9wYXlsb2FkLm5vZGVJZCkge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaG9va3MyLmNhbGxIb29rV2l0aChhc3luYyAoY2FsbGJhY2tzKSA9PiB7XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2FsbGJhY2tzLm1hcCgoY2IpID0+IGNiKF9wYXlsb2FkLCBjdHgpKSk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCBcImdldEluc3BlY3RvclN0YXRlXCIgLyogR0VUX0lOU1BFQ1RPUl9TVEFURSAqLyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaG9va3MyLmNhbGxIb29rV2l0aChhc3luYyAoY2FsbGJhY2tzKSA9PiB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChjYWxsYmFja3MubWFwKChjYikgPT4gY2Ioe1xuICAgICAgICBpbnNwZWN0b3JJZCxcbiAgICAgICAgbm9kZUlkOiBfcGF5bG9hZC5ub2RlSWQsXG4gICAgICAgIHN0YXRlOiBfcGF5bG9hZC5zdGF0ZVxuICAgICAgfSkpKTtcbiAgICB9LCBcInNlbmRJbnNwZWN0b3JTdGF0ZVRvQ2xpZW50XCIgLyogU0VORF9JTlNQRUNUT1JfU1RBVEVfVE9fQ0xJRU5UICovKTtcbiAgfSwgMTIwKTtcbiAgaG9va3MyLmhvb2soXCJzZW5kSW5zcGVjdG9yU3RhdGVcIiAvKiBTRU5EX0lOU1BFQ1RPUl9TVEFURSAqLywgZGVib3VuY2VTZW5kSW5zcGVjdG9yU3RhdGUpO1xuICBob29rczIuaG9vayhcImN1c3RvbUluc3BlY3RvclNlbGVjdE5vZGVcIiAvKiBDVVNUT01fSU5TUEVDVE9SX1NFTEVDVF9OT0RFICovLCAoeyBpbnNwZWN0b3JJZCwgbm9kZUlkLCBwbHVnaW4gfSkgPT4ge1xuICAgIGNvbnN0IGluc3BlY3RvciA9IGdldEluc3BlY3RvcihpbnNwZWN0b3JJZCwgcGx1Z2luLmRlc2NyaXB0b3IuYXBwKTtcbiAgICBpZiAoIWluc3BlY3RvcilcbiAgICAgIHJldHVybjtcbiAgICBpbnNwZWN0b3Iuc2VsZWN0ZWROb2RlSWQgPSBub2RlSWQ7XG4gIH0pO1xuICBob29rczIuaG9vayhcInRpbWVsaW5lTGF5ZXJBZGRlZFwiIC8qIFRJTUVMSU5FX0xBWUVSX0FEREVEICovLCAoeyBvcHRpb25zLCBwbHVnaW4gfSkgPT4ge1xuICAgIGFkZFRpbWVsaW5lTGF5ZXIob3B0aW9ucywgcGx1Z2luLmRlc2NyaXB0b3IpO1xuICB9KTtcbiAgaG9va3MyLmhvb2soXCJ0aW1lbGluZUV2ZW50QWRkZWRcIiAvKiBUSU1FTElORV9FVkVOVF9BRERFRCAqLywgKHsgb3B0aW9ucywgcGx1Z2luIH0pID0+IHtcbiAgICB2YXIgX2EyNTtcbiAgICBjb25zdCBpbnRlcm5hbExheWVySWRzID0gW1wicGVyZm9ybWFuY2VcIiwgXCJjb21wb25lbnQtZXZlbnRcIiwgXCJrZXlib2FyZFwiLCBcIm1vdXNlXCJdO1xuICAgIGlmIChkZXZ0b29sc1N0YXRlLmhpZ2hQZXJmTW9kZUVuYWJsZWQgfHwgISgoX2EyNSA9IGRldnRvb2xzU3RhdGUudGltZWxpbmVMYXllcnNTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjVbcGx1Z2luLmRlc2NyaXB0b3IuaWRdKSAmJiAhaW50ZXJuYWxMYXllcklkcy5pbmNsdWRlcyhvcHRpb25zLmxheWVySWQpKVxuICAgICAgcmV0dXJuO1xuICAgIGhvb2tzMi5jYWxsSG9va1dpdGgoYXN5bmMgKGNhbGxiYWNrcykgPT4ge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2FsbGJhY2tzLm1hcCgoY2IpID0+IGNiKG9wdGlvbnMpKSk7XG4gICAgfSwgXCJzZW5kVGltZWxpbmVFdmVudFRvQ2xpZW50XCIgLyogU0VORF9USU1FTElORV9FVkVOVF9UT19DTElFTlQgKi8pO1xuICB9KTtcbiAgaG9va3MyLmhvb2soXCJnZXRDb21wb25lbnRJbnN0YW5jZXNcIiAvKiBHRVRfQ09NUE9ORU5UX0lOU1RBTkNFUyAqLywgYXN5bmMgKHsgYXBwIH0pID0+IHtcbiAgICBjb25zdCBhcHBSZWNvcmQgPSBhcHAuX19WVUVfREVWVE9PTFNfTkVYVF9BUFBfUkVDT1JEX187XG4gICAgaWYgKCFhcHBSZWNvcmQpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBhcHBJZCA9IGFwcFJlY29yZC5pZC50b1N0cmluZygpO1xuICAgIGNvbnN0IGluc3RhbmNlcyA9IFsuLi5hcHBSZWNvcmQuaW5zdGFuY2VNYXBdLmZpbHRlcigoW2tleV0pID0+IGtleS5zcGxpdChcIjpcIilbMF0gPT09IGFwcElkKS5tYXAoKFssIGluc3RhbmNlXSkgPT4gaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZXM7XG4gIH0pO1xuICBob29rczIuaG9vayhcImdldENvbXBvbmVudEJvdW5kc1wiIC8qIEdFVF9DT01QT05FTlRfQk9VTkRTICovLCBhc3luYyAoeyBpbnN0YW5jZSB9KSA9PiB7XG4gICAgY29uc3QgYm91bmRzID0gZ2V0Q29tcG9uZW50Qm91bmRpbmdSZWN0KGluc3RhbmNlKTtcbiAgICByZXR1cm4gYm91bmRzO1xuICB9KTtcbiAgaG9va3MyLmhvb2soXCJnZXRDb21wb25lbnROYW1lXCIgLyogR0VUX0NPTVBPTkVOVF9OQU1FICovLCAoeyBpbnN0YW5jZSB9KSA9PiB7XG4gICAgY29uc3QgbmFtZSA9IGdldEluc3RhbmNlTmFtZShpbnN0YW5jZSk7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH0pO1xuICBob29rczIuaG9vayhcImNvbXBvbmVudEhpZ2hsaWdodFwiIC8qIENPTVBPTkVOVF9ISUdITElHSFQgKi8sICh7IHVpZCB9KSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBhY3RpdmVBcHBSZWNvcmQudmFsdWUuaW5zdGFuY2VNYXAuZ2V0KHVpZCk7XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBoaWdobGlnaHQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfSk7XG4gIGhvb2tzMi5ob29rKFwiY29tcG9uZW50VW5oaWdobGlnaHRcIiAvKiBDT01QT05FTlRfVU5ISUdITElHSFQgKi8sICgpID0+IHtcbiAgICB1bmhpZ2hsaWdodCgpO1xuICB9KTtcbiAgcmV0dXJuIGhvb2tzMjtcbn1cblxuLy8gc3JjL2N0eC9zdGF0ZS50c1xudmFyIF9hNCwgX2I0O1xuKF9iNCA9IChfYTQgPSBnbG9iYWwpLl9fVlVFX0RFVlRPT0xTX0tJVF9BUFBfUkVDT1JEU19fKSAhPSBudWxsID8gX2I0IDogX2E0Ll9fVlVFX0RFVlRPT0xTX0tJVF9BUFBfUkVDT1JEU19fID0gW107XG52YXIgX2E1LCBfYjU7XG4oX2I1ID0gKF9hNSA9IGdsb2JhbCkuX19WVUVfREVWVE9PTFNfS0lUX0FDVElWRV9BUFBfUkVDT1JEX18pICE9IG51bGwgPyBfYjUgOiBfYTUuX19WVUVfREVWVE9PTFNfS0lUX0FDVElWRV9BUFBfUkVDT1JEX18gPSB7fTtcbnZhciBfYTYsIF9iNjtcbihfYjYgPSAoX2E2ID0gZ2xvYmFsKS5fX1ZVRV9ERVZUT09MU19LSVRfQUNUSVZFX0FQUF9SRUNPUkRfSURfXykgIT0gbnVsbCA/IF9iNiA6IF9hNi5fX1ZVRV9ERVZUT09MU19LSVRfQUNUSVZFX0FQUF9SRUNPUkRfSURfXyA9IFwiXCI7XG52YXIgX2E3LCBfYjc7XG4oX2I3ID0gKF9hNyA9IGdsb2JhbCkuX19WVUVfREVWVE9PTFNfS0lUX0NVU1RPTV9UQUJTX18pICE9IG51bGwgPyBfYjcgOiBfYTcuX19WVUVfREVWVE9PTFNfS0lUX0NVU1RPTV9UQUJTX18gPSBbXTtcbnZhciBfYTgsIF9iODtcbihfYjggPSAoX2E4ID0gZ2xvYmFsKS5fX1ZVRV9ERVZUT09MU19LSVRfQ1VTVE9NX0NPTU1BTkRTX18pICE9IG51bGwgPyBfYjggOiBfYTguX19WVUVfREVWVE9PTFNfS0lUX0NVU1RPTV9DT01NQU5EU19fID0gW107XG52YXIgU1RBVEVfS0VZID0gXCJfX1ZVRV9ERVZUT09MU19LSVRfR0xPQkFMX1NUQVRFX19cIjtcbmZ1bmN0aW9uIGluaXRTdGF0ZUZhY3RvcnkoKSB7XG4gIHJldHVybiB7XG4gICAgY29ubmVjdGVkOiBmYWxzZSxcbiAgICBjbGllbnRDb25uZWN0ZWQ6IGZhbHNlLFxuICAgIHZpdGVQbHVnaW5EZXRlY3RlZDogdHJ1ZSxcbiAgICBhcHBSZWNvcmRzOiBbXSxcbiAgICBhY3RpdmVBcHBSZWNvcmRJZDogXCJcIixcbiAgICB0YWJzOiBbXSxcbiAgICBjb21tYW5kczogW10sXG4gICAgaGlnaFBlcmZNb2RlRW5hYmxlZDogdHJ1ZSxcbiAgICBkZXZ0b29sc0NsaWVudERldGVjdGVkOiB7fSxcbiAgICBwZXJmVW5pcXVlR3JvdXBJZDogMCxcbiAgICB0aW1lbGluZUxheWVyc1N0YXRlOiBnZXRUaW1lbGluZUxheWVyc1N0YXRlRnJvbVN0b3JhZ2UoKVxuICB9O1xufVxudmFyIF9hOSwgX2I5O1xuKF9iOSA9IChfYTkgPSBnbG9iYWwpW1NUQVRFX0tFWV0pICE9IG51bGwgPyBfYjkgOiBfYTlbU1RBVEVfS0VZXSA9IGluaXRTdGF0ZUZhY3RvcnkoKTtcbnZhciBjYWxsU3RhdGVVcGRhdGVkSG9vayA9IGRlYm91bmNlMygoc3RhdGUpID0+IHtcbiAgZGV2dG9vbHNDb250ZXh0Lmhvb2tzLmNhbGxIb29rKFwiZGV2dG9vbHNTdGF0ZVVwZGF0ZWRcIiAvKiBERVZUT09MU19TVEFURV9VUERBVEVEICovLCB7IHN0YXRlIH0pO1xufSk7XG52YXIgY2FsbENvbm5lY3RlZFVwZGF0ZWRIb29rID0gZGVib3VuY2UzKChzdGF0ZSwgb2xkU3RhdGUpID0+IHtcbiAgZGV2dG9vbHNDb250ZXh0Lmhvb2tzLmNhbGxIb29rKFwiZGV2dG9vbHNDb25uZWN0ZWRVcGRhdGVkXCIgLyogREVWVE9PTFNfQ09OTkVDVEVEX1VQREFURUQgKi8sIHsgc3RhdGUsIG9sZFN0YXRlIH0pO1xufSk7XG52YXIgZGV2dG9vbHNBcHBSZWNvcmRzID0gbmV3IFByb3h5KGdsb2JhbC5fX1ZVRV9ERVZUT09MU19LSVRfQVBQX1JFQ09SRFNfXywge1xuICBnZXQoX3RhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICBpZiAocHJvcCA9PT0gXCJ2YWx1ZVwiKVxuICAgICAgcmV0dXJuIGdsb2JhbC5fX1ZVRV9ERVZUT09MU19LSVRfQVBQX1JFQ09SRFNfXztcbiAgICByZXR1cm4gZ2xvYmFsLl9fVlVFX0RFVlRPT0xTX0tJVF9BUFBfUkVDT1JEU19fW3Byb3BdO1xuICB9XG59KTtcbnZhciBhZGREZXZUb29sc0FwcFJlY29yZCA9IChhcHApID0+IHtcbiAgZ2xvYmFsLl9fVlVFX0RFVlRPT0xTX0tJVF9BUFBfUkVDT1JEU19fID0gW1xuICAgIC4uLmdsb2JhbC5fX1ZVRV9ERVZUT09MU19LSVRfQVBQX1JFQ09SRFNfXyxcbiAgICBhcHBcbiAgXTtcbn07XG52YXIgcmVtb3ZlRGV2VG9vbHNBcHBSZWNvcmQgPSAoYXBwKSA9PiB7XG4gIGdsb2JhbC5fX1ZVRV9ERVZUT09MU19LSVRfQVBQX1JFQ09SRFNfXyA9IGRldnRvb2xzQXBwUmVjb3Jkcy52YWx1ZS5maWx0ZXIoKHJlY29yZCkgPT4gcmVjb3JkLmFwcCAhPT0gYXBwKTtcbn07XG52YXIgYWN0aXZlQXBwUmVjb3JkID0gbmV3IFByb3h5KGdsb2JhbC5fX1ZVRV9ERVZUT09MU19LSVRfQUNUSVZFX0FQUF9SRUNPUkRfXywge1xuICBnZXQoX3RhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICBpZiAocHJvcCA9PT0gXCJ2YWx1ZVwiKVxuICAgICAgcmV0dXJuIGdsb2JhbC5fX1ZVRV9ERVZUT09MU19LSVRfQUNUSVZFX0FQUF9SRUNPUkRfXztcbiAgICBlbHNlIGlmIChwcm9wID09PSBcImlkXCIpXG4gICAgICByZXR1cm4gZ2xvYmFsLl9fVlVFX0RFVlRPT0xTX0tJVF9BQ1RJVkVfQVBQX1JFQ09SRF9JRF9fO1xuICAgIHJldHVybiBnbG9iYWwuX19WVUVfREVWVE9PTFNfS0lUX0FDVElWRV9BUFBfUkVDT1JEX19bcHJvcF07XG4gIH1cbn0pO1xuZnVuY3Rpb24gdXBkYXRlQWxsU3RhdGVzKCkge1xuICBjYWxsU3RhdGVVcGRhdGVkSG9vayh7XG4gICAgLi4uZ2xvYmFsW1NUQVRFX0tFWV0sXG4gICAgYXBwUmVjb3JkczogZGV2dG9vbHNBcHBSZWNvcmRzLnZhbHVlLFxuICAgIGFjdGl2ZUFwcFJlY29yZElkOiBhY3RpdmVBcHBSZWNvcmQuaWQsXG4gICAgdGFiczogZ2xvYmFsLl9fVlVFX0RFVlRPT0xTX0tJVF9DVVNUT01fVEFCU19fLFxuICAgIGNvbW1hbmRzOiBnbG9iYWwuX19WVUVfREVWVE9PTFNfS0lUX0NVU1RPTV9DT01NQU5EU19fXG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0QWN0aXZlQXBwUmVjb3JkKGFwcCkge1xuICBnbG9iYWwuX19WVUVfREVWVE9PTFNfS0lUX0FDVElWRV9BUFBfUkVDT1JEX18gPSBhcHA7XG4gIHVwZGF0ZUFsbFN0YXRlcygpO1xufVxuZnVuY3Rpb24gc2V0QWN0aXZlQXBwUmVjb3JkSWQoaWQpIHtcbiAgZ2xvYmFsLl9fVlVFX0RFVlRPT0xTX0tJVF9BQ1RJVkVfQVBQX1JFQ09SRF9JRF9fID0gaWQ7XG4gIHVwZGF0ZUFsbFN0YXRlcygpO1xufVxudmFyIGRldnRvb2xzU3RhdGUgPSBuZXcgUHJveHkoZ2xvYmFsW1NUQVRFX0tFWV0sIHtcbiAgZ2V0KHRhcmdldDIyLCBwcm9wZXJ0eSkge1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gXCJhcHBSZWNvcmRzXCIpIHtcbiAgICAgIHJldHVybiBkZXZ0b29sc0FwcFJlY29yZHM7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gXCJhY3RpdmVBcHBSZWNvcmRJZFwiKSB7XG4gICAgICByZXR1cm4gYWN0aXZlQXBwUmVjb3JkLmlkO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHkgPT09IFwidGFic1wiKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsLl9fVlVFX0RFVlRPT0xTX0tJVF9DVVNUT01fVEFCU19fO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHkgPT09IFwiY29tbWFuZHNcIikge1xuICAgICAgcmV0dXJuIGdsb2JhbC5fX1ZVRV9ERVZUT09MU19LSVRfQ1VTVE9NX0NPTU1BTkRTX187XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxbU1RBVEVfS0VZXVtwcm9wZXJ0eV07XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5KHRhcmdldDIyLCBwcm9wZXJ0eSkge1xuICAgIGRlbGV0ZSB0YXJnZXQyMltwcm9wZXJ0eV07XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHNldCh0YXJnZXQyMiwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB7IC4uLmdsb2JhbFtTVEFURV9LRVldIH07XG4gICAgdGFyZ2V0MjJbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZ2xvYmFsW1NUQVRFX0tFWV1bcHJvcGVydHldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0pO1xuZnVuY3Rpb24gcmVzZXREZXZUb29sc1N0YXRlKCkge1xuICBPYmplY3QuYXNzaWduKGdsb2JhbFtTVEFURV9LRVldLCBpbml0U3RhdGVGYWN0b3J5KCkpO1xufVxuZnVuY3Rpb24gdXBkYXRlRGV2VG9vbHNTdGF0ZShzdGF0ZSkge1xuICBjb25zdCBvbGRTdGF0ZSA9IHtcbiAgICAuLi5nbG9iYWxbU1RBVEVfS0VZXSxcbiAgICBhcHBSZWNvcmRzOiBkZXZ0b29sc0FwcFJlY29yZHMudmFsdWUsXG4gICAgYWN0aXZlQXBwUmVjb3JkSWQ6IGFjdGl2ZUFwcFJlY29yZC5pZFxuICB9O1xuICBpZiAob2xkU3RhdGUuY29ubmVjdGVkICE9PSBzdGF0ZS5jb25uZWN0ZWQgJiYgc3RhdGUuY29ubmVjdGVkIHx8IG9sZFN0YXRlLmNsaWVudENvbm5lY3RlZCAhPT0gc3RhdGUuY2xpZW50Q29ubmVjdGVkICYmIHN0YXRlLmNsaWVudENvbm5lY3RlZCkge1xuICAgIGNhbGxDb25uZWN0ZWRVcGRhdGVkSG9vayhnbG9iYWxbU1RBVEVfS0VZXSwgb2xkU3RhdGUpO1xuICB9XG4gIE9iamVjdC5hc3NpZ24oZ2xvYmFsW1NUQVRFX0tFWV0sIHN0YXRlKTtcbiAgdXBkYXRlQWxsU3RhdGVzKCk7XG59XG5mdW5jdGlvbiBvbkRldlRvb2xzQ29ubmVjdGVkKGZuKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGlmIChkZXZ0b29sc1N0YXRlLmNvbm5lY3RlZCkge1xuICAgICAgZm4oKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9XG4gICAgZGV2dG9vbHNDb250ZXh0Lmhvb2tzLmhvb2soXCJkZXZ0b29sc0Nvbm5lY3RlZFVwZGF0ZWRcIiAvKiBERVZUT09MU19DT05ORUNURURfVVBEQVRFRCAqLywgKHsgc3RhdGUgfSkgPT4ge1xuICAgICAgaWYgKHN0YXRlLmNvbm5lY3RlZCkge1xuICAgICAgICBmbigpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxudmFyIHJlc29sdmVJY29uID0gKGljb24pID0+IHtcbiAgaWYgKCFpY29uKVxuICAgIHJldHVybjtcbiAgaWYgKGljb24uc3RhcnRzV2l0aChcImJhc2VsaW5lLVwiKSkge1xuICAgIHJldHVybiBgY3VzdG9tLWljLSR7aWNvbn1gO1xuICB9XG4gIGlmIChpY29uLnN0YXJ0c1dpdGgoXCJpLVwiKSB8fCBpc1VybFN0cmluZyhpY29uKSlcbiAgICByZXR1cm4gaWNvbjtcbiAgcmV0dXJuIGBjdXN0b20taWMtYmFzZWxpbmUtJHtpY29ufWA7XG59O1xuZnVuY3Rpb24gYWRkQ3VzdG9tVGFiKHRhYikge1xuICBjb25zdCB0YWJzID0gZ2xvYmFsLl9fVlVFX0RFVlRPT0xTX0tJVF9DVVNUT01fVEFCU19fO1xuICBpZiAodGFicy5zb21lKCh0KSA9PiB0Lm5hbWUgPT09IHRhYi5uYW1lKSlcbiAgICByZXR1cm47XG4gIHRhYnMucHVzaCh7XG4gICAgLi4udGFiLFxuICAgIGljb246IHJlc29sdmVJY29uKHRhYi5pY29uKVxuICB9KTtcbiAgdXBkYXRlQWxsU3RhdGVzKCk7XG59XG5mdW5jdGlvbiBhZGRDdXN0b21Db21tYW5kKGFjdGlvbikge1xuICBjb25zdCBjb21tYW5kcyA9IGdsb2JhbC5fX1ZVRV9ERVZUT09MU19LSVRfQ1VTVE9NX0NPTU1BTkRTX187XG4gIGlmIChjb21tYW5kcy5zb21lKCh0KSA9PiB0LmlkID09PSBhY3Rpb24uaWQpKVxuICAgIHJldHVybjtcbiAgY29tbWFuZHMucHVzaCh7XG4gICAgLi4uYWN0aW9uLFxuICAgIGljb246IHJlc29sdmVJY29uKGFjdGlvbi5pY29uKSxcbiAgICBjaGlsZHJlbjogYWN0aW9uLmNoaWxkcmVuID8gYWN0aW9uLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+ICh7XG4gICAgICAuLi5jaGlsZCxcbiAgICAgIGljb246IHJlc29sdmVJY29uKGNoaWxkLmljb24pXG4gICAgfSkpIDogdm9pZCAwXG4gIH0pO1xuICB1cGRhdGVBbGxTdGF0ZXMoKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUN1c3RvbUNvbW1hbmQoYWN0aW9uSWQpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBnbG9iYWwuX19WVUVfREVWVE9PTFNfS0lUX0NVU1RPTV9DT01NQU5EU19fO1xuICBjb25zdCBpbmRleCA9IGNvbW1hbmRzLmZpbmRJbmRleCgodCkgPT4gdC5pZCA9PT0gYWN0aW9uSWQpO1xuICBpZiAoaW5kZXggPT09IC0xKVxuICAgIHJldHVybjtcbiAgY29tbWFuZHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgdXBkYXRlQWxsU3RhdGVzKCk7XG59XG5mdW5jdGlvbiB0b2dnbGVDbGllbnRDb25uZWN0ZWQoc3RhdGUpIHtcbiAgdXBkYXRlRGV2VG9vbHNTdGF0ZSh7IGNsaWVudENvbm5lY3RlZDogc3RhdGUgfSk7XG59XG5cbi8vIHNyYy9jb3JlL29wZW4taW4tZWRpdG9yL2luZGV4LnRzXG5mdW5jdGlvbiBzZXRPcGVuSW5FZGl0b3JCYXNlVXJsKHVybCkge1xuICB0YXJnZXQ1Ll9fVlVFX0RFVlRPT0xTX09QRU5fSU5fRURJVE9SX0JBU0VfVVJMX18gPSB1cmw7XG59XG5mdW5jdGlvbiBvcGVuSW5FZGl0b3Iob3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYTI1LCBfYjI1LCBfYztcbiAgY29uc3QgeyBmaWxlLCBob3N0LCBiYXNlVXJsID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbiwgbGluZSA9IDAsIGNvbHVtbiA9IDAgfSA9IG9wdGlvbnM7XG4gIGlmIChmaWxlKSB7XG4gICAgaWYgKGhvc3QgPT09IFwiY2hyb21lLWV4dGVuc2lvblwiKSB7XG4gICAgICBjb25zdCBmaWxlTmFtZSA9IGZpbGUucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpO1xuICAgICAgY29uc3QgX2Jhc2VVcmwgPSAoX2IyNSA9IChfYTI1ID0gd2luZG93LlZVRV9ERVZUT09MU19DT05GSUcpID09IG51bGwgPyB2b2lkIDAgOiBfYTI1Lm9wZW5JbkVkaXRvckhvc3QpICE9IG51bGwgPyBfYjI1IDogXCIvXCI7XG4gICAgICBmZXRjaChgJHtfYmFzZVVybH1fX29wZW4taW4tZWRpdG9yP2ZpbGU9JHtlbmNvZGVVUkkoZmlsZSl9YCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IGBPcGVuaW5nIGNvbXBvbmVudCAke2ZpbGVOYW1lfSBmYWlsZWRgO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGAlYyR7bXNnfWAsIFwiY29sb3I6cmVkXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGRldnRvb2xzU3RhdGUudml0ZVBsdWdpbkRldGVjdGVkKSB7XG4gICAgICBjb25zdCBfYmFzZVVybCA9IChfYyA9IHRhcmdldDUuX19WVUVfREVWVE9PTFNfT1BFTl9JTl9FRElUT1JfQkFTRV9VUkxfXykgIT0gbnVsbCA/IF9jIDogYmFzZVVybDtcbiAgICAgIHRhcmdldDUuX19WVUVfSU5TUEVDVE9SX18ub3BlbkluRWRpdG9yKF9iYXNlVXJsLCBmaWxlLCBsaW5lLCBjb2x1bW4pO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvY29yZS9wbHVnaW4vaW5kZXgudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5pbXBvcnQgeyB0YXJnZXQgYXMgdGFyZ2V0OCB9IGZyb20gXCJAdnVlL2RldnRvb2xzLXNoYXJlZFwiO1xuXG4vLyBzcmMvYXBpL2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyBzcmMvYXBpL3Y2L2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyBzcmMvY29yZS9wbHVnaW4vcGx1Z2luLXNldHRpbmdzLnRzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyBzcmMvY3R4L3BsdWdpbi50c1xuaW5pdF9lc21fc2hpbXMoKTtcbmltcG9ydCB7IHRhcmdldCBhcyB0YXJnZXQ2IH0gZnJvbSBcIkB2dWUvZGV2dG9vbHMtc2hhcmVkXCI7XG52YXIgX2ExMCwgX2IxMDtcbihfYjEwID0gKF9hMTAgPSB0YXJnZXQ2KS5fX1ZVRV9ERVZUT09MU19LSVRfUExVR0lOX0JVRkZFUl9fKSAhPSBudWxsID8gX2IxMCA6IF9hMTAuX19WVUVfREVWVE9PTFNfS0lUX1BMVUdJTl9CVUZGRVJfXyA9IFtdO1xudmFyIGRldnRvb2xzUGx1Z2luQnVmZmVyID0gbmV3IFByb3h5KHRhcmdldDYuX19WVUVfREVWVE9PTFNfS0lUX1BMVUdJTl9CVUZGRVJfXywge1xuICBnZXQodGFyZ2V0MjIsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldDIyLCBwcm9wLCByZWNlaXZlcik7XG4gIH1cbn0pO1xuZnVuY3Rpb24gYWRkRGV2VG9vbHNQbHVnaW5Ub0J1ZmZlcihwbHVnaW5EZXNjcmlwdG9yLCBzZXR1cEZuKSB7XG4gIGRldnRvb2xzUGx1Z2luQnVmZmVyLnB1c2goW3BsdWdpbkRlc2NyaXB0b3IsIHNldHVwRm5dKTtcbn1cblxuLy8gc3JjL2NvcmUvcGx1Z2luL3BsdWdpbi1zZXR0aW5ncy50c1xuZnVuY3Rpb24gX2dldFNldHRpbmdzKHNldHRpbmdzKSB7XG4gIGNvbnN0IF9zZXR0aW5ncyA9IHt9O1xuICBPYmplY3Qua2V5cyhzZXR0aW5ncykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgX3NldHRpbmdzW2tleV0gPSBzZXR0aW5nc1trZXldLmRlZmF1bHRWYWx1ZTtcbiAgfSk7XG4gIHJldHVybiBfc2V0dGluZ3M7XG59XG5mdW5jdGlvbiBnZXRQbHVnaW5Mb2NhbEtleShwbHVnaW5JZCkge1xuICByZXR1cm4gYF9fVlVFX0RFVlRPT0xTX05FWFRfUExVR0lOX1NFVFRJTkdTX18ke3BsdWdpbklkfV9fYDtcbn1cbmZ1bmN0aW9uIGdldFBsdWdpblNldHRpbmdzT3B0aW9ucyhwbHVnaW5JZCkge1xuICB2YXIgX2EyNSwgX2IyNSwgX2M7XG4gIGNvbnN0IGl0ZW0gPSAoX2IyNSA9IChfYTI1ID0gZGV2dG9vbHNQbHVnaW5CdWZmZXIuZmluZCgoaXRlbTIpID0+IHtcbiAgICB2YXIgX2EyNjtcbiAgICByZXR1cm4gaXRlbTJbMF0uaWQgPT09IHBsdWdpbklkICYmICEhKChfYTI2ID0gaXRlbTJbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTI2LnNldHRpbmdzKTtcbiAgfSkpID09IG51bGwgPyB2b2lkIDAgOiBfYTI1WzBdKSAhPSBudWxsID8gX2IyNSA6IG51bGw7XG4gIHJldHVybiAoX2MgPSBpdGVtID09IG51bGwgPyB2b2lkIDAgOiBpdGVtLnNldHRpbmdzKSAhPSBudWxsID8gX2MgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UGx1Z2luU2V0dGluZ3MocGx1Z2luSWQsIGZhbGxiYWNrVmFsdWUpIHtcbiAgdmFyIF9hMjUsIF9iMjUsIF9jO1xuICBjb25zdCBsb2NhbEtleSA9IGdldFBsdWdpbkxvY2FsS2V5KHBsdWdpbklkKTtcbiAgaWYgKGxvY2FsS2V5KSB7XG4gICAgY29uc3QgbG9jYWxTZXR0aW5ncyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGxvY2FsS2V5KTtcbiAgICBpZiAobG9jYWxTZXR0aW5ncykge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UobG9jYWxTZXR0aW5ncyk7XG4gICAgfVxuICB9XG4gIGlmIChwbHVnaW5JZCkge1xuICAgIGNvbnN0IGl0ZW0gPSAoX2IyNSA9IChfYTI1ID0gZGV2dG9vbHNQbHVnaW5CdWZmZXIuZmluZCgoaXRlbTIpID0+IGl0ZW0yWzBdLmlkID09PSBwbHVnaW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfYTI1WzBdKSAhPSBudWxsID8gX2IyNSA6IG51bGw7XG4gICAgcmV0dXJuIF9nZXRTZXR0aW5ncygoX2MgPSBpdGVtID09IG51bGwgPyB2b2lkIDAgOiBpdGVtLnNldHRpbmdzKSAhPSBudWxsID8gX2MgOiB7fSk7XG4gIH1cbiAgcmV0dXJuIF9nZXRTZXR0aW5ncyhmYWxsYmFja1ZhbHVlKTtcbn1cbmZ1bmN0aW9uIGluaXRQbHVnaW5TZXR0aW5ncyhwbHVnaW5JZCwgc2V0dGluZ3MpIHtcbiAgY29uc3QgbG9jYWxLZXkgPSBnZXRQbHVnaW5Mb2NhbEtleShwbHVnaW5JZCk7XG4gIGNvbnN0IGxvY2FsU2V0dGluZ3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShsb2NhbEtleSk7XG4gIGlmICghbG9jYWxTZXR0aW5ncykge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGxvY2FsS2V5LCBKU09OLnN0cmluZ2lmeShfZ2V0U2V0dGluZ3Moc2V0dGluZ3MpKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFBsdWdpblNldHRpbmdzKHBsdWdpbklkLCBrZXksIHZhbHVlKSB7XG4gIGNvbnN0IGxvY2FsS2V5ID0gZ2V0UGx1Z2luTG9jYWxLZXkocGx1Z2luSWQpO1xuICBjb25zdCBsb2NhbFNldHRpbmdzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obG9jYWxLZXkpO1xuICBjb25zdCBwYXJzZWRMb2NhbFNldHRpbmdzID0gSlNPTi5wYXJzZShsb2NhbFNldHRpbmdzIHx8IFwie31cIik7XG4gIGNvbnN0IHVwZGF0ZWQgPSB7XG4gICAgLi4ucGFyc2VkTG9jYWxTZXR0aW5ncyxcbiAgICBba2V5XTogdmFsdWVcbiAgfTtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obG9jYWxLZXksIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWQpKTtcbiAgZGV2dG9vbHNDb250ZXh0Lmhvb2tzLmNhbGxIb29rV2l0aCgoY2FsbGJhY2tzKSA9PiB7XG4gICAgY2FsbGJhY2tzLmZvckVhY2goKGNiKSA9PiBjYih7XG4gICAgICBwbHVnaW5JZCxcbiAgICAgIGtleSxcbiAgICAgIG9sZFZhbHVlOiBwYXJzZWRMb2NhbFNldHRpbmdzW2tleV0sXG4gICAgICBuZXdWYWx1ZTogdmFsdWUsXG4gICAgICBzZXR0aW5nczogdXBkYXRlZFxuICAgIH0pKTtcbiAgfSwgXCJzZXRQbHVnaW5TZXR0aW5nc1wiIC8qIFNFVF9QTFVHSU5fU0VUVElOR1MgKi8pO1xufVxuXG4vLyBzcmMvaG9vay9pbmRleC50c1xuaW5pdF9lc21fc2hpbXMoKTtcbmltcG9ydCB7IHRhcmdldCBhcyB0YXJnZXQ3IH0gZnJvbSBcIkB2dWUvZGV2dG9vbHMtc2hhcmVkXCI7XG5pbXBvcnQgeyBjcmVhdGVIb29rcyBhcyBjcmVhdGVIb29rczIgfSBmcm9tIFwiaG9va2FibGVcIjtcblxuLy8gc3JjL3R5cGVzL2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyBzcmMvdHlwZXMvYXBwLnRzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyBzcmMvdHlwZXMvY29tbWFuZC50c1xuaW5pdF9lc21fc2hpbXMoKTtcblxuLy8gc3JjL3R5cGVzL2NvbXBvbmVudC50c1xuaW5pdF9lc21fc2hpbXMoKTtcblxuLy8gc3JjL3R5cGVzL2hvb2sudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy90eXBlcy9pbnNwZWN0b3IudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy90eXBlcy9wbHVnaW4udHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy90eXBlcy9yb3V0ZXIudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy90eXBlcy90YWIudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy90eXBlcy90aW1lbGluZS50c1xuaW5pdF9lc21fc2hpbXMoKTtcblxuLy8gc3JjL2hvb2svaW5kZXgudHNcbnZhciBfYTExLCBfYjExO1xudmFyIGRldnRvb2xzSG9va3MgPSAoX2IxMSA9IChfYTExID0gdGFyZ2V0NykuX19WVUVfREVWVE9PTFNfSE9PSykgIT0gbnVsbCA/IF9iMTEgOiBfYTExLl9fVlVFX0RFVlRPT0xTX0hPT0sgPSBjcmVhdGVIb29rczIoKTtcbnZhciBvbiA9IHtcbiAgdnVlQXBwSW5pdChmbikge1xuICAgIGRldnRvb2xzSG9va3MuaG9vayhcImFwcDppbml0XCIgLyogQVBQX0lOSVQgKi8sIGZuKTtcbiAgfSxcbiAgdnVlQXBwVW5tb3VudChmbikge1xuICAgIGRldnRvb2xzSG9va3MuaG9vayhcImFwcDp1bm1vdW50XCIgLyogQVBQX1VOTU9VTlQgKi8sIGZuKTtcbiAgfSxcbiAgdnVlQXBwQ29ubmVjdGVkKGZuKSB7XG4gICAgZGV2dG9vbHNIb29rcy5ob29rKFwiYXBwOmNvbm5lY3RlZFwiIC8qIEFQUF9DT05ORUNURUQgKi8sIGZuKTtcbiAgfSxcbiAgY29tcG9uZW50QWRkZWQoZm4pIHtcbiAgICByZXR1cm4gZGV2dG9vbHNIb29rcy5ob29rKFwiY29tcG9uZW50OmFkZGVkXCIgLyogQ09NUE9ORU5UX0FEREVEICovLCBmbik7XG4gIH0sXG4gIGNvbXBvbmVudEVtaXQoZm4pIHtcbiAgICByZXR1cm4gZGV2dG9vbHNIb29rcy5ob29rKFwiY29tcG9uZW50OmVtaXRcIiAvKiBDT01QT05FTlRfRU1JVCAqLywgZm4pO1xuICB9LFxuICBjb21wb25lbnRVcGRhdGVkKGZuKSB7XG4gICAgcmV0dXJuIGRldnRvb2xzSG9va3MuaG9vayhcImNvbXBvbmVudDp1cGRhdGVkXCIgLyogQ09NUE9ORU5UX1VQREFURUQgKi8sIGZuKTtcbiAgfSxcbiAgY29tcG9uZW50UmVtb3ZlZChmbikge1xuICAgIHJldHVybiBkZXZ0b29sc0hvb2tzLmhvb2soXCJjb21wb25lbnQ6cmVtb3ZlZFwiIC8qIENPTVBPTkVOVF9SRU1PVkVEICovLCBmbik7XG4gIH0sXG4gIHNldHVwRGV2dG9vbHNQbHVnaW4oZm4pIHtcbiAgICBkZXZ0b29sc0hvb2tzLmhvb2soXCJkZXZ0b29scy1wbHVnaW46c2V0dXBcIiAvKiBTRVRVUF9ERVZUT09MU19QTFVHSU4gKi8sIGZuKTtcbiAgfSxcbiAgcGVyZlN0YXJ0KGZuKSB7XG4gICAgcmV0dXJuIGRldnRvb2xzSG9va3MuaG9vayhcInBlcmY6c3RhcnRcIiAvKiBQRVJGT1JNQU5DRV9TVEFSVCAqLywgZm4pO1xuICB9LFxuICBwZXJmRW5kKGZuKSB7XG4gICAgcmV0dXJuIGRldnRvb2xzSG9va3MuaG9vayhcInBlcmY6ZW5kXCIgLyogUEVSRk9STUFOQ0VfRU5EICovLCBmbik7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVEZXZUb29sc0hvb2soKSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IFwidnVlLWRldnRvb2xzLW5leHRcIixcbiAgICBkZXZ0b29sc1ZlcnNpb246IFwiNy4wXCIsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgYXBwUmVjb3JkczogW10sXG4gICAgYXBwczogW10sXG4gICAgZXZlbnRzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIG9uKGV2ZW50LCBmbikge1xuICAgICAgdmFyIF9hMjU7XG4gICAgICBpZiAoIXRoaXMuZXZlbnRzLmhhcyhldmVudCkpXG4gICAgICAgIHRoaXMuZXZlbnRzLnNldChldmVudCwgW10pO1xuICAgICAgKF9hMjUgPSB0aGlzLmV2ZW50cy5nZXQoZXZlbnQpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyNS5wdXNoKGZuKTtcbiAgICAgIHJldHVybiAoKSA9PiB0aGlzLm9mZihldmVudCwgZm4pO1xuICAgIH0sXG4gICAgb25jZShldmVudCwgZm4pIHtcbiAgICAgIGNvbnN0IG9uY2VGbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKGV2ZW50LCBvbmNlRm4pO1xuICAgICAgICBmbiguLi5hcmdzKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uKGV2ZW50LCBvbmNlRm4pO1xuICAgICAgcmV0dXJuIFtldmVudCwgb25jZUZuXTtcbiAgICB9LFxuICAgIG9mZihldmVudCwgZm4pIHtcbiAgICAgIGlmICh0aGlzLmV2ZW50cy5oYXMoZXZlbnQpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50Q2FsbGJhY2tzID0gdGhpcy5ldmVudHMuZ2V0KGV2ZW50KTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBldmVudENhbGxiYWNrcy5pbmRleE9mKGZuKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICBldmVudENhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW1pdChldmVudCwgLi4ucGF5bG9hZCkge1xuICAgICAgaWYgKHRoaXMuZXZlbnRzLmhhcyhldmVudCkpXG4gICAgICAgIHRoaXMuZXZlbnRzLmdldChldmVudCkuZm9yRWFjaCgoZm4pID0+IGZuKC4uLnBheWxvYWQpKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzdWJzY3JpYmVEZXZUb29sc0hvb2soaG9vazIpIHtcbiAgaG9vazIub24oXCJhcHA6aW5pdFwiIC8qIEFQUF9JTklUICovLCAoYXBwLCB2ZXJzaW9uLCB0eXBlcykgPT4ge1xuICAgIHZhciBfYTI1LCBfYjI1LCBfYztcbiAgICBpZiAoKF9jID0gKF9iMjUgPSAoX2EyNSA9IGFwcCA9PSBudWxsID8gdm9pZCAwIDogYXBwLl9pbnN0YW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjUudHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMjUuZGV2dG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYy5oaWRlKVxuICAgICAgcmV0dXJuO1xuICAgIGRldnRvb2xzSG9va3MuY2FsbEhvb2soXCJhcHA6aW5pdFwiIC8qIEFQUF9JTklUICovLCBhcHAsIHZlcnNpb24sIHR5cGVzKTtcbiAgfSk7XG4gIGhvb2syLm9uKFwiYXBwOnVubW91bnRcIiAvKiBBUFBfVU5NT1VOVCAqLywgKGFwcCkgPT4ge1xuICAgIGRldnRvb2xzSG9va3MuY2FsbEhvb2soXCJhcHA6dW5tb3VudFwiIC8qIEFQUF9VTk1PVU5UICovLCBhcHApO1xuICB9KTtcbiAgaG9vazIub24oXCJjb21wb25lbnQ6YWRkZWRcIiAvKiBDT01QT05FTlRfQURERUQgKi8sIGFzeW5jIChhcHAsIHVpZCwgcGFyZW50VWlkLCBjb21wb25lbnQpID0+IHtcbiAgICB2YXIgX2EyNSwgX2IyNSwgX2M7XG4gICAgaWYgKCgoX2MgPSAoX2IyNSA9IChfYTI1ID0gYXBwID09IG51bGwgPyB2b2lkIDAgOiBhcHAuX2luc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyNS50eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2IyNS5kZXZ0b29scykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmhpZGUpIHx8IGRldnRvb2xzU3RhdGUuaGlnaFBlcmZNb2RlRW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIWFwcCB8fCB0eXBlb2YgdWlkICE9PSBcIm51bWJlclwiICYmICF1aWQgfHwgIWNvbXBvbmVudClcbiAgICAgIHJldHVybjtcbiAgICBkZXZ0b29sc0hvb2tzLmNhbGxIb29rKFwiY29tcG9uZW50OmFkZGVkXCIgLyogQ09NUE9ORU5UX0FEREVEICovLCBhcHAsIHVpZCwgcGFyZW50VWlkLCBjb21wb25lbnQpO1xuICB9KTtcbiAgaG9vazIub24oXCJjb21wb25lbnQ6dXBkYXRlZFwiIC8qIENPTVBPTkVOVF9VUERBVEVEICovLCAoYXBwLCB1aWQsIHBhcmVudFVpZCwgY29tcG9uZW50KSA9PiB7XG4gICAgaWYgKCFhcHAgfHwgdHlwZW9mIHVpZCAhPT0gXCJudW1iZXJcIiAmJiAhdWlkIHx8ICFjb21wb25lbnQgfHwgZGV2dG9vbHNTdGF0ZS5oaWdoUGVyZk1vZGVFbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGRldnRvb2xzSG9va3MuY2FsbEhvb2soXCJjb21wb25lbnQ6dXBkYXRlZFwiIC8qIENPTVBPTkVOVF9VUERBVEVEICovLCBhcHAsIHVpZCwgcGFyZW50VWlkLCBjb21wb25lbnQpO1xuICB9KTtcbiAgaG9vazIub24oXCJjb21wb25lbnQ6cmVtb3ZlZFwiIC8qIENPTVBPTkVOVF9SRU1PVkVEICovLCBhc3luYyAoYXBwLCB1aWQsIHBhcmVudFVpZCwgY29tcG9uZW50KSA9PiB7XG4gICAgaWYgKCFhcHAgfHwgdHlwZW9mIHVpZCAhPT0gXCJudW1iZXJcIiAmJiAhdWlkIHx8ICFjb21wb25lbnQgfHwgZGV2dG9vbHNTdGF0ZS5oaWdoUGVyZk1vZGVFbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGRldnRvb2xzSG9va3MuY2FsbEhvb2soXCJjb21wb25lbnQ6cmVtb3ZlZFwiIC8qIENPTVBPTkVOVF9SRU1PVkVEICovLCBhcHAsIHVpZCwgcGFyZW50VWlkLCBjb21wb25lbnQpO1xuICB9KTtcbiAgaG9vazIub24oXCJjb21wb25lbnQ6ZW1pdFwiIC8qIENPTVBPTkVOVF9FTUlUICovLCBhc3luYyAoYXBwLCBpbnN0YW5jZSwgZXZlbnQsIHBhcmFtcykgPT4ge1xuICAgIGlmICghYXBwIHx8ICFpbnN0YW5jZSB8fCBkZXZ0b29sc1N0YXRlLmhpZ2hQZXJmTW9kZUVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgZGV2dG9vbHNIb29rcy5jYWxsSG9vayhcImNvbXBvbmVudDplbWl0XCIgLyogQ09NUE9ORU5UX0VNSVQgKi8sIGFwcCwgaW5zdGFuY2UsIGV2ZW50LCBwYXJhbXMpO1xuICB9KTtcbiAgaG9vazIub24oXCJwZXJmOnN0YXJ0XCIgLyogUEVSRk9STUFOQ0VfU1RBUlQgKi8sIChhcHAsIHVpZCwgdm0sIHR5cGUsIHRpbWUpID0+IHtcbiAgICBpZiAoIWFwcCB8fCBkZXZ0b29sc1N0YXRlLmhpZ2hQZXJmTW9kZUVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgZGV2dG9vbHNIb29rcy5jYWxsSG9vayhcInBlcmY6c3RhcnRcIiAvKiBQRVJGT1JNQU5DRV9TVEFSVCAqLywgYXBwLCB1aWQsIHZtLCB0eXBlLCB0aW1lKTtcbiAgfSk7XG4gIGhvb2syLm9uKFwicGVyZjplbmRcIiAvKiBQRVJGT1JNQU5DRV9FTkQgKi8sIChhcHAsIHVpZCwgdm0sIHR5cGUsIHRpbWUpID0+IHtcbiAgICBpZiAoIWFwcCB8fCBkZXZ0b29sc1N0YXRlLmhpZ2hQZXJmTW9kZUVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgZGV2dG9vbHNIb29rcy5jYWxsSG9vayhcInBlcmY6ZW5kXCIgLyogUEVSRk9STUFOQ0VfRU5EICovLCBhcHAsIHVpZCwgdm0sIHR5cGUsIHRpbWUpO1xuICB9KTtcbiAgaG9vazIub24oXCJkZXZ0b29scy1wbHVnaW46c2V0dXBcIiAvKiBTRVRVUF9ERVZUT09MU19QTFVHSU4gKi8sIChwbHVnaW5EZXNjcmlwdG9yLCBzZXR1cEZuLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRhcmdldCkgPT09IFwibGVnYWN5XCIpXG4gICAgICByZXR1cm47XG4gICAgZGV2dG9vbHNIb29rcy5jYWxsSG9vayhcImRldnRvb2xzLXBsdWdpbjpzZXR1cFwiIC8qIFNFVFVQX0RFVlRPT0xTX1BMVUdJTiAqLywgcGx1Z2luRGVzY3JpcHRvciwgc2V0dXBGbik7XG4gIH0pO1xufVxudmFyIGhvb2sgPSB7XG4gIG9uLFxuICBzZXR1cERldlRvb2xzUGx1Z2luKHBsdWdpbkRlc2NyaXB0b3IsIHNldHVwRm4pIHtcbiAgICByZXR1cm4gZGV2dG9vbHNIb29rcy5jYWxsSG9vayhcImRldnRvb2xzLXBsdWdpbjpzZXR1cFwiIC8qIFNFVFVQX0RFVlRPT0xTX1BMVUdJTiAqLywgcGx1Z2luRGVzY3JpcHRvciwgc2V0dXBGbik7XG4gIH1cbn07XG5cbi8vIHNyYy9hcGkvdjYvaW5kZXgudHNcbnZhciBEZXZUb29sc1Y2UGx1Z2luQVBJID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7IHBsdWdpbiwgY3R4IH0pIHtcbiAgICB0aGlzLmhvb2tzID0gY3R4Lmhvb2tzO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICB9XG4gIGdldCBvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gY29tcG9uZW50IGluc3BlY3RvclxuICAgICAgdmlzaXRDb21wb25lbnRUcmVlOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLmhvb2tzLmhvb2soXCJ2aXNpdENvbXBvbmVudFRyZWVcIiAvKiBWSVNJVF9DT01QT05FTlRfVFJFRSAqLywgaGFuZGxlcik7XG4gICAgICB9LFxuICAgICAgaW5zcGVjdENvbXBvbmVudDogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy5ob29rcy5ob29rKFwiaW5zcGVjdENvbXBvbmVudFwiIC8qIElOU1BFQ1RfQ09NUE9ORU5UICovLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBlZGl0Q29tcG9uZW50U3RhdGU6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuaG9va3MuaG9vayhcImVkaXRDb21wb25lbnRTdGF0ZVwiIC8qIEVESVRfQ09NUE9ORU5UX1NUQVRFICovLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICAvLyBjdXN0b20gaW5zcGVjdG9yXG4gICAgICBnZXRJbnNwZWN0b3JUcmVlOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLmhvb2tzLmhvb2soXCJnZXRJbnNwZWN0b3JUcmVlXCIgLyogR0VUX0lOU1BFQ1RPUl9UUkVFICovLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBnZXRJbnNwZWN0b3JTdGF0ZTogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy5ob29rcy5ob29rKFwiZ2V0SW5zcGVjdG9yU3RhdGVcIiAvKiBHRVRfSU5TUEVDVE9SX1NUQVRFICovLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBlZGl0SW5zcGVjdG9yU3RhdGU6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuaG9va3MuaG9vayhcImVkaXRJbnNwZWN0b3JTdGF0ZVwiIC8qIEVESVRfSU5TUEVDVE9SX1NUQVRFICovLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICAvLyB0aW1lbGluZVxuICAgICAgaW5zcGVjdFRpbWVsaW5lRXZlbnQ6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuaG9va3MuaG9vayhcImluc3BlY3RUaW1lbGluZUV2ZW50XCIgLyogSU5TUEVDVF9USU1FTElORV9FVkVOVCAqLywgaGFuZGxlcik7XG4gICAgICB9LFxuICAgICAgdGltZWxpbmVDbGVhcmVkOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLmhvb2tzLmhvb2soXCJ0aW1lbGluZUNsZWFyZWRcIiAvKiBUSU1FTElORV9DTEVBUkVEICovLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICAvLyBzZXR0aW5nc1xuICAgICAgc2V0UGx1Z2luU2V0dGluZ3M6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuaG9va3MuaG9vayhcInNldFBsdWdpblNldHRpbmdzXCIgLyogU0VUX1BMVUdJTl9TRVRUSU5HUyAqLywgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvLyBjb21wb25lbnQgaW5zcGVjdG9yXG4gIG5vdGlmeUNvbXBvbmVudFVwZGF0ZShpbnN0YW5jZSkge1xuICAgIHZhciBfYTI1O1xuICAgIGlmIChkZXZ0b29sc1N0YXRlLmhpZ2hQZXJmTW9kZUVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5zcGVjdG9yID0gZ2V0QWN0aXZlSW5zcGVjdG9ycygpLmZpbmQoKGkpID0+IGkucGFja2FnZU5hbWUgPT09IHRoaXMucGx1Z2luLmRlc2NyaXB0b3IucGFja2FnZU5hbWUpO1xuICAgIGlmIChpbnNwZWN0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3BlY3Rvci5pZCkge1xuICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5hcHAsXG4gICAgICAgICAgaW5zdGFuY2UudWlkLFxuICAgICAgICAgIChfYTI1ID0gaW5zdGFuY2UucGFyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyNS51aWQsXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgXTtcbiAgICAgICAgZGV2dG9vbHNIb29rcy5jYWxsSG9vayhcImNvbXBvbmVudDp1cGRhdGVkXCIgLyogQ09NUE9ORU5UX1VQREFURUQgKi8sIC4uLmFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGV2dG9vbHNIb29rcy5jYWxsSG9vayhcImNvbXBvbmVudDp1cGRhdGVkXCIgLyogQ09NUE9ORU5UX1VQREFURUQgKi8pO1xuICAgICAgfVxuICAgICAgdGhpcy5ob29rcy5jYWxsSG9vayhcInNlbmRJbnNwZWN0b3JTdGF0ZVwiIC8qIFNFTkRfSU5TUEVDVE9SX1NUQVRFICovLCB7IGluc3BlY3RvcklkOiBpbnNwZWN0b3IuaWQsIHBsdWdpbjogdGhpcy5wbHVnaW4gfSk7XG4gICAgfVxuICB9XG4gIC8vIGN1c3RvbSBpbnNwZWN0b3JcbiAgYWRkSW5zcGVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmhvb2tzLmNhbGxIb29rKFwiYWRkSW5zcGVjdG9yXCIgLyogQUREX0lOU1BFQ1RPUiAqLywgeyBpbnNwZWN0b3I6IG9wdGlvbnMsIHBsdWdpbjogdGhpcy5wbHVnaW4gfSk7XG4gICAgaWYgKHRoaXMucGx1Z2luLmRlc2NyaXB0b3Iuc2V0dGluZ3MpIHtcbiAgICAgIGluaXRQbHVnaW5TZXR0aW5ncyhvcHRpb25zLmlkLCB0aGlzLnBsdWdpbi5kZXNjcmlwdG9yLnNldHRpbmdzKTtcbiAgICB9XG4gIH1cbiAgc2VuZEluc3BlY3RvclRyZWUoaW5zcGVjdG9ySWQpIHtcbiAgICBpZiAoZGV2dG9vbHNTdGF0ZS5oaWdoUGVyZk1vZGVFbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaG9va3MuY2FsbEhvb2soXCJzZW5kSW5zcGVjdG9yVHJlZVwiIC8qIFNFTkRfSU5TUEVDVE9SX1RSRUUgKi8sIHsgaW5zcGVjdG9ySWQsIHBsdWdpbjogdGhpcy5wbHVnaW4gfSk7XG4gIH1cbiAgc2VuZEluc3BlY3RvclN0YXRlKGluc3BlY3RvcklkKSB7XG4gICAgaWYgKGRldnRvb2xzU3RhdGUuaGlnaFBlcmZNb2RlRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhvb2tzLmNhbGxIb29rKFwic2VuZEluc3BlY3RvclN0YXRlXCIgLyogU0VORF9JTlNQRUNUT1JfU1RBVEUgKi8sIHsgaW5zcGVjdG9ySWQsIHBsdWdpbjogdGhpcy5wbHVnaW4gfSk7XG4gIH1cbiAgc2VsZWN0SW5zcGVjdG9yTm9kZShpbnNwZWN0b3JJZCwgbm9kZUlkKSB7XG4gICAgdGhpcy5ob29rcy5jYWxsSG9vayhcImN1c3RvbUluc3BlY3RvclNlbGVjdE5vZGVcIiAvKiBDVVNUT01fSU5TUEVDVE9SX1NFTEVDVF9OT0RFICovLCB7IGluc3BlY3RvcklkLCBub2RlSWQsIHBsdWdpbjogdGhpcy5wbHVnaW4gfSk7XG4gIH1cbiAgdmlzaXRDb21wb25lbnRUcmVlKHBheWxvYWQpIHtcbiAgICByZXR1cm4gdGhpcy5ob29rcy5jYWxsSG9vayhcInZpc2l0Q29tcG9uZW50VHJlZVwiIC8qIFZJU0lUX0NPTVBPTkVOVF9UUkVFICovLCBwYXlsb2FkKTtcbiAgfVxuICAvLyB0aW1lbGluZVxuICBub3coKSB7XG4gICAgaWYgKGRldnRvb2xzU3RhdGUuaGlnaFBlcmZNb2RlRW5hYmxlZCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9XG4gIGFkZFRpbWVsaW5lTGF5ZXIob3B0aW9ucykge1xuICAgIHRoaXMuaG9va3MuY2FsbEhvb2soXCJ0aW1lbGluZUxheWVyQWRkZWRcIiAvKiBUSU1FTElORV9MQVlFUl9BRERFRCAqLywgeyBvcHRpb25zLCBwbHVnaW46IHRoaXMucGx1Z2luIH0pO1xuICB9XG4gIGFkZFRpbWVsaW5lRXZlbnQob3B0aW9ucykge1xuICAgIGlmIChkZXZ0b29sc1N0YXRlLmhpZ2hQZXJmTW9kZUVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ob29rcy5jYWxsSG9vayhcInRpbWVsaW5lRXZlbnRBZGRlZFwiIC8qIFRJTUVMSU5FX0VWRU5UX0FEREVEICovLCB7IG9wdGlvbnMsIHBsdWdpbjogdGhpcy5wbHVnaW4gfSk7XG4gIH1cbiAgLy8gc2V0dGluZ3NcbiAgZ2V0U2V0dGluZ3MocGx1Z2luSWQpIHtcbiAgICByZXR1cm4gZ2V0UGx1Z2luU2V0dGluZ3MocGx1Z2luSWQgIT0gbnVsbCA/IHBsdWdpbklkIDogdGhpcy5wbHVnaW4uZGVzY3JpcHRvci5pZCwgdGhpcy5wbHVnaW4uZGVzY3JpcHRvci5zZXR0aW5ncyk7XG4gIH1cbiAgLy8gdXRpbGl0aWVzXG4gIGdldENvbXBvbmVudEluc3RhbmNlcyhhcHApIHtcbiAgICByZXR1cm4gdGhpcy5ob29rcy5jYWxsSG9vayhcImdldENvbXBvbmVudEluc3RhbmNlc1wiIC8qIEdFVF9DT01QT05FTlRfSU5TVEFOQ0VTICovLCB7IGFwcCB9KTtcbiAgfVxuICBnZXRDb21wb25lbnRCb3VuZHMoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gdGhpcy5ob29rcy5jYWxsSG9vayhcImdldENvbXBvbmVudEJvdW5kc1wiIC8qIEdFVF9DT01QT05FTlRfQk9VTkRTICovLCB7IGluc3RhbmNlIH0pO1xuICB9XG4gIGdldENvbXBvbmVudE5hbWUoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gdGhpcy5ob29rcy5jYWxsSG9vayhcImdldENvbXBvbmVudE5hbWVcIiAvKiBHRVRfQ09NUE9ORU5UX05BTUUgKi8sIHsgaW5zdGFuY2UgfSk7XG4gIH1cbiAgaGlnaGxpZ2h0RWxlbWVudChpbnN0YW5jZSkge1xuICAgIGNvbnN0IHVpZCA9IGluc3RhbmNlLl9fVlVFX0RFVlRPT0xTX05FWFRfVUlEX187XG4gICAgcmV0dXJuIHRoaXMuaG9va3MuY2FsbEhvb2soXCJjb21wb25lbnRIaWdobGlnaHRcIiAvKiBDT01QT05FTlRfSElHSExJR0hUICovLCB7IHVpZCB9KTtcbiAgfVxuICB1bmhpZ2hsaWdodEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9va3MuY2FsbEhvb2soXCJjb21wb25lbnRVbmhpZ2hsaWdodFwiIC8qIENPTVBPTkVOVF9VTkhJR0hMSUdIVCAqLyk7XG4gIH1cbn07XG5cbi8vIHNyYy9hcGkvaW5kZXgudHNcbnZhciBEZXZUb29sc1BsdWdpbkFQSSA9IERldlRvb2xzVjZQbHVnaW5BUEk7XG5cbi8vIHNyYy9jb3JlL3BsdWdpbi9jb21wb25lbnRzLnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgZGVib3VuY2UgYXMgZGVib3VuY2U0IH0gZnJvbSBcInBlcmZlY3QtZGVib3VuY2VcIjtcblxuLy8gc3JjL2NvcmUvY29tcG9uZW50L3N0YXRlL2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyBzcmMvY29yZS9jb21wb25lbnQvc3RhdGUvcHJvY2Vzcy50c1xuaW5pdF9lc21fc2hpbXMoKTtcbmltcG9ydCB7IGNhbWVsaXplIH0gZnJvbSBcIkB2dWUvZGV2dG9vbHMtc2hhcmVkXCI7XG5cbi8vIHNyYy9jb3JlL2NvbXBvbmVudC9zdGF0ZS9jb25zdGFudHMudHNcbmluaXRfZXNtX3NoaW1zKCk7XG52YXIgdnVlQnVpbHRpbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwibmV4dFRpY2tcIixcbiAgXCJkZWZpbmVDb21wb25lbnRcIixcbiAgXCJkZWZpbmVBc3luY0NvbXBvbmVudFwiLFxuICBcImRlZmluZUN1c3RvbUVsZW1lbnRcIixcbiAgXCJyZWZcIixcbiAgXCJjb21wdXRlZFwiLFxuICBcInJlYWN0aXZlXCIsXG4gIFwicmVhZG9ubHlcIixcbiAgXCJ3YXRjaEVmZmVjdFwiLFxuICBcIndhdGNoUG9zdEVmZmVjdFwiLFxuICBcIndhdGNoU3luY0VmZmVjdFwiLFxuICBcIndhdGNoXCIsXG4gIFwiaXNSZWZcIixcbiAgXCJ1bnJlZlwiLFxuICBcInRvUmVmXCIsXG4gIFwidG9SZWZzXCIsXG4gIFwiaXNQcm94eVwiLFxuICBcImlzUmVhY3RpdmVcIixcbiAgXCJpc1JlYWRvbmx5XCIsXG4gIFwic2hhbGxvd1JlZlwiLFxuICBcInRyaWdnZXJSZWZcIixcbiAgXCJjdXN0b21SZWZcIixcbiAgXCJzaGFsbG93UmVhY3RpdmVcIixcbiAgXCJzaGFsbG93UmVhZG9ubHlcIixcbiAgXCJ0b1Jhd1wiLFxuICBcIm1hcmtSYXdcIixcbiAgXCJlZmZlY3RTY29wZVwiLFxuICBcImdldEN1cnJlbnRTY29wZVwiLFxuICBcIm9uU2NvcGVEaXNwb3NlXCIsXG4gIFwib25Nb3VudGVkXCIsXG4gIFwib25VcGRhdGVkXCIsXG4gIFwib25Vbm1vdW50ZWRcIixcbiAgXCJvbkJlZm9yZU1vdW50XCIsXG4gIFwib25CZWZvcmVVcGRhdGVcIixcbiAgXCJvbkJlZm9yZVVubW91bnRcIixcbiAgXCJvbkVycm9yQ2FwdHVyZWRcIixcbiAgXCJvblJlbmRlclRyYWNrZWRcIixcbiAgXCJvblJlbmRlclRyaWdnZXJlZFwiLFxuICBcIm9uQWN0aXZhdGVkXCIsXG4gIFwib25EZWFjdGl2YXRlZFwiLFxuICBcIm9uU2VydmVyUHJlZmV0Y2hcIixcbiAgXCJwcm92aWRlXCIsXG4gIFwiaW5qZWN0XCIsXG4gIFwiaFwiLFxuICBcIm1lcmdlUHJvcHNcIixcbiAgXCJjbG9uZVZOb2RlXCIsXG4gIFwiaXNWTm9kZVwiLFxuICBcInJlc29sdmVDb21wb25lbnRcIixcbiAgXCJyZXNvbHZlRGlyZWN0aXZlXCIsXG4gIFwid2l0aERpcmVjdGl2ZXNcIixcbiAgXCJ3aXRoTW9kaWZpZXJzXCJcbl0pO1xudmFyIHN5bWJvbFJFID0gL15cXFtuYXRpdmUgU3ltYm9sIFN5bWJvbFxcKCguKilcXClcXF0kLztcbnZhciByYXdUeXBlUkUgPSAvXlxcW29iamVjdCAoXFx3KylcXF0kLztcbnZhciBzcGVjaWFsVHlwZVJFID0gL15cXFtuYXRpdmUgKFxcdyspICguKj8pKDw+KChbXFxzXFxTXSkqKSk/XFxdJC87XG52YXIgZm5UeXBlUkUgPSAvXig/OmZ1bmN0aW9ufGNsYXNzKSAoXFx3KykvO1xudmFyIE1BWF9TVFJJTkdfU0laRSA9IDFlNDtcbnZhciBNQVhfQVJSQVlfU0laRSA9IDVlMztcbnZhciBVTkRFRklORUQgPSBcIl9fdnVlX2RldnRvb2xfdW5kZWZpbmVkX19cIjtcbnZhciBJTkZJTklUWSA9IFwiX192dWVfZGV2dG9vbF9pbmZpbml0eV9fXCI7XG52YXIgTkVHQVRJVkVfSU5GSU5JVFkgPSBcIl9fdnVlX2RldnRvb2xfbmVnYXRpdmVfaW5maW5pdHlfX1wiO1xudmFyIE5BTiA9IFwiX192dWVfZGV2dG9vbF9uYW5fX1wiO1xudmFyIEVTQyA9IHtcbiAgXCI8XCI6IFwiJmx0O1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gICdcIic6IFwiJnF1b3Q7XCIsXG4gIFwiJlwiOiBcIiZhbXA7XCJcbn07XG5cbi8vIHNyYy9jb3JlL2NvbXBvbmVudC9zdGF0ZS91dGlsLnRzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyBzcmMvY29yZS9jb21wb25lbnQvc3RhdGUvaXMudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5mdW5jdGlvbiBpc1Z1ZUluc3RhbmNlKHZhbHVlKSB7XG4gIGlmICghZW5zdXJlUHJvcGVydHlFeGlzdHModmFsdWUsIFwiX1wiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUuXykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlLl8pLmluY2x1ZGVzKFwidm5vZGVcIik7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShkYXRhKSB7XG4gIGlmIChkYXRhID09IG51bGwpXG4gICAgcmV0dXJuIHRydWU7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgZGF0YTtcbiAgcmV0dXJuIHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGlzUmVmMihyYXcpIHtcbiAgcmV0dXJuICEhcmF3Ll9fdl9pc1JlZjtcbn1cbmZ1bmN0aW9uIGlzQ29tcHV0ZWQocmF3KSB7XG4gIHJldHVybiBpc1JlZjIocmF3KSAmJiAhIXJhdy5lZmZlY3Q7XG59XG5mdW5jdGlvbiBpc1JlYWN0aXZlMihyYXcpIHtcbiAgcmV0dXJuICEhcmF3Ll9fdl9pc1JlYWN0aXZlO1xufVxuZnVuY3Rpb24gaXNSZWFkT25seShyYXcpIHtcbiAgcmV0dXJuICEhcmF3Ll9fdl9pc1JlYWRvbmx5O1xufVxuXG4vLyBzcmMvY29yZS9jb21wb25lbnQvc3RhdGUvdXRpbC50c1xudmFyIHRva2VuTWFwID0ge1xuICBbVU5ERUZJTkVEXTogXCJ1bmRlZmluZWRcIixcbiAgW05BTl06IFwiTmFOXCIsXG4gIFtJTkZJTklUWV06IFwiSW5maW5pdHlcIixcbiAgW05FR0FUSVZFX0lORklOSVRZXTogXCItSW5maW5pdHlcIlxufTtcbnZhciByZXZlcnNlZFRva2VuTWFwID0gT2JqZWN0LmVudHJpZXModG9rZW5NYXApLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgYWNjW3ZhbHVlXSA9IGtleTtcbiAgcmV0dXJuIGFjYztcbn0sIHt9KTtcbmZ1bmN0aW9uIGludGVybmFsU3RhdGVUb2tlblRvU3RyaW5nKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdG9rZW5NYXBbdmFsdWVdIHx8IGZhbHNlO1xufVxuZnVuY3Rpb24gcmVwbGFjZVRva2VuVG9TdHJpbmcodmFsdWUpIHtcbiAgY29uc3QgcmVwbGFjZVJlZ2V4ID0gbmV3IFJlZ0V4cChgXCIoJHtPYmplY3Qua2V5cyh0b2tlbk1hcCkuam9pbihcInxcIil9KVwiYCwgXCJnXCIpO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZXBsYWNlUmVnZXgsIChfLCBnMSkgPT4gdG9rZW5NYXBbZzFdKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VTdHJpbmdUb1Rva2VuKHZhbHVlKSB7XG4gIGNvbnN0IGxpdGVyYWxWYWx1ZSA9IHJldmVyc2VkVG9rZW5NYXBbdmFsdWUudHJpbSgpXTtcbiAgaWYgKGxpdGVyYWxWYWx1ZSlcbiAgICByZXR1cm4gYFwiJHtsaXRlcmFsVmFsdWV9XCJgO1xuICBjb25zdCByZXBsYWNlUmVnZXggPSBuZXcgUmVnRXhwKGA6XFxcXHMqKCR7T2JqZWN0LmtleXMocmV2ZXJzZWRUb2tlbk1hcCkuam9pbihcInxcIil9KWAsIFwiZ1wiKTtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmVwbGFjZVJlZ2V4LCAoXywgZzEpID0+IGA6XCIke3JldmVyc2VkVG9rZW5NYXBbZzFdfVwiYCk7XG59XG5mdW5jdGlvbiBnZXRQcm9wVHlwZSh0eXBlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKVxuICAgIHJldHVybiB0eXBlLm1hcCgodCkgPT4gZ2V0UHJvcFR5cGUodCkpLmpvaW4oXCIgb3IgXCIpO1xuICBpZiAodHlwZSA9PSBudWxsKVxuICAgIHJldHVybiBcIm51bGxcIjtcbiAgY29uc3QgbWF0Y2ggPSB0eXBlLnRvU3RyaW5nKCkubWF0Y2goZm5UeXBlUkUpO1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIiA/IG1hdGNoICYmIG1hdGNoWzFdIHx8IFwiYW55XCIgOiBcImFueVwiO1xufVxuZnVuY3Rpb24gc2FuaXRpemUoZGF0YSkge1xuICBpZiAoIWlzUHJpbWl0aXZlKGRhdGEpICYmICFBcnJheS5pc0FycmF5KGRhdGEpICYmICFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2V0dXBTdGF0ZVR5cGUocmF3KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZjogaXNSZWYyKHJhdyksXG4gICAgICBjb21wdXRlZDogaXNDb21wdXRlZChyYXcpLFxuICAgICAgcmVhY3RpdmU6IGlzUmVhY3RpdmUyKHJhdyksXG4gICAgICByZWFkb25seTogaXNSZWFkT25seShyYXcpXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7XG4gICAgICByZWY6IGZhbHNlLFxuICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgcmVhY3RpdmU6IGZhbHNlLFxuICAgICAgcmVhZG9ubHk6IGZhbHNlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gdG9SYXcyKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuX192X3JhdylcbiAgICByZXR1cm4gdmFsdWUuX192X3JhdztcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZXNjYXBlKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvWzw+XCImXS9nLCAoczIpID0+IHtcbiAgICByZXR1cm4gRVNDW3MyXSB8fCBzMjtcbiAgfSk7XG59XG5cbi8vIHNyYy9jb3JlL2NvbXBvbmVudC9zdGF0ZS9wcm9jZXNzLnRzXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnModG8sIGZyb20sIGluc3RhbmNlKSB7XG4gIGlmICh0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKVxuICAgIGZyb20gPSBmcm9tLm9wdGlvbnM7XG4gIGlmICghZnJvbSlcbiAgICByZXR1cm4gdG87XG4gIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gZnJvbTtcbiAgZXh0ZW5kc09wdGlvbnMgJiYgbWVyZ2VPcHRpb25zKHRvLCBleHRlbmRzT3B0aW9ucywgaW5zdGFuY2UpO1xuICBtaXhpbnMgJiYgbWl4aW5zLmZvckVhY2goXG4gICAgKG0pID0+IG1lcmdlT3B0aW9ucyh0bywgbSwgaW5zdGFuY2UpXG4gICk7XG4gIGZvciAoY29uc3Qga2V5IG9mIFtcImNvbXB1dGVkXCIsIFwiaW5qZWN0XCJdKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG4gICAgICBpZiAoIXRvW2tleV0pXG4gICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgICBlbHNlXG4gICAgICAgIE9iamVjdC5hc3NpZ24odG9ba2V5XSwgZnJvbVtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuZnVuY3Rpb24gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpIHtcbiAgY29uc3QgcmF3ID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLnR5cGU7XG4gIGlmICghcmF3KVxuICAgIHJldHVybiB7fTtcbiAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSByYXc7XG4gIGNvbnN0IGdsb2JhbE1peGlucyA9IGluc3RhbmNlLmFwcENvbnRleHQubWl4aW5zO1xuICBpZiAoIWdsb2JhbE1peGlucy5sZW5ndGggJiYgIW1peGlucyAmJiAhZXh0ZW5kc09wdGlvbnMpXG4gICAgcmV0dXJuIHJhdztcbiAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICBnbG9iYWxNaXhpbnMuZm9yRWFjaCgobSkgPT4gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIG0sIGluc3RhbmNlKSk7XG4gIG1lcmdlT3B0aW9ucyhvcHRpb25zLCByYXcsIGluc3RhbmNlKTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBwcm9jZXNzUHJvcHMoaW5zdGFuY2UpIHtcbiAgdmFyIF9hMjU7XG4gIGNvbnN0IHByb3BzID0gW107XG4gIGNvbnN0IHByb3BEZWZpbml0aW9ucyA9IChfYTI1ID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLnR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYTI1LnByb3BzO1xuICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UucHJvcHMpIHtcbiAgICBjb25zdCBwcm9wRGVmaW5pdGlvbiA9IHByb3BEZWZpbml0aW9ucyA/IHByb3BEZWZpbml0aW9uc1trZXldIDogbnVsbDtcbiAgICBjb25zdCBjYW1lbGl6ZUtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgcHJvcHMucHVzaCh7XG4gICAgICB0eXBlOiBcInByb3BzXCIsXG4gICAgICBrZXk6IGNhbWVsaXplS2V5LFxuICAgICAgdmFsdWU6IHJldHVybkVycm9yKCgpID0+IGluc3RhbmNlLnByb3BzW2tleV0pLFxuICAgICAgZWRpdGFibGU6IHRydWUsXG4gICAgICBtZXRhOiBwcm9wRGVmaW5pdGlvbiA/IHtcbiAgICAgICAgdHlwZTogcHJvcERlZmluaXRpb24udHlwZSA/IGdldFByb3BUeXBlKHByb3BEZWZpbml0aW9uLnR5cGUpIDogXCJhbnlcIixcbiAgICAgICAgcmVxdWlyZWQ6ICEhcHJvcERlZmluaXRpb24ucmVxdWlyZWQsXG4gICAgICAgIC4uLnByb3BEZWZpbml0aW9uLmRlZmF1bHQgPyB7XG4gICAgICAgICAgZGVmYXVsdDogcHJvcERlZmluaXRpb24uZGVmYXVsdC50b1N0cmluZygpXG4gICAgICAgIH0gOiB7fVxuICAgICAgfSA6IHsgdHlwZTogXCJpbnZhbGlkXCIgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIHByb2Nlc3NTdGF0ZShpbnN0YW5jZSkge1xuICBjb25zdCB0eXBlID0gaW5zdGFuY2UudHlwZTtcbiAgY29uc3QgcHJvcHMgPSB0eXBlID09IG51bGwgPyB2b2lkIDAgOiB0eXBlLnByb3BzO1xuICBjb25zdCBnZXR0ZXJzID0gdHlwZS52dWV4ICYmIHR5cGUudnVleC5nZXR0ZXJzO1xuICBjb25zdCBjb21wdXRlZERlZnMgPSB0eXBlLmNvbXB1dGVkO1xuICBjb25zdCBkYXRhID0ge1xuICAgIC4uLmluc3RhbmNlLmRhdGEsXG4gICAgLi4uaW5zdGFuY2UucmVuZGVyQ29udGV4dFxuICB9O1xuICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSkuZmlsdGVyKChrZXkpID0+ICEocHJvcHMgJiYga2V5IGluIHByb3BzKSAmJiAhKGdldHRlcnMgJiYga2V5IGluIGdldHRlcnMpICYmICEoY29tcHV0ZWREZWZzICYmIGtleSBpbiBjb21wdXRlZERlZnMpKS5tYXAoKGtleSkgPT4gKHtcbiAgICBrZXksXG4gICAgdHlwZTogXCJkYXRhXCIsXG4gICAgdmFsdWU6IHJldHVybkVycm9yKCgpID0+IGRhdGFba2V5XSksXG4gICAgZWRpdGFibGU6IHRydWVcbiAgfSkpO1xufVxuZnVuY3Rpb24gZ2V0U3RhdGVUeXBlQW5kTmFtZShpbmZvKSB7XG4gIGNvbnN0IHN0YXRlVHlwZSA9IGluZm8uY29tcHV0ZWQgPyBcImNvbXB1dGVkXCIgOiBpbmZvLnJlZiA/IFwicmVmXCIgOiBpbmZvLnJlYWN0aXZlID8gXCJyZWFjdGl2ZVwiIDogbnVsbDtcbiAgY29uc3Qgc3RhdGVUeXBlTmFtZSA9IHN0YXRlVHlwZSA/IGAke3N0YXRlVHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke3N0YXRlVHlwZS5zbGljZSgxKX1gIDogbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBzdGF0ZVR5cGUsXG4gICAgc3RhdGVUeXBlTmFtZVxuICB9O1xufVxuZnVuY3Rpb24gcHJvY2Vzc1NldHVwU3RhdGUoaW5zdGFuY2UpIHtcbiAgY29uc3QgcmF3ID0gaW5zdGFuY2UuZGV2dG9vbHNSYXdTZXR1cFN0YXRlIHx8IHt9O1xuICByZXR1cm4gT2JqZWN0LmtleXMoaW5zdGFuY2Uuc2V0dXBTdGF0ZSkuZmlsdGVyKChrZXkpID0+ICF2dWVCdWlsdGlucy5oYXMoa2V5KSAmJiBrZXkuc3BsaXQoLyg/PVtBLVpdKS8pWzBdICE9PSBcInVzZVwiKS5tYXAoKGtleSkgPT4ge1xuICAgIHZhciBfYTI1LCBfYjI1LCBfYywgX2Q7XG4gICAgY29uc3QgdmFsdWUgPSByZXR1cm5FcnJvcigoKSA9PiB0b1JhdzIoaW5zdGFuY2Uuc2V0dXBTdGF0ZVtrZXldKSk7XG4gICAgY29uc3QgYWNjZXNzRXJyb3IgPSB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xuICAgIGNvbnN0IHJhd0RhdGEgPSByYXdba2V5XTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBpc090aGVyVHlwZSA9IGFjY2Vzc0Vycm9yIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IGVuc3VyZVByb3BlcnR5RXhpc3RzKHZhbHVlLCBcInJlbmRlclwiKSAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSBcImZ1bmN0aW9uXCIgfHwgZW5zdXJlUHJvcGVydHlFeGlzdHModmFsdWUsIFwiX19hc3luY0xvYWRlclwiKSAmJiB0eXBlb2YgdmFsdWUuX19hc3luY0xvYWRlciA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAmJiAoXCJzZXR1cFwiIGluIHZhbHVlIHx8IFwicHJvcHNcIiBpbiB2YWx1ZSkgfHwgL152W0EtWl0vLnRlc3Qoa2V5KTtcbiAgICBpZiAocmF3RGF0YSAmJiAhYWNjZXNzRXJyb3IpIHtcbiAgICAgIGNvbnN0IGluZm8gPSBnZXRTZXR1cFN0YXRlVHlwZShyYXdEYXRhKTtcbiAgICAgIGNvbnN0IHsgc3RhdGVUeXBlLCBzdGF0ZVR5cGVOYW1lIH0gPSBnZXRTdGF0ZVR5cGVBbmROYW1lKGluZm8pO1xuICAgICAgY29uc3QgaXNTdGF0ZSA9IGluZm8ucmVmIHx8IGluZm8uY29tcHV0ZWQgfHwgaW5mby5yZWFjdGl2ZTtcbiAgICAgIGNvbnN0IHJhdzIgPSBlbnN1cmVQcm9wZXJ0eUV4aXN0cyhyYXdEYXRhLCBcImVmZmVjdFwiKSA/ICgoX2IyNSA9IChfYTI1ID0gcmF3RGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTI1LnJhdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMjUudG9TdHJpbmcoKSkgfHwgKChfZCA9IChfYyA9IHJhd0RhdGEuZWZmZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2MuZm4pID09IG51bGwgPyB2b2lkIDAgOiBfZC50b1N0cmluZygpKSA6IG51bGw7XG4gICAgICBpZiAoc3RhdGVUeXBlKVxuICAgICAgICBpc090aGVyVHlwZSA9IGZhbHNlO1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAuLi5zdGF0ZVR5cGUgPyB7IHN0YXRlVHlwZSwgc3RhdGVUeXBlTmFtZSB9IDoge30sXG4gICAgICAgIC4uLnJhdzIgPyB7IHJhdzogcmF3MiB9IDoge30sXG4gICAgICAgIGVkaXRhYmxlOiBpc1N0YXRlICYmICFpbmZvLnJlYWRvbmx5XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gaXNPdGhlclR5cGUgPyBcInNldHVwIChvdGhlcilcIiA6IFwic2V0dXBcIjtcbiAgICByZXR1cm4ge1xuICAgICAga2V5LFxuICAgICAgdmFsdWUsXG4gICAgICB0eXBlLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBpZ25vcmVcbiAgICAgIC4uLnJlc3VsdFxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0NvbXB1dGVkKGluc3RhbmNlLCBtZXJnZWRUeXBlKSB7XG4gIGNvbnN0IHR5cGUgPSBtZXJnZWRUeXBlO1xuICBjb25zdCBjb21wdXRlZCA9IFtdO1xuICBjb25zdCBkZWZzID0gdHlwZS5jb21wdXRlZCB8fCB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gZGVmcykge1xuICAgIGNvbnN0IGRlZiA9IGRlZnNba2V5XTtcbiAgICBjb25zdCB0eXBlMiA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWYudnVleCA/IFwidnVleCBiaW5kaW5nc1wiIDogXCJjb21wdXRlZFwiO1xuICAgIGNvbXB1dGVkLnB1c2goe1xuICAgICAgdHlwZTogdHlwZTIsXG4gICAgICBrZXksXG4gICAgICB2YWx1ZTogcmV0dXJuRXJyb3IoKCkgPT4ge1xuICAgICAgICB2YXIgX2EyNTtcbiAgICAgICAgcmV0dXJuIChfYTI1ID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLnByb3h5KSA9PSBudWxsID8gdm9pZCAwIDogX2EyNVtrZXldO1xuICAgICAgfSksXG4gICAgICBlZGl0YWJsZTogdHlwZW9mIGRlZi5zZXQgPT09IFwiZnVuY3Rpb25cIlxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjb21wdXRlZDtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyhpbnN0YW5jZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoaW5zdGFuY2UuYXR0cnMpLm1hcCgoa2V5KSA9PiAoe1xuICAgIHR5cGU6IFwiYXR0cnNcIixcbiAgICBrZXksXG4gICAgdmFsdWU6IHJldHVybkVycm9yKCgpID0+IGluc3RhbmNlLmF0dHJzW2tleV0pXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NQcm92aWRlKGluc3RhbmNlKSB7XG4gIHJldHVybiBSZWZsZWN0Lm93bktleXMoaW5zdGFuY2UucHJvdmlkZXMpLm1hcCgoa2V5KSA9PiAoe1xuICAgIHR5cGU6IFwicHJvdmlkZWRcIixcbiAgICBrZXk6IGtleS50b1N0cmluZygpLFxuICAgIHZhbHVlOiByZXR1cm5FcnJvcigoKSA9PiBpbnN0YW5jZS5wcm92aWRlc1trZXldKVxuICB9KSk7XG59XG5mdW5jdGlvbiBwcm9jZXNzSW5qZWN0KGluc3RhbmNlLCBtZXJnZWRUeXBlKSB7XG4gIGlmICghKG1lcmdlZFR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IG1lcmdlZFR5cGUuaW5qZWN0KSlcbiAgICByZXR1cm4gW107XG4gIGxldCBrZXlzID0gW107XG4gIGxldCBkZWZhdWx0VmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KG1lcmdlZFR5cGUuaW5qZWN0KSkge1xuICAgIGtleXMgPSBtZXJnZWRUeXBlLmluamVjdC5tYXAoKGtleSkgPT4gKHtcbiAgICAgIGtleSxcbiAgICAgIG9yaWdpbmFsS2V5OiBrZXlcbiAgICB9KSk7XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IFJlZmxlY3Qub3duS2V5cyhtZXJnZWRUeXBlLmluamVjdCkubWFwKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbWVyZ2VkVHlwZS5pbmplY3Rba2V5XTtcbiAgICAgIGxldCBvcmlnaW5hbEtleTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIG9yaWdpbmFsS2V5ID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcmlnaW5hbEtleSA9IHZhbHVlLmZyb207XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IHZhbHVlLmRlZmF1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXksXG4gICAgICAgIG9yaWdpbmFsS2V5XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBrZXlzLm1hcCgoeyBrZXksIG9yaWdpbmFsS2V5IH0pID0+ICh7XG4gICAgdHlwZTogXCJpbmplY3RlZFwiLFxuICAgIGtleTogb3JpZ2luYWxLZXkgJiYga2V5ICE9PSBvcmlnaW5hbEtleSA/IGAke29yaWdpbmFsS2V5LnRvU3RyaW5nKCl9IFxcdTI3OUUgJHtrZXkudG9TdHJpbmcoKX1gIDoga2V5LnRvU3RyaW5nKCksXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIHZhbHVlOiByZXR1cm5FcnJvcigoKSA9PiBpbnN0YW5jZS5jdHguaGFzT3duUHJvcGVydHkoa2V5KSA/IGluc3RhbmNlLmN0eFtrZXldIDogaW5zdGFuY2UucHJvdmlkZXMuaGFzT3duUHJvcGVydHkob3JpZ2luYWxLZXkpID8gaW5zdGFuY2UucHJvdmlkZXNbb3JpZ2luYWxLZXldIDogZGVmYXVsdFZhbHVlKVxuICB9KSk7XG59XG5mdW5jdGlvbiBwcm9jZXNzUmVmcyhpbnN0YW5jZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoaW5zdGFuY2UucmVmcykubWFwKChrZXkpID0+ICh7XG4gICAgdHlwZTogXCJ0ZW1wbGF0ZSByZWZzXCIsXG4gICAga2V5LFxuICAgIHZhbHVlOiByZXR1cm5FcnJvcigoKSA9PiBpbnN0YW5jZS5yZWZzW2tleV0pXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NFdmVudExpc3RlbmVycyhpbnN0YW5jZSkge1xuICB2YXIgX2EyNSwgX2IyNTtcbiAgY29uc3QgZW1pdHNEZWZpbml0aW9uID0gaW5zdGFuY2UudHlwZS5lbWl0cztcbiAgY29uc3QgZGVjbGFyZWRFbWl0cyA9IEFycmF5LmlzQXJyYXkoZW1pdHNEZWZpbml0aW9uKSA/IGVtaXRzRGVmaW5pdGlvbiA6IE9iamVjdC5rZXlzKGVtaXRzRGVmaW5pdGlvbiAhPSBudWxsID8gZW1pdHNEZWZpbml0aW9uIDoge30pO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoKF9iMjUgPSAoX2EyNSA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS52bm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjUucHJvcHMpICE9IG51bGwgPyBfYjI1IDoge30pO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IFtwcmVmaXgsIC4uLmV2ZW50TmFtZVBhcnRzXSA9IGtleS5zcGxpdCgvKD89W0EtWl0pLyk7XG4gICAgaWYgKHByZWZpeCA9PT0gXCJvblwiKSB7XG4gICAgICBjb25zdCBldmVudE5hbWUgPSBldmVudE5hbWVQYXJ0cy5qb2luKFwiLVwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgaXNEZWNsYXJlZCA9IGRlY2xhcmVkRW1pdHMuaW5jbHVkZXMoZXZlbnROYW1lKTtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJldmVudCBsaXN0ZW5lcnNcIixcbiAgICAgICAga2V5OiBldmVudE5hbWUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgX2N1c3RvbToge1xuICAgICAgICAgICAgZGlzcGxheVRleHQ6IGlzRGVjbGFyZWQgPyBcIlxcdTI3MDUgRGVjbGFyZWRcIiA6IFwiXFx1MjZBMFxcdUZFMEYgTm90IGRlY2xhcmVkXCIsXG4gICAgICAgICAgICBrZXk6IGlzRGVjbGFyZWQgPyBcIlxcdTI3MDUgRGVjbGFyZWRcIiA6IFwiXFx1MjZBMFxcdUZFMEYgTm90IGRlY2xhcmVkXCIsXG4gICAgICAgICAgICB2YWx1ZTogaXNEZWNsYXJlZCA/IFwiXFx1MjcwNSBEZWNsYXJlZFwiIDogXCJcXHUyNkEwXFx1RkUwRiBOb3QgZGVjbGFyZWRcIixcbiAgICAgICAgICAgIHRvb2x0aXBUZXh0OiAhaXNEZWNsYXJlZCA/IGBUaGUgZXZlbnQgPGNvZGU+JHtldmVudE5hbWV9PC9jb2RlPiBpcyBub3QgZGVjbGFyZWQgaW4gdGhlIDxjb2RlPmVtaXRzPC9jb2RlPiBvcHRpb24uIEl0IHdpbGwgbGVhayBpbnRvIHRoZSBjb21wb25lbnQncyBhdHRyaWJ1dGVzICg8Y29kZT4kYXR0cnM8L2NvZGU+KS5gIDogbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwcm9jZXNzSW5zdGFuY2VTdGF0ZShpbnN0YW5jZSkge1xuICBjb25zdCBtZXJnZWRUeXBlID0gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpO1xuICByZXR1cm4gcHJvY2Vzc1Byb3BzKGluc3RhbmNlKS5jb25jYXQoXG4gICAgcHJvY2Vzc1N0YXRlKGluc3RhbmNlKSxcbiAgICBwcm9jZXNzU2V0dXBTdGF0ZShpbnN0YW5jZSksXG4gICAgcHJvY2Vzc0NvbXB1dGVkKGluc3RhbmNlLCBtZXJnZWRUeXBlKSxcbiAgICBwcm9jZXNzQXR0cnMoaW5zdGFuY2UpLFxuICAgIHByb2Nlc3NQcm92aWRlKGluc3RhbmNlKSxcbiAgICBwcm9jZXNzSW5qZWN0KGluc3RhbmNlLCBtZXJnZWRUeXBlKSxcbiAgICBwcm9jZXNzUmVmcyhpbnN0YW5jZSksXG4gICAgcHJvY2Vzc0V2ZW50TGlzdGVuZXJzKGluc3RhbmNlKVxuICApO1xufVxuXG4vLyBzcmMvY29yZS9jb21wb25lbnQvc3RhdGUvaW5kZXgudHNcbmZ1bmN0aW9uIGdldEluc3RhbmNlU3RhdGUocGFyYW1zKSB7XG4gIHZhciBfYTI1O1xuICBjb25zdCBpbnN0YW5jZSA9IGdldENvbXBvbmVudEluc3RhbmNlKGFjdGl2ZUFwcFJlY29yZC52YWx1ZSwgcGFyYW1zLmluc3RhbmNlSWQpO1xuICBjb25zdCBpZCA9IGdldFVuaXF1ZUNvbXBvbmVudElkKGluc3RhbmNlKTtcbiAgY29uc3QgbmFtZSA9IGdldEluc3RhbmNlTmFtZShpbnN0YW5jZSk7XG4gIGNvbnN0IGZpbGUgPSAoX2EyNSA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS50eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyNS5fX2ZpbGU7XG4gIGNvbnN0IHN0YXRlID0gcHJvY2Vzc0luc3RhbmNlU3RhdGUoaW5zdGFuY2UpO1xuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIG5hbWUsXG4gICAgZmlsZSxcbiAgICBzdGF0ZSxcbiAgICBpbnN0YW5jZVxuICB9O1xufVxuXG4vLyBzcmMvY29yZS9jb21wb25lbnQvdHJlZS93YWxrZXIudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy9jb3JlL2NvbXBvbmVudC90cmVlL2ZpbHRlci50c1xuaW5pdF9lc21fc2hpbXMoKTtcbmltcG9ydCB7IGNsYXNzaWZ5IGFzIGNsYXNzaWZ5Miwga2ViYWJpemUgfSBmcm9tIFwiQHZ1ZS9kZXZ0b29scy1zaGFyZWRcIjtcbnZhciBDb21wb25lbnRGaWx0ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGZpbHRlcikge1xuICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyIHx8IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGluc3RhbmNlIGlzIHF1YWxpZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV8Vm5vZGV9IGluc3RhbmNlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1F1YWxpZmllZChpbnN0YW5jZSkge1xuICAgIGNvbnN0IG5hbWUgPSBnZXRJbnN0YW5jZU5hbWUoaW5zdGFuY2UpO1xuICAgIHJldHVybiBjbGFzc2lmeTIobmFtZSkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0aGlzLmZpbHRlcikgfHwga2ViYWJpemUobmFtZSkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0aGlzLmZpbHRlcik7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRGaWx0ZXIoZmlsdGVyVGV4dCkge1xuICByZXR1cm4gbmV3IENvbXBvbmVudEZpbHRlcihmaWx0ZXJUZXh0KTtcbn1cblxuLy8gc3JjL2NvcmUvY29tcG9uZW50L3RyZWUvd2Fsa2VyLnRzXG52YXIgQ29tcG9uZW50V2Fsa2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgLy8gRGVkdXBlIGluc3RhbmNlcyAoU29tZSBpbnN0YW5jZXMgbWF5IGJlIGJvdGggb24gYSBjb21wb25lbnQgYW5kIG9uIGEgY2hpbGQgYWJzdHJhY3QvZnVuY3Rpb25hbCBjb21wb25lbnQpXG4gICAgdGhpcy5jYXB0dXJlSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCB7IGZpbHRlclRleHQgPSBcIlwiLCBtYXhEZXB0aCwgcmVjdXJzaXZlbHksIGFwaSB9ID0gb3B0aW9ucztcbiAgICB0aGlzLmNvbXBvbmVudEZpbHRlciA9IGNyZWF0ZUNvbXBvbmVudEZpbHRlcihmaWx0ZXJUZXh0KTtcbiAgICB0aGlzLm1heERlcHRoID0gbWF4RGVwdGg7XG4gICAgdGhpcy5yZWN1cnNpdmVseSA9IHJlY3Vyc2l2ZWx5O1xuICAgIHRoaXMuYXBpID0gYXBpO1xuICB9XG4gIGdldENvbXBvbmVudFRyZWUoaW5zdGFuY2UpIHtcbiAgICB0aGlzLmNhcHR1cmVJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmRRdWFsaWZpZWRDaGlsZHJlbihpbnN0YW5jZSwgMCk7XG4gIH1cbiAgZ2V0Q29tcG9uZW50UGFyZW50cyhpbnN0YW5jZSkge1xuICAgIHRoaXMuY2FwdHVyZUlkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgIHRoaXMuY2FwdHVyZUlkKGluc3RhbmNlKTtcbiAgICBsZXQgcGFyZW50ID0gaW5zdGFuY2U7XG4gICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudC5wYXJlbnQpIHtcbiAgICAgIHRoaXMuY2FwdHVyZUlkKHBhcmVudCk7XG4gICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudHM7XG4gIH1cbiAgY2FwdHVyZUlkKGluc3RhbmNlKSB7XG4gICAgaWYgKCFpbnN0YW5jZSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGlkID0gaW5zdGFuY2UuX19WVUVfREVWVE9PTFNfTkVYVF9VSURfXyAhPSBudWxsID8gaW5zdGFuY2UuX19WVUVfREVWVE9PTFNfTkVYVF9VSURfXyA6IGdldFVuaXF1ZUNvbXBvbmVudElkKGluc3RhbmNlKTtcbiAgICBpbnN0YW5jZS5fX1ZVRV9ERVZUT09MU19ORVhUX1VJRF9fID0gaWQ7XG4gICAgaWYgKHRoaXMuY2FwdHVyZUlkcy5oYXMoaWQpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZWxzZVxuICAgICAgdGhpcy5jYXB0dXJlSWRzLnNldChpZCwgdm9pZCAwKTtcbiAgICB0aGlzLm1hcmsoaW5zdGFuY2UpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICAvKipcbiAgICogQ2FwdHVyZSB0aGUgbWV0YSBpbmZvcm1hdGlvbiBvZiBhbiBpbnN0YW5jZS4gKHJlY3Vyc2l2ZSlcbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IGluc3RhbmNlXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICovXG4gIGFzeW5jIGNhcHR1cmUoaW5zdGFuY2UsIGRlcHRoKSB7XG4gICAgdmFyIF9hMjU7XG4gICAgaWYgKCFpbnN0YW5jZSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGlkID0gdGhpcy5jYXB0dXJlSWQoaW5zdGFuY2UpO1xuICAgIGNvbnN0IG5hbWUgPSBnZXRJbnN0YW5jZU5hbWUoaW5zdGFuY2UpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRJbnRlcm5hbEluc3RhbmNlQ2hpbGRyZW4oaW5zdGFuY2Uuc3ViVHJlZSkuZmlsdGVyKChjaGlsZCkgPT4gIWlzQmVpbmdEZXN0cm95ZWQoY2hpbGQpKTtcbiAgICBjb25zdCBwYXJlbnRzID0gdGhpcy5nZXRDb21wb25lbnRQYXJlbnRzKGluc3RhbmNlKSB8fCBbXTtcbiAgICBjb25zdCBpbmFjdGl2ZSA9ICEhaW5zdGFuY2UuaXNEZWFjdGl2YXRlZCB8fCBwYXJlbnRzLnNvbWUoKHBhcmVudCkgPT4gcGFyZW50LmlzRGVhY3RpdmF0ZWQpO1xuICAgIGNvbnN0IHRyZWVOb2RlID0ge1xuICAgICAgdWlkOiBpbnN0YW5jZS51aWQsXG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICByZW5kZXJLZXk6IGdldFJlbmRlcktleShpbnN0YW5jZS52bm9kZSA/IGluc3RhbmNlLnZub2RlLmtleSA6IG51bGwpLFxuICAgICAgaW5hY3RpdmUsXG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBpc0ZyYWdtZW50OiBpc0ZyYWdtZW50KGluc3RhbmNlKSxcbiAgICAgIHRhZ3M6IHR5cGVvZiBpbnN0YW5jZS50eXBlICE9PSBcImZ1bmN0aW9uXCIgPyBbXSA6IFtcbiAgICAgICAge1xuICAgICAgICAgIGxhYmVsOiBcImZ1bmN0aW9uYWxcIixcbiAgICAgICAgICB0ZXh0Q29sb3I6IDU1OTI0MDUsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAxNTY1ODczNFxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgYXV0b09wZW46IHRoaXMucmVjdXJzaXZlbHksXG4gICAgICBmaWxlOiBpbnN0YW5jZS50eXBlLl9fZmlsZSB8fCBcIlwiXG4gICAgfTtcbiAgICBpZiAoZGVwdGggPCB0aGlzLm1heERlcHRoIHx8IGluc3RhbmNlLnR5cGUuX19pc0tlZXBBbGl2ZSB8fCBwYXJlbnRzLnNvbWUoKHBhcmVudCkgPT4gcGFyZW50LnR5cGUuX19pc0tlZXBBbGl2ZSkpIHtcbiAgICAgIHRyZWVOb2RlLmNoaWxkcmVuID0gYXdhaXQgUHJvbWlzZS5hbGwoY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gdGhpcy5jYXB0dXJlKGNoaWxkLCBkZXB0aCArIDEpKS5maWx0ZXIoQm9vbGVhbikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0tlZXBBbGl2ZShpbnN0YW5jZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlZENvbXBvbmVudHMgPSB0aGlzLmdldEtlZXBBbGl2ZUNhY2hlZEluc3RhbmNlcyhpbnN0YW5jZSk7XG4gICAgICBjb25zdCBjaGlsZHJlbklkcyA9IGNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLl9fVlVFX0RFVlRPT0xTX05FWFRfVUlEX18pO1xuICAgICAgZm9yIChjb25zdCBjYWNoZWRDaGlsZCBvZiBjYWNoZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGlmICghY2hpbGRyZW5JZHMuaW5jbHVkZXMoY2FjaGVkQ2hpbGQuX19WVUVfREVWVE9PTFNfTkVYVF9VSURfXykpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gYXdhaXQgdGhpcy5jYXB0dXJlKHsgLi4uY2FjaGVkQ2hpbGQsIGlzRGVhY3RpdmF0ZWQ6IHRydWUgfSwgZGVwdGggKyAxKTtcbiAgICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgIHRyZWVOb2RlLmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgcm9vdEVsZW1lbnRzID0gZ2V0Um9vdEVsZW1lbnRzRnJvbUNvbXBvbmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSByb290RWxlbWVudHNbMF07XG4gICAgaWYgKGZpcnN0RWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RFbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHBhcmVudEluc3RhbmNlID0gaW5zdGFuY2UucGFyZW50O1xuICAgICAgY29uc3QgcGFyZW50Um9vdEVsZW1lbnRzID0gcGFyZW50SW5zdGFuY2UgPyBnZXRSb290RWxlbWVudHNGcm9tQ29tcG9uZW50SW5zdGFuY2UocGFyZW50SW5zdGFuY2UpIDogW107XG4gICAgICBsZXQgZWwgPSBmaXJzdEVsZW1lbnQ7XG4gICAgICBjb25zdCBpbmRleExpc3QgPSBbXTtcbiAgICAgIGRvIHtcbiAgICAgICAgaW5kZXhMaXN0LnB1c2goQXJyYXkuZnJvbShlbC5wYXJlbnRFbGVtZW50LmNoaWxkTm9kZXMpLmluZGV4T2YoZWwpKTtcbiAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgICAgfSB3aGlsZSAoZWwucGFyZW50RWxlbWVudCAmJiBwYXJlbnRSb290RWxlbWVudHMubGVuZ3RoICYmICFwYXJlbnRSb290RWxlbWVudHMuaW5jbHVkZXMoZWwpKTtcbiAgICAgIHRyZWVOb2RlLmRvbU9yZGVyID0gaW5kZXhMaXN0LnJldmVyc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZU5vZGUuZG9tT3JkZXIgPSBbLTFdO1xuICAgIH1cbiAgICBpZiAoKF9hMjUgPSBpbnN0YW5jZS5zdXNwZW5zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjUuc3VzcGVuc2VLZXkpIHtcbiAgICAgIHRyZWVOb2RlLnRhZ3MucHVzaCh7XG4gICAgICAgIGxhYmVsOiBpbnN0YW5jZS5zdXNwZW5zZS5zdXNwZW5zZUtleSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAxNDk3OTgxMixcbiAgICAgICAgdGV4dENvbG9yOiAxNjc3NzIxNVxuICAgICAgfSk7XG4gICAgICB0aGlzLm1hcmsoaW5zdGFuY2UsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmFwaS52aXNpdENvbXBvbmVudFRyZWUoe1xuICAgICAgdHJlZU5vZGUsXG4gICAgICBjb21wb25lbnRJbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICBhcHA6IGluc3RhbmNlLmFwcENvbnRleHQuYXBwLFxuICAgICAgZmlsdGVyOiB0aGlzLmNvbXBvbmVudEZpbHRlci5maWx0ZXJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJlZU5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgcXVhbGlmaWVkIGNoaWxkcmVuIGZyb20gYSBzaW5nbGUgaW5zdGFuY2UuXG4gICAqIElmIHRoZSBpbnN0YW5jZSBpdHNlbGYgaXMgcXVhbGlmaWVkLCBqdXN0IHJldHVybiBpdHNlbGYuXG4gICAqIFRoaXMgaXMgb2sgYmVjYXVzZSBbXS5jb25jYXQgd29ya3MgaW4gYm90aCBjYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV8Vm5vZGV9IGluc3RhbmNlXG4gICAqIEByZXR1cm4ge1Z1ZXxBcnJheX1cbiAgICovXG4gIGFzeW5jIGZpbmRRdWFsaWZpZWRDaGlsZHJlbihpbnN0YW5jZSwgZGVwdGgpIHtcbiAgICB2YXIgX2EyNTtcbiAgICBpZiAodGhpcy5jb21wb25lbnRGaWx0ZXIuaXNRdWFsaWZpZWQoaW5zdGFuY2UpICYmICEoKF9hMjUgPSBpbnN0YW5jZS50eXBlLmRldnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyNS5oaWRlKSkge1xuICAgICAgcmV0dXJuIFthd2FpdCB0aGlzLmNhcHR1cmUoaW5zdGFuY2UsIGRlcHRoKV07XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5zdWJUcmVlKSB7XG4gICAgICBjb25zdCBsaXN0ID0gdGhpcy5pc0tlZXBBbGl2ZShpbnN0YW5jZSkgPyB0aGlzLmdldEtlZXBBbGl2ZUNhY2hlZEluc3RhbmNlcyhpbnN0YW5jZSkgOiB0aGlzLmdldEludGVybmFsSW5zdGFuY2VDaGlsZHJlbihpbnN0YW5jZS5zdWJUcmVlKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRRdWFsaWZpZWRDaGlsZHJlbkZyb21MaXN0KGxpc3QsIGRlcHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFuIGFycmF5IG9mIGluc3RhbmNlcyBhbmQgZmxhdHRlbiBpdCBpbnRvXG4gICAqIGFuIGFycmF5IG9mIHF1YWxpZmllZCBpbnN0YW5jZXMuIFRoaXMgaXMgYSBkZXB0aC1maXJzdFxuICAgKiB0cmF2ZXJzYWwgLSBlLmcuIGlmIGFuIGluc3RhbmNlIGlzIG5vdCBtYXRjaGVkLCB3ZSB3aWxsXG4gICAqIHJlY3Vyc2l2ZWx5IGdvIGRlZXBlciB1bnRpbCBhIHF1YWxpZmllZCBjaGlsZCBpcyBmb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gaW5zdGFuY2VzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgYXN5bmMgZmluZFF1YWxpZmllZENoaWxkcmVuRnJvbUxpc3QoaW5zdGFuY2VzLCBkZXB0aCkge1xuICAgIGluc3RhbmNlcyA9IGluc3RhbmNlcy5maWx0ZXIoKGNoaWxkKSA9PiB7XG4gICAgICB2YXIgX2EyNTtcbiAgICAgIHJldHVybiAhaXNCZWluZ0Rlc3Ryb3llZChjaGlsZCkgJiYgISgoX2EyNSA9IGNoaWxkLnR5cGUuZGV2dG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTI1LmhpZGUpO1xuICAgIH0pO1xuICAgIGlmICghdGhpcy5jb21wb25lbnRGaWx0ZXIuZmlsdGVyKVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoKGNoaWxkKSA9PiB0aGlzLmNhcHR1cmUoY2hpbGQsIGRlcHRoKSkpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKChpKSA9PiB0aGlzLmZpbmRRdWFsaWZpZWRDaGlsZHJlbihpLCBkZXB0aCkpKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjaGlsZHJlbiBmcm9tIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKi9cbiAgZ2V0SW50ZXJuYWxJbnN0YW5jZUNoaWxkcmVuKHN1YlRyZWUsIHN1c3BlbnNlID0gbnVsbCkge1xuICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICBpZiAoc3ViVHJlZSkge1xuICAgICAgaWYgKHN1YlRyZWUuY29tcG9uZW50KSB7XG4gICAgICAgICFzdXNwZW5zZSA/IGxpc3QucHVzaChzdWJUcmVlLmNvbXBvbmVudCkgOiBsaXN0LnB1c2goeyAuLi5zdWJUcmVlLmNvbXBvbmVudCwgc3VzcGVuc2UgfSk7XG4gICAgICB9IGVsc2UgaWYgKHN1YlRyZWUuc3VzcGVuc2UpIHtcbiAgICAgICAgY29uc3Qgc3VzcGVuc2VLZXkgPSAhc3ViVHJlZS5zdXNwZW5zZS5pc0luRmFsbGJhY2sgPyBcInN1c3BlbnNlIGRlZmF1bHRcIiA6IFwic3VzcGVuc2UgZmFsbGJhY2tcIjtcbiAgICAgICAgbGlzdC5wdXNoKC4uLnRoaXMuZ2V0SW50ZXJuYWxJbnN0YW5jZUNoaWxkcmVuKHN1YlRyZWUuc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCB7IC4uLnN1YlRyZWUuc3VzcGVuc2UsIHN1c3BlbnNlS2V5IH0pKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzdWJUcmVlLmNoaWxkcmVuKSkge1xuICAgICAgICBzdWJUcmVlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkU3ViVHJlZSkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZFN1YlRyZWUuY29tcG9uZW50KVxuICAgICAgICAgICAgIXN1c3BlbnNlID8gbGlzdC5wdXNoKGNoaWxkU3ViVHJlZS5jb21wb25lbnQpIDogbGlzdC5wdXNoKHsgLi4uY2hpbGRTdWJUcmVlLmNvbXBvbmVudCwgc3VzcGVuc2UgfSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGlzdC5wdXNoKC4uLnRoaXMuZ2V0SW50ZXJuYWxJbnN0YW5jZUNoaWxkcmVuKGNoaWxkU3ViVHJlZSwgc3VzcGVuc2UpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaXN0LmZpbHRlcigoY2hpbGQpID0+IHtcbiAgICAgIHZhciBfYTI1O1xuICAgICAgcmV0dXJuICFpc0JlaW5nRGVzdHJveWVkKGNoaWxkKSAmJiAhKChfYTI1ID0gY2hpbGQudHlwZS5kZXZ0b29scykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjUuaGlkZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmsgYW4gaW5zdGFuY2UgYXMgY2FwdHVyZWQgYW5kIHN0b3JlIGl0IGluIHRoZSBpbnN0YW5jZSBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSBpbnN0YW5jZVxuICAgKi9cbiAgbWFyayhpbnN0YW5jZSwgZm9yY2UgPSBmYWxzZSkge1xuICAgIGNvbnN0IGluc3RhbmNlTWFwID0gZ2V0QXBwUmVjb3JkKGluc3RhbmNlKS5pbnN0YW5jZU1hcDtcbiAgICBpZiAoZm9yY2UgfHwgIWluc3RhbmNlTWFwLmhhcyhpbnN0YW5jZS5fX1ZVRV9ERVZUT09MU19ORVhUX1VJRF9fKSkge1xuICAgICAgaW5zdGFuY2VNYXAuc2V0KGluc3RhbmNlLl9fVlVFX0RFVlRPT0xTX05FWFRfVUlEX18sIGluc3RhbmNlKTtcbiAgICAgIGFjdGl2ZUFwcFJlY29yZC52YWx1ZS5pbnN0YW5jZU1hcCA9IGluc3RhbmNlTWFwO1xuICAgIH1cbiAgfVxuICBpc0tlZXBBbGl2ZShpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZS50eXBlLl9faXNLZWVwQWxpdmUgJiYgaW5zdGFuY2UuX192X2NhY2hlO1xuICB9XG4gIGdldEtlZXBBbGl2ZUNhY2hlZEluc3RhbmNlcyhpbnN0YW5jZSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGluc3RhbmNlLl9fdl9jYWNoZS52YWx1ZXMoKSkubWFwKCh2bm9kZSkgPT4gdm5vZGUuY29tcG9uZW50KS5maWx0ZXIoQm9vbGVhbik7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL3RpbWVsaW5lL2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgaXNCcm93c2VyIGFzIGlzQnJvd3NlcjIgfSBmcm9tIFwiQHZ1ZS9kZXZ0b29scy1zaGFyZWRcIjtcblxuLy8gc3JjL2NvcmUvdGltZWxpbmUvcGVyZi50c1xuaW5pdF9lc21fc2hpbXMoKTtcbnZhciBtYXJrRW5kUXVldWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIFBFUkZPUk1BTkNFX0VWRU5UX0xBWUVSX0lEID0gXCJwZXJmb3JtYW5jZVwiO1xuYXN5bmMgZnVuY3Rpb24gcGVyZm9ybWFuY2VNYXJrU3RhcnQoYXBpLCBhcHAsIHVpZCwgdm0sIHR5cGUsIHRpbWUpIHtcbiAgY29uc3QgYXBwUmVjb3JkID0gYXdhaXQgZ2V0QXBwUmVjb3JkKGFwcCk7XG4gIGlmICghYXBwUmVjb3JkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBnZXRJbnN0YW5jZU5hbWUodm0pIHx8IFwiVW5rbm93biBDb21wb25lbnRcIjtcbiAgY29uc3QgZ3JvdXBJZCA9IGRldnRvb2xzU3RhdGUucGVyZlVuaXF1ZUdyb3VwSWQrKztcbiAgY29uc3QgZ3JvdXBLZXkgPSBgJHt1aWR9LSR7dHlwZX1gO1xuICBhcHBSZWNvcmQucGVyZkdyb3VwSWRzLnNldChncm91cEtleSwgeyBncm91cElkLCB0aW1lIH0pO1xuICBhd2FpdCBhcGkuYWRkVGltZWxpbmVFdmVudCh7XG4gICAgbGF5ZXJJZDogUEVSRk9STUFOQ0VfRVZFTlRfTEFZRVJfSUQsXG4gICAgZXZlbnQ6IHtcbiAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50TmFtZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbWVhc3VyZTogXCJzdGFydFwiXG4gICAgICB9LFxuICAgICAgdGl0bGU6IGNvbXBvbmVudE5hbWUsXG4gICAgICBzdWJ0aXRsZTogdHlwZSxcbiAgICAgIGdyb3VwSWRcbiAgICB9XG4gIH0pO1xuICBpZiAobWFya0VuZFF1ZXVlLmhhcyhncm91cEtleSkpIHtcbiAgICBjb25zdCB7XG4gICAgICBhcHA6IGFwcDIsXG4gICAgICB1aWQ6IHVpZDIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIHR5cGU6IHR5cGUyLFxuICAgICAgdGltZTogdGltZTJcbiAgICB9ID0gbWFya0VuZFF1ZXVlLmdldChncm91cEtleSk7XG4gICAgbWFya0VuZFF1ZXVlLmRlbGV0ZShncm91cEtleSk7XG4gICAgYXdhaXQgcGVyZm9ybWFuY2VNYXJrRW5kKFxuICAgICAgYXBpLFxuICAgICAgYXBwMixcbiAgICAgIHVpZDIsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIHR5cGUyLFxuICAgICAgdGltZTJcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBwZXJmb3JtYW5jZU1hcmtFbmQoYXBpLCBhcHAsIHVpZCwgdm0sIHR5cGUsIHRpbWUpIHtcbiAgY29uc3QgYXBwUmVjb3JkID0gZ2V0QXBwUmVjb3JkKGFwcCk7XG4gIGlmICghYXBwUmVjb3JkKVxuICAgIHJldHVybjtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IGdldEluc3RhbmNlTmFtZSh2bSkgfHwgXCJVbmtub3duIENvbXBvbmVudFwiO1xuICBjb25zdCBncm91cEtleSA9IGAke3VpZH0tJHt0eXBlfWA7XG4gIGNvbnN0IGdyb3VwSW5mbyA9IGFwcFJlY29yZC5wZXJmR3JvdXBJZHMuZ2V0KGdyb3VwS2V5KTtcbiAgaWYgKGdyb3VwSW5mbykge1xuICAgIGNvbnN0IGdyb3VwSWQgPSBncm91cEluZm8uZ3JvdXBJZDtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBncm91cEluZm8udGltZTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRpbWUgLSBzdGFydFRpbWU7XG4gICAgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xuICAgICAgbGF5ZXJJZDogUEVSRk9STUFOQ0VfRVZFTlRfTEFZRVJfSUQsXG4gICAgICBldmVudDoge1xuICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnROYW1lLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgbWVhc3VyZTogXCJlbmRcIixcbiAgICAgICAgICBkdXJhdGlvbjoge1xuICAgICAgICAgICAgX2N1c3RvbToge1xuICAgICAgICAgICAgICB0eXBlOiBcIkR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgZGlzcGxheTogYCR7ZHVyYXRpb259IG1zYFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IGNvbXBvbmVudE5hbWUsXG4gICAgICAgIHN1YnRpdGxlOiB0eXBlLFxuICAgICAgICBncm91cElkXG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbWFya0VuZFF1ZXVlLnNldChncm91cEtleSwgeyBhcHAsIHVpZCwgaW5zdGFuY2U6IHZtLCB0eXBlLCB0aW1lIH0pO1xuICB9XG59XG5cbi8vIHNyYy9jb3JlL3RpbWVsaW5lL2luZGV4LnRzXG52YXIgQ09NUE9ORU5UX0VWRU5UX0xBWUVSX0lEID0gXCJjb21wb25lbnQtZXZlbnRcIjtcbmZ1bmN0aW9uIHNldHVwQnVpbHRpblRpbWVsaW5lTGF5ZXJzKGFwaSkge1xuICBpZiAoIWlzQnJvd3NlcjIpXG4gICAgcmV0dXJuO1xuICBhcGkuYWRkVGltZWxpbmVMYXllcih7XG4gICAgaWQ6IFwibW91c2VcIixcbiAgICBsYWJlbDogXCJNb3VzZVwiLFxuICAgIGNvbG9yOiAxMDc2ODgxNVxuICB9KTtcbiAgW1wibW91c2Vkb3duXCIsIFwibW91c2V1cFwiLCBcImNsaWNrXCIsIFwiZGJsY2xpY2tcIl0uZm9yRWFjaCgoZXZlbnRUeXBlKSA9PiB7XG4gICAgaWYgKCFkZXZ0b29sc1N0YXRlLnRpbWVsaW5lTGF5ZXJzU3RhdGUucmVjb3JkaW5nU3RhdGUgfHwgIWRldnRvb2xzU3RhdGUudGltZWxpbmVMYXllcnNTdGF0ZS5tb3VzZUV2ZW50RW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgYXdhaXQgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xuICAgICAgICBsYXllcklkOiBcIm1vdXNlXCIsXG4gICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB0eXBlOiBldmVudFR5cGUsXG4gICAgICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGl0bGU6IGV2ZW50VHlwZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbiAgYXBpLmFkZFRpbWVsaW5lTGF5ZXIoe1xuICAgIGlkOiBcImtleWJvYXJkXCIsXG4gICAgbGFiZWw6IFwiS2V5Ym9hcmRcIixcbiAgICBjb2xvcjogODQ3NTA1NVxuICB9KTtcbiAgW1wia2V5dXBcIiwgXCJrZXlkb3duXCIsIFwia2V5cHJlc3NcIl0uZm9yRWFjaCgoZXZlbnRUeXBlKSA9PiB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghZGV2dG9vbHNTdGF0ZS50aW1lbGluZUxheWVyc1N0YXRlLnJlY29yZGluZ1N0YXRlIHx8ICFkZXZ0b29sc1N0YXRlLnRpbWVsaW5lTGF5ZXJzU3RhdGUua2V5Ym9hcmRFdmVudEVuYWJsZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGF3YWl0IGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcbiAgICAgICAgbGF5ZXJJZDogXCJrZXlib2FyZFwiLFxuICAgICAgICBldmVudDoge1xuICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdHlwZTogZXZlbnRUeXBlLFxuICAgICAgICAgICAga2V5OiBldmVudC5rZXksXG4gICAgICAgICAgICBjdHJsS2V5OiBldmVudC5jdHJsS2V5LFxuICAgICAgICAgICAgc2hpZnRLZXk6IGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgYWx0S2V5OiBldmVudC5hbHRLZXksXG4gICAgICAgICAgICBtZXRhS2V5OiBldmVudC5tZXRhS2V5XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aXRsZTogZXZlbnQua2V5XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xuICBhcGkuYWRkVGltZWxpbmVMYXllcih7XG4gICAgaWQ6IENPTVBPTkVOVF9FVkVOVF9MQVlFUl9JRCxcbiAgICBsYWJlbDogXCJDb21wb25lbnQgZXZlbnRzXCIsXG4gICAgY29sb3I6IDUyMjY2MzdcbiAgfSk7XG4gIGhvb2sub24uY29tcG9uZW50RW1pdChhc3luYyAoYXBwLCBpbnN0YW5jZSwgZXZlbnQsIHBhcmFtcykgPT4ge1xuICAgIGlmICghZGV2dG9vbHNTdGF0ZS50aW1lbGluZUxheWVyc1N0YXRlLnJlY29yZGluZ1N0YXRlIHx8ICFkZXZ0b29sc1N0YXRlLnRpbWVsaW5lTGF5ZXJzU3RhdGUuY29tcG9uZW50RXZlbnRFbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGFwcFJlY29yZCA9IGF3YWl0IGdldEFwcFJlY29yZChhcHApO1xuICAgIGlmICghYXBwUmVjb3JkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNvbXBvbmVudElkID0gYCR7YXBwUmVjb3JkLmlkfToke2luc3RhbmNlLnVpZH1gO1xuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBnZXRJbnN0YW5jZU5hbWUoaW5zdGFuY2UpIHx8IFwiVW5rbm93biBDb21wb25lbnRcIjtcbiAgICBhcGkuYWRkVGltZWxpbmVFdmVudCh7XG4gICAgICBsYXllcklkOiBDT01QT05FTlRfRVZFTlRfTEFZRVJfSUQsXG4gICAgICBldmVudDoge1xuICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgY29tcG9uZW50OiB7XG4gICAgICAgICAgICBfY3VzdG9tOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiY29tcG9uZW50LWRlZmluaXRpb25cIixcbiAgICAgICAgICAgICAgZGlzcGxheTogY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgcGFyYW1zXG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlOiBldmVudCxcbiAgICAgICAgc3VidGl0bGU6IGBieSAke2NvbXBvbmVudE5hbWV9YCxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIGNvbXBvbmVudElkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIGFwaS5hZGRUaW1lbGluZUxheWVyKHtcbiAgICBpZDogXCJwZXJmb3JtYW5jZVwiLFxuICAgIGxhYmVsOiBQRVJGT1JNQU5DRV9FVkVOVF9MQVlFUl9JRCxcbiAgICBjb2xvcjogNDMwNzA1MFxuICB9KTtcbiAgaG9vay5vbi5wZXJmU3RhcnQoKGFwcCwgdWlkLCB2bSwgdHlwZSwgdGltZSkgPT4ge1xuICAgIGlmICghZGV2dG9vbHNTdGF0ZS50aW1lbGluZUxheWVyc1N0YXRlLnJlY29yZGluZ1N0YXRlIHx8ICFkZXZ0b29sc1N0YXRlLnRpbWVsaW5lTGF5ZXJzU3RhdGUucGVyZm9ybWFuY2VFdmVudEVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgcGVyZm9ybWFuY2VNYXJrU3RhcnQoYXBpLCBhcHAsIHVpZCwgdm0sIHR5cGUsIHRpbWUpO1xuICB9KTtcbiAgaG9vay5vbi5wZXJmRW5kKChhcHAsIHVpZCwgdm0sIHR5cGUsIHRpbWUpID0+IHtcbiAgICBpZiAoIWRldnRvb2xzU3RhdGUudGltZWxpbmVMYXllcnNTdGF0ZS5yZWNvcmRpbmdTdGF0ZSB8fCAhZGV2dG9vbHNTdGF0ZS50aW1lbGluZUxheWVyc1N0YXRlLnBlcmZvcm1hbmNlRXZlbnRFbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHBlcmZvcm1hbmNlTWFya0VuZChhcGksIGFwcCwgdWlkLCB2bSwgdHlwZSwgdGltZSk7XG4gIH0pO1xufVxuXG4vLyBzcmMvY29yZS92bS9pbmRleC50c1xuaW5pdF9lc21fc2hpbXMoKTtcbnZhciBNQVhfJFZNID0gMTA7XG52YXIgJHZtUXVldWUgPSBbXTtcbmZ1bmN0aW9uIGV4cG9zZUluc3RhbmNlVG9XaW5kb3coY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgcmV0dXJuO1xuICBjb25zdCB3aW4gPSB3aW5kb3c7XG4gIGlmICghY29tcG9uZW50SW5zdGFuY2UpXG4gICAgcmV0dXJuO1xuICB3aW4uJHZtID0gY29tcG9uZW50SW5zdGFuY2U7XG4gIGlmICgkdm1RdWV1ZVswXSAhPT0gY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICBpZiAoJHZtUXVldWUubGVuZ3RoID49IE1BWF8kVk0pIHtcbiAgICAgICR2bVF1ZXVlLnBvcCgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gJHZtUXVldWUubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICB3aW5bYCR2bSR7aX1gXSA9ICR2bVF1ZXVlW2ldID0gJHZtUXVldWVbaSAtIDFdO1xuICAgIH1cbiAgICB3aW4uJHZtMCA9ICR2bVF1ZXVlWzBdID0gY29tcG9uZW50SW5zdGFuY2U7XG4gIH1cbn1cblxuLy8gc3JjL2NvcmUvcGx1Z2luL2NvbXBvbmVudHMudHNcbnZhciBJTlNQRUNUT1JfSUQgPSBcImNvbXBvbmVudHNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudHNEZXZUb29sc1BsdWdpbihhcHApIHtcbiAgY29uc3QgZGVzY3JpcHRvciA9IHtcbiAgICBpZDogSU5TUEVDVE9SX0lELFxuICAgIGxhYmVsOiBcIkNvbXBvbmVudHNcIixcbiAgICBhcHBcbiAgfTtcbiAgY29uc3Qgc2V0dXBGbiA9IChhcGkpID0+IHtcbiAgICBhcGkuYWRkSW5zcGVjdG9yKHtcbiAgICAgIGlkOiBJTlNQRUNUT1JfSUQsXG4gICAgICBsYWJlbDogXCJDb21wb25lbnRzXCIsXG4gICAgICB0cmVlRmlsdGVyUGxhY2Vob2xkZXI6IFwiU2VhcmNoIGNvbXBvbmVudHNcIlxuICAgIH0pO1xuICAgIHNldHVwQnVpbHRpblRpbWVsaW5lTGF5ZXJzKGFwaSk7XG4gICAgYXBpLm9uLmdldEluc3BlY3RvclRyZWUoYXN5bmMgKHBheWxvYWQpID0+IHtcbiAgICAgIGlmIChwYXlsb2FkLmFwcCA9PT0gYXBwICYmIHBheWxvYWQuaW5zcGVjdG9ySWQgPT09IElOU1BFQ1RPUl9JRCkge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldENvbXBvbmVudEluc3RhbmNlKGFjdGl2ZUFwcFJlY29yZC52YWx1ZSwgcGF5bG9hZC5pbnN0YW5jZUlkKTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgY29uc3Qgd2Fsa2VyMiA9IG5ldyBDb21wb25lbnRXYWxrZXIoe1xuICAgICAgICAgICAgZmlsdGVyVGV4dDogcGF5bG9hZC5maWx0ZXIsXG4gICAgICAgICAgICAvLyBAVE9ETzogc2hvdWxkIG1ha2UgdGhpcyBjb25maWd1cmFibGU/XG4gICAgICAgICAgICBtYXhEZXB0aDogMTAwLFxuICAgICAgICAgICAgcmVjdXJzaXZlbHk6IGZhbHNlLFxuICAgICAgICAgICAgYXBpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcGF5bG9hZC5yb290Tm9kZXMgPSBhd2FpdCB3YWxrZXIyLmdldENvbXBvbmVudFRyZWUoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXBpLm9uLmdldEluc3BlY3RvclN0YXRlKGFzeW5jIChwYXlsb2FkKSA9PiB7XG4gICAgICB2YXIgX2EyNTtcbiAgICAgIGlmIChwYXlsb2FkLmFwcCA9PT0gYXBwICYmIHBheWxvYWQuaW5zcGVjdG9ySWQgPT09IElOU1BFQ1RPUl9JRCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBnZXRJbnN0YW5jZVN0YXRlKHtcbiAgICAgICAgICBpbnN0YW5jZUlkOiBwYXlsb2FkLm5vZGVJZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50SW5zdGFuY2UgPSByZXN1bHQuaW5zdGFuY2U7XG4gICAgICAgIGNvbnN0IGFwcDIgPSAoX2EyNSA9IHJlc3VsdC5pbnN0YW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjUuYXBwQ29udGV4dC5hcHA7XG4gICAgICAgIGNvbnN0IF9wYXlsb2FkID0ge1xuICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlLFxuICAgICAgICAgIGFwcDogYXBwMixcbiAgICAgICAgICBpbnN0YW5jZURhdGE6IHJlc3VsdFxuICAgICAgICB9O1xuICAgICAgICBkZXZ0b29sc0NvbnRleHQuaG9va3MuY2FsbEhvb2tXaXRoKChjYWxsYmFja3MpID0+IHtcbiAgICAgICAgICBjYWxsYmFja3MuZm9yRWFjaCgoY2IpID0+IGNiKF9wYXlsb2FkKSk7XG4gICAgICAgIH0sIFwiaW5zcGVjdENvbXBvbmVudFwiIC8qIElOU1BFQ1RfQ09NUE9ORU5UICovKTtcbiAgICAgICAgcGF5bG9hZC5zdGF0ZSA9IHJlc3VsdDtcbiAgICAgICAgZXhwb3NlSW5zdGFuY2VUb1dpbmRvdyhjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXBpLm9uLmVkaXRJbnNwZWN0b3JTdGF0ZShhc3luYyAocGF5bG9hZCkgPT4ge1xuICAgICAgaWYgKHBheWxvYWQuYXBwID09PSBhcHAgJiYgcGF5bG9hZC5pbnNwZWN0b3JJZCA9PT0gSU5TUEVDVE9SX0lEKSB7XG4gICAgICAgIGVkaXRTdGF0ZShwYXlsb2FkKTtcbiAgICAgICAgYXdhaXQgYXBpLnNlbmRJbnNwZWN0b3JTdGF0ZShcImNvbXBvbmVudHNcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZGVib3VuY2VTZW5kSW5zcGVjdG9yVHJlZSA9IGRlYm91bmNlNCgoKSA9PiB7XG4gICAgICBhcGkuc2VuZEluc3BlY3RvclRyZWUoSU5TUEVDVE9SX0lEKTtcbiAgICB9LCAxMjApO1xuICAgIGNvbnN0IGRlYm91bmNlU2VuZEluc3BlY3RvclN0YXRlID0gZGVib3VuY2U0KCgpID0+IHtcbiAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUoSU5TUEVDVE9SX0lEKTtcbiAgICB9LCAxMjApO1xuICAgIGNvbnN0IGNvbXBvbmVudEFkZGVkQ2xlYW51cCA9IGhvb2sub24uY29tcG9uZW50QWRkZWQoYXN5bmMgKGFwcDIsIHVpZCwgcGFyZW50VWlkLCBjb21wb25lbnQpID0+IHtcbiAgICAgIHZhciBfYTI1LCBfYjI1LCBfYztcbiAgICAgIGlmIChkZXZ0b29sc1N0YXRlLmhpZ2hQZXJmTW9kZUVuYWJsZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICgoX2MgPSAoX2IyNSA9IChfYTI1ID0gYXBwMiA9PSBudWxsID8gdm9pZCAwIDogYXBwMi5faW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTI1LnR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYjI1LmRldnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2MuaGlkZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCFhcHAyIHx8IHR5cGVvZiB1aWQgIT09IFwibnVtYmVyXCIgJiYgIXVpZCB8fCAhY29tcG9uZW50KVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBpZCA9IGF3YWl0IGdldENvbXBvbmVudElkKHtcbiAgICAgICAgYXBwOiBhcHAyLFxuICAgICAgICB1aWQsXG4gICAgICAgIGluc3RhbmNlOiBjb21wb25lbnRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYXBwUmVjb3JkID0gYXdhaXQgZ2V0QXBwUmVjb3JkKGFwcDIpO1xuICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoY29tcG9uZW50Ll9fVlVFX0RFVlRPT0xTX05FWFRfVUlEX18gPT0gbnVsbClcbiAgICAgICAgICBjb21wb25lbnQuX19WVUVfREVWVE9PTFNfTkVYVF9VSURfXyA9IGlkO1xuICAgICAgICBpZiAoIShhcHBSZWNvcmQgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcFJlY29yZC5pbnN0YW5jZU1hcC5oYXMoaWQpKSkge1xuICAgICAgICAgIGFwcFJlY29yZCA9PSBudWxsID8gdm9pZCAwIDogYXBwUmVjb3JkLmluc3RhbmNlTWFwLnNldChpZCwgY29tcG9uZW50KTtcbiAgICAgICAgICBpZiAoYWN0aXZlQXBwUmVjb3JkLnZhbHVlLmlkID09PSAoYXBwUmVjb3JkID09IG51bGwgPyB2b2lkIDAgOiBhcHBSZWNvcmQuaWQpKVxuICAgICAgICAgICAgYWN0aXZlQXBwUmVjb3JkLnZhbHVlLmluc3RhbmNlTWFwID0gYXBwUmVjb3JkLmluc3RhbmNlTWFwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWFwcFJlY29yZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVib3VuY2VTZW5kSW5zcGVjdG9yVHJlZSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGNvbXBvbmVudFVwZGF0ZWRDbGVhbnVwID0gaG9vay5vbi5jb21wb25lbnRVcGRhdGVkKGFzeW5jIChhcHAyLCB1aWQsIHBhcmVudFVpZCwgY29tcG9uZW50KSA9PiB7XG4gICAgICB2YXIgX2EyNSwgX2IyNSwgX2M7XG4gICAgICBpZiAoZGV2dG9vbHNTdGF0ZS5oaWdoUGVyZk1vZGVFbmFibGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoKF9jID0gKF9iMjUgPSAoX2EyNSA9IGFwcDIgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcDIuX2luc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyNS50eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2IyNS5kZXZ0b29scykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmhpZGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICghYXBwMiB8fCB0eXBlb2YgdWlkICE9PSBcIm51bWJlclwiICYmICF1aWQgfHwgIWNvbXBvbmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgaWQgPSBhd2FpdCBnZXRDb21wb25lbnRJZCh7XG4gICAgICAgIGFwcDogYXBwMixcbiAgICAgICAgdWlkLFxuICAgICAgICBpbnN0YW5jZTogY29tcG9uZW50XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFwcFJlY29yZCA9IGF3YWl0IGdldEFwcFJlY29yZChhcHAyKTtcbiAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudC5fX1ZVRV9ERVZUT09MU19ORVhUX1VJRF9fID09IG51bGwpXG4gICAgICAgICAgY29tcG9uZW50Ll9fVlVFX0RFVlRPT0xTX05FWFRfVUlEX18gPSBpZDtcbiAgICAgICAgaWYgKCEoYXBwUmVjb3JkID09IG51bGwgPyB2b2lkIDAgOiBhcHBSZWNvcmQuaW5zdGFuY2VNYXAuaGFzKGlkKSkpIHtcbiAgICAgICAgICBhcHBSZWNvcmQgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcFJlY29yZC5pbnN0YW5jZU1hcC5zZXQoaWQsIGNvbXBvbmVudCk7XG4gICAgICAgICAgaWYgKGFjdGl2ZUFwcFJlY29yZC52YWx1ZS5pZCA9PT0gKGFwcFJlY29yZCA9PSBudWxsID8gdm9pZCAwIDogYXBwUmVjb3JkLmlkKSlcbiAgICAgICAgICAgIGFjdGl2ZUFwcFJlY29yZC52YWx1ZS5pbnN0YW5jZU1hcCA9IGFwcFJlY29yZC5pbnN0YW5jZU1hcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFhcHBSZWNvcmQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlYm91bmNlU2VuZEluc3BlY3RvclRyZWUoKTtcbiAgICAgIGRlYm91bmNlU2VuZEluc3BlY3RvclN0YXRlKCk7XG4gICAgfSk7XG4gICAgY29uc3QgY29tcG9uZW50UmVtb3ZlZENsZWFudXAgPSBob29rLm9uLmNvbXBvbmVudFJlbW92ZWQoYXN5bmMgKGFwcDIsIHVpZCwgcGFyZW50VWlkLCBjb21wb25lbnQpID0+IHtcbiAgICAgIHZhciBfYTI1LCBfYjI1LCBfYztcbiAgICAgIGlmIChkZXZ0b29sc1N0YXRlLmhpZ2hQZXJmTW9kZUVuYWJsZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICgoX2MgPSAoX2IyNSA9IChfYTI1ID0gYXBwMiA9PSBudWxsID8gdm9pZCAwIDogYXBwMi5faW5zdGFuY2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTI1LnR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYjI1LmRldnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2MuaGlkZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCFhcHAyIHx8IHR5cGVvZiB1aWQgIT09IFwibnVtYmVyXCIgJiYgIXVpZCB8fCAhY29tcG9uZW50KVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBhcHBSZWNvcmQgPSBhd2FpdCBnZXRBcHBSZWNvcmQoYXBwMik7XG4gICAgICBpZiAoIWFwcFJlY29yZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgaWQgPSBhd2FpdCBnZXRDb21wb25lbnRJZCh7XG4gICAgICAgIGFwcDogYXBwMixcbiAgICAgICAgdWlkLFxuICAgICAgICBpbnN0YW5jZTogY29tcG9uZW50XG4gICAgICB9KTtcbiAgICAgIGFwcFJlY29yZCA9PSBudWxsID8gdm9pZCAwIDogYXBwUmVjb3JkLmluc3RhbmNlTWFwLmRlbGV0ZShpZCk7XG4gICAgICBpZiAoYWN0aXZlQXBwUmVjb3JkLnZhbHVlLmlkID09PSAoYXBwUmVjb3JkID09IG51bGwgPyB2b2lkIDAgOiBhcHBSZWNvcmQuaWQpKVxuICAgICAgICBhY3RpdmVBcHBSZWNvcmQudmFsdWUuaW5zdGFuY2VNYXAgPSBhcHBSZWNvcmQuaW5zdGFuY2VNYXA7XG4gICAgICBkZWJvdW5jZVNlbmRJbnNwZWN0b3JUcmVlKCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBbZGVzY3JpcHRvciwgc2V0dXBGbl07XG59XG5cbi8vIHNyYy9jb3JlL3BsdWdpbi9pbmRleC50c1xudmFyIF9hMTIsIF9iMTI7XG4oX2IxMiA9IChfYTEyID0gdGFyZ2V0OCkuX19WVUVfREVWVE9PTFNfS0lUX19SRUdJU1RFUkVEX1BMVUdJTl9BUFBTX18pICE9IG51bGwgPyBfYjEyIDogX2ExMi5fX1ZVRV9ERVZUT09MU19LSVRfX1JFR0lTVEVSRURfUExVR0lOX0FQUFNfXyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5mdW5jdGlvbiBzZXR1cERldlRvb2xzUGx1Z2luKHBsdWdpbkRlc2NyaXB0b3IsIHNldHVwRm4pIHtcbiAgcmV0dXJuIGhvb2suc2V0dXBEZXZUb29sc1BsdWdpbihwbHVnaW5EZXNjcmlwdG9yLCBzZXR1cEZuKTtcbn1cbmZ1bmN0aW9uIGNhbGxEZXZUb29sc1BsdWdpblNldHVwRm4ocGx1Z2luLCBhcHApIHtcbiAgY29uc3QgW3BsdWdpbkRlc2NyaXB0b3IsIHNldHVwRm5dID0gcGx1Z2luO1xuICBpZiAocGx1Z2luRGVzY3JpcHRvci5hcHAgIT09IGFwcClcbiAgICByZXR1cm47XG4gIGNvbnN0IGFwaSA9IG5ldyBEZXZUb29sc1BsdWdpbkFQSSh7XG4gICAgcGx1Z2luOiB7XG4gICAgICBzZXR1cEZuLFxuICAgICAgZGVzY3JpcHRvcjogcGx1Z2luRGVzY3JpcHRvclxuICAgIH0sXG4gICAgY3R4OiBkZXZ0b29sc0NvbnRleHRcbiAgfSk7XG4gIGlmIChwbHVnaW5EZXNjcmlwdG9yLnBhY2thZ2VOYW1lID09PSBcInZ1ZXhcIikge1xuICAgIGFwaS5vbi5lZGl0SW5zcGVjdG9yU3RhdGUoKHBheWxvYWQpID0+IHtcbiAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUocGF5bG9hZC5pbnNwZWN0b3JJZCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0dXBGbihhcGkpO1xufVxuZnVuY3Rpb24gcmVtb3ZlUmVnaXN0ZXJlZFBsdWdpbkFwcChhcHApIHtcbiAgdGFyZ2V0OC5fX1ZVRV9ERVZUT09MU19LSVRfX1JFR0lTVEVSRURfUExVR0lOX0FQUFNfXy5kZWxldGUoYXBwKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGV2VG9vbHNQbHVnaW4oYXBwLCBvcHRpb25zKSB7XG4gIGlmICh0YXJnZXQ4Ll9fVlVFX0RFVlRPT0xTX0tJVF9fUkVHSVNURVJFRF9QTFVHSU5fQVBQU19fLmhhcyhhcHApKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChkZXZ0b29sc1N0YXRlLmhpZ2hQZXJmTW9kZUVuYWJsZWQgJiYgIShvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmluc3BlY3RpbmdDb21wb25lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRhcmdldDguX19WVUVfREVWVE9PTFNfS0lUX19SRUdJU1RFUkVEX1BMVUdJTl9BUFBTX18uYWRkKGFwcCk7XG4gIGRldnRvb2xzUGx1Z2luQnVmZmVyLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgIGNhbGxEZXZUb29sc1BsdWdpblNldHVwRm4ocGx1Z2luLCBhcHApO1xuICB9KTtcbn1cblxuLy8gc3JjL2NvcmUvcm91dGVyL2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgZGVlcENsb25lLCB0YXJnZXQgYXMgZ2xvYmFsMyB9IGZyb20gXCJAdnVlL2RldnRvb2xzLXNoYXJlZFwiO1xuaW1wb3J0IHsgZGVib3VuY2UgYXMgZGVib3VuY2U1IH0gZnJvbSBcInBlcmZlY3QtZGVib3VuY2VcIjtcblxuLy8gc3JjL2N0eC9yb3V0ZXIudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5pbXBvcnQgeyB0YXJnZXQgYXMgZ2xvYmFsMiB9IGZyb20gXCJAdnVlL2RldnRvb2xzLXNoYXJlZFwiO1xudmFyIFJPVVRFUl9LRVkgPSBcIl9fVlVFX0RFVlRPT0xTX1JPVVRFUl9fXCI7XG52YXIgUk9VVEVSX0lORk9fS0VZID0gXCJfX1ZVRV9ERVZUT09MU19ST1VURVJfSU5GT19fXCI7XG52YXIgX2ExMywgX2IxMztcbihfYjEzID0gKF9hMTMgPSBnbG9iYWwyKVtST1VURVJfSU5GT19LRVldKSAhPSBudWxsID8gX2IxMyA6IF9hMTNbUk9VVEVSX0lORk9fS0VZXSA9IHtcbiAgY3VycmVudFJvdXRlOiBudWxsLFxuICByb3V0ZXM6IFtdXG59O1xudmFyIF9hMTQsIF9iMTQ7XG4oX2IxNCA9IChfYTE0ID0gZ2xvYmFsMilbUk9VVEVSX0tFWV0pICE9IG51bGwgPyBfYjE0IDogX2ExNFtST1VURVJfS0VZXSA9IHt9O1xudmFyIGRldnRvb2xzUm91dGVySW5mbyA9IG5ldyBQcm94eShnbG9iYWwyW1JPVVRFUl9JTkZPX0tFWV0sIHtcbiAgZ2V0KHRhcmdldDIyLCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBnbG9iYWwyW1JPVVRFUl9JTkZPX0tFWV1bcHJvcGVydHldO1xuICB9XG59KTtcbnZhciBkZXZ0b29sc1JvdXRlciA9IG5ldyBQcm94eShnbG9iYWwyW1JPVVRFUl9LRVldLCB7XG4gIGdldCh0YXJnZXQyMiwgcHJvcGVydHkpIHtcbiAgICBpZiAocHJvcGVydHkgPT09IFwidmFsdWVcIikge1xuICAgICAgcmV0dXJuIGdsb2JhbDJbUk9VVEVSX0tFWV07XG4gICAgfVxuICB9XG59KTtcblxuLy8gc3JjL2NvcmUvcm91dGVyL2luZGV4LnRzXG5mdW5jdGlvbiBnZXRSb3V0ZXMocm91dGVyKSB7XG4gIGNvbnN0IHJvdXRlc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiAoKHJvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcm91dGVyLmdldFJvdXRlcygpKSB8fCBbXSkuZmlsdGVyKChpKSA9PiAhcm91dGVzTWFwLmhhcyhpLnBhdGgpICYmIHJvdXRlc01hcC5zZXQoaS5wYXRoLCAxKSk7XG59XG5mdW5jdGlvbiBmaWx0ZXJSb3V0ZXMocm91dGVzKSB7XG4gIHJldHVybiByb3V0ZXMubWFwKChpdGVtKSA9PiB7XG4gICAgbGV0IHsgcGF0aCwgbmFtZSwgY2hpbGRyZW4sIG1ldGEgfSA9IGl0ZW07XG4gICAgaWYgKGNoaWxkcmVuID09IG51bGwgPyB2b2lkIDAgOiBjaGlsZHJlbi5sZW5ndGgpXG4gICAgICBjaGlsZHJlbiA9IGZpbHRlclJvdXRlcyhjaGlsZHJlbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBtZXRhXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmaWx0ZXJDdXJyZW50Um91dGUocm91dGUpIHtcbiAgaWYgKHJvdXRlKSB7XG4gICAgY29uc3QgeyBmdWxsUGF0aCwgaGFzaCwgaHJlZiwgcGF0aCwgbmFtZSwgbWF0Y2hlZCwgcGFyYW1zLCBxdWVyeSB9ID0gcm91dGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZ1bGxQYXRoLFxuICAgICAgaGFzaCxcbiAgICAgIGhyZWYsXG4gICAgICBwYXRoLFxuICAgICAgbmFtZSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHF1ZXJ5LFxuICAgICAgbWF0Y2hlZDogZmlsdGVyUm91dGVzKG1hdGNoZWQpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcm91dGU7XG59XG5mdW5jdGlvbiBub3JtYWxpemVSb3V0ZXJJbmZvKGFwcFJlY29yZCwgYWN0aXZlQXBwUmVjb3JkMikge1xuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIHZhciBfYTI1O1xuICAgIGNvbnN0IHJvdXRlciA9IChfYTI1ID0gYXBwUmVjb3JkLmFwcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjUuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMuJHJvdXRlcjtcbiAgICBjb25zdCBjdXJyZW50Um91dGUgPSBmaWx0ZXJDdXJyZW50Um91dGUocm91dGVyID09IG51bGwgPyB2b2lkIDAgOiByb3V0ZXIuY3VycmVudFJvdXRlLnZhbHVlKTtcbiAgICBjb25zdCByb3V0ZXMgPSBmaWx0ZXJSb3V0ZXMoZ2V0Um91dGVzKHJvdXRlcikpO1xuICAgIGNvbnN0IGMgPSBjb25zb2xlLndhcm47XG4gICAgY29uc29sZS53YXJuID0gKCkgPT4ge1xuICAgIH07XG4gICAgZ2xvYmFsM1tST1VURVJfSU5GT19LRVldID0ge1xuICAgICAgY3VycmVudFJvdXRlOiBjdXJyZW50Um91dGUgPyBkZWVwQ2xvbmUoY3VycmVudFJvdXRlKSA6IHt9LFxuICAgICAgcm91dGVzOiBkZWVwQ2xvbmUocm91dGVzKVxuICAgIH07XG4gICAgZ2xvYmFsM1tST1VURVJfS0VZXSA9IHJvdXRlcjtcbiAgICBjb25zb2xlLndhcm4gPSBjO1xuICB9XG4gIGluaXQoKTtcbiAgaG9vay5vbi5jb21wb25lbnRVcGRhdGVkKGRlYm91bmNlNSgoKSA9PiB7XG4gICAgdmFyIF9hMjU7XG4gICAgaWYgKCgoX2EyNSA9IGFjdGl2ZUFwcFJlY29yZDIudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfYTI1LmFwcCkgIT09IGFwcFJlY29yZC5hcHApXG4gICAgICByZXR1cm47XG4gICAgaW5pdCgpO1xuICAgIGlmIChkZXZ0b29sc1N0YXRlLmhpZ2hQZXJmTW9kZUVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgZGV2dG9vbHNDb250ZXh0Lmhvb2tzLmNhbGxIb29rKFwicm91dGVySW5mb1VwZGF0ZWRcIiAvKiBST1VURVJfSU5GT19VUERBVEVEICovLCB7IHN0YXRlOiBnbG9iYWwzW1JPVVRFUl9JTkZPX0tFWV0gfSk7XG4gIH0sIDIwMCkpO1xufVxuXG4vLyBzcmMvY3R4L2FwaS50c1xuZnVuY3Rpb24gY3JlYXRlRGV2VG9vbHNBcGkoaG9va3MyKSB7XG4gIHJldHVybiB7XG4gICAgLy8gZ2V0IGluc3BlY3RvciB0cmVlXG4gICAgYXN5bmMgZ2V0SW5zcGVjdG9yVHJlZShwYXlsb2FkKSB7XG4gICAgICBjb25zdCBfcGF5bG9hZCA9IHtcbiAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgYXBwOiBhY3RpdmVBcHBSZWNvcmQudmFsdWUuYXBwLFxuICAgICAgICByb290Tm9kZXM6IFtdXG4gICAgICB9O1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaG9va3MyLmNhbGxIb29rV2l0aChhc3luYyAoY2FsbGJhY2tzKSA9PiB7XG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2FsbGJhY2tzLm1hcCgoY2IpID0+IGNiKF9wYXlsb2FkKSkpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgXCJnZXRJbnNwZWN0b3JUcmVlXCIgLyogR0VUX0lOU1BFQ1RPUl9UUkVFICovKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9wYXlsb2FkLnJvb3ROb2RlcztcbiAgICB9LFxuICAgIC8vIGdldCBpbnNwZWN0b3Igc3RhdGVcbiAgICBhc3luYyBnZXRJbnNwZWN0b3JTdGF0ZShwYXlsb2FkKSB7XG4gICAgICBjb25zdCBfcGF5bG9hZCA9IHtcbiAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgYXBwOiBhY3RpdmVBcHBSZWNvcmQudmFsdWUuYXBwLFxuICAgICAgICBzdGF0ZTogbnVsbFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgY3VycmVudFRhYjogYGN1c3RvbS1pbnNwZWN0b3I6JHtwYXlsb2FkLmluc3BlY3RvcklkfWBcbiAgICAgIH07XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBob29rczIuY2FsbEhvb2tXaXRoKGFzeW5jIChjYWxsYmFja3MpID0+IHtcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjYWxsYmFja3MubWFwKChjYikgPT4gY2IoX3BheWxvYWQsIGN0eCkpKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIFwiZ2V0SW5zcGVjdG9yU3RhdGVcIiAvKiBHRVRfSU5TUEVDVE9SX1NUQVRFICovKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9wYXlsb2FkLnN0YXRlO1xuICAgIH0sXG4gICAgLy8gZWRpdCBpbnNwZWN0b3Igc3RhdGVcbiAgICBlZGl0SW5zcGVjdG9yU3RhdGUocGF5bG9hZCkge1xuICAgICAgY29uc3Qgc3RhdGVFZGl0b3IyID0gbmV3IFN0YXRlRWRpdG9yKCk7XG4gICAgICBjb25zdCBfcGF5bG9hZCA9IHtcbiAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgYXBwOiBhY3RpdmVBcHBSZWNvcmQudmFsdWUuYXBwLFxuICAgICAgICBzZXQ6IChvYmosIHBhdGggPSBwYXlsb2FkLnBhdGgsIHZhbHVlID0gcGF5bG9hZC5zdGF0ZS52YWx1ZSwgY2IpID0+IHtcbiAgICAgICAgICBzdGF0ZUVkaXRvcjIuc2V0KG9iaiwgcGF0aCwgdmFsdWUsIGNiIHx8IHN0YXRlRWRpdG9yMi5jcmVhdGVEZWZhdWx0U2V0Q2FsbGJhY2socGF5bG9hZC5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaG9va3MyLmNhbGxIb29rV2l0aCgoY2FsbGJhY2tzKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKChjYikgPT4gY2IoX3BheWxvYWQpKTtcbiAgICAgIH0sIFwiZWRpdEluc3BlY3RvclN0YXRlXCIgLyogRURJVF9JTlNQRUNUT1JfU1RBVEUgKi8pO1xuICAgIH0sXG4gICAgLy8gc2VuZCBpbnNwZWN0b3Igc3RhdGVcbiAgICBzZW5kSW5zcGVjdG9yU3RhdGUoaW5zcGVjdG9ySWQpIHtcbiAgICAgIGNvbnN0IGluc3BlY3RvciA9IGdldEluc3BlY3RvcihpbnNwZWN0b3JJZCk7XG4gICAgICBob29rczIuY2FsbEhvb2soXCJzZW5kSW5zcGVjdG9yU3RhdGVcIiAvKiBTRU5EX0lOU1BFQ1RPUl9TVEFURSAqLywgeyBpbnNwZWN0b3JJZCwgcGx1Z2luOiB7XG4gICAgICAgIGRlc2NyaXB0b3I6IGluc3BlY3Rvci5kZXNjcmlwdG9yLFxuICAgICAgICBzZXR1cEZuOiAoKSA9PiAoe30pXG4gICAgICB9IH0pO1xuICAgIH0sXG4gICAgLy8gaW5zcGVjdCBjb21wb25lbnQgaW5zcGVjdG9yXG4gICAgaW5zcGVjdENvbXBvbmVudEluc3BlY3RvcigpIHtcbiAgICAgIHJldHVybiBpbnNwZWN0Q29tcG9uZW50SGlnaExpZ2h0ZXIoKTtcbiAgICB9LFxuICAgIC8vIGNhbmNlbCBpbnNwZWN0IGNvbXBvbmVudCBpbnNwZWN0b3JcbiAgICBjYW5jZWxJbnNwZWN0Q29tcG9uZW50SW5zcGVjdG9yKCkge1xuICAgICAgcmV0dXJuIGNhbmNlbEluc3BlY3RDb21wb25lbnRIaWdoTGlnaHRlcigpO1xuICAgIH0sXG4gICAgLy8gZ2V0IGNvbXBvbmVudCByZW5kZXIgY29kZVxuICAgIGdldENvbXBvbmVudFJlbmRlckNvZGUoaWQpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q29tcG9uZW50SW5zdGFuY2UoYWN0aXZlQXBwUmVjb3JkLnZhbHVlLCBpZCk7XG4gICAgICBpZiAoaW5zdGFuY2UpXG4gICAgICAgIHJldHVybiAhKHR5cGVvZiAoaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLnR5cGUpID09PSBcImZ1bmN0aW9uXCIpID8gaW5zdGFuY2UucmVuZGVyLnRvU3RyaW5nKCkgOiBpbnN0YW5jZS50eXBlLnRvU3RyaW5nKCk7XG4gICAgfSxcbiAgICAvLyBzY3JvbGwgdG8gY29tcG9uZW50XG4gICAgc2Nyb2xsVG9Db21wb25lbnQoaWQpIHtcbiAgICAgIHJldHVybiBzY3JvbGxUb0NvbXBvbmVudCh7IGlkIH0pO1xuICAgIH0sXG4gICAgLy8gb3BlbiBpbiBlZGl0b3JcbiAgICBvcGVuSW5FZGl0b3IsXG4gICAgLy8gZ2V0IHZ1ZSBpbnNwZWN0b3JcbiAgICBnZXRWdWVJbnNwZWN0b3I6IGdldENvbXBvbmVudEluc3BlY3RvcixcbiAgICAvLyB0b2dnbGUgYXBwXG4gICAgdG9nZ2xlQXBwKGlkLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBhcHBSZWNvcmQgPSBkZXZ0b29sc0FwcFJlY29yZHMudmFsdWUuZmluZCgocmVjb3JkKSA9PiByZWNvcmQuaWQgPT09IGlkKTtcbiAgICAgIGlmIChhcHBSZWNvcmQpIHtcbiAgICAgICAgc2V0QWN0aXZlQXBwUmVjb3JkSWQoaWQpO1xuICAgICAgICBzZXRBY3RpdmVBcHBSZWNvcmQoYXBwUmVjb3JkKTtcbiAgICAgICAgbm9ybWFsaXplUm91dGVySW5mbyhhcHBSZWNvcmQsIGFjdGl2ZUFwcFJlY29yZCk7XG4gICAgICAgIGNhbGxJbnNwZWN0b3JVcGRhdGVkSG9vaygpO1xuICAgICAgICByZWdpc3RlckRldlRvb2xzUGx1Z2luKGFwcFJlY29yZC5hcHAsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gaW5zcGVjdCBkb21cbiAgICBpbnNwZWN0RE9NKGluc3RhbmNlSWQpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q29tcG9uZW50SW5zdGFuY2UoYWN0aXZlQXBwUmVjb3JkLnZhbHVlLCBpbnN0YW5jZUlkKTtcbiAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICBjb25zdCBbZWxdID0gZ2V0Um9vdEVsZW1lbnRzRnJvbUNvbXBvbmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgdGFyZ2V0OS5fX1ZVRV9ERVZUT09MU19JTlNQRUNUX0RPTV9UQVJHRVRfXyA9IGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGVQbHVnaW5TZXR0aW5ncyhwbHVnaW5JZCwga2V5LCB2YWx1ZSkge1xuICAgICAgc2V0UGx1Z2luU2V0dGluZ3MocGx1Z2luSWQsIGtleSwgdmFsdWUpO1xuICAgIH0sXG4gICAgZ2V0UGx1Z2luU2V0dGluZ3MocGx1Z2luSWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9wdGlvbnM6IGdldFBsdWdpblNldHRpbmdzT3B0aW9ucyhwbHVnaW5JZCksXG4gICAgICAgIHZhbHVlczogZ2V0UGx1Z2luU2V0dGluZ3MocGx1Z2luSWQpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2N0eC9lbnYudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5pbXBvcnQgeyB0YXJnZXQgYXMgdGFyZ2V0MTAgfSBmcm9tIFwiQHZ1ZS9kZXZ0b29scy1zaGFyZWRcIjtcbnZhciBfYTE1LCBfYjE1O1xuKF9iMTUgPSAoX2ExNSA9IHRhcmdldDEwKS5fX1ZVRV9ERVZUT09MU19FTlZfXykgIT0gbnVsbCA/IF9iMTUgOiBfYTE1Ll9fVlVFX0RFVlRPT0xTX0VOVl9fID0ge1xuICB2aXRlUGx1Z2luRGV0ZWN0ZWQ6IGZhbHNlXG59O1xuZnVuY3Rpb24gZ2V0RGV2VG9vbHNFbnYoKSB7XG4gIHJldHVybiB0YXJnZXQxMC5fX1ZVRV9ERVZUT09MU19FTlZfXztcbn1cbmZ1bmN0aW9uIHNldERldlRvb2xzRW52KGVudikge1xuICB0YXJnZXQxMC5fX1ZVRV9ERVZUT09MU19FTlZfXyA9IHtcbiAgICAuLi50YXJnZXQxMC5fX1ZVRV9ERVZUT09MU19FTlZfXyxcbiAgICAuLi5lbnZcbiAgfTtcbn1cblxuLy8gc3JjL2N0eC9pbmRleC50c1xudmFyIGhvb2tzID0gY3JlYXRlRGV2VG9vbHNDdHhIb29rcygpO1xudmFyIF9hMTYsIF9iMTY7XG4oX2IxNiA9IChfYTE2ID0gdGFyZ2V0MTEpLl9fVlVFX0RFVlRPT0xTX0tJVF9DT05URVhUX18pICE9IG51bGwgPyBfYjE2IDogX2ExNi5fX1ZVRV9ERVZUT09MU19LSVRfQ09OVEVYVF9fID0ge1xuICBob29rcyxcbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kZXZ0b29sc1N0YXRlLFxuICAgICAgYWN0aXZlQXBwUmVjb3JkSWQ6IGFjdGl2ZUFwcFJlY29yZC5pZCxcbiAgICAgIGFjdGl2ZUFwcFJlY29yZDogYWN0aXZlQXBwUmVjb3JkLnZhbHVlLFxuICAgICAgYXBwUmVjb3JkczogZGV2dG9vbHNBcHBSZWNvcmRzLnZhbHVlXG4gICAgfTtcbiAgfSxcbiAgYXBpOiBjcmVhdGVEZXZUb29sc0FwaShob29rcylcbn07XG52YXIgZGV2dG9vbHNDb250ZXh0ID0gdGFyZ2V0MTEuX19WVUVfREVWVE9PTFNfS0lUX0NPTlRFWFRfXztcblxuLy8gc3JjL2NvcmUvYXBwL2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xudmFyIGltcG9ydF9zcGVha2luZ3VybCA9IF9fdG9FU00ocmVxdWlyZV9zcGVha2luZ3VybDIoKSwgMSk7XG5pbXBvcnQgeyBpc0Jyb3dzZXIgYXMgaXNCcm93c2VyMywgdGFyZ2V0IGFzIHRhcmdldDEyIH0gZnJvbSBcIkB2dWUvZGV2dG9vbHMtc2hhcmVkXCI7XG52YXIgX2ExNywgX2IxNztcbnZhciBhcHBSZWNvcmRJbmZvID0gKF9iMTcgPSAoX2ExNyA9IHRhcmdldDEyKS5fX1ZVRV9ERVZUT09MU19ORVhUX0FQUF9SRUNPUkRfSU5GT19fKSAhPSBudWxsID8gX2IxNyA6IF9hMTcuX19WVUVfREVWVE9PTFNfTkVYVF9BUFBfUkVDT1JEX0lORk9fXyA9IHtcbiAgaWQ6IDAsXG4gIGFwcElkczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxufTtcbmZ1bmN0aW9uIGdldEFwcFJlY29yZE5hbWUoYXBwLCBmYWxsYmFja05hbWUpIHtcbiAgdmFyIF9hMjU7XG4gIHJldHVybiAoKF9hMjUgPSBhcHAgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcC5fY29tcG9uZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyNS5uYW1lKSB8fCBgQXBwICR7ZmFsbGJhY2tOYW1lfWA7XG59XG5mdW5jdGlvbiBnZXRBcHBSb290SW5zdGFuY2UoYXBwKSB7XG4gIHZhciBfYTI1LCBfYjI1LCBfYywgX2Q7XG4gIGlmIChhcHAuX2luc3RhbmNlKVxuICAgIHJldHVybiBhcHAuX2luc3RhbmNlO1xuICBlbHNlIGlmICgoX2IyNSA9IChfYTI1ID0gYXBwLl9jb250YWluZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYTI1Ll92bm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMjUuY29tcG9uZW50KVxuICAgIHJldHVybiAoX2QgPSAoX2MgPSBhcHAuX2NvbnRhaW5lcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLl92bm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIHJlbW92ZUFwcFJlY29yZElkKGFwcCkge1xuICBjb25zdCBpZCA9IGFwcC5fX1ZVRV9ERVZUT09MU19ORVhUX0FQUF9SRUNPUkRfSURfXztcbiAgaWYgKGlkICE9IG51bGwpIHtcbiAgICBhcHBSZWNvcmRJbmZvLmFwcElkcy5kZWxldGUoaWQpO1xuICAgIGFwcFJlY29yZEluZm8uaWQtLTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QXBwUmVjb3JkSWQoYXBwLCBkZWZhdWx0SWQpIHtcbiAgaWYgKGFwcC5fX1ZVRV9ERVZUT09MU19ORVhUX0FQUF9SRUNPUkRfSURfXyAhPSBudWxsKVxuICAgIHJldHVybiBhcHAuX19WVUVfREVWVE9PTFNfTkVYVF9BUFBfUkVDT1JEX0lEX187XG4gIGxldCBpZCA9IGRlZmF1bHRJZCAhPSBudWxsID8gZGVmYXVsdElkIDogKGFwcFJlY29yZEluZm8uaWQrKykudG9TdHJpbmcoKTtcbiAgaWYgKGRlZmF1bHRJZCAmJiBhcHBSZWNvcmRJbmZvLmFwcElkcy5oYXMoaWQpKSB7XG4gICAgbGV0IGNvdW50ID0gMTtcbiAgICB3aGlsZSAoYXBwUmVjb3JkSW5mby5hcHBJZHMuaGFzKGAke2RlZmF1bHRJZH1fJHtjb3VudH1gKSlcbiAgICAgIGNvdW50Kys7XG4gICAgaWQgPSBgJHtkZWZhdWx0SWR9XyR7Y291bnR9YDtcbiAgfVxuICBhcHBSZWNvcmRJbmZvLmFwcElkcy5hZGQoaWQpO1xuICBhcHAuX19WVUVfREVWVE9PTFNfTkVYVF9BUFBfUkVDT1JEX0lEX18gPSBpZDtcbiAgcmV0dXJuIGlkO1xufVxuZnVuY3Rpb24gY3JlYXRlQXBwUmVjb3JkKGFwcCwgdHlwZXMpIHtcbiAgdmFyIF9hMjUsIF9iMjU7XG4gIGNvbnN0IHJvb3RJbnN0YW5jZSA9IGdldEFwcFJvb3RJbnN0YW5jZShhcHApO1xuICBpZiAocm9vdEluc3RhbmNlKSB7XG4gICAgYXBwUmVjb3JkSW5mby5pZCsrO1xuICAgIGNvbnN0IG5hbWUgPSBnZXRBcHBSZWNvcmROYW1lKGFwcCwgYXBwUmVjb3JkSW5mby5pZC50b1N0cmluZygpKTtcbiAgICBjb25zdCBpZCA9IGdldEFwcFJlY29yZElkKGFwcCwgKDAsIGltcG9ydF9zcGVha2luZ3VybC5kZWZhdWx0KShuYW1lKSk7XG4gICAgY29uc3QgW2VsXSA9IGdldFJvb3RFbGVtZW50c0Zyb21Db21wb25lbnRJbnN0YW5jZShyb290SW5zdGFuY2UpO1xuICAgIGNvbnN0IHJlY29yZCA9IHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIHR5cGVzLFxuICAgICAgaW5zdGFuY2VNYXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBwZXJmR3JvdXBJZHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICByb290SW5zdGFuY2UsXG4gICAgICBpZnJhbWU6IGlzQnJvd3NlcjMgJiYgZG9jdW1lbnQgIT09IChlbCA9PSBudWxsID8gdm9pZCAwIDogZWwub3duZXJEb2N1bWVudCkgPyAoX2IyNSA9IChfYTI1ID0gZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTI1LmxvY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2IyNS5wYXRobmFtZSA6IHZvaWQgMFxuICAgIH07XG4gICAgYXBwLl9fVlVFX0RFVlRPT0xTX05FWFRfQVBQX1JFQ09SRF9fID0gcmVjb3JkO1xuICAgIGNvbnN0IHJvb3RJZCA9IGAke3JlY29yZC5pZH06cm9vdGA7XG4gICAgcmVjb3JkLmluc3RhbmNlTWFwLnNldChyb290SWQsIHJlY29yZC5yb290SW5zdGFuY2UpO1xuICAgIHJlY29yZC5yb290SW5zdGFuY2UuX19WVUVfREVWVE9PTFNfTkVYVF9VSURfXyA9IHJvb3RJZDtcbiAgICByZXR1cm4gcmVjb3JkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG4vLyBzcmMvY29yZS9pZnJhbWUvaW5kZXgudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5mdW5jdGlvbiBkZXRlY3RJZnJhbWVBcHAodGFyZ2V0MjIsIGluSWZyYW1lID0gZmFsc2UpIHtcbiAgaWYgKGluSWZyYW1lKSB7XG4gICAgbGV0IHNlbmRFdmVudFRvUGFyZW50MiA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBob29rMyA9IHdpbmRvdy5wYXJlbnQuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbiAgICAgICAgaWYgKGhvb2szKSB7XG4gICAgICAgICAgY2IoaG9vazMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc2VuZEV2ZW50VG9QYXJlbnQgPSBzZW5kRXZlbnRUb1BhcmVudDI7XG4gICAgY29uc3QgaG9vazIgPSB7XG4gICAgICBpZDogXCJ2dWUtZGV2dG9vbHMtbmV4dFwiLFxuICAgICAgZGV2dG9vbHNWZXJzaW9uOiBcIjcuMFwiLFxuICAgICAgb246IChldmVudCwgY2IpID0+IHtcbiAgICAgICAgc2VuZEV2ZW50VG9QYXJlbnQyKChob29rMykgPT4ge1xuICAgICAgICAgIGhvb2szLm9uKGV2ZW50LCBjYik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9uY2U6IChldmVudCwgY2IpID0+IHtcbiAgICAgICAgc2VuZEV2ZW50VG9QYXJlbnQyKChob29rMykgPT4ge1xuICAgICAgICAgIGhvb2szLm9uY2UoZXZlbnQsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb2ZmOiAoZXZlbnQsIGNiKSA9PiB7XG4gICAgICAgIHNlbmRFdmVudFRvUGFyZW50MigoaG9vazMpID0+IHtcbiAgICAgICAgICBob29rMy5vZmYoZXZlbnQsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZW1pdDogKGV2ZW50LCAuLi5wYXlsb2FkKSA9PiB7XG4gICAgICAgIHNlbmRFdmVudFRvUGFyZW50MigoaG9vazMpID0+IHtcbiAgICAgICAgICBob29rMy5lbWl0KGV2ZW50LCAuLi5wYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0MjIsIFwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfX1wiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBob29rMjtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBpbmplY3RWdWVIb29rVG9JZnJhbWUoaWZyYW1lKSB7XG4gICAgaWYgKGlmcmFtZS5fX3ZkZXZ0b29sc19faW5qZWN0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmcmFtZS5fX3ZkZXZ0b29sc19faW5qZWN0ZWQgPSB0cnVlO1xuICAgICAgY29uc3QgaW5qZWN0ID0gKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93Ll9fVlVFX0RFVlRPT0xTX0lGUkFNRV9fID0gaWZyYW1lO1xuICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IGlmcmFtZS5jb250ZW50RG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICBzY3JpcHQudGV4dENvbnRlbnQgPSBgOygke2RldGVjdElmcmFtZUFwcC50b1N0cmluZygpfSkod2luZG93LCB0cnVlKWA7XG4gICAgICAgICAgaWZyYW1lLmNvbnRlbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpbmplY3QoKTtcbiAgICAgIGlmcmFtZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiBpbmplY3QoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbmplY3RWdWVIb29rVG9JZnJhbWVzKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlmcmFtZXMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpZnJhbWU6bm90KFtkYXRhLXZ1ZS1kZXZ0b29scy1pZ25vcmVdKVwiKSk7XG4gICAgZm9yIChjb25zdCBpZnJhbWUgb2YgaWZyYW1lcykge1xuICAgICAgaW5qZWN0VnVlSG9va1RvSWZyYW1lKGlmcmFtZSk7XG4gICAgfVxuICB9XG4gIGluamVjdFZ1ZUhvb2tUb0lmcmFtZXMoKTtcbiAgbGV0IGlmcmFtZUFwcENoZWNrcyA9IDA7XG4gIGNvbnN0IGlmcmFtZUFwcENoZWNrVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgaW5qZWN0VnVlSG9va1RvSWZyYW1lcygpO1xuICAgIGlmcmFtZUFwcENoZWNrcysrO1xuICAgIGlmIChpZnJhbWVBcHBDaGVja3MgPj0gNSkge1xuICAgICAgY2xlYXJJbnRlcnZhbChpZnJhbWVBcHBDaGVja1RpbWVyKTtcbiAgICB9XG4gIH0sIDFlMyk7XG59XG5cbi8vIHNyYy9jb3JlL2luZGV4LnRzXG5mdW5jdGlvbiBpbml0RGV2VG9vbHMoKSB7XG4gIHZhciBfYTI1O1xuICBkZXRlY3RJZnJhbWVBcHAodGFyZ2V0MTMpO1xuICB1cGRhdGVEZXZUb29sc1N0YXRlKHtcbiAgICB2aXRlUGx1Z2luRGV0ZWN0ZWQ6IGdldERldlRvb2xzRW52KCkudml0ZVBsdWdpbkRldGVjdGVkXG4gIH0pO1xuICBjb25zdCBpc0RldlRvb2xzTmV4dCA9ICgoX2EyNSA9IHRhcmdldDEzLl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pID09IG51bGwgPyB2b2lkIDAgOiBfYTI1LmlkKSA9PT0gXCJ2dWUtZGV2dG9vbHMtbmV4dFwiO1xuICBpZiAodGFyZ2V0MTMuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJiBpc0RldlRvb2xzTmV4dClcbiAgICByZXR1cm47XG4gIGNvbnN0IF9kZXZ0b29sc0hvb2sgPSBjcmVhdGVEZXZUb29sc0hvb2soKTtcbiAgaWYgKHRhcmdldDEzLl9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18pIHtcbiAgICB0cnkge1xuICAgICAgdGFyZ2V0MTMuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXy5mb3JFYWNoKChjYikgPT4gY2IoX2RldnRvb2xzSG9vaykpO1xuICAgICAgdGFyZ2V0MTMuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9IFtdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdnVlLWRldnRvb2xzXSBFcnJvciBkdXJpbmcgaG9vayByZXBsYXlcIiwgZSk7XG4gICAgfVxuICB9XG4gIF9kZXZ0b29sc0hvb2sub25jZShcImluaXRcIiwgKFZ1ZSkgPT4ge1xuICAgIHRhcmdldDEzLl9fVlVFX0RFVlRPT0xTX1ZVRTJfQVBQX0RFVEVDVEVEX18gPSB0cnVlO1xuICAgIGNvbnNvbGUubG9nKFwiJWNbX19fX19WdWUgRGV2VG9vbHMgdjcgbG9nX19fX19dXCIsIFwiY29sb3I6IHJlZDsgZm9udC1ib2xkOiA2MDA7IGZvbnQtc2l6ZTogMTZweDtcIik7XG4gICAgY29uc29sZS5sb2coXCIlY1Z1ZSBEZXZUb29scyB2NyBkZXRlY3RlZCBpbiB5b3VyIFZ1ZTIgcHJvamVjdC4gdjcgb25seSBzdXBwb3J0cyBWdWUzIGFuZCB3aWxsIG5vdCB3b3JrLlwiLCBcImZvbnQtYm9sZDogNTAwOyBmb250LXNpemU6IDE0cHg7XCIpO1xuICAgIGNvbnN0IGxlZ2FjeUNocm9tZVVybCA9IFwiaHR0cHM6Ly9jaHJvbWV3ZWJzdG9yZS5nb29nbGUuY29tL2RldGFpbC92dWVqcy1kZXZ0b29scy9pYWFqbWxjZXBsZWNibGppYWxoaGttZWRqbHBkYmxocFwiO1xuICAgIGNvbnN0IGxlZ2FjeUZpcmVmb3hVcmwgPSBcImh0dHBzOi8vYWRkb25zLm1vemlsbGEub3JnL2ZpcmVmb3gvYWRkb24vdnVlLWpzLWRldnRvb2xzLXY2LWxlZ2FjeVwiO1xuICAgIGNvbnNvbGUubG9nKGAlY1RoZSBsZWdhY3kgdmVyc2lvbiBvZiBjaHJvbWUgZXh0ZW5zaW9uIHRoYXQgc3VwcG9ydHMgYm90aCBWdWUgMiBhbmQgVnVlIDMgaGFzIGJlZW4gbW92ZWQgdG8gJWMgJHtsZWdhY3lDaHJvbWVVcmx9YCwgXCJmb250LXNpemU6IDE0cHg7XCIsIFwidGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7IGN1cnNvcjogcG9pbnRlcjtmb250LXNpemU6IDE0cHg7XCIpO1xuICAgIGNvbnNvbGUubG9nKGAlY1RoZSBsZWdhY3kgdmVyc2lvbiBvZiBmaXJlZm94IGV4dGVuc2lvbiB0aGF0IHN1cHBvcnRzIGJvdGggVnVlIDIgYW5kIFZ1ZSAzIGhhcyBiZWVuIG1vdmVkIHRvICVjICR7bGVnYWN5RmlyZWZveFVybH1gLCBcImZvbnQtc2l6ZTogMTRweDtcIiwgXCJ0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsgY3Vyc29yOiBwb2ludGVyO2ZvbnQtc2l6ZTogMTRweDtcIik7XG4gICAgY29uc29sZS5sb2coXCIlY1BsZWFzZSBpbnN0YWxsIGFuZCBlbmFibGUgb25seSB0aGUgbGVnYWN5IHZlcnNpb24gZm9yIHlvdXIgVnVlMiBhcHAuXCIsIFwiZm9udC1ib2xkOiA1MDA7IGZvbnQtc2l6ZTogMTRweDtcIik7XG4gICAgY29uc29sZS5sb2coXCIlY1tfX19fX1Z1ZSBEZXZUb29scyB2NyBsb2dfX19fX11cIiwgXCJjb2xvcjogcmVkOyBmb250LWJvbGQ6IDYwMDsgZm9udC1zaXplOiAxNnB4O1wiKTtcbiAgfSk7XG4gIGhvb2sub24uc2V0dXBEZXZ0b29sc1BsdWdpbigocGx1Z2luRGVzY3JpcHRvciwgc2V0dXBGbikgPT4ge1xuICAgIHZhciBfYTI2O1xuICAgIGFkZERldlRvb2xzUGx1Z2luVG9CdWZmZXIocGx1Z2luRGVzY3JpcHRvciwgc2V0dXBGbik7XG4gICAgY29uc3QgeyBhcHAgfSA9IChfYTI2ID0gYWN0aXZlQXBwUmVjb3JkKSAhPSBudWxsID8gX2EyNiA6IHt9O1xuICAgIGlmIChwbHVnaW5EZXNjcmlwdG9yLnNldHRpbmdzKSB7XG4gICAgICBpbml0UGx1Z2luU2V0dGluZ3MocGx1Z2luRGVzY3JpcHRvci5pZCwgcGx1Z2luRGVzY3JpcHRvci5zZXR0aW5ncyk7XG4gICAgfVxuICAgIGlmICghYXBwKVxuICAgICAgcmV0dXJuO1xuICAgIGNhbGxEZXZUb29sc1BsdWdpblNldHVwRm4oW3BsdWdpbkRlc2NyaXB0b3IsIHNldHVwRm5dLCBhcHApO1xuICB9KTtcbiAgb25MZWdhY3lEZXZUb29sc1BsdWdpbkFwaUF2YWlsYWJsZSgoKSA9PiB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFBsdWdpbkJ1ZmZlciA9IGRldnRvb2xzUGx1Z2luQnVmZmVyLmZpbHRlcigoW2l0ZW1dKSA9PiBpdGVtLmlkICE9PSBcImNvbXBvbmVudHNcIik7XG4gICAgbm9ybWFsaXplZFBsdWdpbkJ1ZmZlci5mb3JFYWNoKChbcGx1Z2luRGVzY3JpcHRvciwgc2V0dXBGbl0pID0+IHtcbiAgICAgIF9kZXZ0b29sc0hvb2suZW1pdChcImRldnRvb2xzLXBsdWdpbjpzZXR1cFwiIC8qIFNFVFVQX0RFVlRPT0xTX1BMVUdJTiAqLywgcGx1Z2luRGVzY3JpcHRvciwgc2V0dXBGbiwgeyB0YXJnZXQ6IFwibGVnYWN5XCIgfSk7XG4gICAgfSk7XG4gIH0pO1xuICBob29rLm9uLnZ1ZUFwcEluaXQoYXN5bmMgKGFwcCwgdmVyc2lvbiwgdHlwZXMpID0+IHtcbiAgICBjb25zdCBhcHBSZWNvcmQgPSBjcmVhdGVBcHBSZWNvcmQoYXBwLCB0eXBlcyk7XG4gICAgY29uc3Qgbm9ybWFsaXplZEFwcFJlY29yZCA9IHtcbiAgICAgIC4uLmFwcFJlY29yZCxcbiAgICAgIGFwcCxcbiAgICAgIHZlcnNpb25cbiAgICB9O1xuICAgIGFkZERldlRvb2xzQXBwUmVjb3JkKG5vcm1hbGl6ZWRBcHBSZWNvcmQpO1xuICAgIGlmIChkZXZ0b29sc0FwcFJlY29yZHMudmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICBzZXRBY3RpdmVBcHBSZWNvcmQobm9ybWFsaXplZEFwcFJlY29yZCk7XG4gICAgICBzZXRBY3RpdmVBcHBSZWNvcmRJZChub3JtYWxpemVkQXBwUmVjb3JkLmlkKTtcbiAgICAgIG5vcm1hbGl6ZVJvdXRlckluZm8obm9ybWFsaXplZEFwcFJlY29yZCwgYWN0aXZlQXBwUmVjb3JkKTtcbiAgICAgIHJlZ2lzdGVyRGV2VG9vbHNQbHVnaW4obm9ybWFsaXplZEFwcFJlY29yZC5hcHApO1xuICAgIH1cbiAgICBzZXR1cERldlRvb2xzUGx1Z2luKC4uLmNyZWF0ZUNvbXBvbmVudHNEZXZUb29sc1BsdWdpbihub3JtYWxpemVkQXBwUmVjb3JkLmFwcCkpO1xuICAgIHVwZGF0ZURldlRvb2xzU3RhdGUoe1xuICAgICAgY29ubmVjdGVkOiB0cnVlXG4gICAgfSk7XG4gICAgX2RldnRvb2xzSG9vay5hcHBzLnB1c2goYXBwKTtcbiAgfSk7XG4gIGhvb2sub24udnVlQXBwVW5tb3VudChhc3luYyAoYXBwKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlUmVjb3JkcyA9IGRldnRvb2xzQXBwUmVjb3Jkcy52YWx1ZS5maWx0ZXIoKGFwcFJlY29yZCkgPT4gYXBwUmVjb3JkLmFwcCAhPT0gYXBwKTtcbiAgICBpZiAoYWN0aXZlUmVjb3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHVwZGF0ZURldlRvb2xzU3RhdGUoe1xuICAgICAgICBjb25uZWN0ZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlRGV2VG9vbHNBcHBSZWNvcmQoYXBwKTtcbiAgICByZW1vdmVBcHBSZWNvcmRJZChhcHApO1xuICAgIGlmIChhY3RpdmVBcHBSZWNvcmQudmFsdWUuYXBwID09PSBhcHApIHtcbiAgICAgIHNldEFjdGl2ZUFwcFJlY29yZChhY3RpdmVSZWNvcmRzWzBdKTtcbiAgICAgIGRldnRvb2xzQ29udGV4dC5ob29rcy5jYWxsSG9vayhcInNlbmRBY3RpdmVBcHBVcGRhdGVkVG9DbGllbnRcIiAvKiBTRU5EX0FDVElWRV9BUFBfVU5NT1VOVEVEX1RPX0NMSUVOVCAqLyk7XG4gICAgfVxuICAgIHRhcmdldDEzLl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uYXBwcy5zcGxpY2UodGFyZ2V0MTMuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5hcHBzLmluZGV4T2YoYXBwKSwgMSk7XG4gICAgcmVtb3ZlUmVnaXN0ZXJlZFBsdWdpbkFwcChhcHApO1xuICB9KTtcbiAgc3Vic2NyaWJlRGV2VG9vbHNIb29rKF9kZXZ0b29sc0hvb2spO1xuICBpZiAoIXRhcmdldDEzLl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0MTMsIFwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfX1wiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZGV2dG9vbHNIb29rO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmICghaXNOdXh0QXBwKSB7XG4gICAgICBPYmplY3QuYXNzaWduKF9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18sIF9kZXZ0b29sc0hvb2spO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25EZXZUb29sc0NsaWVudENvbm5lY3RlZChmbikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBpZiAoZGV2dG9vbHNTdGF0ZS5jb25uZWN0ZWQgJiYgZGV2dG9vbHNTdGF0ZS5jbGllbnRDb25uZWN0ZWQpIHtcbiAgICAgIGZuKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRldnRvb2xzQ29udGV4dC5ob29rcy5ob29rKFwiZGV2dG9vbHNDb25uZWN0ZWRVcGRhdGVkXCIgLyogREVWVE9PTFNfQ09OTkVDVEVEX1VQREFURUQgKi8sICh7IHN0YXRlIH0pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5jb25uZWN0ZWQgJiYgc3RhdGUuY2xpZW50Q29ubmVjdGVkKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIHNyYy9jb3JlL2hpZ2gtcGVyZi1tb2RlL2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xuZnVuY3Rpb24gdG9nZ2xlSGlnaFBlcmZNb2RlKHN0YXRlKSB7XG4gIGRldnRvb2xzU3RhdGUuaGlnaFBlcmZNb2RlRW5hYmxlZCA9IHN0YXRlICE9IG51bGwgPyBzdGF0ZSA6ICFkZXZ0b29sc1N0YXRlLmhpZ2hQZXJmTW9kZUVuYWJsZWQ7XG4gIGlmICghc3RhdGUgJiYgYWN0aXZlQXBwUmVjb3JkLnZhbHVlKSB7XG4gICAgcmVnaXN0ZXJEZXZUb29sc1BsdWdpbihhY3RpdmVBcHBSZWNvcmQudmFsdWUuYXBwKTtcbiAgfVxufVxuXG4vLyBzcmMvY29yZS9jb21wb25lbnQvc3RhdGUvZm9ybWF0LnRzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyBzcmMvY29yZS9jb21wb25lbnQvc3RhdGUvcmV2aXZlci50c1xuaW5pdF9lc21fc2hpbXMoKTtcbmltcG9ydCB7IHRhcmdldCBhcyB0YXJnZXQxNCB9IGZyb20gXCJAdnVlL2RldnRvb2xzLXNoYXJlZFwiO1xuZnVuY3Rpb24gcmV2aXZlU2V0KHZhbCkge1xuICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBsaXN0ID0gdmFsLl9jdXN0b20udmFsdWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gbGlzdFtpXTtcbiAgICByZXN1bHQuYWRkKHJldml2ZSh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZXZpdmVNYXAodmFsKSB7XG4gIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGxpc3QgPSB2YWwuX2N1c3RvbS52YWx1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBsaXN0W2ldO1xuICAgIHJlc3VsdC5zZXQoa2V5LCByZXZpdmUodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmV2aXZlKHZhbCkge1xuICBpZiAodmFsID09PSBVTkRFRklORUQpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9IGVsc2UgaWYgKHZhbCA9PT0gSU5GSU5JVFkpIHtcbiAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB9IGVsc2UgaWYgKHZhbCA9PT0gTkVHQVRJVkVfSU5GSU5JVFkpIHtcbiAgICByZXR1cm4gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICB9IGVsc2UgaWYgKHZhbCA9PT0gTkFOKSB7XG4gICAgcmV0dXJuIE51bWJlci5OYU47XG4gIH0gZWxzZSBpZiAodmFsICYmIHZhbC5fY3VzdG9tKSB7XG4gICAgY29uc3QgeyBfY3VzdG9tOiBjdXN0b20gfSA9IHZhbDtcbiAgICBpZiAoY3VzdG9tLnR5cGUgPT09IFwiY29tcG9uZW50XCIpXG4gICAgICByZXR1cm4gYWN0aXZlQXBwUmVjb3JkLnZhbHVlLmluc3RhbmNlTWFwLmdldChjdXN0b20uaWQpO1xuICAgIGVsc2UgaWYgKGN1c3RvbS50eXBlID09PSBcIm1hcFwiKVxuICAgICAgcmV0dXJuIHJldml2ZU1hcCh2YWwpO1xuICAgIGVsc2UgaWYgKGN1c3RvbS50eXBlID09PSBcInNldFwiKVxuICAgICAgcmV0dXJuIHJldml2ZVNldCh2YWwpO1xuICAgIGVsc2UgaWYgKGN1c3RvbS50eXBlID09PSBcImJpZ2ludFwiKVxuICAgICAgcmV0dXJuIEJpZ0ludChjdXN0b20udmFsdWUpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiByZXZpdmUoY3VzdG9tLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChzeW1ib2xSRS50ZXN0KHZhbCkpIHtcbiAgICBjb25zdCBbLCBzdHJpbmddID0gc3ltYm9sUkUuZXhlYyh2YWwpO1xuICAgIHJldHVybiBTeW1ib2wuZm9yKHN0cmluZyk7XG4gIH0gZWxzZSBpZiAoc3BlY2lhbFR5cGVSRS50ZXN0KHZhbCkpIHtcbiAgICBjb25zdCBbLCB0eXBlLCBzdHJpbmcsICwgZGV0YWlsc10gPSBzcGVjaWFsVHlwZVJFLmV4ZWModmFsKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgdGFyZ2V0MTRbdHlwZV0oc3RyaW5nKTtcbiAgICBpZiAodHlwZSA9PT0gXCJFcnJvclwiICYmIGRldGFpbHMpXG4gICAgICByZXN1bHQuc3RhY2sgPSBkZXRhaWxzO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufVxuZnVuY3Rpb24gcmV2aXZlcihrZXksIHZhbHVlKSB7XG4gIHJldHVybiByZXZpdmUodmFsdWUpO1xufVxuXG4vLyBzcmMvY29yZS9jb21wb25lbnQvc3RhdGUvZm9ybWF0LnRzXG5mdW5jdGlvbiBnZXRJbnNwZWN0b3JTdGF0ZVZhbHVlVHlwZSh2YWx1ZSwgcmF3ID0gdHJ1ZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gVU5ERUZJTkVEIHx8IHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSBORUdBVElWRV9JTkZJTklUWSB8fCB2YWx1ZSA9PT0gTkFOKSB7XG4gICAgcmV0dXJuIFwibGl0ZXJhbFwiO1xuICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5fY3VzdG9tKSB7XG4gICAgaWYgKHJhdyB8fCB2YWx1ZS5fY3VzdG9tLmRpc3BsYXkgIT0gbnVsbCB8fCB2YWx1ZS5fY3VzdG9tLmRpc3BsYXlUZXh0ICE9IG51bGwpXG4gICAgICByZXR1cm4gXCJjdXN0b21cIjtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gZ2V0SW5zcGVjdG9yU3RhdGVWYWx1ZVR5cGUodmFsdWUuX2N1c3RvbS52YWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgdHlwZU1hdGNoID0gc3BlY2lhbFR5cGVSRS5leGVjKHZhbHVlKTtcbiAgICBpZiAodHlwZU1hdGNoKSB7XG4gICAgICBjb25zdCBbLCB0eXBlMl0gPSB0eXBlTWF0Y2g7XG4gICAgICByZXR1cm4gYG5hdGl2ZSAke3R5cGUyfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAodmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlLl9pc0FycmF5KSkge1xuICAgIHJldHVybiBcImFycmF5XCI7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJwbGFpbi1vYmplY3RcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdEluc3BlY3RvclN0YXRlVmFsdWUodmFsdWUsIHF1b3RlcyA9IGZhbHNlLCBvcHRpb25zKSB7XG4gIHZhciBfYTI1LCBfYjI1LCBfYztcbiAgY29uc3QgeyBjdXN0b21DbGFzcyB9ID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9O1xuICBsZXQgcmVzdWx0O1xuICBjb25zdCB0eXBlID0gZ2V0SW5zcGVjdG9yU3RhdGVWYWx1ZVR5cGUodmFsdWUsIGZhbHNlKTtcbiAgaWYgKHR5cGUgIT09IFwiY3VzdG9tXCIgJiYgKHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5fY3VzdG9tKSlcbiAgICB2YWx1ZSA9IHZhbHVlLl9jdXN0b20udmFsdWU7XG4gIGlmIChyZXN1bHQgPSBpbnRlcm5hbFN0YXRlVG9rZW5Ub1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY3VzdG9tXCIpIHtcbiAgICBjb25zdCBuZXN0ZWROYW1lID0gKChfYTI1ID0gdmFsdWUuX2N1c3RvbS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjUuX2N1c3RvbSkgJiYgZm9ybWF0SW5zcGVjdG9yU3RhdGVWYWx1ZSh2YWx1ZS5fY3VzdG9tLnZhbHVlLCBxdW90ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXN0ZWROYW1lIHx8IHZhbHVlLl9jdXN0b20uZGlzcGxheVRleHQgfHwgdmFsdWUuX2N1c3RvbS5kaXNwbGF5O1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgIHJldHVybiBgQXJyYXlbJHt2YWx1ZS5sZW5ndGh9XWA7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJwbGFpbi1vYmplY3RcIikge1xuICAgIHJldHVybiBgT2JqZWN0JHtPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID8gXCJcIiA6IFwiIChlbXB0eSlcIn1gO1xuICB9IGVsc2UgaWYgKHR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IHR5cGUuaW5jbHVkZXMoXCJuYXRpdmVcIikpIHtcbiAgICByZXR1cm4gZXNjYXBlKChfYjI1ID0gc3BlY2lhbFR5cGVSRS5leGVjKHZhbHVlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMjVbMl0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHR5cGVNYXRjaCA9IHZhbHVlLm1hdGNoKHJhd1R5cGVSRSk7XG4gICAgaWYgKHR5cGVNYXRjaCkge1xuICAgICAgdmFsdWUgPSBlc2NhcGVTdHJpbmcodHlwZU1hdGNoWzFdKTtcbiAgICB9IGVsc2UgaWYgKHF1b3Rlcykge1xuICAgICAgdmFsdWUgPSBgPHNwYW4+XCI8L3NwYW4+JHsoY3VzdG9tQ2xhc3MgPT0gbnVsbCA/IHZvaWQgMCA6IGN1c3RvbUNsYXNzLnN0cmluZykgPyBgPHNwYW4gY2xhc3M9JHtjdXN0b21DbGFzcy5zdHJpbmd9PiR7ZXNjYXBlU3RyaW5nKHZhbHVlKX08L3NwYW4+YCA6IGVzY2FwZVN0cmluZyh2YWx1ZSl9PHNwYW4+XCI8L3NwYW4+YDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSAoY3VzdG9tQ2xhc3MgPT0gbnVsbCA/IHZvaWQgMCA6IGN1c3RvbUNsYXNzLnN0cmluZykgPyBgPHNwYW4gY2xhc3M9XCIkeyhfYyA9IGN1c3RvbUNsYXNzID09IG51bGwgPyB2b2lkIDAgOiBjdXN0b21DbGFzcy5zdHJpbmcpICE9IG51bGwgPyBfYyA6IFwiXCJ9XCI+JHtlc2NhcGVTdHJpbmcodmFsdWUpfTwvc3Bhbj5gIDogZXNjYXBlU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBlc2NhcGUodmFsdWUpLnJlcGxhY2UoLyAvZywgXCImbmJzcDtcIikucmVwbGFjZSgvXFxuL2csIFwiPHNwYW4+XFxcXG48L3NwYW4+XCIpO1xufVxuZnVuY3Rpb24gZ2V0UmF3KHZhbHVlKSB7XG4gIHZhciBfYTI1LCBfYjI1LCBfYztcbiAgbGV0IGN1c3RvbVR5cGU7XG4gIGNvbnN0IGlzQ3VzdG9tID0gZ2V0SW5zcGVjdG9yU3RhdGVWYWx1ZVR5cGUodmFsdWUpID09PSBcImN1c3RvbVwiO1xuICBsZXQgaW5oZXJpdCA9IHt9O1xuICBpZiAoaXNDdXN0b20pIHtcbiAgICBjb25zdCBkYXRhID0gdmFsdWU7XG4gICAgY29uc3QgY3VzdG9tVmFsdWUgPSAoX2EyNSA9IGRhdGEuX2N1c3RvbSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjUudmFsdWU7XG4gICAgY29uc3QgY3VycmVudEN1c3RvbVR5cGUgPSAoX2IyNSA9IGRhdGEuX2N1c3RvbSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMjUudHlwZTtcbiAgICBjb25zdCBuZXN0ZWRDdXN0b20gPSB0eXBlb2YgY3VzdG9tVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgY3VzdG9tVmFsdWUgIT09IG51bGwgJiYgXCJfY3VzdG9tXCIgaW4gY3VzdG9tVmFsdWUgPyBnZXRSYXcoY3VzdG9tVmFsdWUpIDogeyBpbmhlcml0OiB2b2lkIDAsIHZhbHVlOiB2b2lkIDAsIGN1c3RvbVR5cGU6IHZvaWQgMCB9O1xuICAgIGluaGVyaXQgPSBuZXN0ZWRDdXN0b20uaW5oZXJpdCB8fCAoKF9jID0gZGF0YS5fY3VzdG9tKSA9PSBudWxsID8gdm9pZCAwIDogX2MuZmllbGRzKSB8fCB7fTtcbiAgICB2YWx1ZSA9IG5lc3RlZEN1c3RvbS52YWx1ZSB8fCBjdXN0b21WYWx1ZTtcbiAgICBjdXN0b21UeXBlID0gbmVzdGVkQ3VzdG9tLmN1c3RvbVR5cGUgfHwgY3VycmVudEN1c3RvbVR5cGU7XG4gIH1cbiAgaWYgKHZhbHVlICYmIHZhbHVlLl9pc0FycmF5KVxuICAgIHZhbHVlID0gdmFsdWUuaXRlbXM7XG4gIHJldHVybiB7IHZhbHVlLCBpbmhlcml0LCBjdXN0b21UeXBlIH07XG59XG5mdW5jdGlvbiB0b0VkaXQodmFsdWUsIGN1c3RvbVR5cGUpIHtcbiAgaWYgKGN1c3RvbVR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgcmV0dXJuIHZhbHVlO1xuICBpZiAoY3VzdG9tVHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgcmV0dXJuIHZhbHVlO1xuICByZXR1cm4gcmVwbGFjZVRva2VuVG9TdHJpbmcoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHRvU3VibWl0KHZhbHVlLCBjdXN0b21UeXBlKSB7XG4gIGlmIChjdXN0b21UeXBlID09PSBcImJpZ2ludFwiKVxuICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICBpZiAoY3VzdG9tVHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgcmV0dXJuIEpTT04ucGFyc2UocmVwbGFjZVN0cmluZ1RvVG9rZW4odmFsdWUpLCByZXZpdmVyKTtcbn1cblxuLy8gc3JjL2NvcmUvZGV2dG9vbHMtY2xpZW50L2RldGVjdGVkLnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgdGFyZ2V0IGFzIHRhcmdldDE1IH0gZnJvbSBcIkB2dWUvZGV2dG9vbHMtc2hhcmVkXCI7XG5mdW5jdGlvbiB1cGRhdGVEZXZUb29sc0NsaWVudERldGVjdGVkKHBhcmFtcykge1xuICBkZXZ0b29sc1N0YXRlLmRldnRvb2xzQ2xpZW50RGV0ZWN0ZWQgPSB7XG4gICAgLi4uZGV2dG9vbHNTdGF0ZS5kZXZ0b29sc0NsaWVudERldGVjdGVkLFxuICAgIC4uLnBhcmFtc1xuICB9O1xuICBjb25zdCBkZXZ0b29sc0NsaWVudFZpc2libGUgPSBPYmplY3QudmFsdWVzKGRldnRvb2xzU3RhdGUuZGV2dG9vbHNDbGllbnREZXRlY3RlZCkuc29tZShCb29sZWFuKTtcbiAgdG9nZ2xlSGlnaFBlcmZNb2RlKCFkZXZ0b29sc0NsaWVudFZpc2libGUpO1xufVxudmFyIF9hMTgsIF9iMTg7XG4oX2IxOCA9IChfYTE4ID0gdGFyZ2V0MTUpLl9fVlVFX0RFVlRPT0xTX1VQREFURV9DTElFTlRfREVURUNURURfXykgIT0gbnVsbCA/IF9iMTggOiBfYTE4Ll9fVlVFX0RFVlRPT0xTX1VQREFURV9DTElFTlRfREVURUNURURfXyA9IHVwZGF0ZURldlRvb2xzQ2xpZW50RGV0ZWN0ZWQ7XG5cbi8vIHNyYy9tZXNzYWdpbmcvaW5kZXgudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5pbXBvcnQgeyB0YXJnZXQgYXMgdGFyZ2V0MjEgfSBmcm9tIFwiQHZ1ZS9kZXZ0b29scy1zaGFyZWRcIjtcbmltcG9ydCB7IGNyZWF0ZUJpcnBjLCBjcmVhdGVCaXJwY0dyb3VwIH0gZnJvbSBcImJpcnBjXCI7XG5cbi8vIHNyYy9tZXNzYWdpbmcvcHJlc2V0cy9pbmRleC50c1xuaW5pdF9lc21fc2hpbXMoKTtcblxuLy8gc3JjL21lc3NhZ2luZy9wcmVzZXRzL2Jyb2FkY2FzdC1jaGFubmVsL2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3VwZXJqc29uQDIuMi4yL25vZGVfbW9kdWxlcy9zdXBlcmpzb24vZGlzdC9pbmRleC5qc1xuaW5pdF9lc21fc2hpbXMoKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N1cGVyanNvbkAyLjIuMi9ub2RlX21vZHVsZXMvc3VwZXJqc29uL2Rpc3QvY2xhc3MtcmVnaXN0cnkuanNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdXBlcmpzb25AMi4yLjIvbm9kZV9tb2R1bGVzL3N1cGVyanNvbi9kaXN0L3JlZ2lzdHJ5LmpzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3VwZXJqc29uQDIuMi4yL25vZGVfbW9kdWxlcy9zdXBlcmpzb24vZGlzdC9kb3VibGUtaW5kZXhlZC1rdi5qc1xuaW5pdF9lc21fc2hpbXMoKTtcbnZhciBEb3VibGVJbmRleGVkS1YgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMua2V5VG9WYWx1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy52YWx1ZVRvS2V5ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMua2V5VG9WYWx1ZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgdGhpcy52YWx1ZVRvS2V5LnNldCh2YWx1ZSwga2V5KTtcbiAgfVxuICBnZXRCeUtleShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlUb1ZhbHVlLmdldChrZXkpO1xuICB9XG4gIGdldEJ5VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVRvS2V5LmdldCh2YWx1ZSk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5rZXlUb1ZhbHVlLmNsZWFyKCk7XG4gICAgdGhpcy52YWx1ZVRvS2V5LmNsZWFyKCk7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdXBlcmpzb25AMi4yLjIvbm9kZV9tb2R1bGVzL3N1cGVyanNvbi9kaXN0L3JlZ2lzdHJ5LmpzXG52YXIgUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGdlbmVyYXRlSWRlbnRpZmllcikge1xuICAgIHRoaXMuZ2VuZXJhdGVJZGVudGlmaWVyID0gZ2VuZXJhdGVJZGVudGlmaWVyO1xuICAgIHRoaXMua3YgPSBuZXcgRG91YmxlSW5kZXhlZEtWKCk7XG4gIH1cbiAgcmVnaXN0ZXIodmFsdWUsIGlkZW50aWZpZXIpIHtcbiAgICBpZiAodGhpcy5rdi5nZXRCeVZhbHVlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlkZW50aWZpZXIpIHtcbiAgICAgIGlkZW50aWZpZXIgPSB0aGlzLmdlbmVyYXRlSWRlbnRpZmllcih2YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMua3Yuc2V0KGlkZW50aWZpZXIsIHZhbHVlKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLmt2LmNsZWFyKCk7XG4gIH1cbiAgZ2V0SWRlbnRpZmllcih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmt2LmdldEJ5VmFsdWUodmFsdWUpO1xuICB9XG4gIGdldFZhbHVlKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5rdi5nZXRCeUtleShpZGVudGlmaWVyKTtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N1cGVyanNvbkAyLjIuMi9ub2RlX21vZHVsZXMvc3VwZXJqc29uL2Rpc3QvY2xhc3MtcmVnaXN0cnkuanNcbnZhciBDbGFzc1JlZ2lzdHJ5ID0gY2xhc3MgZXh0ZW5kcyBSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKChjKSA9PiBjLm5hbWUpO1xuICAgIHRoaXMuY2xhc3NUb0FsbG93ZWRQcm9wcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgcmVnaXN0ZXIodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChvcHRpb25zLmFsbG93UHJvcHMpIHtcbiAgICAgICAgdGhpcy5jbGFzc1RvQWxsb3dlZFByb3BzLnNldCh2YWx1ZSwgb3B0aW9ucy5hbGxvd1Byb3BzKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyLnJlZ2lzdGVyKHZhbHVlLCBvcHRpb25zLmlkZW50aWZpZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5yZWdpc3Rlcih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGdldEFsbG93ZWRQcm9wcyh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzVG9BbGxvd2VkUHJvcHMuZ2V0KHZhbHVlKTtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N1cGVyanNvbkAyLjIuMi9ub2RlX21vZHVsZXMvc3VwZXJqc29uL2Rpc3QvY3VzdG9tLXRyYW5zZm9ybWVyLXJlZ2lzdHJ5LmpzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3VwZXJqc29uQDIuMi4yL25vZGVfbW9kdWxlcy9zdXBlcmpzb24vZGlzdC91dGlsLmpzXG5pbml0X2VzbV9zaGltcygpO1xuZnVuY3Rpb24gdmFsdWVzT2ZPYmoocmVjb3JkKSB7XG4gIGlmIChcInZhbHVlc1wiIGluIE9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlY29yZCk7XG4gIH1cbiAgY29uc3QgdmFsdWVzID0gW107XG4gIGZvciAoY29uc3Qga2V5IGluIHJlY29yZCkge1xuICAgIGlmIChyZWNvcmQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFsdWVzLnB1c2gocmVjb3JkW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuZnVuY3Rpb24gZmluZChyZWNvcmQsIHByZWRpY2F0ZSkge1xuICBjb25zdCB2YWx1ZXMgPSB2YWx1ZXNPZk9iaihyZWNvcmQpO1xuICBpZiAoXCJmaW5kXCIgaW4gdmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5maW5kKHByZWRpY2F0ZSk7XG4gIH1cbiAgY29uc3QgdmFsdWVzTm90TmV2ZXIgPSB2YWx1ZXM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzTm90TmV2ZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc05vdE5ldmVyW2ldO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBmb3JFYWNoKHJlY29yZCwgcnVuKSB7XG4gIE9iamVjdC5lbnRyaWVzKHJlY29yZCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiBydW4odmFsdWUsIGtleSkpO1xufVxuZnVuY3Rpb24gaW5jbHVkZXMoYXJyLCB2YWx1ZSkge1xuICByZXR1cm4gYXJyLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIGZpbmRBcnIocmVjb3JkLCBwcmVkaWNhdGUpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWNvcmQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IHJlY29yZFtpXTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3VwZXJqc29uQDIuMi4yL25vZGVfbW9kdWxlcy9zdXBlcmpzb24vZGlzdC9jdXN0b20tdHJhbnNmb3JtZXItcmVnaXN0cnkuanNcbnZhciBDdXN0b21UcmFuc2Zvcm1lclJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRyYW5zZm9tZXJzID0ge307XG4gIH1cbiAgcmVnaXN0ZXIodHJhbnNmb3JtZXIpIHtcbiAgICB0aGlzLnRyYW5zZm9tZXJzW3RyYW5zZm9ybWVyLm5hbWVdID0gdHJhbnNmb3JtZXI7XG4gIH1cbiAgZmluZEFwcGxpY2FibGUodikge1xuICAgIHJldHVybiBmaW5kKHRoaXMudHJhbnNmb21lcnMsICh0cmFuc2Zvcm1lcikgPT4gdHJhbnNmb3JtZXIuaXNBcHBsaWNhYmxlKHYpKTtcbiAgfVxuICBmaW5kQnlOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2ZvbWVyc1tuYW1lXTtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N1cGVyanNvbkAyLjIuMi9ub2RlX21vZHVsZXMvc3VwZXJqc29uL2Rpc3QvcGxhaW5lci5qc1xuaW5pdF9lc21fc2hpbXMoKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N1cGVyanNvbkAyLjIuMi9ub2RlX21vZHVsZXMvc3VwZXJqc29uL2Rpc3QvaXMuanNcbmluaXRfZXNtX3NoaW1zKCk7XG52YXIgZ2V0VHlwZSA9IChwYXlsb2FkKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocGF5bG9hZCkuc2xpY2UoOCwgLTEpO1xudmFyIGlzVW5kZWZpbmVkID0gKHBheWxvYWQpID0+IHR5cGVvZiBwYXlsb2FkID09PSBcInVuZGVmaW5lZFwiO1xudmFyIGlzTnVsbCA9IChwYXlsb2FkKSA9PiBwYXlsb2FkID09PSBudWxsO1xudmFyIGlzUGxhaW5PYmplY3QyID0gKHBheWxvYWQpID0+IHtcbiAgaWYgKHR5cGVvZiBwYXlsb2FkICE9PSBcIm9iamVjdFwiIHx8IHBheWxvYWQgPT09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAocGF5bG9hZCA9PT0gT2JqZWN0LnByb3RvdHlwZSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocGF5bG9hZCkgPT09IG51bGwpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGF5bG9hZCkgPT09IE9iamVjdC5wcm90b3R5cGU7XG59O1xudmFyIGlzRW1wdHlPYmplY3QgPSAocGF5bG9hZCkgPT4gaXNQbGFpbk9iamVjdDIocGF5bG9hZCkgJiYgT2JqZWN0LmtleXMocGF5bG9hZCkubGVuZ3RoID09PSAwO1xudmFyIGlzQXJyYXkgPSAocGF5bG9hZCkgPT4gQXJyYXkuaXNBcnJheShwYXlsb2FkKTtcbnZhciBpc1N0cmluZyA9IChwYXlsb2FkKSA9PiB0eXBlb2YgcGF5bG9hZCA9PT0gXCJzdHJpbmdcIjtcbnZhciBpc051bWJlciA9IChwYXlsb2FkKSA9PiB0eXBlb2YgcGF5bG9hZCA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4ocGF5bG9hZCk7XG52YXIgaXNCb29sZWFuID0gKHBheWxvYWQpID0+IHR5cGVvZiBwYXlsb2FkID09PSBcImJvb2xlYW5cIjtcbnZhciBpc1JlZ0V4cCA9IChwYXlsb2FkKSA9PiBwYXlsb2FkIGluc3RhbmNlb2YgUmVnRXhwO1xudmFyIGlzTWFwID0gKHBheWxvYWQpID0+IHBheWxvYWQgaW5zdGFuY2VvZiBNYXA7XG52YXIgaXNTZXQgPSAocGF5bG9hZCkgPT4gcGF5bG9hZCBpbnN0YW5jZW9mIFNldDtcbnZhciBpc1N5bWJvbCA9IChwYXlsb2FkKSA9PiBnZXRUeXBlKHBheWxvYWQpID09PSBcIlN5bWJvbFwiO1xudmFyIGlzRGF0ZSA9IChwYXlsb2FkKSA9PiBwYXlsb2FkIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4ocGF5bG9hZC52YWx1ZU9mKCkpO1xudmFyIGlzRXJyb3IgPSAocGF5bG9hZCkgPT4gcGF5bG9hZCBpbnN0YW5jZW9mIEVycm9yO1xudmFyIGlzTmFOVmFsdWUgPSAocGF5bG9hZCkgPT4gdHlwZW9mIHBheWxvYWQgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4ocGF5bG9hZCk7XG52YXIgaXNQcmltaXRpdmUyID0gKHBheWxvYWQpID0+IGlzQm9vbGVhbihwYXlsb2FkKSB8fCBpc051bGwocGF5bG9hZCkgfHwgaXNVbmRlZmluZWQocGF5bG9hZCkgfHwgaXNOdW1iZXIocGF5bG9hZCkgfHwgaXNTdHJpbmcocGF5bG9hZCkgfHwgaXNTeW1ib2wocGF5bG9hZCk7XG52YXIgaXNCaWdpbnQgPSAocGF5bG9hZCkgPT4gdHlwZW9mIHBheWxvYWQgPT09IFwiYmlnaW50XCI7XG52YXIgaXNJbmZpbml0ZSA9IChwYXlsb2FkKSA9PiBwYXlsb2FkID09PSBJbmZpbml0eSB8fCBwYXlsb2FkID09PSAtSW5maW5pdHk7XG52YXIgaXNUeXBlZEFycmF5ID0gKHBheWxvYWQpID0+IEFycmF5QnVmZmVyLmlzVmlldyhwYXlsb2FkKSAmJiAhKHBheWxvYWQgaW5zdGFuY2VvZiBEYXRhVmlldyk7XG52YXIgaXNVUkwgPSAocGF5bG9hZCkgPT4gcGF5bG9hZCBpbnN0YW5jZW9mIFVSTDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N1cGVyanNvbkAyLjIuMi9ub2RlX21vZHVsZXMvc3VwZXJqc29uL2Rpc3QvcGF0aHN0cmluZ2lmaWVyLmpzXG5pbml0X2VzbV9zaGltcygpO1xudmFyIGVzY2FwZUtleSA9IChrZXkpID0+IGtleS5yZXBsYWNlKC9cXC4vZywgXCJcXFxcLlwiKTtcbnZhciBzdHJpbmdpZnlQYXRoID0gKHBhdGgpID0+IHBhdGgubWFwKFN0cmluZykubWFwKGVzY2FwZUtleSkuam9pbihcIi5cIik7XG52YXIgcGFyc2VQYXRoID0gKHN0cmluZykgPT4ge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHNlZ21lbnQgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaGFyID0gc3RyaW5nLmNoYXJBdChpKTtcbiAgICBjb25zdCBpc0VzY2FwZWREb3QgPSBjaGFyID09PSBcIlxcXFxcIiAmJiBzdHJpbmcuY2hhckF0KGkgKyAxKSA9PT0gXCIuXCI7XG4gICAgaWYgKGlzRXNjYXBlZERvdCkge1xuICAgICAgc2VnbWVudCArPSBcIi5cIjtcbiAgICAgIGkrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBpc0VuZE9mU2VnbWVudCA9IGNoYXIgPT09IFwiLlwiO1xuICAgIGlmIChpc0VuZE9mU2VnbWVudCkge1xuICAgICAgcmVzdWx0LnB1c2goc2VnbWVudCk7XG4gICAgICBzZWdtZW50ID0gXCJcIjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzZWdtZW50ICs9IGNoYXI7XG4gIH1cbiAgY29uc3QgbGFzdFNlZ21lbnQgPSBzZWdtZW50O1xuICByZXN1bHQucHVzaChsYXN0U2VnbWVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3VwZXJqc29uQDIuMi4yL25vZGVfbW9kdWxlcy9zdXBlcmpzb24vZGlzdC90cmFuc2Zvcm1lci5qc1xuaW5pdF9lc21fc2hpbXMoKTtcbmZ1bmN0aW9uIHNpbXBsZVRyYW5zZm9ybWF0aW9uKGlzQXBwbGljYWJsZSwgYW5ub3RhdGlvbiwgdHJhbnNmb3JtLCB1bnRyYW5zZm9ybSkge1xuICByZXR1cm4ge1xuICAgIGlzQXBwbGljYWJsZSxcbiAgICBhbm5vdGF0aW9uLFxuICAgIHRyYW5zZm9ybSxcbiAgICB1bnRyYW5zZm9ybVxuICB9O1xufVxudmFyIHNpbXBsZVJ1bGVzID0gW1xuICBzaW1wbGVUcmFuc2Zvcm1hdGlvbihpc1VuZGVmaW5lZCwgXCJ1bmRlZmluZWRcIiwgKCkgPT4gbnVsbCwgKCkgPT4gdm9pZCAwKSxcbiAgc2ltcGxlVHJhbnNmb3JtYXRpb24oaXNCaWdpbnQsIFwiYmlnaW50XCIsICh2KSA9PiB2LnRvU3RyaW5nKCksICh2KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBCaWdJbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBCaWdJbnQodik7XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoXCJQbGVhc2UgYWRkIGEgQmlnSW50IHBvbHlmaWxsLlwiKTtcbiAgICByZXR1cm4gdjtcbiAgfSksXG4gIHNpbXBsZVRyYW5zZm9ybWF0aW9uKGlzRGF0ZSwgXCJEYXRlXCIsICh2KSA9PiB2LnRvSVNPU3RyaW5nKCksICh2KSA9PiBuZXcgRGF0ZSh2KSksXG4gIHNpbXBsZVRyYW5zZm9ybWF0aW9uKGlzRXJyb3IsIFwiRXJyb3JcIiwgKHYsIHN1cGVySnNvbikgPT4ge1xuICAgIGNvbnN0IGJhc2VFcnJvciA9IHtcbiAgICAgIG5hbWU6IHYubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHYubWVzc2FnZVxuICAgIH07XG4gICAgc3VwZXJKc29uLmFsbG93ZWRFcnJvclByb3BzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGJhc2VFcnJvcltwcm9wXSA9IHZbcHJvcF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJhc2VFcnJvcjtcbiAgfSwgKHYsIHN1cGVySnNvbikgPT4ge1xuICAgIGNvbnN0IGUgPSBuZXcgRXJyb3Iodi5tZXNzYWdlKTtcbiAgICBlLm5hbWUgPSB2Lm5hbWU7XG4gICAgZS5zdGFjayA9IHYuc3RhY2s7XG4gICAgc3VwZXJKc29uLmFsbG93ZWRFcnJvclByb3BzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGVbcHJvcF0gPSB2W3Byb3BdO1xuICAgIH0pO1xuICAgIHJldHVybiBlO1xuICB9KSxcbiAgc2ltcGxlVHJhbnNmb3JtYXRpb24oaXNSZWdFeHAsIFwicmVnZXhwXCIsICh2KSA9PiBcIlwiICsgdiwgKHJlZ2V4KSA9PiB7XG4gICAgY29uc3QgYm9keSA9IHJlZ2V4LnNsaWNlKDEsIHJlZ2V4Lmxhc3RJbmRleE9mKFwiL1wiKSk7XG4gICAgY29uc3QgZmxhZ3MgPSByZWdleC5zbGljZShyZWdleC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChib2R5LCBmbGFncyk7XG4gIH0pLFxuICBzaW1wbGVUcmFuc2Zvcm1hdGlvbihcbiAgICBpc1NldCxcbiAgICBcInNldFwiLFxuICAgIC8vIChzZXRzIG9ubHkgZXhpc3QgaW4gZXM2KylcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXM1L25vLWVzNi1tZXRob2RzXG4gICAgKHYpID0+IFsuLi52LnZhbHVlcygpXSxcbiAgICAodikgPT4gbmV3IFNldCh2KVxuICApLFxuICBzaW1wbGVUcmFuc2Zvcm1hdGlvbihpc01hcCwgXCJtYXBcIiwgKHYpID0+IFsuLi52LmVudHJpZXMoKV0sICh2KSA9PiBuZXcgTWFwKHYpKSxcbiAgc2ltcGxlVHJhbnNmb3JtYXRpb24oKHYpID0+IGlzTmFOVmFsdWUodikgfHwgaXNJbmZpbml0ZSh2KSwgXCJudW1iZXJcIiwgKHYpID0+IHtcbiAgICBpZiAoaXNOYU5WYWx1ZSh2KSkge1xuICAgICAgcmV0dXJuIFwiTmFOXCI7XG4gICAgfVxuICAgIGlmICh2ID4gMCkge1xuICAgICAgcmV0dXJuIFwiSW5maW5pdHlcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiLUluZmluaXR5XCI7XG4gICAgfVxuICB9LCBOdW1iZXIpLFxuICBzaW1wbGVUcmFuc2Zvcm1hdGlvbigodikgPT4gdiA9PT0gMCAmJiAxIC8gdiA9PT0gLUluZmluaXR5LCBcIm51bWJlclwiLCAoKSA9PiB7XG4gICAgcmV0dXJuIFwiLTBcIjtcbiAgfSwgTnVtYmVyKSxcbiAgc2ltcGxlVHJhbnNmb3JtYXRpb24oaXNVUkwsIFwiVVJMXCIsICh2KSA9PiB2LnRvU3RyaW5nKCksICh2KSA9PiBuZXcgVVJMKHYpKVxuXTtcbmZ1bmN0aW9uIGNvbXBvc2l0ZVRyYW5zZm9ybWF0aW9uKGlzQXBwbGljYWJsZSwgYW5ub3RhdGlvbiwgdHJhbnNmb3JtLCB1bnRyYW5zZm9ybSkge1xuICByZXR1cm4ge1xuICAgIGlzQXBwbGljYWJsZSxcbiAgICBhbm5vdGF0aW9uLFxuICAgIHRyYW5zZm9ybSxcbiAgICB1bnRyYW5zZm9ybVxuICB9O1xufVxudmFyIHN5bWJvbFJ1bGUgPSBjb21wb3NpdGVUcmFuc2Zvcm1hdGlvbigocywgc3VwZXJKc29uKSA9PiB7XG4gIGlmIChpc1N5bWJvbChzKSkge1xuICAgIGNvbnN0IGlzUmVnaXN0ZXJlZCA9ICEhc3VwZXJKc29uLnN5bWJvbFJlZ2lzdHJ5LmdldElkZW50aWZpZXIocyk7XG4gICAgcmV0dXJuIGlzUmVnaXN0ZXJlZDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59LCAocywgc3VwZXJKc29uKSA9PiB7XG4gIGNvbnN0IGlkZW50aWZpZXIgPSBzdXBlckpzb24uc3ltYm9sUmVnaXN0cnkuZ2V0SWRlbnRpZmllcihzKTtcbiAgcmV0dXJuIFtcInN5bWJvbFwiLCBpZGVudGlmaWVyXTtcbn0sICh2KSA9PiB2LmRlc2NyaXB0aW9uLCAoXywgYSwgc3VwZXJKc29uKSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gc3VwZXJKc29uLnN5bWJvbFJlZ2lzdHJ5LmdldFZhbHVlKGFbMV0pO1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIGRlc2VyaWFsaXplIHVua25vd24gc3ltYm9sXCIpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn0pO1xudmFyIGNvbnN0cnVjdG9yVG9OYW1lID0gW1xuICBJbnQ4QXJyYXksXG4gIFVpbnQ4QXJyYXksXG4gIEludDE2QXJyYXksXG4gIFVpbnQxNkFycmF5LFxuICBJbnQzMkFycmF5LFxuICBVaW50MzJBcnJheSxcbiAgRmxvYXQzMkFycmF5LFxuICBGbG9hdDY0QXJyYXksXG4gIFVpbnQ4Q2xhbXBlZEFycmF5XG5dLnJlZHVjZSgob2JqLCBjdG9yKSA9PiB7XG4gIG9ialtjdG9yLm5hbWVdID0gY3RvcjtcbiAgcmV0dXJuIG9iajtcbn0sIHt9KTtcbnZhciB0eXBlZEFycmF5UnVsZSA9IGNvbXBvc2l0ZVRyYW5zZm9ybWF0aW9uKGlzVHlwZWRBcnJheSwgKHYpID0+IFtcInR5cGVkLWFycmF5XCIsIHYuY29uc3RydWN0b3IubmFtZV0sICh2KSA9PiBbLi4udl0sICh2LCBhKSA9PiB7XG4gIGNvbnN0IGN0b3IgPSBjb25zdHJ1Y3RvclRvTmFtZVthWzFdXTtcbiAgaWYgKCFjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIGRlc2VyaWFsaXplIHVua25vd24gdHlwZWQgYXJyYXlcIik7XG4gIH1cbiAgcmV0dXJuIG5ldyBjdG9yKHYpO1xufSk7XG5mdW5jdGlvbiBpc0luc3RhbmNlT2ZSZWdpc3RlcmVkQ2xhc3MocG90ZW50aWFsQ2xhc3MsIHN1cGVySnNvbikge1xuICBpZiAocG90ZW50aWFsQ2xhc3MgPT0gbnVsbCA/IHZvaWQgMCA6IHBvdGVudGlhbENsYXNzLmNvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgaXNSZWdpc3RlcmVkID0gISFzdXBlckpzb24uY2xhc3NSZWdpc3RyeS5nZXRJZGVudGlmaWVyKHBvdGVudGlhbENsYXNzLmNvbnN0cnVjdG9yKTtcbiAgICByZXR1cm4gaXNSZWdpc3RlcmVkO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBjbGFzc1J1bGUgPSBjb21wb3NpdGVUcmFuc2Zvcm1hdGlvbihpc0luc3RhbmNlT2ZSZWdpc3RlcmVkQ2xhc3MsIChjbGF6eiwgc3VwZXJKc29uKSA9PiB7XG4gIGNvbnN0IGlkZW50aWZpZXIgPSBzdXBlckpzb24uY2xhc3NSZWdpc3RyeS5nZXRJZGVudGlmaWVyKGNsYXp6LmNvbnN0cnVjdG9yKTtcbiAgcmV0dXJuIFtcImNsYXNzXCIsIGlkZW50aWZpZXJdO1xufSwgKGNsYXp6LCBzdXBlckpzb24pID0+IHtcbiAgY29uc3QgYWxsb3dlZFByb3BzID0gc3VwZXJKc29uLmNsYXNzUmVnaXN0cnkuZ2V0QWxsb3dlZFByb3BzKGNsYXp6LmNvbnN0cnVjdG9yKTtcbiAgaWYgKCFhbGxvd2VkUHJvcHMpIHtcbiAgICByZXR1cm4geyAuLi5jbGF6eiB9O1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBhbGxvd2VkUHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIHJlc3VsdFtwcm9wXSA9IGNsYXp6W3Byb3BdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0sICh2LCBhLCBzdXBlckpzb24pID0+IHtcbiAgY29uc3QgY2xhenogPSBzdXBlckpzb24uY2xhc3NSZWdpc3RyeS5nZXRWYWx1ZShhWzFdKTtcbiAgaWYgKCFjbGF6eikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVHJ5aW5nIHRvIGRlc2VyaWFsaXplIHVua25vd24gY2xhc3MgJyR7YVsxXX0nIC0gY2hlY2sgaHR0cHM6Ly9naXRodWIuY29tL2JsaXR6LWpzL3N1cGVyanNvbi9pc3N1ZXMvMTE2I2lzc3VlY29tbWVudC03NzM5OTY1NjRgKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKGNsYXp6LnByb3RvdHlwZSksIHYpO1xufSk7XG52YXIgY3VzdG9tUnVsZSA9IGNvbXBvc2l0ZVRyYW5zZm9ybWF0aW9uKCh2YWx1ZSwgc3VwZXJKc29uKSA9PiB7XG4gIHJldHVybiAhIXN1cGVySnNvbi5jdXN0b21UcmFuc2Zvcm1lclJlZ2lzdHJ5LmZpbmRBcHBsaWNhYmxlKHZhbHVlKTtcbn0sICh2YWx1ZSwgc3VwZXJKc29uKSA9PiB7XG4gIGNvbnN0IHRyYW5zZm9ybWVyID0gc3VwZXJKc29uLmN1c3RvbVRyYW5zZm9ybWVyUmVnaXN0cnkuZmluZEFwcGxpY2FibGUodmFsdWUpO1xuICByZXR1cm4gW1wiY3VzdG9tXCIsIHRyYW5zZm9ybWVyLm5hbWVdO1xufSwgKHZhbHVlLCBzdXBlckpzb24pID0+IHtcbiAgY29uc3QgdHJhbnNmb3JtZXIgPSBzdXBlckpzb24uY3VzdG9tVHJhbnNmb3JtZXJSZWdpc3RyeS5maW5kQXBwbGljYWJsZSh2YWx1ZSk7XG4gIHJldHVybiB0cmFuc2Zvcm1lci5zZXJpYWxpemUodmFsdWUpO1xufSwgKHYsIGEsIHN1cGVySnNvbikgPT4ge1xuICBjb25zdCB0cmFuc2Zvcm1lciA9IHN1cGVySnNvbi5jdXN0b21UcmFuc2Zvcm1lclJlZ2lzdHJ5LmZpbmRCeU5hbWUoYVsxXSk7XG4gIGlmICghdHJhbnNmb3JtZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gZGVzZXJpYWxpemUgdW5rbm93biBjdXN0b20gdmFsdWVcIik7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybWVyLmRlc2VyaWFsaXplKHYpO1xufSk7XG52YXIgY29tcG9zaXRlUnVsZXMgPSBbY2xhc3NSdWxlLCBzeW1ib2xSdWxlLCBjdXN0b21SdWxlLCB0eXBlZEFycmF5UnVsZV07XG52YXIgdHJhbnNmb3JtVmFsdWUgPSAodmFsdWUsIHN1cGVySnNvbikgPT4ge1xuICBjb25zdCBhcHBsaWNhYmxlQ29tcG9zaXRlUnVsZSA9IGZpbmRBcnIoY29tcG9zaXRlUnVsZXMsIChydWxlKSA9PiBydWxlLmlzQXBwbGljYWJsZSh2YWx1ZSwgc3VwZXJKc29uKSk7XG4gIGlmIChhcHBsaWNhYmxlQ29tcG9zaXRlUnVsZSkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYXBwbGljYWJsZUNvbXBvc2l0ZVJ1bGUudHJhbnNmb3JtKHZhbHVlLCBzdXBlckpzb24pLFxuICAgICAgdHlwZTogYXBwbGljYWJsZUNvbXBvc2l0ZVJ1bGUuYW5ub3RhdGlvbih2YWx1ZSwgc3VwZXJKc29uKVxuICAgIH07XG4gIH1cbiAgY29uc3QgYXBwbGljYWJsZVNpbXBsZVJ1bGUgPSBmaW5kQXJyKHNpbXBsZVJ1bGVzLCAocnVsZSkgPT4gcnVsZS5pc0FwcGxpY2FibGUodmFsdWUsIHN1cGVySnNvbikpO1xuICBpZiAoYXBwbGljYWJsZVNpbXBsZVJ1bGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGFwcGxpY2FibGVTaW1wbGVSdWxlLnRyYW5zZm9ybSh2YWx1ZSwgc3VwZXJKc29uKSxcbiAgICAgIHR5cGU6IGFwcGxpY2FibGVTaW1wbGVSdWxlLmFubm90YXRpb25cbiAgICB9O1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59O1xudmFyIHNpbXBsZVJ1bGVzQnlBbm5vdGF0aW9uID0ge307XG5zaW1wbGVSdWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gIHNpbXBsZVJ1bGVzQnlBbm5vdGF0aW9uW3J1bGUuYW5ub3RhdGlvbl0gPSBydWxlO1xufSk7XG52YXIgdW50cmFuc2Zvcm1WYWx1ZSA9IChqc29uLCB0eXBlLCBzdXBlckpzb24pID0+IHtcbiAgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICBzd2l0Y2ggKHR5cGVbMF0pIHtcbiAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgcmV0dXJuIHN5bWJvbFJ1bGUudW50cmFuc2Zvcm0oanNvbiwgdHlwZSwgc3VwZXJKc29uKTtcbiAgICAgIGNhc2UgXCJjbGFzc1wiOlxuICAgICAgICByZXR1cm4gY2xhc3NSdWxlLnVudHJhbnNmb3JtKGpzb24sIHR5cGUsIHN1cGVySnNvbik7XG4gICAgICBjYXNlIFwiY3VzdG9tXCI6XG4gICAgICAgIHJldHVybiBjdXN0b21SdWxlLnVudHJhbnNmb3JtKGpzb24sIHR5cGUsIHN1cGVySnNvbik7XG4gICAgICBjYXNlIFwidHlwZWQtYXJyYXlcIjpcbiAgICAgICAgcmV0dXJuIHR5cGVkQXJyYXlSdWxlLnVudHJhbnNmb3JtKGpzb24sIHR5cGUsIHN1cGVySnNvbik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRyYW5zZm9ybWF0aW9uOiBcIiArIHR5cGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1hdGlvbiA9IHNpbXBsZVJ1bGVzQnlBbm5vdGF0aW9uW3R5cGVdO1xuICAgIGlmICghdHJhbnNmb3JtYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHJhbnNmb3JtYXRpb246IFwiICsgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShqc29uLCBzdXBlckpzb24pO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3VwZXJqc29uQDIuMi4yL25vZGVfbW9kdWxlcy9zdXBlcmpzb24vZGlzdC9hY2Nlc3NEZWVwLmpzXG5pbml0X2VzbV9zaGltcygpO1xudmFyIGdldE50aEtleSA9ICh2YWx1ZSwgbikgPT4ge1xuICBpZiAobiA+IHZhbHVlLnNpemUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbiAgY29uc3Qga2V5cyA9IHZhbHVlLmtleXMoKTtcbiAgd2hpbGUgKG4gPiAwKSB7XG4gICAga2V5cy5uZXh0KCk7XG4gICAgbi0tO1xuICB9XG4gIHJldHVybiBrZXlzLm5leHQoKS52YWx1ZTtcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVBhdGgocGF0aCkge1xuICBpZiAoaW5jbHVkZXMocGF0aCwgXCJfX3Byb3RvX19cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJfX3Byb3RvX18gaXMgbm90IGFsbG93ZWQgYXMgYSBwcm9wZXJ0eVwiKTtcbiAgfVxuICBpZiAoaW5jbHVkZXMocGF0aCwgXCJwcm90b3R5cGVcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm90b3R5cGUgaXMgbm90IGFsbG93ZWQgYXMgYSBwcm9wZXJ0eVwiKTtcbiAgfVxuICBpZiAoaW5jbHVkZXMocGF0aCwgXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvbnN0cnVjdG9yIGlzIG5vdCBhbGxvd2VkIGFzIGEgcHJvcGVydHlcIik7XG4gIH1cbn1cbnZhciBnZXREZWVwID0gKG9iamVjdCwgcGF0aCkgPT4ge1xuICB2YWxpZGF0ZVBhdGgocGF0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IHBhdGhbaV07XG4gICAgaWYgKGlzU2V0KG9iamVjdCkpIHtcbiAgICAgIG9iamVjdCA9IGdldE50aEtleShvYmplY3QsICtrZXkpO1xuICAgIH0gZWxzZSBpZiAoaXNNYXAob2JqZWN0KSkge1xuICAgICAgY29uc3Qgcm93ID0gK2tleTtcbiAgICAgIGNvbnN0IHR5cGUgPSArcGF0aFsrK2ldID09PSAwID8gXCJrZXlcIiA6IFwidmFsdWVcIjtcbiAgICAgIGNvbnN0IGtleU9mUm93ID0gZ2V0TnRoS2V5KG9iamVjdCwgcm93KTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwia2V5XCI6XG4gICAgICAgICAgb2JqZWN0ID0ga2V5T2ZSb3c7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5nZXQoa2V5T2ZSb3cpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn07XG52YXIgc2V0RGVlcCA9IChvYmplY3QsIHBhdGgsIG1hcHBlcikgPT4ge1xuICB2YWxpZGF0ZVBhdGgocGF0aCk7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBtYXBwZXIob2JqZWN0KTtcbiAgfVxuICBsZXQgcGFyZW50ID0gb2JqZWN0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gcGF0aFtpXTtcbiAgICBpZiAoaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBjb25zdCBpbmRleCA9ICtrZXk7XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbaW5kZXhdO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdDIocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gcGFyZW50W2tleV07XG4gICAgfSBlbHNlIGlmIChpc1NldChwYXJlbnQpKSB7XG4gICAgICBjb25zdCByb3cgPSAra2V5O1xuICAgICAgcGFyZW50ID0gZ2V0TnRoS2V5KHBhcmVudCwgcm93KTtcbiAgICB9IGVsc2UgaWYgKGlzTWFwKHBhcmVudCkpIHtcbiAgICAgIGNvbnN0IGlzRW5kID0gaSA9PT0gcGF0aC5sZW5ndGggLSAyO1xuICAgICAgaWYgKGlzRW5kKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm93ID0gK2tleTtcbiAgICAgIGNvbnN0IHR5cGUgPSArcGF0aFsrK2ldID09PSAwID8gXCJrZXlcIiA6IFwidmFsdWVcIjtcbiAgICAgIGNvbnN0IGtleU9mUm93ID0gZ2V0TnRoS2V5KHBhcmVudCwgcm93KTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwia2V5XCI6XG4gICAgICAgICAgcGFyZW50ID0ga2V5T2ZSb3c7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5nZXQoa2V5T2ZSb3cpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBsYXN0S2V5ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICBpZiAoaXNBcnJheShwYXJlbnQpKSB7XG4gICAgcGFyZW50WytsYXN0S2V5XSA9IG1hcHBlcihwYXJlbnRbK2xhc3RLZXldKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0MihwYXJlbnQpKSB7XG4gICAgcGFyZW50W2xhc3RLZXldID0gbWFwcGVyKHBhcmVudFtsYXN0S2V5XSk7XG4gIH1cbiAgaWYgKGlzU2V0KHBhcmVudCkpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldE50aEtleShwYXJlbnQsICtsYXN0S2V5KTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IG1hcHBlcihvbGRWYWx1ZSk7XG4gICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgcGFyZW50LmRlbGV0ZShvbGRWYWx1ZSk7XG4gICAgICBwYXJlbnQuYWRkKG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTWFwKHBhcmVudCkpIHtcbiAgICBjb25zdCByb3cgPSArcGF0aFtwYXRoLmxlbmd0aCAtIDJdO1xuICAgIGNvbnN0IGtleVRvUm93ID0gZ2V0TnRoS2V5KHBhcmVudCwgcm93KTtcbiAgICBjb25zdCB0eXBlID0gK2xhc3RLZXkgPT09IDAgPyBcImtleVwiIDogXCJ2YWx1ZVwiO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImtleVwiOiB7XG4gICAgICAgIGNvbnN0IG5ld0tleSA9IG1hcHBlcihrZXlUb1Jvdyk7XG4gICAgICAgIHBhcmVudC5zZXQobmV3S2V5LCBwYXJlbnQuZ2V0KGtleVRvUm93KSk7XG4gICAgICAgIGlmIChuZXdLZXkgIT09IGtleVRvUm93KSB7XG4gICAgICAgICAgcGFyZW50LmRlbGV0ZShrZXlUb1Jvdyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidmFsdWVcIjoge1xuICAgICAgICBwYXJlbnQuc2V0KGtleVRvUm93LCBtYXBwZXIocGFyZW50LmdldChrZXlUb1JvdykpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3VwZXJqc29uQDIuMi4yL25vZGVfbW9kdWxlcy9zdXBlcmpzb24vZGlzdC9wbGFpbmVyLmpzXG5mdW5jdGlvbiB0cmF2ZXJzZSh0cmVlLCB3YWxrZXIyLCBvcmlnaW4gPSBbXSkge1xuICBpZiAoIXRyZWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFpc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yRWFjaCh0cmVlLCAoc3VidHJlZSwga2V5KSA9PiB0cmF2ZXJzZShzdWJ0cmVlLCB3YWxrZXIyLCBbLi4ub3JpZ2luLCAuLi5wYXJzZVBhdGgoa2V5KV0pKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgW25vZGVWYWx1ZSwgY2hpbGRyZW5dID0gdHJlZTtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgZm9yRWFjaChjaGlsZHJlbiwgKGNoaWxkLCBrZXkpID0+IHtcbiAgICAgIHRyYXZlcnNlKGNoaWxkLCB3YWxrZXIyLCBbLi4ub3JpZ2luLCAuLi5wYXJzZVBhdGgoa2V5KV0pO1xuICAgIH0pO1xuICB9XG4gIHdhbGtlcjIobm9kZVZhbHVlLCBvcmlnaW4pO1xufVxuZnVuY3Rpb24gYXBwbHlWYWx1ZUFubm90YXRpb25zKHBsYWluLCBhbm5vdGF0aW9ucywgc3VwZXJKc29uKSB7XG4gIHRyYXZlcnNlKGFubm90YXRpb25zLCAodHlwZSwgcGF0aCkgPT4ge1xuICAgIHBsYWluID0gc2V0RGVlcChwbGFpbiwgcGF0aCwgKHYpID0+IHVudHJhbnNmb3JtVmFsdWUodiwgdHlwZSwgc3VwZXJKc29uKSk7XG4gIH0pO1xuICByZXR1cm4gcGxhaW47XG59XG5mdW5jdGlvbiBhcHBseVJlZmVyZW50aWFsRXF1YWxpdHlBbm5vdGF0aW9ucyhwbGFpbiwgYW5ub3RhdGlvbnMpIHtcbiAgZnVuY3Rpb24gYXBwbHkoaWRlbnRpY2FsUGF0aHMsIHBhdGgpIHtcbiAgICBjb25zdCBvYmplY3QgPSBnZXREZWVwKHBsYWluLCBwYXJzZVBhdGgocGF0aCkpO1xuICAgIGlkZW50aWNhbFBhdGhzLm1hcChwYXJzZVBhdGgpLmZvckVhY2goKGlkZW50aWNhbE9iamVjdFBhdGgpID0+IHtcbiAgICAgIHBsYWluID0gc2V0RGVlcChwbGFpbiwgaWRlbnRpY2FsT2JqZWN0UGF0aCwgKCkgPT4gb2JqZWN0KTtcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNBcnJheShhbm5vdGF0aW9ucykpIHtcbiAgICBjb25zdCBbcm9vdCwgb3RoZXJdID0gYW5ub3RhdGlvbnM7XG4gICAgcm9vdC5mb3JFYWNoKChpZGVudGljYWxQYXRoKSA9PiB7XG4gICAgICBwbGFpbiA9IHNldERlZXAocGxhaW4sIHBhcnNlUGF0aChpZGVudGljYWxQYXRoKSwgKCkgPT4gcGxhaW4pO1xuICAgIH0pO1xuICAgIGlmIChvdGhlcikge1xuICAgICAgZm9yRWFjaChvdGhlciwgYXBwbHkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoKGFubm90YXRpb25zLCBhcHBseSk7XG4gIH1cbiAgcmV0dXJuIHBsYWluO1xufVxudmFyIGlzRGVlcCA9IChvYmplY3QsIHN1cGVySnNvbikgPT4gaXNQbGFpbk9iamVjdDIob2JqZWN0KSB8fCBpc0FycmF5KG9iamVjdCkgfHwgaXNNYXAob2JqZWN0KSB8fCBpc1NldChvYmplY3QpIHx8IGlzSW5zdGFuY2VPZlJlZ2lzdGVyZWRDbGFzcyhvYmplY3QsIHN1cGVySnNvbik7XG5mdW5jdGlvbiBhZGRJZGVudGl0eShvYmplY3QsIHBhdGgsIGlkZW50aXRpZXMpIHtcbiAgY29uc3QgZXhpc3RpbmdTZXQgPSBpZGVudGl0aWVzLmdldChvYmplY3QpO1xuICBpZiAoZXhpc3RpbmdTZXQpIHtcbiAgICBleGlzdGluZ1NldC5wdXNoKHBhdGgpO1xuICB9IGVsc2Uge1xuICAgIGlkZW50aXRpZXMuc2V0KG9iamVjdCwgW3BhdGhdKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2VuZXJhdGVSZWZlcmVudGlhbEVxdWFsaXR5QW5ub3RhdGlvbnMoaWRlbnRpdGl0ZXMsIGRlZHVwZSkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgbGV0IHJvb3RFcXVhbGl0eVBhdGhzID0gdm9pZCAwO1xuICBpZGVudGl0aXRlcy5mb3JFYWNoKChwYXRocykgPT4ge1xuICAgIGlmIChwYXRocy5sZW5ndGggPD0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWRlZHVwZSkge1xuICAgICAgcGF0aHMgPSBwYXRocy5tYXAoKHBhdGgpID0+IHBhdGgubWFwKFN0cmluZykpLnNvcnQoKGEsIGIpID0+IGEubGVuZ3RoIC0gYi5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBbcmVwcmVzZW50YXRpdmVQYXRoLCAuLi5pZGVudGljYWxQYXRoc10gPSBwYXRocztcbiAgICBpZiAocmVwcmVzZW50YXRpdmVQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcm9vdEVxdWFsaXR5UGF0aHMgPSBpZGVudGljYWxQYXRocy5tYXAoc3RyaW5naWZ5UGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtzdHJpbmdpZnlQYXRoKHJlcHJlc2VudGF0aXZlUGF0aCldID0gaWRlbnRpY2FsUGF0aHMubWFwKHN0cmluZ2lmeVBhdGgpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChyb290RXF1YWxpdHlQYXRocykge1xuICAgIGlmIChpc0VtcHR5T2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBbcm9vdEVxdWFsaXR5UGF0aHNdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3Jvb3RFcXVhbGl0eVBhdGhzLCByZXN1bHRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaXNFbXB0eU9iamVjdChyZXN1bHQpID8gdm9pZCAwIDogcmVzdWx0O1xuICB9XG59XG52YXIgd2Fsa2VyID0gKG9iamVjdCwgaWRlbnRpdGllcywgc3VwZXJKc29uLCBkZWR1cGUsIHBhdGggPSBbXSwgb2JqZWN0c0luVGhpc1BhdGggPSBbXSwgc2Vlbk9iamVjdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSA9PiB7XG4gIHZhciBfYTI1O1xuICBjb25zdCBwcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTIob2JqZWN0KTtcbiAgaWYgKCFwcmltaXRpdmUpIHtcbiAgICBhZGRJZGVudGl0eShvYmplY3QsIHBhdGgsIGlkZW50aXRpZXMpO1xuICAgIGNvbnN0IHNlZW4gPSBzZWVuT2JqZWN0cy5nZXQob2JqZWN0KTtcbiAgICBpZiAoc2Vlbikge1xuICAgICAgcmV0dXJuIGRlZHVwZSA/IHtcbiAgICAgICAgdHJhbnNmb3JtZWRWYWx1ZTogbnVsbFxuICAgICAgfSA6IHNlZW47XG4gICAgfVxuICB9XG4gIGlmICghaXNEZWVwKG9iamVjdCwgc3VwZXJKc29uKSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkMiA9IHRyYW5zZm9ybVZhbHVlKG9iamVjdCwgc3VwZXJKc29uKTtcbiAgICBjb25zdCByZXN1bHQyID0gdHJhbnNmb3JtZWQyID8ge1xuICAgICAgdHJhbnNmb3JtZWRWYWx1ZTogdHJhbnNmb3JtZWQyLnZhbHVlLFxuICAgICAgYW5ub3RhdGlvbnM6IFt0cmFuc2Zvcm1lZDIudHlwZV1cbiAgICB9IDoge1xuICAgICAgdHJhbnNmb3JtZWRWYWx1ZTogb2JqZWN0XG4gICAgfTtcbiAgICBpZiAoIXByaW1pdGl2ZSkge1xuICAgICAgc2Vlbk9iamVjdHMuc2V0KG9iamVjdCwgcmVzdWx0Mik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQyO1xuICB9XG4gIGlmIChpbmNsdWRlcyhvYmplY3RzSW5UaGlzUGF0aCwgb2JqZWN0KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2Zvcm1lZFZhbHVlOiBudWxsXG4gICAgfTtcbiAgfVxuICBjb25zdCB0cmFuc2Zvcm1hdGlvblJlc3VsdCA9IHRyYW5zZm9ybVZhbHVlKG9iamVjdCwgc3VwZXJKc29uKTtcbiAgY29uc3QgdHJhbnNmb3JtZWQgPSAoX2EyNSA9IHRyYW5zZm9ybWF0aW9uUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiB0cmFuc2Zvcm1hdGlvblJlc3VsdC52YWx1ZSkgIT0gbnVsbCA/IF9hMjUgOiBvYmplY3Q7XG4gIGNvbnN0IHRyYW5zZm9ybWVkVmFsdWUgPSBpc0FycmF5KHRyYW5zZm9ybWVkKSA/IFtdIDoge307XG4gIGNvbnN0IGlubmVyQW5ub3RhdGlvbnMgPSB7fTtcbiAgZm9yRWFjaCh0cmFuc2Zvcm1lZCwgKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gXCJfX3Byb3RvX19cIiB8fCBpbmRleCA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IGluZGV4ID09PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYERldGVjdGVkIHByb3BlcnR5ICR7aW5kZXh9LiBUaGlzIGlzIGEgcHJvdG90eXBlIHBvbGx1dGlvbiByaXNrLCBwbGVhc2UgcmVtb3ZlIGl0IGZyb20geW91ciBvYmplY3QuYCk7XG4gICAgfVxuICAgIGNvbnN0IHJlY3Vyc2l2ZVJlc3VsdCA9IHdhbGtlcih2YWx1ZSwgaWRlbnRpdGllcywgc3VwZXJKc29uLCBkZWR1cGUsIFsuLi5wYXRoLCBpbmRleF0sIFsuLi5vYmplY3RzSW5UaGlzUGF0aCwgb2JqZWN0XSwgc2Vlbk9iamVjdHMpO1xuICAgIHRyYW5zZm9ybWVkVmFsdWVbaW5kZXhdID0gcmVjdXJzaXZlUmVzdWx0LnRyYW5zZm9ybWVkVmFsdWU7XG4gICAgaWYgKGlzQXJyYXkocmVjdXJzaXZlUmVzdWx0LmFubm90YXRpb25zKSkge1xuICAgICAgaW5uZXJBbm5vdGF0aW9uc1tpbmRleF0gPSByZWN1cnNpdmVSZXN1bHQuYW5ub3RhdGlvbnM7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0MihyZWN1cnNpdmVSZXN1bHQuYW5ub3RhdGlvbnMpKSB7XG4gICAgICBmb3JFYWNoKHJlY3Vyc2l2ZVJlc3VsdC5hbm5vdGF0aW9ucywgKHRyZWUsIGtleSkgPT4ge1xuICAgICAgICBpbm5lckFubm90YXRpb25zW2VzY2FwZUtleShpbmRleCkgKyBcIi5cIiArIGtleV0gPSB0cmVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0gaXNFbXB0eU9iamVjdChpbm5lckFubm90YXRpb25zKSA/IHtcbiAgICB0cmFuc2Zvcm1lZFZhbHVlLFxuICAgIGFubm90YXRpb25zOiAhIXRyYW5zZm9ybWF0aW9uUmVzdWx0ID8gW3RyYW5zZm9ybWF0aW9uUmVzdWx0LnR5cGVdIDogdm9pZCAwXG4gIH0gOiB7XG4gICAgdHJhbnNmb3JtZWRWYWx1ZSxcbiAgICBhbm5vdGF0aW9uczogISF0cmFuc2Zvcm1hdGlvblJlc3VsdCA/IFt0cmFuc2Zvcm1hdGlvblJlc3VsdC50eXBlLCBpbm5lckFubm90YXRpb25zXSA6IGlubmVyQW5ub3RhdGlvbnNcbiAgfTtcbiAgaWYgKCFwcmltaXRpdmUpIHtcbiAgICBzZWVuT2JqZWN0cy5zZXQob2JqZWN0LCByZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY29weS1hbnl0aGluZ0AzLjAuNS9ub2RlX21vZHVsZXMvY29weS1hbnl0aGluZy9kaXN0L2luZGV4LmpzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXMtd2hhdEA0LjEuMTYvbm9kZV9tb2R1bGVzL2lzLXdoYXQvZGlzdC9pbmRleC5qc1xuaW5pdF9lc21fc2hpbXMoKTtcbmZ1bmN0aW9uIGdldFR5cGUyKHBheWxvYWQpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwYXlsb2FkKS5zbGljZSg4LCAtMSk7XG59XG5mdW5jdGlvbiBpc0FycmF5MihwYXlsb2FkKSB7XG4gIHJldHVybiBnZXRUeXBlMihwYXlsb2FkKSA9PT0gXCJBcnJheVwiO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdDMocGF5bG9hZCkge1xuICBpZiAoZ2V0VHlwZTIocGF5bG9hZCkgIT09IFwiT2JqZWN0XCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGF5bG9hZCk7XG4gIHJldHVybiAhIXByb3RvdHlwZSAmJiBwcm90b3R5cGUuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5mdW5jdGlvbiBpc051bGwyKHBheWxvYWQpIHtcbiAgcmV0dXJuIGdldFR5cGUyKHBheWxvYWQpID09PSBcIk51bGxcIjtcbn1cbmZ1bmN0aW9uIGlzT25lT2YoYSwgYiwgYywgZCwgZSkge1xuICByZXR1cm4gKHZhbHVlKSA9PiBhKHZhbHVlKSB8fCBiKHZhbHVlKSB8fCAhIWMgJiYgYyh2YWx1ZSkgfHwgISFkICYmIGQodmFsdWUpIHx8ICEhZSAmJiBlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkMihwYXlsb2FkKSB7XG4gIHJldHVybiBnZXRUeXBlMihwYXlsb2FkKSA9PT0gXCJVbmRlZmluZWRcIjtcbn1cbnZhciBpc051bGxPclVuZGVmaW5lZCA9IGlzT25lT2YoaXNOdWxsMiwgaXNVbmRlZmluZWQyKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvcHktYW55dGhpbmdAMy4wLjUvbm9kZV9tb2R1bGVzL2NvcHktYW55dGhpbmcvZGlzdC9pbmRleC5qc1xuZnVuY3Rpb24gYXNzaWduUHJvcChjYXJyeSwga2V5LCBuZXdWYWwsIG9yaWdpbmFsT2JqZWN0LCBpbmNsdWRlTm9uZW51bWVyYWJsZSkge1xuICBjb25zdCBwcm9wVHlwZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob3JpZ2luYWxPYmplY3QsIGtleSkgPyBcImVudW1lcmFibGVcIiA6IFwibm9uZW51bWVyYWJsZVwiO1xuICBpZiAocHJvcFR5cGUgPT09IFwiZW51bWVyYWJsZVwiKVxuICAgIGNhcnJ5W2tleV0gPSBuZXdWYWw7XG4gIGlmIChpbmNsdWRlTm9uZW51bWVyYWJsZSAmJiBwcm9wVHlwZSA9PT0gXCJub25lbnVtZXJhYmxlXCIpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FycnksIGtleSwge1xuICAgICAgdmFsdWU6IG5ld1ZhbCxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY29weSh0YXJnZXQyMiwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmIChpc0FycmF5Mih0YXJnZXQyMikpIHtcbiAgICByZXR1cm4gdGFyZ2V0MjIubWFwKChpdGVtKSA9PiBjb3B5KGl0ZW0sIG9wdGlvbnMpKTtcbiAgfVxuICBpZiAoIWlzUGxhaW5PYmplY3QzKHRhcmdldDIyKSkge1xuICAgIHJldHVybiB0YXJnZXQyMjtcbiAgfVxuICBjb25zdCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldDIyKTtcbiAgY29uc3Qgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0MjIpO1xuICByZXR1cm4gWy4uLnByb3BzLCAuLi5zeW1ib2xzXS5yZWR1Y2UoKGNhcnJ5LCBrZXkpID0+IHtcbiAgICBpZiAoaXNBcnJheTIob3B0aW9ucy5wcm9wcykgJiYgIW9wdGlvbnMucHJvcHMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhcnJ5O1xuICAgIH1cbiAgICBjb25zdCB2YWwgPSB0YXJnZXQyMltrZXldO1xuICAgIGNvbnN0IG5ld1ZhbCA9IGNvcHkodmFsLCBvcHRpb25zKTtcbiAgICBhc3NpZ25Qcm9wKGNhcnJ5LCBrZXksIG5ld1ZhbCwgdGFyZ2V0MjIsIG9wdGlvbnMubm9uZW51bWVyYWJsZSk7XG4gICAgcmV0dXJuIGNhcnJ5O1xuICB9LCB7fSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zdXBlcmpzb25AMi4yLjIvbm9kZV9tb2R1bGVzL3N1cGVyanNvbi9kaXN0L2luZGV4LmpzXG52YXIgU3VwZXJKU09OID0gY2xhc3Mge1xuICAvKipcbiAgICogQHBhcmFtIGRlZHVwZVJlZmVyZW50aWFsRXF1YWxpdGllcyAgSWYgdHJ1ZSwgU3VwZXJKU09OIHdpbGwgbWFrZSBzdXJlIG9ubHkgb25lIGluc3RhbmNlIG9mIHJlZmVyZW50aWFsbHkgZXF1YWwgb2JqZWN0cyBhcmUgc2VyaWFsaXplZCBhbmQgdGhlIHJlc3QgYXJlIHJlcGxhY2VkIHdpdGggYG51bGxgLlxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBkZWR1cGUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICB0aGlzLmNsYXNzUmVnaXN0cnkgPSBuZXcgQ2xhc3NSZWdpc3RyeSgpO1xuICAgIHRoaXMuc3ltYm9sUmVnaXN0cnkgPSBuZXcgUmVnaXN0cnkoKHMpID0+IHtcbiAgICAgIHZhciBfYTI1O1xuICAgICAgcmV0dXJuIChfYTI1ID0gcy5kZXNjcmlwdGlvbikgIT0gbnVsbCA/IF9hMjUgOiBcIlwiO1xuICAgIH0pO1xuICAgIHRoaXMuY3VzdG9tVHJhbnNmb3JtZXJSZWdpc3RyeSA9IG5ldyBDdXN0b21UcmFuc2Zvcm1lclJlZ2lzdHJ5KCk7XG4gICAgdGhpcy5hbGxvd2VkRXJyb3JQcm9wcyA9IFtdO1xuICAgIHRoaXMuZGVkdXBlID0gZGVkdXBlO1xuICB9XG4gIHNlcmlhbGl6ZShvYmplY3QpIHtcbiAgICBjb25zdCBpZGVudGl0aWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBvdXRwdXQgPSB3YWxrZXIob2JqZWN0LCBpZGVudGl0aWVzLCB0aGlzLCB0aGlzLmRlZHVwZSk7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAganNvbjogb3V0cHV0LnRyYW5zZm9ybWVkVmFsdWVcbiAgICB9O1xuICAgIGlmIChvdXRwdXQuYW5ub3RhdGlvbnMpIHtcbiAgICAgIHJlcy5tZXRhID0ge1xuICAgICAgICAuLi5yZXMubWV0YSxcbiAgICAgICAgdmFsdWVzOiBvdXRwdXQuYW5ub3RhdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVxdWFsaXR5QW5ub3RhdGlvbnMgPSBnZW5lcmF0ZVJlZmVyZW50aWFsRXF1YWxpdHlBbm5vdGF0aW9ucyhpZGVudGl0aWVzLCB0aGlzLmRlZHVwZSk7XG4gICAgaWYgKGVxdWFsaXR5QW5ub3RhdGlvbnMpIHtcbiAgICAgIHJlcy5tZXRhID0ge1xuICAgICAgICAuLi5yZXMubWV0YSxcbiAgICAgICAgcmVmZXJlbnRpYWxFcXVhbGl0aWVzOiBlcXVhbGl0eUFubm90YXRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGRlc2VyaWFsaXplKHBheWxvYWQpIHtcbiAgICBjb25zdCB7IGpzb24sIG1ldGEgfSA9IHBheWxvYWQ7XG4gICAgbGV0IHJlc3VsdCA9IGNvcHkoanNvbik7XG4gICAgaWYgKG1ldGEgPT0gbnVsbCA/IHZvaWQgMCA6IG1ldGEudmFsdWVzKSB7XG4gICAgICByZXN1bHQgPSBhcHBseVZhbHVlQW5ub3RhdGlvbnMocmVzdWx0LCBtZXRhLnZhbHVlcywgdGhpcyk7XG4gICAgfVxuICAgIGlmIChtZXRhID09IG51bGwgPyB2b2lkIDAgOiBtZXRhLnJlZmVyZW50aWFsRXF1YWxpdGllcykge1xuICAgICAgcmVzdWx0ID0gYXBwbHlSZWZlcmVudGlhbEVxdWFsaXR5QW5ub3RhdGlvbnMocmVzdWx0LCBtZXRhLnJlZmVyZW50aWFsRXF1YWxpdGllcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RyaW5naWZ5KG9iamVjdCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnNlcmlhbGl6ZShvYmplY3QpKTtcbiAgfVxuICBwYXJzZShzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZShKU09OLnBhcnNlKHN0cmluZykpO1xuICB9XG4gIHJlZ2lzdGVyQ2xhc3Modiwgb3B0aW9ucykge1xuICAgIHRoaXMuY2xhc3NSZWdpc3RyeS5yZWdpc3Rlcih2LCBvcHRpb25zKTtcbiAgfVxuICByZWdpc3RlclN5bWJvbCh2LCBpZGVudGlmaWVyKSB7XG4gICAgdGhpcy5zeW1ib2xSZWdpc3RyeS5yZWdpc3Rlcih2LCBpZGVudGlmaWVyKTtcbiAgfVxuICByZWdpc3RlckN1c3RvbSh0cmFuc2Zvcm1lciwgbmFtZSkge1xuICAgIHRoaXMuY3VzdG9tVHJhbnNmb3JtZXJSZWdpc3RyeS5yZWdpc3Rlcih7XG4gICAgICBuYW1lLFxuICAgICAgLi4udHJhbnNmb3JtZXJcbiAgICB9KTtcbiAgfVxuICBhbGxvd0Vycm9yUHJvcHMoLi4ucHJvcHMpIHtcbiAgICB0aGlzLmFsbG93ZWRFcnJvclByb3BzLnB1c2goLi4ucHJvcHMpO1xuICB9XG59O1xuU3VwZXJKU09OLmRlZmF1bHRJbnN0YW5jZSA9IG5ldyBTdXBlckpTT04oKTtcblN1cGVySlNPTi5zZXJpYWxpemUgPSBTdXBlckpTT04uZGVmYXVsdEluc3RhbmNlLnNlcmlhbGl6ZS5iaW5kKFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2UpO1xuU3VwZXJKU09OLmRlc2VyaWFsaXplID0gU3VwZXJKU09OLmRlZmF1bHRJbnN0YW5jZS5kZXNlcmlhbGl6ZS5iaW5kKFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2UpO1xuU3VwZXJKU09OLnN0cmluZ2lmeSA9IFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2Uuc3RyaW5naWZ5LmJpbmQoU3VwZXJKU09OLmRlZmF1bHRJbnN0YW5jZSk7XG5TdXBlckpTT04ucGFyc2UgPSBTdXBlckpTT04uZGVmYXVsdEluc3RhbmNlLnBhcnNlLmJpbmQoU3VwZXJKU09OLmRlZmF1bHRJbnN0YW5jZSk7XG5TdXBlckpTT04ucmVnaXN0ZXJDbGFzcyA9IFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2UucmVnaXN0ZXJDbGFzcy5iaW5kKFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2UpO1xuU3VwZXJKU09OLnJlZ2lzdGVyU3ltYm9sID0gU3VwZXJKU09OLmRlZmF1bHRJbnN0YW5jZS5yZWdpc3RlclN5bWJvbC5iaW5kKFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2UpO1xuU3VwZXJKU09OLnJlZ2lzdGVyQ3VzdG9tID0gU3VwZXJKU09OLmRlZmF1bHRJbnN0YW5jZS5yZWdpc3RlckN1c3RvbS5iaW5kKFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2UpO1xuU3VwZXJKU09OLmFsbG93RXJyb3JQcm9wcyA9IFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2UuYWxsb3dFcnJvclByb3BzLmJpbmQoU3VwZXJKU09OLmRlZmF1bHRJbnN0YW5jZSk7XG52YXIgc2VyaWFsaXplID0gU3VwZXJKU09OLnNlcmlhbGl6ZTtcbnZhciBkZXNlcmlhbGl6ZSA9IFN1cGVySlNPTi5kZXNlcmlhbGl6ZTtcbnZhciBzdHJpbmdpZnkgPSBTdXBlckpTT04uc3RyaW5naWZ5O1xudmFyIHBhcnNlID0gU3VwZXJKU09OLnBhcnNlO1xudmFyIHJlZ2lzdGVyQ2xhc3MgPSBTdXBlckpTT04ucmVnaXN0ZXJDbGFzcztcbnZhciByZWdpc3RlckN1c3RvbSA9IFN1cGVySlNPTi5yZWdpc3RlckN1c3RvbTtcbnZhciByZWdpc3RlclN5bWJvbCA9IFN1cGVySlNPTi5yZWdpc3RlclN5bWJvbDtcbnZhciBhbGxvd0Vycm9yUHJvcHMgPSBTdXBlckpTT04uYWxsb3dFcnJvclByb3BzO1xuXG4vLyBzcmMvbWVzc2FnaW5nL3ByZXNldHMvYnJvYWRjYXN0LWNoYW5uZWwvY29udGV4dC50c1xuaW5pdF9lc21fc2hpbXMoKTtcbnZhciBfX0RFVlRPT0xTX0tJVF9CUk9BRENBU1RfTUVTU0FHSU5HX0VWRU5UX0tFWSA9IFwiX19kZXZ0b29scy1raXQtYnJvYWRjYXN0LW1lc3NhZ2luZy1ldmVudC1rZXlfX1wiO1xuXG4vLyBzcmMvbWVzc2FnaW5nL3ByZXNldHMvYnJvYWRjYXN0LWNoYW5uZWwvaW5kZXgudHNcbnZhciBCUk9BRENBU1RfQ0hBTk5FTF9OQU1FID0gXCJfX2RldnRvb2xzLWtpdDpicm9hZGNhc3QtY2hhbm5lbF9fXCI7XG5mdW5jdGlvbiBjcmVhdGVCcm9hZGNhc3RDaGFubmVsKCkge1xuICBjb25zdCBjaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoQlJPQURDQVNUX0NIQU5ORUxfTkFNRSk7XG4gIHJldHVybiB7XG4gICAgcG9zdDogKGRhdGEpID0+IHtcbiAgICAgIGNoYW5uZWwucG9zdE1lc3NhZ2UoU3VwZXJKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGV2ZW50OiBfX0RFVlRPT0xTX0tJVF9CUk9BRENBU1RfTUVTU0FHSU5HX0VWRU5UX0tFWSxcbiAgICAgICAgZGF0YVxuICAgICAgfSkpO1xuICAgIH0sXG4gICAgb246IChoYW5kbGVyKSA9PiB7XG4gICAgICBjaGFubmVsLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBTdXBlckpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgIGlmIChwYXJzZWQuZXZlbnQgPT09IF9fREVWVE9PTFNfS0lUX0JST0FEQ0FTVF9NRVNTQUdJTkdfRVZFTlRfS0VZKSB7XG4gICAgICAgICAgaGFuZGxlcihwYXJzZWQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWVzc2FnaW5nL3ByZXNldHMvZWxlY3Ryb24vaW5kZXgudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy9tZXNzYWdpbmcvcHJlc2V0cy9lbGVjdHJvbi9jbGllbnQudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy9tZXNzYWdpbmcvcHJlc2V0cy9lbGVjdHJvbi9jb250ZXh0LnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgdGFyZ2V0IGFzIHRhcmdldDE2IH0gZnJvbSBcIkB2dWUvZGV2dG9vbHMtc2hhcmVkXCI7XG52YXIgX19FTEVDVFJPTl9DTElFTlRfQ09OVEVYVF9fID0gXCJlbGVjdHJvbjpjbGllbnQtY29udGV4dFwiO1xudmFyIF9fRUxFQ1RST05fUlBPWFlfQ09OVEVYVF9fID0gXCJlbGVjdHJvbjpwcm94eS1jb250ZXh0XCI7XG52YXIgX19FTEVDVFJPTl9TRVJWRVJfQ09OVEVYVF9fID0gXCJlbGVjdHJvbjpzZXJ2ZXItY29udGV4dFwiO1xudmFyIF9fREVWVE9PTFNfS0lUX0VMRUNUUk9OX01FU1NBR0lOR19FVkVOVF9LRVlfXyA9IHtcbiAgLy8gY2xpZW50XG4gIENMSUVOVF9UT19QUk9YWTogXCJjbGllbnQtPnByb3h5XCIsXG4gIC8vIG9uOiBwcm94eS0+Y2xpZW50XG4gIC8vIHByb3h5XG4gIFBST1hZX1RPX0NMSUVOVDogXCJwcm94eS0+Y2xpZW50XCIsXG4gIC8vIG9uOiBzZXJ2ZXItPnByb3h5XG4gIFBST1hZX1RPX1NFUlZFUjogXCJwcm94eS0+c2VydmVyXCIsXG4gIC8vIG9uOiBjbGllbnQtPnByb3h5XG4gIC8vIHNlcnZlclxuICBTRVJWRVJfVE9fUFJPWFk6IFwic2VydmVyLT5wcm94eVwiXG4gIC8vIG9uOiBwcm94eS0+c2VydmVyXG59O1xuZnVuY3Rpb24gZ2V0RWxlY3Ryb25DbGllbnRDb250ZXh0KCkge1xuICByZXR1cm4gdGFyZ2V0MTZbX19FTEVDVFJPTl9DTElFTlRfQ09OVEVYVF9fXTtcbn1cbmZ1bmN0aW9uIHNldEVsZWN0cm9uQ2xpZW50Q29udGV4dChjb250ZXh0KSB7XG4gIHRhcmdldDE2W19fRUxFQ1RST05fQ0xJRU5UX0NPTlRFWFRfX10gPSBjb250ZXh0O1xufVxuZnVuY3Rpb24gZ2V0RWxlY3Ryb25Qcm94eUNvbnRleHQoKSB7XG4gIHJldHVybiB0YXJnZXQxNltfX0VMRUNUUk9OX1JQT1hZX0NPTlRFWFRfX107XG59XG5mdW5jdGlvbiBzZXRFbGVjdHJvblByb3h5Q29udGV4dChjb250ZXh0KSB7XG4gIHRhcmdldDE2W19fRUxFQ1RST05fUlBPWFlfQ09OVEVYVF9fXSA9IGNvbnRleHQ7XG59XG5mdW5jdGlvbiBnZXRFbGVjdHJvblNlcnZlckNvbnRleHQoKSB7XG4gIHJldHVybiB0YXJnZXQxNltfX0VMRUNUUk9OX1NFUlZFUl9DT05URVhUX19dO1xufVxuZnVuY3Rpb24gc2V0RWxlY3Ryb25TZXJ2ZXJDb250ZXh0KGNvbnRleHQpIHtcbiAgdGFyZ2V0MTZbX19FTEVDVFJPTl9TRVJWRVJfQ09OVEVYVF9fXSA9IGNvbnRleHQ7XG59XG5cbi8vIHNyYy9tZXNzYWdpbmcvcHJlc2V0cy9lbGVjdHJvbi9jbGllbnQudHNcbmZ1bmN0aW9uIGNyZWF0ZUVsZWN0cm9uQ2xpZW50Q2hhbm5lbCgpIHtcbiAgY29uc3Qgc29ja2V0ID0gZ2V0RWxlY3Ryb25DbGllbnRDb250ZXh0KCk7XG4gIHJldHVybiB7XG4gICAgcG9zdDogKGRhdGEpID0+IHtcbiAgICAgIHNvY2tldC5lbWl0KF9fREVWVE9PTFNfS0lUX0VMRUNUUk9OX01FU1NBR0lOR19FVkVOVF9LRVlfXy5DTElFTlRfVE9fUFJPWFksIFN1cGVySlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIH0sXG4gICAgb246IChoYW5kbGVyKSA9PiB7XG4gICAgICBzb2NrZXQub24oX19ERVZUT09MU19LSVRfRUxFQ1RST05fTUVTU0FHSU5HX0VWRU5UX0tFWV9fLlBST1hZX1RPX0NMSUVOVCwgKGUpID0+IHtcbiAgICAgICAgaGFuZGxlcihTdXBlckpTT04ucGFyc2UoZSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWVzc2FnaW5nL3ByZXNldHMvZWxlY3Ryb24vcHJveHkudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5mdW5jdGlvbiBjcmVhdGVFbGVjdHJvblByb3h5Q2hhbm5lbCgpIHtcbiAgY29uc3Qgc29ja2V0ID0gZ2V0RWxlY3Ryb25Qcm94eUNvbnRleHQoKTtcbiAgcmV0dXJuIHtcbiAgICBwb3N0OiAoZGF0YSkgPT4ge1xuICAgIH0sXG4gICAgb246IChoYW5kbGVyKSA9PiB7XG4gICAgICBzb2NrZXQub24oX19ERVZUT09MU19LSVRfRUxFQ1RST05fTUVTU0FHSU5HX0VWRU5UX0tFWV9fLlNFUlZFUl9UT19QUk9YWSwgKGRhdGEpID0+IHtcbiAgICAgICAgc29ja2V0LmJyb2FkY2FzdC5lbWl0KF9fREVWVE9PTFNfS0lUX0VMRUNUUk9OX01FU1NBR0lOR19FVkVOVF9LRVlfXy5QUk9YWV9UT19DTElFTlQsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBzb2NrZXQub24oX19ERVZUT09MU19LSVRfRUxFQ1RST05fTUVTU0FHSU5HX0VWRU5UX0tFWV9fLkNMSUVOVF9UT19QUk9YWSwgKGRhdGEpID0+IHtcbiAgICAgICAgc29ja2V0LmJyb2FkY2FzdC5lbWl0KF9fREVWVE9PTFNfS0lUX0VMRUNUUk9OX01FU1NBR0lOR19FVkVOVF9LRVlfXy5QUk9YWV9UT19TRVJWRVIsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWVzc2FnaW5nL3ByZXNldHMvZWxlY3Ryb24vc2VydmVyLnRzXG5pbml0X2VzbV9zaGltcygpO1xuZnVuY3Rpb24gY3JlYXRlRWxlY3Ryb25TZXJ2ZXJDaGFubmVsKCkge1xuICBjb25zdCBzb2NrZXQgPSBnZXRFbGVjdHJvblNlcnZlckNvbnRleHQoKTtcbiAgcmV0dXJuIHtcbiAgICBwb3N0OiAoZGF0YSkgPT4ge1xuICAgICAgc29ja2V0LmVtaXQoX19ERVZUT09MU19LSVRfRUxFQ1RST05fTUVTU0FHSU5HX0VWRU5UX0tFWV9fLlNFUlZFUl9UT19QUk9YWSwgU3VwZXJKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgfSxcbiAgICBvbjogKGhhbmRsZXIpID0+IHtcbiAgICAgIHNvY2tldC5vbihfX0RFVlRPT0xTX0tJVF9FTEVDVFJPTl9NRVNTQUdJTkdfRVZFTlRfS0VZX18uUFJPWFlfVE9fU0VSVkVSLCAoZGF0YSkgPT4ge1xuICAgICAgICBoYW5kbGVyKFN1cGVySlNPTi5wYXJzZShkYXRhKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXNzYWdpbmcvcHJlc2V0cy9leHRlbnNpb24vaW5kZXgudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy9tZXNzYWdpbmcvcHJlc2V0cy9leHRlbnNpb24vY2xpZW50LnRzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyBzcmMvbWVzc2FnaW5nL3ByZXNldHMvZXh0ZW5zaW9uL2NvbnRleHQudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5pbXBvcnQgeyB0YXJnZXQgYXMgdGFyZ2V0MTcgfSBmcm9tIFwiQHZ1ZS9kZXZ0b29scy1zaGFyZWRcIjtcbnZhciBfX0VYVEVOU0lPTl9DTElFTlRfQ09OVEVYVF9fID0gXCJlbGVjdHJvbjpjbGllbnQtY29udGV4dFwiO1xudmFyIF9fREVWVE9PTFNfS0lUX0VYVEVOU0lPTl9NRVNTQUdJTkdfRVZFTlRfS0VZX18gPSB7XG4gIC8vIGNsaWVudFxuICBDTElFTlRfVE9fUFJPWFk6IFwiY2xpZW50LT5wcm94eVwiLFxuICAvLyBvbjogcHJveHktPmNsaWVudFxuICAvLyBwcm94eVxuICBQUk9YWV9UT19DTElFTlQ6IFwicHJveHktPmNsaWVudFwiLFxuICAvLyBvbjogc2VydmVyLT5wcm94eVxuICBQUk9YWV9UT19TRVJWRVI6IFwicHJveHktPnNlcnZlclwiLFxuICAvLyBvbjogY2xpZW50LT5wcm94eVxuICAvLyBzZXJ2ZXJcbiAgU0VSVkVSX1RPX1BST1hZOiBcInNlcnZlci0+cHJveHlcIlxuICAvLyBvbjogcHJveHktPnNlcnZlclxufTtcbmZ1bmN0aW9uIGdldEV4dGVuc2lvbkNsaWVudENvbnRleHQoKSB7XG4gIHJldHVybiB0YXJnZXQxN1tfX0VYVEVOU0lPTl9DTElFTlRfQ09OVEVYVF9fXTtcbn1cbmZ1bmN0aW9uIHNldEV4dGVuc2lvbkNsaWVudENvbnRleHQoY29udGV4dCkge1xuICB0YXJnZXQxN1tfX0VYVEVOU0lPTl9DTElFTlRfQ09OVEVYVF9fXSA9IGNvbnRleHQ7XG59XG5cbi8vIHNyYy9tZXNzYWdpbmcvcHJlc2V0cy9leHRlbnNpb24vY2xpZW50LnRzXG5mdW5jdGlvbiBjcmVhdGVFeHRlbnNpb25DbGllbnRDaGFubmVsKCkge1xuICBsZXQgZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIGxldCBwb3J0ID0gbnVsbDtcbiAgbGV0IHJlY29ubmVjdFRpbWVyID0gbnVsbDtcbiAgbGV0IG9uTWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgIHRyeSB7XG4gICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZXIpO1xuICAgICAgcG9ydCA9IGNocm9tZS5ydW50aW1lLmNvbm5lY3Qoe1xuICAgICAgICBuYW1lOiBgJHtjaHJvbWUuZGV2dG9vbHMuaW5zcGVjdGVkV2luZG93LnRhYklkfWBcbiAgICAgIH0pO1xuICAgICAgc2V0RXh0ZW5zaW9uQ2xpZW50Q29udGV4dChwb3J0KTtcbiAgICAgIGRpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgcG9ydCA9PSBudWxsID8gdm9pZCAwIDogcG9ydC5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIob25NZXNzYWdlSGFuZGxlcik7XG4gICAgICBwb3J0Lm9uRGlzY29ubmVjdC5hZGRMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgIGRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHBvcnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnQub25NZXNzYWdlLnJlbW92ZUxpc3RlbmVyKG9uTWVzc2FnZUhhbmRsZXIpO1xuICAgICAgICByZWNvbm5lY3RUaW1lciA9IHNldFRpbWVvdXQoY29ubmVjdCwgMWUzKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGNvbm5lY3QoKTtcbiAgcmV0dXJuIHtcbiAgICBwb3N0OiAoZGF0YSkgPT4ge1xuICAgICAgaWYgKGRpc2Nvbm5lY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwb3J0ID09IG51bGwgPyB2b2lkIDAgOiBwb3J0LnBvc3RNZXNzYWdlKFN1cGVySlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIH0sXG4gICAgb246IChoYW5kbGVyKSA9PiB7XG4gICAgICBvbk1lc3NhZ2VIYW5kbGVyID0gKGRhdGEpID0+IHtcbiAgICAgICAgaWYgKGRpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyKFN1cGVySlNPTi5wYXJzZShkYXRhKSk7XG4gICAgICB9O1xuICAgICAgcG9ydCA9PSBudWxsID8gdm9pZCAwIDogcG9ydC5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIob25NZXNzYWdlSGFuZGxlcik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWVzc2FnaW5nL3ByZXNldHMvZXh0ZW5zaW9uL3Byb3h5LnRzXG5pbml0X2VzbV9zaGltcygpO1xuZnVuY3Rpb24gY3JlYXRlRXh0ZW5zaW9uUHJveHlDaGFubmVsKCkge1xuICBjb25zdCBwb3J0ID0gY2hyb21lLnJ1bnRpbWUuY29ubmVjdCh7XG4gICAgbmFtZTogXCJjb250ZW50LXNjcmlwdFwiXG4gIH0pO1xuICBmdW5jdGlvbiBzZW5kTWVzc2FnZVRvVXNlckFwcChwYXlsb2FkKSB7XG4gICAgd2luZG93LnBvc3RNZXNzYWdlKHtcbiAgICAgIHNvdXJjZTogX19ERVZUT09MU19LSVRfRVhURU5TSU9OX01FU1NBR0lOR19FVkVOVF9LRVlfXy5QUk9YWV9UT19TRVJWRVIsXG4gICAgICBwYXlsb2FkXG4gICAgfSwgXCIqXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHNlbmRNZXNzYWdlVG9EZXZUb29sc0NsaWVudChlKSB7XG4gICAgaWYgKGUuZGF0YSAmJiBlLmRhdGEuc291cmNlID09PSBfX0RFVlRPT0xTX0tJVF9FWFRFTlNJT05fTUVTU0FHSU5HX0VWRU5UX0tFWV9fLlNFUlZFUl9UT19QUk9YWSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcG9ydC5wb3N0TWVzc2FnZShlLmRhdGEucGF5bG9hZCk7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwb3J0Lm9uTWVzc2FnZS5hZGRMaXN0ZW5lcihzZW5kTWVzc2FnZVRvVXNlckFwcCk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBzZW5kTWVzc2FnZVRvRGV2VG9vbHNDbGllbnQpO1xuICBwb3J0Lm9uRGlzY29ubmVjdC5hZGRMaXN0ZW5lcigoKSA9PiB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHNlbmRNZXNzYWdlVG9EZXZUb29sc0NsaWVudCk7XG4gICAgc2VuZE1lc3NhZ2VUb1VzZXJBcHAoU3VwZXJKU09OLnN0cmluZ2lmeSh7XG4gICAgICBldmVudDogXCJzaHV0ZG93blwiXG4gICAgfSkpO1xuICB9KTtcbiAgc2VuZE1lc3NhZ2VUb1VzZXJBcHAoU3VwZXJKU09OLnN0cmluZ2lmeSh7XG4gICAgZXZlbnQ6IFwiaW5pdFwiXG4gIH0pKTtcbiAgcmV0dXJuIHtcbiAgICBwb3N0OiAoZGF0YSkgPT4ge1xuICAgIH0sXG4gICAgb246IChoYW5kbGVyKSA9PiB7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWVzc2FnaW5nL3ByZXNldHMvZXh0ZW5zaW9uL3NlcnZlci50c1xuaW5pdF9lc21fc2hpbXMoKTtcbmZ1bmN0aW9uIGNyZWF0ZUV4dGVuc2lvblNlcnZlckNoYW5uZWwoKSB7XG4gIHJldHVybiB7XG4gICAgcG9zdDogKGRhdGEpID0+IHtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZTogX19ERVZUT09MU19LSVRfRVhURU5TSU9OX01FU1NBR0lOR19FVkVOVF9LRVlfXy5TRVJWRVJfVE9fUFJPWFksXG4gICAgICAgIHBheWxvYWQ6IFN1cGVySlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAgIH0sIFwiKlwiKTtcbiAgICB9LFxuICAgIG9uOiAoaGFuZGxlcikgPT4ge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEuc291cmNlID09PSBfX0RFVlRPT0xTX0tJVF9FWFRFTlNJT05fTUVTU0FHSU5HX0VWRU5UX0tFWV9fLlBST1hZX1RPX1NFUlZFUiAmJiBldmVudC5kYXRhLnBheWxvYWQpIHtcbiAgICAgICAgICBoYW5kbGVyKFN1cGVySlNPTi5wYXJzZShldmVudC5kYXRhLnBheWxvYWQpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBsaXN0ZW5lcik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuZXIpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXNzYWdpbmcvcHJlc2V0cy9pZnJhbWUvaW5kZXgudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy9tZXNzYWdpbmcvcHJlc2V0cy9pZnJhbWUvY2xpZW50LnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgaXNCcm93c2VyIGFzIGlzQnJvd3NlcjQgfSBmcm9tIFwiQHZ1ZS9kZXZ0b29scy1zaGFyZWRcIjtcblxuLy8gc3JjL21lc3NhZ2luZy9wcmVzZXRzL2lmcmFtZS9jb250ZXh0LnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgdGFyZ2V0IGFzIHRhcmdldDE4IH0gZnJvbSBcIkB2dWUvZGV2dG9vbHMtc2hhcmVkXCI7XG52YXIgX19ERVZUT09MU19LSVRfSUZSQU1FX01FU1NBR0lOR19FVkVOVF9LRVkgPSBcIl9fZGV2dG9vbHMta2l0LWlmcmFtZS1tZXNzYWdpbmctZXZlbnQta2V5X19cIjtcbnZhciBfX0lGUkFNRV9TRVJWRVJfQ09OVEVYVF9fID0gXCJpZnJhbWU6c2VydmVyLWNvbnRleHRcIjtcbmZ1bmN0aW9uIGdldElmcmFtZVNlcnZlckNvbnRleHQoKSB7XG4gIHJldHVybiB0YXJnZXQxOFtfX0lGUkFNRV9TRVJWRVJfQ09OVEVYVF9fXTtcbn1cbmZ1bmN0aW9uIHNldElmcmFtZVNlcnZlckNvbnRleHQoY29udGV4dCkge1xuICB0YXJnZXQxOFtfX0lGUkFNRV9TRVJWRVJfQ09OVEVYVF9fXSA9IGNvbnRleHQ7XG59XG5cbi8vIHNyYy9tZXNzYWdpbmcvcHJlc2V0cy9pZnJhbWUvY2xpZW50LnRzXG5mdW5jdGlvbiBjcmVhdGVJZnJhbWVDbGllbnRDaGFubmVsKCkge1xuICBpZiAoIWlzQnJvd3NlcjQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdDogKGRhdGEpID0+IHtcbiAgICAgIH0sXG4gICAgICBvbjogKGhhbmRsZXIpID0+IHtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgcG9zdDogKGRhdGEpID0+IHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UoU3VwZXJKU09OLnN0cmluZ2lmeSh7XG4gICAgICBldmVudDogX19ERVZUT09MU19LSVRfSUZSQU1FX01FU1NBR0lOR19FVkVOVF9LRVksXG4gICAgICBkYXRhXG4gICAgfSksIFwiKlwiKSxcbiAgICBvbjogKGhhbmRsZXIpID0+IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IFN1cGVySlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gd2luZG93LnBhcmVudCAmJiBwYXJzZWQuZXZlbnQgPT09IF9fREVWVE9PTFNfS0lUX0lGUkFNRV9NRVNTQUdJTkdfRVZFTlRfS0VZKSB7XG4gICAgICAgICAgaGFuZGxlcihwYXJzZWQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICB9KVxuICB9O1xufVxuXG4vLyBzcmMvbWVzc2FnaW5nL3ByZXNldHMvaWZyYW1lL3NlcnZlci50c1xuaW5pdF9lc21fc2hpbXMoKTtcbmltcG9ydCB7IGlzQnJvd3NlciBhcyBpc0Jyb3dzZXI1IH0gZnJvbSBcIkB2dWUvZGV2dG9vbHMtc2hhcmVkXCI7XG5mdW5jdGlvbiBjcmVhdGVJZnJhbWVTZXJ2ZXJDaGFubmVsKCkge1xuICBpZiAoIWlzQnJvd3NlcjUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdDogKGRhdGEpID0+IHtcbiAgICAgIH0sXG4gICAgICBvbjogKGhhbmRsZXIpID0+IHtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgcG9zdDogKGRhdGEpID0+IHtcbiAgICAgIHZhciBfYTI1O1xuICAgICAgY29uc3QgaWZyYW1lID0gZ2V0SWZyYW1lU2VydmVyQ29udGV4dCgpO1xuICAgICAgKF9hMjUgPSBpZnJhbWUgPT0gbnVsbCA/IHZvaWQgMCA6IGlmcmFtZS5jb250ZW50V2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX2EyNS5wb3N0TWVzc2FnZShTdXBlckpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZXZlbnQ6IF9fREVWVE9PTFNfS0lUX0lGUkFNRV9NRVNTQUdJTkdfRVZFTlRfS0VZLFxuICAgICAgICBkYXRhXG4gICAgICB9KSwgXCIqXCIpO1xuICAgIH0sXG4gICAgb246IChoYW5kbGVyKSA9PiB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGlmcmFtZSA9IGdldElmcmFtZVNlcnZlckNvbnRleHQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBTdXBlckpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gKGlmcmFtZSA9PSBudWxsID8gdm9pZCAwIDogaWZyYW1lLmNvbnRlbnRXaW5kb3cpICYmIHBhcnNlZC5ldmVudCA9PT0gX19ERVZUT09MU19LSVRfSUZSQU1FX01FU1NBR0lOR19FVkVOVF9LRVkpIHtcbiAgICAgICAgICAgIGhhbmRsZXIocGFyc2VkLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXNzYWdpbmcvcHJlc2V0cy92aXRlL2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyBzcmMvbWVzc2FnaW5nL3ByZXNldHMvdml0ZS9jbGllbnQudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy9tZXNzYWdpbmcvcHJlc2V0cy92aXRlL2NvbnRleHQudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5pbXBvcnQgeyB0YXJnZXQgYXMgdGFyZ2V0MTkgfSBmcm9tIFwiQHZ1ZS9kZXZ0b29scy1zaGFyZWRcIjtcbnZhciBfX0RFVlRPT0xTX0tJVF9WSVRFX01FU1NBR0lOR19FVkVOVF9LRVkgPSBcIl9fZGV2dG9vbHMta2l0LXZpdGUtbWVzc2FnaW5nLWV2ZW50LWtleV9fXCI7XG52YXIgX19WSVRFX0NMSUVOVF9DT05URVhUX18gPSBcInZpdGU6Y2xpZW50LWNvbnRleHRcIjtcbnZhciBfX1ZJVEVfU0VSVkVSX0NPTlRFWFRfXyA9IFwidml0ZTpzZXJ2ZXItY29udGV4dFwiO1xuZnVuY3Rpb24gZ2V0Vml0ZUNsaWVudENvbnRleHQoKSB7XG4gIHJldHVybiB0YXJnZXQxOVtfX1ZJVEVfQ0xJRU5UX0NPTlRFWFRfX107XG59XG5mdW5jdGlvbiBzZXRWaXRlQ2xpZW50Q29udGV4dChjb250ZXh0KSB7XG4gIHRhcmdldDE5W19fVklURV9DTElFTlRfQ09OVEVYVF9fXSA9IGNvbnRleHQ7XG59XG5mdW5jdGlvbiBnZXRWaXRlU2VydmVyQ29udGV4dCgpIHtcbiAgcmV0dXJuIHRhcmdldDE5W19fVklURV9TRVJWRVJfQ09OVEVYVF9fXTtcbn1cbmZ1bmN0aW9uIHNldFZpdGVTZXJ2ZXJDb250ZXh0KGNvbnRleHQpIHtcbiAgdGFyZ2V0MTlbX19WSVRFX1NFUlZFUl9DT05URVhUX19dID0gY29udGV4dDtcbn1cblxuLy8gc3JjL21lc3NhZ2luZy9wcmVzZXRzL3ZpdGUvY2xpZW50LnRzXG5mdW5jdGlvbiBjcmVhdGVWaXRlQ2xpZW50Q2hhbm5lbCgpIHtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Vml0ZUNsaWVudENvbnRleHQoKTtcbiAgcmV0dXJuIHtcbiAgICBwb3N0OiAoZGF0YSkgPT4ge1xuICAgICAgY2xpZW50ID09IG51bGwgPyB2b2lkIDAgOiBjbGllbnQuc2VuZChfX0RFVlRPT0xTX0tJVF9WSVRFX01FU1NBR0lOR19FVkVOVF9LRVksIFN1cGVySlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIH0sXG4gICAgb246IChoYW5kbGVyKSA9PiB7XG4gICAgICBjbGllbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNsaWVudC5vbihfX0RFVlRPT0xTX0tJVF9WSVRFX01FU1NBR0lOR19FVkVOVF9LRVksIChldmVudCkgPT4ge1xuICAgICAgICBoYW5kbGVyKFN1cGVySlNPTi5wYXJzZShldmVudCkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWVzc2FnaW5nL3ByZXNldHMvdml0ZS9zZXJ2ZXIudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5mdW5jdGlvbiBjcmVhdGVWaXRlU2VydmVyQ2hhbm5lbCgpIHtcbiAgdmFyIF9hMjU7XG4gIGNvbnN0IHZpdGVTZXJ2ZXIgPSBnZXRWaXRlU2VydmVyQ29udGV4dCgpO1xuICBjb25zdCB3cyA9IChfYTI1ID0gdml0ZVNlcnZlci5ob3QpICE9IG51bGwgPyBfYTI1IDogdml0ZVNlcnZlci53cztcbiAgcmV0dXJuIHtcbiAgICBwb3N0OiAoZGF0YSkgPT4gd3MgPT0gbnVsbCA/IHZvaWQgMCA6IHdzLnNlbmQoX19ERVZUT09MU19LSVRfVklURV9NRVNTQUdJTkdfRVZFTlRfS0VZLCBTdXBlckpTT04uc3RyaW5naWZ5KGRhdGEpKSxcbiAgICBvbjogKGhhbmRsZXIpID0+IHdzID09IG51bGwgPyB2b2lkIDAgOiB3cy5vbihfX0RFVlRPT0xTX0tJVF9WSVRFX01FU1NBR0lOR19FVkVOVF9LRVksIChldmVudCkgPT4ge1xuICAgICAgaGFuZGxlcihTdXBlckpTT04ucGFyc2UoZXZlbnQpKTtcbiAgICB9KVxuICB9O1xufVxuXG4vLyBzcmMvbWVzc2FnaW5nL3ByZXNldHMvd3MvaW5kZXgudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy9tZXNzYWdpbmcvcHJlc2V0cy93cy9jbGllbnQudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy9tZXNzYWdpbmcvcHJlc2V0cy93cy9jb250ZXh0LnRzXG5pbml0X2VzbV9zaGltcygpO1xuaW1wb3J0IHsgdGFyZ2V0IGFzIHRhcmdldDIwIH0gZnJvbSBcIkB2dWUvZGV2dG9vbHMtc2hhcmVkXCI7XG5cbi8vIHNyYy9tZXNzYWdpbmcvcHJlc2V0cy93cy9zZXJ2ZXIudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy9tZXNzYWdpbmcvaW5kZXgudHNcbnZhciBfYTE5LCBfYjE5O1xuKF9iMTkgPSAoX2ExOSA9IHRhcmdldDIxKS5fX1ZVRV9ERVZUT09MU19LSVRfTUVTU0FHRV9DSEFOTkVMU19fKSAhPSBudWxsID8gX2IxOSA6IF9hMTkuX19WVUVfREVWVE9PTFNfS0lUX01FU1NBR0VfQ0hBTk5FTFNfXyA9IFtdO1xudmFyIF9hMjAsIF9iMjA7XG4oX2IyMCA9IChfYTIwID0gdGFyZ2V0MjEpLl9fVlVFX0RFVlRPT0xTX0tJVF9SUENfQ0xJRU5UX18pICE9IG51bGwgPyBfYjIwIDogX2EyMC5fX1ZVRV9ERVZUT09MU19LSVRfUlBDX0NMSUVOVF9fID0gbnVsbDtcbnZhciBfYTIxLCBfYjIxO1xuKF9iMjEgPSAoX2EyMSA9IHRhcmdldDIxKS5fX1ZVRV9ERVZUT09MU19LSVRfUlBDX1NFUlZFUl9fKSAhPSBudWxsID8gX2IyMSA6IF9hMjEuX19WVUVfREVWVE9PTFNfS0lUX1JQQ19TRVJWRVJfXyA9IG51bGw7XG52YXIgX2EyMiwgX2IyMjtcbihfYjIyID0gKF9hMjIgPSB0YXJnZXQyMSkuX19WVUVfREVWVE9PTFNfS0lUX1ZJVEVfUlBDX0NMSUVOVF9fKSAhPSBudWxsID8gX2IyMiA6IF9hMjIuX19WVUVfREVWVE9PTFNfS0lUX1ZJVEVfUlBDX0NMSUVOVF9fID0gbnVsbDtcbnZhciBfYTIzLCBfYjIzO1xuKF9iMjMgPSAoX2EyMyA9IHRhcmdldDIxKS5fX1ZVRV9ERVZUT09MU19LSVRfVklURV9SUENfU0VSVkVSX18pICE9IG51bGwgPyBfYjIzIDogX2EyMy5fX1ZVRV9ERVZUT09MU19LSVRfVklURV9SUENfU0VSVkVSX18gPSBudWxsO1xudmFyIF9hMjQsIF9iMjQ7XG4oX2IyNCA9IChfYTI0ID0gdGFyZ2V0MjEpLl9fVlVFX0RFVlRPT0xTX0tJVF9CUk9BRENBU1RfUlBDX1NFUlZFUl9fKSAhPSBudWxsID8gX2IyNCA6IF9hMjQuX19WVUVfREVWVE9PTFNfS0lUX0JST0FEQ0FTVF9SUENfU0VSVkVSX18gPSBudWxsO1xuZnVuY3Rpb24gc2V0UnBjQ2xpZW50VG9HbG9iYWwocnBjKSB7XG4gIHRhcmdldDIxLl9fVlVFX0RFVlRPT0xTX0tJVF9SUENfQ0xJRU5UX18gPSBycGM7XG59XG5mdW5jdGlvbiBzZXRScGNTZXJ2ZXJUb0dsb2JhbChycGMpIHtcbiAgdGFyZ2V0MjEuX19WVUVfREVWVE9PTFNfS0lUX1JQQ19TRVJWRVJfXyA9IHJwYztcbn1cbmZ1bmN0aW9uIGdldFJwY0NsaWVudCgpIHtcbiAgcmV0dXJuIHRhcmdldDIxLl9fVlVFX0RFVlRPT0xTX0tJVF9SUENfQ0xJRU5UX187XG59XG5mdW5jdGlvbiBnZXRScGNTZXJ2ZXIoKSB7XG4gIHJldHVybiB0YXJnZXQyMS5fX1ZVRV9ERVZUT09MU19LSVRfUlBDX1NFUlZFUl9fO1xufVxuZnVuY3Rpb24gc2V0Vml0ZVJwY0NsaWVudFRvR2xvYmFsKHJwYykge1xuICB0YXJnZXQyMS5fX1ZVRV9ERVZUT09MU19LSVRfVklURV9SUENfQ0xJRU5UX18gPSBycGM7XG59XG5mdW5jdGlvbiBzZXRWaXRlUnBjU2VydmVyVG9HbG9iYWwocnBjKSB7XG4gIHRhcmdldDIxLl9fVlVFX0RFVlRPT0xTX0tJVF9WSVRFX1JQQ19TRVJWRVJfXyA9IHJwYztcbn1cbmZ1bmN0aW9uIGdldFZpdGVScGNDbGllbnQoKSB7XG4gIHJldHVybiB0YXJnZXQyMS5fX1ZVRV9ERVZUT09MU19LSVRfVklURV9SUENfQ0xJRU5UX187XG59XG5mdW5jdGlvbiBnZXRWaXRlUnBjU2VydmVyKCkge1xuICByZXR1cm4gdGFyZ2V0MjEuX19WVUVfREVWVE9PTFNfS0lUX1ZJVEVfUlBDX1NFUlZFUl9fO1xufVxuZnVuY3Rpb24gZ2V0Q2hhbm5lbChwcmVzZXQsIGhvc3QgPSBcImNsaWVudFwiKSB7XG4gIGNvbnN0IGNoYW5uZWwgPSB7XG4gICAgaWZyYW1lOiB7XG4gICAgICBjbGllbnQ6IGNyZWF0ZUlmcmFtZUNsaWVudENoYW5uZWwsXG4gICAgICBzZXJ2ZXI6IGNyZWF0ZUlmcmFtZVNlcnZlckNoYW5uZWxcbiAgICB9W2hvc3RdLFxuICAgIGVsZWN0cm9uOiB7XG4gICAgICBjbGllbnQ6IGNyZWF0ZUVsZWN0cm9uQ2xpZW50Q2hhbm5lbCxcbiAgICAgIHByb3h5OiBjcmVhdGVFbGVjdHJvblByb3h5Q2hhbm5lbCxcbiAgICAgIHNlcnZlcjogY3JlYXRlRWxlY3Ryb25TZXJ2ZXJDaGFubmVsXG4gICAgfVtob3N0XSxcbiAgICB2aXRlOiB7XG4gICAgICBjbGllbnQ6IGNyZWF0ZVZpdGVDbGllbnRDaGFubmVsLFxuICAgICAgc2VydmVyOiBjcmVhdGVWaXRlU2VydmVyQ2hhbm5lbFxuICAgIH1baG9zdF0sXG4gICAgYnJvYWRjYXN0OiB7XG4gICAgICBjbGllbnQ6IGNyZWF0ZUJyb2FkY2FzdENoYW5uZWwsXG4gICAgICBzZXJ2ZXI6IGNyZWF0ZUJyb2FkY2FzdENoYW5uZWxcbiAgICB9W2hvc3RdLFxuICAgIGV4dGVuc2lvbjoge1xuICAgICAgY2xpZW50OiBjcmVhdGVFeHRlbnNpb25DbGllbnRDaGFubmVsLFxuICAgICAgcHJveHk6IGNyZWF0ZUV4dGVuc2lvblByb3h5Q2hhbm5lbCxcbiAgICAgIHNlcnZlcjogY3JlYXRlRXh0ZW5zaW9uU2VydmVyQ2hhbm5lbFxuICAgIH1baG9zdF1cbiAgfVtwcmVzZXRdO1xuICByZXR1cm4gY2hhbm5lbCgpO1xufVxuZnVuY3Rpb24gY3JlYXRlUnBjQ2xpZW50KGZ1bmN0aW9ucywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgY2hhbm5lbDogX2NoYW5uZWwsIG9wdGlvbnM6IF9vcHRpb25zLCBwcmVzZXQgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNoYW5uZWwgPSBwcmVzZXQgPyBnZXRDaGFubmVsKHByZXNldCkgOiBfY2hhbm5lbDtcbiAgY29uc3QgcnBjID0gY3JlYXRlQmlycGMoZnVuY3Rpb25zLCB7XG4gICAgLi4uX29wdGlvbnMsXG4gICAgLi4uY2hhbm5lbCxcbiAgICB0aW1lb3V0OiAtMVxuICB9KTtcbiAgaWYgKHByZXNldCA9PT0gXCJ2aXRlXCIpIHtcbiAgICBzZXRWaXRlUnBjQ2xpZW50VG9HbG9iYWwocnBjKTtcbiAgICByZXR1cm47XG4gIH1cbiAgc2V0UnBjQ2xpZW50VG9HbG9iYWwocnBjKTtcbiAgcmV0dXJuIHJwYztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJwY1NlcnZlcihmdW5jdGlvbnMsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGNoYW5uZWw6IF9jaGFubmVsLCBvcHRpb25zOiBfb3B0aW9ucywgcHJlc2V0IH0gPSBvcHRpb25zO1xuICBjb25zdCBjaGFubmVsID0gcHJlc2V0ID8gZ2V0Q2hhbm5lbChwcmVzZXQsIFwic2VydmVyXCIpIDogX2NoYW5uZWw7XG4gIGNvbnN0IHJwY1NlcnZlciA9IGdldFJwY1NlcnZlcigpO1xuICBpZiAoIXJwY1NlcnZlcikge1xuICAgIGNvbnN0IGdyb3VwID0gY3JlYXRlQmlycGNHcm91cChmdW5jdGlvbnMsIFtjaGFubmVsXSwge1xuICAgICAgLi4uX29wdGlvbnMsXG4gICAgICB0aW1lb3V0OiAtMVxuICAgIH0pO1xuICAgIGlmIChwcmVzZXQgPT09IFwidml0ZVwiKSB7XG4gICAgICBzZXRWaXRlUnBjU2VydmVyVG9HbG9iYWwoZ3JvdXApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRScGNTZXJ2ZXJUb0dsb2JhbChncm91cCk7XG4gIH0gZWxzZSB7XG4gICAgcnBjU2VydmVyLnVwZGF0ZUNoYW5uZWxzKChjaGFubmVscykgPT4ge1xuICAgICAgY2hhbm5lbHMucHVzaChjaGFubmVsKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUnBjUHJveHkob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgY2hhbm5lbDogX2NoYW5uZWwsIG9wdGlvbnM6IF9vcHRpb25zLCBwcmVzZXQgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNoYW5uZWwgPSBwcmVzZXQgPyBnZXRDaGFubmVsKHByZXNldCwgXCJwcm94eVwiKSA6IF9jaGFubmVsO1xuICByZXR1cm4gY3JlYXRlQmlycGMoe30sIHtcbiAgICAuLi5fb3B0aW9ucyxcbiAgICAuLi5jaGFubmVsLFxuICAgIHRpbWVvdXQ6IC0xXG4gIH0pO1xufVxuXG4vLyBzcmMvc2hhcmVkL2luZGV4LnRzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyBzcmMvc2hhcmVkL2Vudi50c1xuaW5pdF9lc21fc2hpbXMoKTtcblxuLy8gc3JjL3NoYXJlZC90aW1lLnRzXG5pbml0X2VzbV9zaGltcygpO1xuXG4vLyBzcmMvc2hhcmVkL3V0aWwudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy9jb3JlL2NvbXBvbmVudC9zdGF0ZS9yZXBsYWNlci50c1xuaW5pdF9lc21fc2hpbXMoKTtcblxuLy8gc3JjL2NvcmUvY29tcG9uZW50L3N0YXRlL2N1c3RvbS50c1xuaW5pdF9lc21fc2hpbXMoKTtcbmZ1bmN0aW9uIGdldEZ1bmN0aW9uRGV0YWlscyhmdW5jKSB7XG4gIGxldCBzdHJpbmcgPSBcIlwiO1xuICBsZXQgbWF0Y2hlcyA9IG51bGw7XG4gIHRyeSB7XG4gICAgc3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgbWF0Y2hlcyA9IFN0cmluZy5wcm90b3R5cGUubWF0Y2guY2FsbChzdHJpbmcsIC9cXChbXFxzXFxTXSo/XFwpLyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICBjb25zdCBtYXRjaCA9IG1hdGNoZXMgJiYgbWF0Y2hlc1swXTtcbiAgY29uc3QgYXJncyA9IHR5cGVvZiBtYXRjaCA9PT0gXCJzdHJpbmdcIiA/IG1hdGNoIDogXCIoPylcIjtcbiAgY29uc3QgbmFtZSA9IHR5cGVvZiBmdW5jLm5hbWUgPT09IFwic3RyaW5nXCIgPyBmdW5jLm5hbWUgOiBcIlwiO1xuICByZXR1cm4ge1xuICAgIF9jdXN0b206IHtcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgIGRpc3BsYXlUZXh0OiBgPHNwYW4gc3R5bGU9XCJvcGFjaXR5Oi44O21hcmdpbi1yaWdodDo1cHg7XCI+ZnVuY3Rpb248L3NwYW4+IDxzcGFuIHN0eWxlPVwid2hpdGUtc3BhY2U6bm93cmFwO1wiPiR7ZXNjYXBlKG5hbWUpfSR7YXJnc308L3NwYW4+YCxcbiAgICAgIHRvb2x0aXBUZXh0OiBzdHJpbmcudHJpbSgpID8gYDxwcmU+JHtzdHJpbmd9PC9wcmU+YCA6IG51bGxcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRCaWdJbnREZXRhaWxzKHZhbCkge1xuICBjb25zdCBzdHJpbmdpZmllZEJpZ0ludCA9IEJpZ0ludC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpO1xuICByZXR1cm4ge1xuICAgIF9jdXN0b206IHtcbiAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICBkaXNwbGF5VGV4dDogYEJpZ0ludCgke3N0cmluZ2lmaWVkQmlnSW50fSlgLFxuICAgICAgdmFsdWU6IHN0cmluZ2lmaWVkQmlnSW50XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGF0ZURldGFpbHModmFsKSB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh2YWwuZ2V0VGltZSgpKTtcbiAgZGF0ZS5zZXRNaW51dGVzKGRhdGUuZ2V0TWludXRlcygpIC0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgcmV0dXJuIHtcbiAgICBfY3VzdG9tOiB7XG4gICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgIGRpc3BsYXlUZXh0OiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCksXG4gICAgICB2YWx1ZTogZGF0ZS50b0lTT1N0cmluZygpLnNsaWNlKDAsIC0xKVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE1hcERldGFpbHModmFsKSB7XG4gIGNvbnN0IGxpc3QgPSBPYmplY3QuZnJvbUVudHJpZXModmFsKTtcbiAgcmV0dXJuIHtcbiAgICBfY3VzdG9tOiB7XG4gICAgICB0eXBlOiBcIm1hcFwiLFxuICAgICAgZGlzcGxheVRleHQ6IFwiTWFwXCIsXG4gICAgICB2YWx1ZTogbGlzdCxcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgZmllbGRzOiB7XG4gICAgICAgIGFic3RyYWN0OiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2V0RGV0YWlscyh2YWwpIHtcbiAgY29uc3QgbGlzdCA9IEFycmF5LmZyb20odmFsKTtcbiAgcmV0dXJuIHtcbiAgICBfY3VzdG9tOiB7XG4gICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgZGlzcGxheVRleHQ6IGBTZXRbJHtsaXN0Lmxlbmd0aH1dYCxcbiAgICAgIHZhbHVlOiBsaXN0LFxuICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDYXVnaHRHZXR0ZXJzKHN0b3JlKSB7XG4gIGNvbnN0IGdldHRlcnMgPSB7fTtcbiAgY29uc3Qgb3JpZ0dldHRlcnMgPSBzdG9yZS5nZXR0ZXJzIHx8IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3JpZ0dldHRlcnMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZXR0ZXJzLCBrZXksIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gb3JpZ0dldHRlcnNba2V5XTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGdldHRlcnM7XG59XG5mdW5jdGlvbiByZWR1Y2VTdGF0ZUxpc3QobGlzdCkge1xuICBpZiAoIWxpc3QubGVuZ3RoKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiBsaXN0LnJlZHVjZSgobWFwLCBpdGVtKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaXRlbS50eXBlIHx8IFwiZGF0YVwiO1xuICAgIGNvbnN0IG9iaiA9IG1hcFtrZXldID0gbWFwW2tleV0gfHwge307XG4gICAgb2JqW2l0ZW0ua2V5XSA9IGl0ZW0udmFsdWU7XG4gICAgcmV0dXJuIG1hcDtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gbmFtZWROb2RlTWFwVG9PYmplY3QobWFwKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBsID0gbWFwLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbWFwLml0ZW0oaSk7XG4gICAgcmVzdWx0W25vZGUubmFtZV0gPSBub2RlLnZhbHVlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRTdG9yZURldGFpbHMoc3RvcmUpIHtcbiAgcmV0dXJuIHtcbiAgICBfY3VzdG9tOiB7XG4gICAgICB0eXBlOiBcInN0b3JlXCIsXG4gICAgICBkaXNwbGF5VGV4dDogXCJTdG9yZVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgc3RhdGU6IHN0b3JlLnN0YXRlLFxuICAgICAgICBnZXR0ZXJzOiBnZXRDYXVnaHRHZXR0ZXJzKHN0b3JlKVxuICAgICAgfSxcbiAgICAgIGZpZWxkczoge1xuICAgICAgICBhYnN0cmFjdDogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJvdXRlckRldGFpbHMocm91dGVyKSB7XG4gIHJldHVybiB7XG4gICAgX2N1c3RvbToge1xuICAgICAgdHlwZTogXCJyb3V0ZXJcIixcbiAgICAgIGRpc3BsYXlUZXh0OiBcIlZ1ZVJvdXRlclwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgb3B0aW9uczogcm91dGVyLm9wdGlvbnMsXG4gICAgICAgIGN1cnJlbnRSb3V0ZTogcm91dGVyLmN1cnJlbnRSb3V0ZVxuICAgICAgfSxcbiAgICAgIGZpZWxkczoge1xuICAgICAgICBhYnN0cmFjdDogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEluc3RhbmNlRGV0YWlscyhpbnN0YW5jZSkge1xuICBpZiAoaW5zdGFuY2UuXylcbiAgICBpbnN0YW5jZSA9IGluc3RhbmNlLl87XG4gIGNvbnN0IHN0YXRlID0gcHJvY2Vzc0luc3RhbmNlU3RhdGUoaW5zdGFuY2UpO1xuICByZXR1cm4ge1xuICAgIF9jdXN0b206IHtcbiAgICAgIHR5cGU6IFwiY29tcG9uZW50XCIsXG4gICAgICBpZDogaW5zdGFuY2UuX19WVUVfREVWVE9PTFNfTkVYVF9VSURfXyxcbiAgICAgIGRpc3BsYXlUZXh0OiBnZXRJbnN0YW5jZU5hbWUoaW5zdGFuY2UpLFxuICAgICAgdG9vbHRpcFRleHQ6IFwiQ29tcG9uZW50IGluc3RhbmNlXCIsXG4gICAgICB2YWx1ZTogcmVkdWNlU3RhdGVMaXN0KHN0YXRlKSxcbiAgICAgIGZpZWxkczoge1xuICAgICAgICBhYnN0cmFjdDogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudERlZmluaXRpb25EZXRhaWxzKGRlZmluaXRpb24pIHtcbiAgbGV0IGRpc3BsYXkgPSBnZXRDb21wb25lbnROYW1lKGRlZmluaXRpb24pO1xuICBpZiAoZGlzcGxheSkge1xuICAgIGlmIChkZWZpbml0aW9uLm5hbWUgJiYgZGVmaW5pdGlvbi5fX2ZpbGUpXG4gICAgICBkaXNwbGF5ICs9IGAgPHNwYW4+KCR7ZGVmaW5pdGlvbi5fX2ZpbGV9KTwvc3Bhbj5gO1xuICB9IGVsc2Uge1xuICAgIGRpc3BsYXkgPSBcIjxpPlVua25vd24gQ29tcG9uZW50PC9pPlwiO1xuICB9XG4gIHJldHVybiB7XG4gICAgX2N1c3RvbToge1xuICAgICAgdHlwZTogXCJjb21wb25lbnQtZGVmaW5pdGlvblwiLFxuICAgICAgZGlzcGxheVRleHQ6IGRpc3BsYXksXG4gICAgICB0b29sdGlwVGV4dDogXCJDb21wb25lbnQgZGVmaW5pdGlvblwiLFxuICAgICAgLi4uZGVmaW5pdGlvbi5fX2ZpbGUgPyB7XG4gICAgICAgIGZpbGU6IGRlZmluaXRpb24uX19maWxlXG4gICAgICB9IDoge31cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRIVE1MRWxlbWVudERldGFpbHModmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgX2N1c3RvbToge1xuICAgICAgICB0eXBlOiBcIkhUTUxFbGVtZW50XCIsXG4gICAgICAgIGRpc3BsYXlUZXh0OiBgPHNwYW4gY2xhc3M9XCJvcGFjaXR5LTMwXCI+Jmx0Ozwvc3Bhbj48c3BhbiBjbGFzcz1cInRleHQtYmx1ZS01MDBcIj4ke3ZhbHVlLnRhZ05hbWUudG9Mb3dlckNhc2UoKX08L3NwYW4+PHNwYW4gY2xhc3M9XCJvcGFjaXR5LTMwXCI+Jmd0Ozwvc3Bhbj5gLFxuICAgICAgICB2YWx1ZTogbmFtZWROb2RlTWFwVG9PYmplY3QodmFsdWUuYXR0cmlidXRlcylcbiAgICAgIH1cbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9jdXN0b206IHtcbiAgICAgICAgdHlwZTogXCJIVE1MRWxlbWVudFwiLFxuICAgICAgICBkaXNwbGF5VGV4dDogYDxzcGFuIGNsYXNzPVwidGV4dC1ibHVlLTUwMFwiPiR7U3RyaW5nKHZhbHVlKX08L3NwYW4+YFxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHRyeUdldFJlZlZhbHVlKHJlZikge1xuICBpZiAoZW5zdXJlUHJvcGVydHlFeGlzdHMocmVmLCBcIl92YWx1ZVwiLCB0cnVlKSkge1xuICAgIHJldHVybiByZWYuX3ZhbHVlO1xuICB9XG4gIGlmIChlbnN1cmVQcm9wZXJ0eUV4aXN0cyhyZWYsIFwidmFsdWVcIiwgdHJ1ZSkpIHtcbiAgICByZXR1cm4gcmVmLnZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPYmplY3REZXRhaWxzKG9iamVjdCkge1xuICB2YXIgX2EyNSwgX2IyNSwgX2MsIF9kO1xuICBjb25zdCBpbmZvID0gZ2V0U2V0dXBTdGF0ZVR5cGUob2JqZWN0KTtcbiAgY29uc3QgaXNTdGF0ZSA9IGluZm8ucmVmIHx8IGluZm8uY29tcHV0ZWQgfHwgaW5mby5yZWFjdGl2ZTtcbiAgaWYgKGlzU3RhdGUpIHtcbiAgICBjb25zdCBzdGF0ZVR5cGVOYW1lID0gaW5mby5jb21wdXRlZCA/IFwiQ29tcHV0ZWRcIiA6IGluZm8ucmVmID8gXCJSZWZcIiA6IGluZm8ucmVhY3RpdmUgPyBcIlJlYWN0aXZlXCIgOiBudWxsO1xuICAgIGNvbnN0IHZhbHVlID0gdG9SYXcyKGluZm8ucmVhY3RpdmUgPyBvYmplY3QgOiB0cnlHZXRSZWZWYWx1ZShvYmplY3QpKTtcbiAgICBjb25zdCByYXcgPSBlbnN1cmVQcm9wZXJ0eUV4aXN0cyhvYmplY3QsIFwiZWZmZWN0XCIpID8gKChfYjI1ID0gKF9hMjUgPSBvYmplY3QuZWZmZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyNS5yYXcpID09IG51bGwgPyB2b2lkIDAgOiBfYjI1LnRvU3RyaW5nKCkpIHx8ICgoX2QgPSAoX2MgPSBvYmplY3QuZWZmZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2MuZm4pID09IG51bGwgPyB2b2lkIDAgOiBfZC50b1N0cmluZygpKSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9jdXN0b206IHtcbiAgICAgICAgdHlwZTogc3RhdGVUeXBlTmFtZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGVUeXBlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBzdGF0ZVR5cGVOYW1lLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLi4ucmF3ID8geyB0b29sdGlwVGV4dDogYDxzcGFuIGNsYXNzPVwiZm9udC1tb25vXCI+JHtyYXd9PC9zcGFuPmAgfSA6IHt9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBpZiAoZW5zdXJlUHJvcGVydHlFeGlzdHMob2JqZWN0LCBcIl9fYXN5bmNMb2FkZXJcIikgJiYgdHlwZW9mIG9iamVjdC5fX2FzeW5jTG9hZGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX2N1c3RvbToge1xuICAgICAgICB0eXBlOiBcImNvbXBvbmVudC1kZWZpbml0aW9uXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiQXN5bmMgY29tcG9uZW50IGRlZmluaXRpb25cIlxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL2NvcmUvY29tcG9uZW50L3N0YXRlL3JlcGxhY2VyLnRzXG5mdW5jdGlvbiBzdHJpbmdpZnlSZXBsYWNlcihrZXksIF92YWx1ZSwgZGVwdGgsIHNlZW5JbnN0YW5jZSkge1xuICB2YXIgX2EyNTtcbiAgaWYgKGtleSA9PT0gXCJjb21waWxlck9wdGlvbnNcIilcbiAgICByZXR1cm47XG4gIGNvbnN0IHZhbCA9IHRoaXNba2V5XTtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBjb25zdCBsID0gdmFsLmxlbmd0aDtcbiAgICBpZiAobCA+IE1BWF9BUlJBWV9TSVpFKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfaXNBcnJheTogdHJ1ZSxcbiAgICAgICAgbGVuZ3RoOiBsLFxuICAgICAgICBpdGVtczogdmFsLnNsaWNlKDAsIE1BWF9BUlJBWV9TSVpFKVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPiBNQVhfU1RSSU5HX1NJWkUpXG4gICAgICByZXR1cm4gYCR7dmFsLnN1YnN0cmluZygwLCBNQVhfU1RSSU5HX1NJWkUpfS4uLiAoJHt2YWwubGVuZ3RofSB0b3RhbCBsZW5ndGgpYDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdmFsO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gVU5ERUZJTkVEO1xuICB9IGVsc2UgaWYgKHZhbCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgcmV0dXJuIElORklOSVRZO1xuICB9IGVsc2UgaWYgKHZhbCA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSB7XG4gICAgcmV0dXJuIE5FR0FUSVZFX0lORklOSVRZO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBnZXRGdW5jdGlvbkRldGFpbHModmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcInN5bWJvbFwiKSB7XG4gICAgcmV0dXJuIGBbbmF0aXZlIFN5bWJvbCAke1N5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpfV1gO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwiYmlnaW50XCIpIHtcbiAgICByZXR1cm4gZ2V0QmlnSW50RGV0YWlscyh2YWwpO1xuICB9IGVsc2UgaWYgKHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKTtcbiAgICBpZiAocHJvdG8gPT09IFwiW29iamVjdCBNYXBdXCIpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEZXRhaWxzKHZhbCk7XG4gICAgfSBlbHNlIGlmIChwcm90byA9PT0gXCJbb2JqZWN0IFNldF1cIikge1xuICAgICAgcmV0dXJuIGdldFNldERldGFpbHModmFsKTtcbiAgICB9IGVsc2UgaWYgKHByb3RvID09PSBcIltvYmplY3QgUmVnRXhwXVwiKSB7XG4gICAgICByZXR1cm4gYFtuYXRpdmUgUmVnRXhwICR7UmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCl9XWA7XG4gICAgfSBlbHNlIGlmIChwcm90byA9PT0gXCJbb2JqZWN0IERhdGVdXCIpIHtcbiAgICAgIHJldHVybiBnZXREYXRlRGV0YWlscyh2YWwpO1xuICAgIH0gZWxzZSBpZiAocHJvdG8gPT09IFwiW29iamVjdCBFcnJvcl1cIikge1xuICAgICAgcmV0dXJuIGBbbmF0aXZlIEVycm9yICR7dmFsLm1lc3NhZ2V9PD4ke3ZhbC5zdGFja31dYDtcbiAgICB9IGVsc2UgaWYgKGVuc3VyZVByb3BlcnR5RXhpc3RzKHZhbCwgXCJzdGF0ZVwiLCB0cnVlKSAmJiBlbnN1cmVQcm9wZXJ0eUV4aXN0cyh2YWwsIFwiX3ZtXCIsIHRydWUpKSB7XG4gICAgICByZXR1cm4gZ2V0U3RvcmVEZXRhaWxzKHZhbCk7XG4gICAgfSBlbHNlIGlmICh2YWwuY29uc3RydWN0b3IgJiYgdmFsLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiVnVlUm91dGVyXCIpIHtcbiAgICAgIHJldHVybiBnZXRSb3V0ZXJEZXRhaWxzKHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1Z1ZUluc3RhbmNlKHZhbCkpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudFZhbCA9IGdldEluc3RhbmNlRGV0YWlscyh2YWwpO1xuICAgICAgY29uc3QgcGFyZW50SW5zdGFuY2VEZXB0aCA9IHNlZW5JbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogc2Vlbkluc3RhbmNlLmdldCh2YWwpO1xuICAgICAgaWYgKHBhcmVudEluc3RhbmNlRGVwdGggJiYgcGFyZW50SW5zdGFuY2VEZXB0aCA8IGRlcHRoKSB7XG4gICAgICAgIHJldHVybiBgW1tDaXJjdWxhclJlZl1dIDwke2NvbXBvbmVudFZhbC5fY3VzdG9tLmRpc3BsYXlUZXh0fT5gO1xuICAgICAgfVxuICAgICAgc2Vlbkluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBzZWVuSW5zdGFuY2Uuc2V0KHZhbCwgZGVwdGgpO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudFZhbDtcbiAgICB9IGVsc2UgaWYgKGVuc3VyZVByb3BlcnR5RXhpc3RzKHZhbCwgXCJyZW5kZXJcIiwgdHJ1ZSkgJiYgdHlwZW9mIHZhbC5yZW5kZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGdldENvbXBvbmVudERlZmluaXRpb25EZXRhaWxzKHZhbCk7XG4gICAgfSBlbHNlIGlmICh2YWwuY29uc3RydWN0b3IgJiYgdmFsLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiVk5vZGVcIikge1xuICAgICAgcmV0dXJuIGBbbmF0aXZlIFZOb2RlIDwke3ZhbC50YWd9Pl1gO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnREZXRhaWxzKHZhbCk7XG4gICAgfSBlbHNlIGlmICgoKF9hMjUgPSB2YWwuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYTI1Lm5hbWUpID09PSBcIlN0b3JlXCIgJiYgXCJfd3JhcHBlZEdldHRlcnNcIiBpbiB2YWwpIHtcbiAgICAgIHJldHVybiBcIltvYmplY3QgU3RvcmVdXCI7XG4gICAgfSBlbHNlIGlmIChlbnN1cmVQcm9wZXJ0eUV4aXN0cyh2YWwsIFwiY3VycmVudFJvdXRlXCIsIHRydWUpKSB7XG4gICAgICByZXR1cm4gXCJbb2JqZWN0IFJvdXRlcl1cIjtcbiAgICB9XG4gICAgY29uc3QgY3VzdG9tRGV0YWlscyA9IGdldE9iamVjdERldGFpbHModmFsKTtcbiAgICBpZiAoY3VzdG9tRGV0YWlscyAhPSBudWxsKVxuICAgICAgcmV0dXJuIGN1c3RvbURldGFpbHM7XG4gIH0gZWxzZSBpZiAoTnVtYmVyLmlzTmFOKHZhbCkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIHJldHVybiBzYW5pdGl6ZSh2YWwpO1xufVxuXG4vLyBzcmMvc2hhcmVkL3RyYW5zZmVyLnRzXG5pbml0X2VzbV9zaGltcygpO1xudmFyIE1BWF9TRVJJQUxJWkVEX1NJWkUgPSAyICogMTAyNCAqIDEwMjQ7XG5mdW5jdGlvbiBpc09iamVjdChfZGF0YSwgcHJvdG8pIHtcbiAgcmV0dXJuIHByb3RvID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gaXNBcnJheTMoX2RhdGEsIHByb3RvKSB7XG4gIHJldHVybiBwcm90byA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xufVxuZnVuY3Rpb24gaXNWdWVSZWFjdGl2ZUxpbmtOb2RlKG5vZGUpIHtcbiAgdmFyIF9hMjU7XG4gIGNvbnN0IGNvbnN0cnVjdG9yTmFtZSA9IChfYTI1ID0gbm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjUubmFtZTtcbiAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZSA9PT0gXCJEZXBcIiAmJiBcImFjdGl2ZUxpbmtcIiBpbiBub2RlIHx8IGNvbnN0cnVjdG9yTmFtZSA9PT0gXCJMaW5rXCIgJiYgXCJkZXBcIiBpbiBub2RlO1xufVxuZnVuY3Rpb24gZW5jb2RlKGRhdGEsIHJlcGxhY2VyLCBsaXN0LCBzZWVuLCBkZXB0aCA9IDAsIHNlZW5WdWVJbnN0YW5jZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpIHtcbiAgbGV0IHN0b3JlZDtcbiAgbGV0IGtleTtcbiAgbGV0IHZhbHVlO1xuICBsZXQgaTtcbiAgbGV0IGw7XG4gIGNvbnN0IHNlZW5JbmRleCA9IHNlZW4uZ2V0KGRhdGEpO1xuICBpZiAoc2VlbkluZGV4ICE9IG51bGwpXG4gICAgcmV0dXJuIHNlZW5JbmRleDtcbiAgY29uc3QgaW5kZXggPSBsaXN0Lmxlbmd0aDtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSk7XG4gIGlmIChpc09iamVjdChkYXRhLCBwcm90bykpIHtcbiAgICBpZiAoaXNWdWVSZWFjdGl2ZUxpbmtOb2RlKGRhdGEpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIHN0b3JlZCA9IHt9O1xuICAgIHNlZW4uc2V0KGRhdGEsIGluZGV4KTtcbiAgICBsaXN0LnB1c2goc3RvcmVkKTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGtleSA9PT0gXCJjb21waWxlck9wdGlvbnNcIilcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgdmFsdWUgPSBkYXRhW2tleV07XG4gICAgICBjb25zdCBpc1ZtID0gdmFsdWUgIT0gbnVsbCAmJiBpc09iamVjdCh2YWx1ZSwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSAmJiBpc1Z1ZUluc3RhbmNlKHZhbHVlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChyZXBsYWNlcikge1xuICAgICAgICAgIHZhbHVlID0gcmVwbGFjZXIuY2FsbChkYXRhLCBrZXksIHZhbHVlLCBkZXB0aCwgc2VlblZ1ZUluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB2YWx1ZSA9IGU7XG4gICAgICB9XG4gICAgICBzdG9yZWRba2V5XSA9IGVuY29kZSh2YWx1ZSwgcmVwbGFjZXIsIGxpc3QsIHNlZW4sIGRlcHRoICsgMSwgc2VlblZ1ZUluc3RhbmNlKTtcbiAgICAgIGlmIChpc1ZtKSB7XG4gICAgICAgIHNlZW5WdWVJbnN0YW5jZS5kZWxldGUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5MyhkYXRhLCBwcm90bykpIHtcbiAgICBzdG9yZWQgPSBbXTtcbiAgICBzZWVuLnNldChkYXRhLCBpbmRleCk7XG4gICAgbGlzdC5wdXNoKHN0b3JlZCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YWx1ZSA9IGRhdGFbaV07XG4gICAgICAgIGlmIChyZXBsYWNlcilcbiAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwoZGF0YSwgaSwgdmFsdWUsIGRlcHRoLCBzZWVuVnVlSW5zdGFuY2UpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB2YWx1ZSA9IGU7XG4gICAgICB9XG4gICAgICBzdG9yZWRbaV0gPSBlbmNvZGUodmFsdWUsIHJlcGxhY2VyLCBsaXN0LCBzZWVuLCBkZXB0aCArIDEsIHNlZW5WdWVJbnN0YW5jZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxpc3QucHVzaChkYXRhKTtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBkZWNvZGUobGlzdCwgcmV2aXZlcjIgPSBudWxsKSB7XG4gIGxldCBpID0gbGlzdC5sZW5ndGg7XG4gIGxldCBqLCBrLCBkYXRhLCBrZXksIHZhbHVlLCBwcm90bztcbiAgd2hpbGUgKGktLSkge1xuICAgIGRhdGEgPSBsaXN0W2ldO1xuICAgIHByb3RvID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpO1xuICAgIGlmIChwcm90byA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgZm9yIChqID0gMCwgayA9IGtleXMubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgIGtleSA9IGtleXNbal07XG4gICAgICAgIHZhbHVlID0gbGlzdFtkYXRhW2tleV1dO1xuICAgICAgICBpZiAocmV2aXZlcjIpXG4gICAgICAgICAgdmFsdWUgPSByZXZpdmVyMi5jYWxsKGRhdGEsIGtleSwgdmFsdWUpO1xuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3RvID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgIGZvciAoaiA9IDAsIGsgPSBkYXRhLmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICB2YWx1ZSA9IGxpc3RbZGF0YVtqXV07XG4gICAgICAgIGlmIChyZXZpdmVyMilcbiAgICAgICAgICB2YWx1ZSA9IHJldml2ZXIyLmNhbGwoZGF0YSwgaiwgdmFsdWUpO1xuICAgICAgICBkYXRhW2pdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlDaXJjdWxhckF1dG9DaHVua3MoZGF0YSwgcmVwbGFjZXIgPSBudWxsLCBzcGFjZSA9IG51bGwpIHtcbiAgbGV0IHJlc3VsdDtcbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gSlNPTi5zdHJpbmdpZnkoZGF0YSkgOiBKU09OLnN0cmluZ2lmeShkYXRhLCAoaywgdikgPT4ge1xuICAgICAgdmFyIF9hMjU7XG4gICAgICByZXR1cm4gKF9hMjUgPSByZXBsYWNlciA9PSBudWxsID8gdm9pZCAwIDogcmVwbGFjZXIoaywgdikpID09IG51bGwgPyB2b2lkIDAgOiBfYTI1LmNhbGwodGhpcyk7XG4gICAgfSwgc3BhY2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVzdWx0ID0gc3RyaW5naWZ5U3RyaWN0Q2lyY3VsYXJBdXRvQ2h1bmtzKGRhdGEsIHJlcGxhY2VyLCBzcGFjZSk7XG4gIH1cbiAgaWYgKHJlc3VsdC5sZW5ndGggPiBNQVhfU0VSSUFMSVpFRF9TSVpFKSB7XG4gICAgY29uc3QgY2h1bmtDb3VudCA9IE1hdGguY2VpbChyZXN1bHQubGVuZ3RoIC8gTUFYX1NFUklBTElaRURfU0laRSk7XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua0NvdW50OyBpKyspXG4gICAgICBjaHVua3MucHVzaChyZXN1bHQuc2xpY2UoaSAqIE1BWF9TRVJJQUxJWkVEX1NJWkUsIChpICsgMSkgKiBNQVhfU0VSSUFMSVpFRF9TSVpFKSk7XG4gICAgcmV0dXJuIGNodW5rcztcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U3RyaWN0Q2lyY3VsYXJBdXRvQ2h1bmtzKGRhdGEsIHJlcGxhY2VyID0gbnVsbCwgc3BhY2UgPSBudWxsKSB7XG4gIGNvbnN0IGxpc3QgPSBbXTtcbiAgZW5jb2RlKGRhdGEsIHJlcGxhY2VyLCBsaXN0LCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgcmV0dXJuIHNwYWNlID8gYCAke0pTT04uc3RyaW5naWZ5KGxpc3QsIG51bGwsIHNwYWNlKX1gIDogYCAke0pTT04uc3RyaW5naWZ5KGxpc3QpfWA7XG59XG5mdW5jdGlvbiBwYXJzZUNpcmN1bGFyQXV0b0NodW5rcyhkYXRhLCByZXZpdmVyMiA9IG51bGwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgZGF0YSA9IGRhdGEuam9pbihcIlwiKTtcbiAgY29uc3QgaGFzQ2lyY3VsYXIgPSAvXlxccy8udGVzdChkYXRhKTtcbiAgaWYgKCFoYXNDaXJjdWxhcikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gSlNPTi5wYXJzZShkYXRhKSA6IEpTT04ucGFyc2UoZGF0YSwgcmV2aXZlcjIpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxpc3QgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIGRlY29kZShsaXN0LCByZXZpdmVyMik7XG4gICAgcmV0dXJuIGxpc3RbMF07XG4gIH1cbn1cblxuLy8gc3JjL3NoYXJlZC91dGlsLnRzXG5mdW5jdGlvbiBzdHJpbmdpZnkyKGRhdGEpIHtcbiAgcmV0dXJuIHN0cmluZ2lmeUNpcmN1bGFyQXV0b0NodW5rcyhkYXRhLCBzdHJpbmdpZnlSZXBsYWNlcik7XG59XG5mdW5jdGlvbiBwYXJzZTIoZGF0YSwgcmV2aXZlMiA9IGZhbHNlKSB7XG4gIGlmIChkYXRhID09IHZvaWQgMClcbiAgICByZXR1cm4ge307XG4gIHJldHVybiByZXZpdmUyID8gcGFyc2VDaXJjdWxhckF1dG9DaHVua3MoZGF0YSwgcmV2aXZlcikgOiBwYXJzZUNpcmN1bGFyQXV0b0NodW5rcyhkYXRhKTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG52YXIgZGV2dG9vbHMgPSB7XG4gIGhvb2ssXG4gIGluaXQ6ICgpID0+IHtcbiAgICBpbml0RGV2VG9vbHMoKTtcbiAgfSxcbiAgZ2V0IGN0eCgpIHtcbiAgICByZXR1cm4gZGV2dG9vbHNDb250ZXh0O1xuICB9LFxuICBnZXQgYXBpKCkge1xuICAgIHJldHVybiBkZXZ0b29sc0NvbnRleHQuYXBpO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgRGV2VG9vbHNDb250ZXh0SG9va0tleXMsXG4gIERldlRvb2xzTWVzc2FnaW5nSG9va0tleXMsXG4gIERldlRvb2xzVjZQbHVnaW5BUElIb29rS2V5cyxcbiAgSU5GSU5JVFksXG4gIE5BTixcbiAgTkVHQVRJVkVfSU5GSU5JVFksXG4gIFJPVVRFUl9JTkZPX0tFWSxcbiAgUk9VVEVSX0tFWSxcbiAgVU5ERUZJTkVELFxuICBhY3RpdmVBcHBSZWNvcmQsXG4gIGFkZEN1c3RvbUNvbW1hbmQsXG4gIGFkZEN1c3RvbVRhYixcbiAgYWRkRGV2VG9vbHNBcHBSZWNvcmQsXG4gIGFkZERldlRvb2xzUGx1Z2luVG9CdWZmZXIsXG4gIGFkZEluc3BlY3RvcixcbiAgY2FsbENvbm5lY3RlZFVwZGF0ZWRIb29rLFxuICBjYWxsRGV2VG9vbHNQbHVnaW5TZXR1cEZuLFxuICBjYWxsSW5zcGVjdG9yVXBkYXRlZEhvb2ssXG4gIGNhbGxTdGF0ZVVwZGF0ZWRIb29rLFxuICBjcmVhdGVDb21wb25lbnRzRGV2VG9vbHNQbHVnaW4sXG4gIGNyZWF0ZURldlRvb2xzQXBpLFxuICBjcmVhdGVEZXZUb29sc0N0eEhvb2tzLFxuICBjcmVhdGVScGNDbGllbnQsXG4gIGNyZWF0ZVJwY1Byb3h5LFxuICBjcmVhdGVScGNTZXJ2ZXIsXG4gIGRldnRvb2xzLFxuICBkZXZ0b29sc0FwcFJlY29yZHMsXG4gIGRldnRvb2xzQ29udGV4dCxcbiAgZGV2dG9vbHNJbnNwZWN0b3IsXG4gIGRldnRvb2xzUGx1Z2luQnVmZmVyLFxuICBkZXZ0b29sc1JvdXRlcixcbiAgZGV2dG9vbHNSb3V0ZXJJbmZvLFxuICBkZXZ0b29sc1N0YXRlLFxuICBlc2NhcGUsXG4gIGZvcm1hdEluc3BlY3RvclN0YXRlVmFsdWUsXG4gIGdldEFjdGl2ZUluc3BlY3RvcnMsXG4gIGdldERldlRvb2xzRW52LFxuICBnZXRFeHRlbnNpb25DbGllbnRDb250ZXh0LFxuICBnZXRJbnNwZWN0b3IsXG4gIGdldEluc3BlY3RvckFjdGlvbnMsXG4gIGdldEluc3BlY3RvckluZm8sXG4gIGdldEluc3BlY3Rvck5vZGVBY3Rpb25zLFxuICBnZXRJbnNwZWN0b3JTdGF0ZVZhbHVlVHlwZSxcbiAgZ2V0UmF3LFxuICBnZXRScGNDbGllbnQsXG4gIGdldFJwY1NlcnZlcixcbiAgZ2V0Vml0ZVJwY0NsaWVudCxcbiAgZ2V0Vml0ZVJwY1NlcnZlcixcbiAgaW5pdERldlRvb2xzLFxuICBpc1BsYWluT2JqZWN0LFxuICBvbkRldlRvb2xzQ2xpZW50Q29ubmVjdGVkLFxuICBvbkRldlRvb2xzQ29ubmVjdGVkLFxuICBwYXJzZTIgYXMgcGFyc2UsXG4gIHJlZ2lzdGVyRGV2VG9vbHNQbHVnaW4sXG4gIHJlbW92ZUN1c3RvbUNvbW1hbmQsXG4gIHJlbW92ZURldlRvb2xzQXBwUmVjb3JkLFxuICByZW1vdmVSZWdpc3RlcmVkUGx1Z2luQXBwLFxuICByZXNldERldlRvb2xzU3RhdGUsXG4gIHNldEFjdGl2ZUFwcFJlY29yZCxcbiAgc2V0QWN0aXZlQXBwUmVjb3JkSWQsXG4gIHNldERldlRvb2xzRW52LFxuICBzZXRFbGVjdHJvbkNsaWVudENvbnRleHQsXG4gIHNldEVsZWN0cm9uUHJveHlDb250ZXh0LFxuICBzZXRFbGVjdHJvblNlcnZlckNvbnRleHQsXG4gIHNldEV4dGVuc2lvbkNsaWVudENvbnRleHQsXG4gIHNldElmcmFtZVNlcnZlckNvbnRleHQsXG4gIHNldE9wZW5JbkVkaXRvckJhc2VVcmwsXG4gIHNldFJwY1NlcnZlclRvR2xvYmFsLFxuICBzZXRWaXRlQ2xpZW50Q29udGV4dCxcbiAgc2V0Vml0ZVJwY0NsaWVudFRvR2xvYmFsLFxuICBzZXRWaXRlUnBjU2VydmVyVG9HbG9iYWwsXG4gIHNldFZpdGVTZXJ2ZXJDb250ZXh0LFxuICBzZXR1cERldlRvb2xzUGx1Z2luLFxuICBzdHJpbmdpZnkyIGFzIHN0cmluZ2lmeSxcbiAgdG9FZGl0LFxuICB0b1N1Ym1pdCxcbiAgdG9nZ2xlQ2xpZW50Q29ubmVjdGVkLFxuICB0b2dnbGVDb21wb25lbnRJbnNwZWN0b3JFbmFibGVkLFxuICB0b2dnbGVIaWdoUGVyZk1vZGUsXG4gIHVwZGF0ZURldlRvb2xzQ2xpZW50RGV0ZWN0ZWQsXG4gIHVwZGF0ZURldlRvb2xzU3RhdGUsXG4gIHVwZGF0ZVRpbWVsaW5lTGF5ZXJzU3RhdGVcbn07XG4iLCJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXNtID0gKGZuLCByZXMpID0+IGZ1bmN0aW9uIF9faW5pdCgpIHtcbiAgcmV0dXJuIGZuICYmIChyZXMgPSAoMCwgZm5bX19nZXRPd25Qcm9wTmFtZXMoZm4pWzBdXSkoZm4gPSAwKSksIHJlcztcbn07XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0MikgPT4gKHRhcmdldDIgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldDIsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQyLFxuICBtb2RcbikpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdHN1cEA4LjQuMF9AbWljcm9zb2Z0K2FwaS1leHRyYWN0b3JANy41MS4xX0B0eXBlcytub2RlQDIyLjEzLjE0X19qaXRpQDIuNC4yX3Bvc3Rjc3NAOC41Xzk2ZWIwNWE5ZDY1MzQzMDIxZTUzNzkxZGQ4M2YzNzczL25vZGVfbW9kdWxlcy90c3VwL2Fzc2V0cy9lc21fc2hpbXMuanNcbnZhciBpbml0X2VzbV9zaGltcyA9IF9fZXNtKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdHN1cEA4LjQuMF9AbWljcm9zb2Z0K2FwaS1leHRyYWN0b3JANy41MS4xX0B0eXBlcytub2RlQDIyLjEzLjE0X19qaXRpQDIuNC4yX3Bvc3Rjc3NAOC41Xzk2ZWIwNWE5ZDY1MzQzMDIxZTUzNzkxZGQ4M2YzNzczL25vZGVfbW9kdWxlcy90c3VwL2Fzc2V0cy9lc21fc2hpbXMuanNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yZmRjQDEuNC4xL25vZGVfbW9kdWxlcy9yZmRjL2luZGV4LmpzXG52YXIgcmVxdWlyZV9yZmRjID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JmZGNAMS40LjEvbm9kZV9tb2R1bGVzL3JmZGMvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2VzbV9zaGltcygpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmZkYzI7XG4gICAgZnVuY3Rpb24gY29weUJ1ZmZlcihjdXIpIHtcbiAgICAgIGlmIChjdXIgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGN1cik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IGN1ci5jb25zdHJ1Y3RvcihjdXIuYnVmZmVyLnNsaWNlKCksIGN1ci5ieXRlT2Zmc2V0LCBjdXIubGVuZ3RoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmZkYzIob3B0cykge1xuICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICBpZiAob3B0cy5jaXJjbGVzKSByZXR1cm4gcmZkY0NpcmNsZXMob3B0cyk7XG4gICAgICBjb25zdCBjb25zdHJ1Y3RvckhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0cnVjdG9ySGFuZGxlcnMuc2V0KERhdGUsIChvKSA9PiBuZXcgRGF0ZShvKSk7XG4gICAgICBjb25zdHJ1Y3RvckhhbmRsZXJzLnNldChNYXAsIChvLCBmbikgPT4gbmV3IE1hcChjbG9uZUFycmF5KEFycmF5LmZyb20obyksIGZuKSkpO1xuICAgICAgY29uc3RydWN0b3JIYW5kbGVycy5zZXQoU2V0LCAobywgZm4pID0+IG5ldyBTZXQoY2xvbmVBcnJheShBcnJheS5mcm9tKG8pLCBmbikpKTtcbiAgICAgIGlmIChvcHRzLmNvbnN0cnVjdG9ySGFuZGxlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyMiBvZiBvcHRzLmNvbnN0cnVjdG9ySGFuZGxlcnMpIHtcbiAgICAgICAgICBjb25zdHJ1Y3RvckhhbmRsZXJzLnNldChoYW5kbGVyMlswXSwgaGFuZGxlcjJbMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgaGFuZGxlciA9IG51bGw7XG4gICAgICByZXR1cm4gb3B0cy5wcm90byA/IGNsb25lUHJvdG8gOiBjbG9uZTtcbiAgICAgIGZ1bmN0aW9uIGNsb25lQXJyYXkoYSwgZm4pIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICBjb25zdCBhMiA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgICAgICAgIGNvbnN0IGN1ciA9IGFba107XG4gICAgICAgICAgaWYgKHR5cGVvZiBjdXIgIT09IFwib2JqZWN0XCIgfHwgY3VyID09PSBudWxsKSB7XG4gICAgICAgICAgICBhMltrXSA9IGN1cjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ci5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0ICYmIChoYW5kbGVyID0gY29uc3RydWN0b3JIYW5kbGVycy5nZXQoY3VyLmNvbnN0cnVjdG9yKSkpIHtcbiAgICAgICAgICAgIGEyW2tdID0gaGFuZGxlcihjdXIsIGZuKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhjdXIpKSB7XG4gICAgICAgICAgICBhMltrXSA9IGNvcHlCdWZmZXIoY3VyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYTJba10gPSBmbihjdXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjbG9uZShvKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbyAhPT0gXCJvYmplY3RcIiB8fCBvID09PSBudWxsKSByZXR1cm4gbztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobykpIHJldHVybiBjbG9uZUFycmF5KG8sIGNsb25lKTtcbiAgICAgICAgaWYgKG8uY29uc3RydWN0b3IgIT09IE9iamVjdCAmJiAoaGFuZGxlciA9IGNvbnN0cnVjdG9ySGFuZGxlcnMuZ2V0KG8uY29uc3RydWN0b3IpKSkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVyKG8sIGNsb25lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvMiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gbykge1xuICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IGN1ciA9IG9ba107XG4gICAgICAgICAgaWYgKHR5cGVvZiBjdXIgIT09IFwib2JqZWN0XCIgfHwgY3VyID09PSBudWxsKSB7XG4gICAgICAgICAgICBvMltrXSA9IGN1cjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ci5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0ICYmIChoYW5kbGVyID0gY29uc3RydWN0b3JIYW5kbGVycy5nZXQoY3VyLmNvbnN0cnVjdG9yKSkpIHtcbiAgICAgICAgICAgIG8yW2tdID0gaGFuZGxlcihjdXIsIGNsb25lKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhjdXIpKSB7XG4gICAgICAgICAgICBvMltrXSA9IGNvcHlCdWZmZXIoY3VyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbzJba10gPSBjbG9uZShjdXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbzI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjbG9uZVByb3RvKG8pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvICE9PSBcIm9iamVjdFwiIHx8IG8gPT09IG51bGwpIHJldHVybiBvO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvKSkgcmV0dXJuIGNsb25lQXJyYXkobywgY2xvbmVQcm90byk7XG4gICAgICAgIGlmIChvLmNvbnN0cnVjdG9yICE9PSBPYmplY3QgJiYgKGhhbmRsZXIgPSBjb25zdHJ1Y3RvckhhbmRsZXJzLmdldChvLmNvbnN0cnVjdG9yKSkpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlcihvLCBjbG9uZVByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvMiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gbykge1xuICAgICAgICAgIGNvbnN0IGN1ciA9IG9ba107XG4gICAgICAgICAgaWYgKHR5cGVvZiBjdXIgIT09IFwib2JqZWN0XCIgfHwgY3VyID09PSBudWxsKSB7XG4gICAgICAgICAgICBvMltrXSA9IGN1cjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ci5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0ICYmIChoYW5kbGVyID0gY29uc3RydWN0b3JIYW5kbGVycy5nZXQoY3VyLmNvbnN0cnVjdG9yKSkpIHtcbiAgICAgICAgICAgIG8yW2tdID0gaGFuZGxlcihjdXIsIGNsb25lUHJvdG8pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGN1cikpIHtcbiAgICAgICAgICAgIG8yW2tdID0gY29weUJ1ZmZlcihjdXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvMltrXSA9IGNsb25lUHJvdG8oY3VyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG8yO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZmRjQ2lyY2xlcyhvcHRzKSB7XG4gICAgICBjb25zdCByZWZzID0gW107XG4gICAgICBjb25zdCByZWZzTmV3ID0gW107XG4gICAgICBjb25zdCBjb25zdHJ1Y3RvckhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0cnVjdG9ySGFuZGxlcnMuc2V0KERhdGUsIChvKSA9PiBuZXcgRGF0ZShvKSk7XG4gICAgICBjb25zdHJ1Y3RvckhhbmRsZXJzLnNldChNYXAsIChvLCBmbikgPT4gbmV3IE1hcChjbG9uZUFycmF5KEFycmF5LmZyb20obyksIGZuKSkpO1xuICAgICAgY29uc3RydWN0b3JIYW5kbGVycy5zZXQoU2V0LCAobywgZm4pID0+IG5ldyBTZXQoY2xvbmVBcnJheShBcnJheS5mcm9tKG8pLCBmbikpKTtcbiAgICAgIGlmIChvcHRzLmNvbnN0cnVjdG9ySGFuZGxlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyMiBvZiBvcHRzLmNvbnN0cnVjdG9ySGFuZGxlcnMpIHtcbiAgICAgICAgICBjb25zdHJ1Y3RvckhhbmRsZXJzLnNldChoYW5kbGVyMlswXSwgaGFuZGxlcjJbMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgaGFuZGxlciA9IG51bGw7XG4gICAgICByZXR1cm4gb3B0cy5wcm90byA/IGNsb25lUHJvdG8gOiBjbG9uZTtcbiAgICAgIGZ1bmN0aW9uIGNsb25lQXJyYXkoYSwgZm4pIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICBjb25zdCBhMiA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgICAgICAgIGNvbnN0IGN1ciA9IGFba107XG4gICAgICAgICAgaWYgKHR5cGVvZiBjdXIgIT09IFwib2JqZWN0XCIgfHwgY3VyID09PSBudWxsKSB7XG4gICAgICAgICAgICBhMltrXSA9IGN1cjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ci5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0ICYmIChoYW5kbGVyID0gY29uc3RydWN0b3JIYW5kbGVycy5nZXQoY3VyLmNvbnN0cnVjdG9yKSkpIHtcbiAgICAgICAgICAgIGEyW2tdID0gaGFuZGxlcihjdXIsIGZuKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhjdXIpKSB7XG4gICAgICAgICAgICBhMltrXSA9IGNvcHlCdWZmZXIoY3VyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSByZWZzLmluZGV4T2YoY3VyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgYTJba10gPSByZWZzTmV3W2luZGV4XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGEyW2tdID0gZm4oY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEyO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2xvbmUobykge1xuICAgICAgICBpZiAodHlwZW9mIG8gIT09IFwib2JqZWN0XCIgfHwgbyA9PT0gbnVsbCkgcmV0dXJuIG87XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG8pKSByZXR1cm4gY2xvbmVBcnJheShvLCBjbG9uZSk7XG4gICAgICAgIGlmIChvLmNvbnN0cnVjdG9yICE9PSBPYmplY3QgJiYgKGhhbmRsZXIgPSBjb25zdHJ1Y3RvckhhbmRsZXJzLmdldChvLmNvbnN0cnVjdG9yKSkpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlcihvLCBjbG9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbzIgPSB7fTtcbiAgICAgICAgcmVmcy5wdXNoKG8pO1xuICAgICAgICByZWZzTmV3LnB1c2gobzIpO1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gbykge1xuICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IGN1ciA9IG9ba107XG4gICAgICAgICAgaWYgKHR5cGVvZiBjdXIgIT09IFwib2JqZWN0XCIgfHwgY3VyID09PSBudWxsKSB7XG4gICAgICAgICAgICBvMltrXSA9IGN1cjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ci5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0ICYmIChoYW5kbGVyID0gY29uc3RydWN0b3JIYW5kbGVycy5nZXQoY3VyLmNvbnN0cnVjdG9yKSkpIHtcbiAgICAgICAgICAgIG8yW2tdID0gaGFuZGxlcihjdXIsIGNsb25lKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhjdXIpKSB7XG4gICAgICAgICAgICBvMltrXSA9IGNvcHlCdWZmZXIoY3VyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaSA9IHJlZnMuaW5kZXhPZihjdXIpO1xuICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIG8yW2tdID0gcmVmc05ld1tpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG8yW2tdID0gY2xvbmUoY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVmcy5wb3AoKTtcbiAgICAgICAgcmVmc05ldy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIG8yO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2xvbmVQcm90byhvKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbyAhPT0gXCJvYmplY3RcIiB8fCBvID09PSBudWxsKSByZXR1cm4gbztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobykpIHJldHVybiBjbG9uZUFycmF5KG8sIGNsb25lUHJvdG8pO1xuICAgICAgICBpZiAoby5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0ICYmIChoYW5kbGVyID0gY29uc3RydWN0b3JIYW5kbGVycy5nZXQoby5jb25zdHJ1Y3RvcikpKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZXIobywgY2xvbmVQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbzIgPSB7fTtcbiAgICAgICAgcmVmcy5wdXNoKG8pO1xuICAgICAgICByZWZzTmV3LnB1c2gobzIpO1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gbykge1xuICAgICAgICAgIGNvbnN0IGN1ciA9IG9ba107XG4gICAgICAgICAgaWYgKHR5cGVvZiBjdXIgIT09IFwib2JqZWN0XCIgfHwgY3VyID09PSBudWxsKSB7XG4gICAgICAgICAgICBvMltrXSA9IGN1cjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ci5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0ICYmIChoYW5kbGVyID0gY29uc3RydWN0b3JIYW5kbGVycy5nZXQoY3VyLmNvbnN0cnVjdG9yKSkpIHtcbiAgICAgICAgICAgIG8yW2tdID0gaGFuZGxlcihjdXIsIGNsb25lUHJvdG8pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGN1cikpIHtcbiAgICAgICAgICAgIG8yW2tdID0gY29weUJ1ZmZlcihjdXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpID0gcmVmcy5pbmRleE9mKGN1cik7XG4gICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgbzJba10gPSByZWZzTmV3W2ldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbzJba10gPSBjbG9uZVByb3RvKGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlZnMucG9wKCk7XG4gICAgICAgIHJlZnNOZXcucG9wKCk7XG4gICAgICAgIHJldHVybiBvMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBzcmMvaW5kZXgudHNcbmluaXRfZXNtX3NoaW1zKCk7XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbmluaXRfZXNtX3NoaW1zKCk7XG52YXIgVklFV19NT0RFX1NUT1JBR0VfS0VZID0gXCJfX3Z1ZS1kZXZ0b29scy12aWV3LW1vZGVfX1wiO1xudmFyIFZJVEVfUExVR0lOX0RFVEVDVEVEX1NUT1JBR0VfS0VZID0gXCJfX3Z1ZS1kZXZ0b29scy12aXRlLXBsdWdpbi1kZXRlY3RlZF9fXCI7XG52YXIgVklURV9QTFVHSU5fQ0xJRU5UX1VSTF9TVE9SQUdFX0tFWSA9IFwiX192dWUtZGV2dG9vbHMtdml0ZS1wbHVnaW4tY2xpZW50LXVybF9fXCI7XG52YXIgQlJPQURDQVNUX0NIQU5ORUxfTkFNRSA9IFwiX192dWUtZGV2dG9vbHMtYnJvYWRjYXN0LWNoYW5uZWxfX1wiO1xuXG4vLyBzcmMvZW52LnRzXG5pbml0X2VzbV9zaGltcygpO1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgdGFyZ2V0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fTtcbnZhciBpc0luQ2hyb21lUGFuZWwgPSB0eXBlb2YgdGFyZ2V0LmNocm9tZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIXRhcmdldC5jaHJvbWUuZGV2dG9vbHM7XG52YXIgaXNJbklmcmFtZSA9IGlzQnJvd3NlciAmJiB0YXJnZXQuc2VsZiAhPT0gdGFyZ2V0LnRvcDtcbnZhciBfYTtcbnZhciBpc0luRWxlY3Ryb24gPSB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmICgoX2EgPSBuYXZpZ2F0b3IudXNlckFnZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImVsZWN0cm9uXCIpKTtcbnZhciBpc051eHRBcHAgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICEhd2luZG93Ll9fTlVYVF9fO1xudmFyIGlzSW5TZXBhcmF0ZVdpbmRvdyA9ICFpc0luSWZyYW1lICYmICFpc0luQ2hyb21lUGFuZWwgJiYgIWlzSW5FbGVjdHJvbjtcblxuLy8gc3JjL2dlbmVyYWwudHNcbmluaXRfZXNtX3NoaW1zKCk7XG52YXIgaW1wb3J0X3JmZGMgPSBfX3RvRVNNKHJlcXVpcmVfcmZkYygpLCAxKTtcbmZ1bmN0aW9uIE5PT1AoKSB7XG59XG52YXIgaXNOdW1lcmljID0gKHN0cikgPT4gYCR7K3N0cn1gID09PSBzdHI7XG52YXIgaXNNYWNPUyA9ICgpID0+IChuYXZpZ2F0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IG5hdmlnYXRvci5wbGF0Zm9ybSkgPyBuYXZpZ2F0b3IgPT0gbnVsbCA/IHZvaWQgMCA6IG5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwibWFjXCIpIDogL01hY2ludG9zaC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fL10pKFxcdykvZztcbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGtlYmFiaXplUkUgPSAvKFthLXowLTldKShbQS1aXSkvZztcbmZ1bmN0aW9uIHRvVXBwZXIoXywgYykge1xuICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6IFwiXCI7XG59XG5mdW5jdGlvbiBjbGFzc2lmeShzdHIpIHtcbiAgcmV0dXJuIHN0ciAmJiBgJHtzdHJ9YC5yZXBsYWNlKGNsYXNzaWZ5UkUsIHRvVXBwZXIpO1xufVxuZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIgJiYgc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgdG9VcHBlcik7XG59XG5mdW5jdGlvbiBrZWJhYml6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ciAmJiBzdHIucmVwbGFjZShrZWJhYml6ZVJFLCAoXywgbG93ZXJDYXNlQ2hhcmFjdGVyLCB1cHBlckNhc2VMZXR0ZXIpID0+IHtcbiAgICByZXR1cm4gYCR7bG93ZXJDYXNlQ2hhcmFjdGVyfS0ke3VwcGVyQ2FzZUxldHRlcn1gO1xuICB9KS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gYmFzZW5hbWUoZmlsZW5hbWUsIGV4dCkge1xuICBsZXQgbm9ybWFsaXplZEZpbGVuYW1lID0gZmlsZW5hbWUucmVwbGFjZSgvXlthLXpdOi9pLCBcIlwiKS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiAgaWYgKG5vcm1hbGl6ZWRGaWxlbmFtZS5lbmRzV2l0aChgaW5kZXgke2V4dH1gKSkge1xuICAgIG5vcm1hbGl6ZWRGaWxlbmFtZSA9IG5vcm1hbGl6ZWRGaWxlbmFtZS5yZXBsYWNlKGAvaW5kZXgke2V4dH1gLCBleHQpO1xuICB9XG4gIGNvbnN0IGxhc3RTbGFzaEluZGV4ID0gbm9ybWFsaXplZEZpbGVuYW1lLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgY29uc3QgYmFzZU5hbWVXaXRoRXh0ID0gbm9ybWFsaXplZEZpbGVuYW1lLnN1YnN0cmluZyhsYXN0U2xhc2hJbmRleCArIDEpO1xuICBpZiAoZXh0KSB7XG4gICAgY29uc3QgZXh0SW5kZXggPSBiYXNlTmFtZVdpdGhFeHQubGFzdEluZGV4T2YoZXh0KTtcbiAgICByZXR1cm4gYmFzZU5hbWVXaXRoRXh0LnN1YnN0cmluZygwLCBleHRJbmRleCk7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiBzb3J0QnlLZXkoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLnNsaWNlKCkuc29ydCgoYSwgYikgPT4ge1xuICAgIGlmIChhLmtleSA8IGIua2V5KVxuICAgICAgcmV0dXJuIC0xO1xuICAgIGlmIChhLmtleSA+IGIua2V5KVxuICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xufVxudmFyIEhUVFBfVVJMX1JFID0gL15odHRwcz86XFwvXFwvLztcbmZ1bmN0aW9uIGlzVXJsU3RyaW5nKHN0cikge1xuICByZXR1cm4gc3RyLnN0YXJ0c1dpdGgoXCIvXCIpIHx8IEhUVFBfVVJMX1JFLnRlc3Qoc3RyKTtcbn1cbnZhciBkZWVwQ2xvbmUgPSAoMCwgaW1wb3J0X3JmZGMuZGVmYXVsdCkoeyBjaXJjbGVzOiB0cnVlIH0pO1xuZnVuY3Rpb24gcmFuZG9tU3RyKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0O1xufVxuZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTWFwO1xufVxuZXhwb3J0IHtcbiAgQlJPQURDQVNUX0NIQU5ORUxfTkFNRSxcbiAgTk9PUCxcbiAgVklFV19NT0RFX1NUT1JBR0VfS0VZLFxuICBWSVRFX1BMVUdJTl9DTElFTlRfVVJMX1NUT1JBR0VfS0VZLFxuICBWSVRFX1BMVUdJTl9ERVRFQ1RFRF9TVE9SQUdFX0tFWSxcbiAgYmFzZW5hbWUsXG4gIGNhbWVsaXplLFxuICBjbGFzc2lmeSxcbiAgZGVlcENsb25lLFxuICBpc0FycmF5LFxuICBpc0Jyb3dzZXIsXG4gIGlzSW5DaHJvbWVQYW5lbCxcbiAgaXNJbkVsZWN0cm9uLFxuICBpc0luSWZyYW1lLFxuICBpc0luU2VwYXJhdGVXaW5kb3csXG4gIGlzTWFjT1MsXG4gIGlzTWFwLFxuICBpc051bWVyaWMsXG4gIGlzTnV4dEFwcCxcbiAgaXNPYmplY3QsXG4gIGlzU2V0LFxuICBpc1VybFN0cmluZyxcbiAga2ViYWJpemUsXG4gIHJhbmRvbVN0cixcbiAgc29ydEJ5S2V5LFxuICB0YXJnZXRcbn07XG4iLCIvKipcbiogQHZ1ZS9yZWFjdGl2aXR5IHYzLjUuMjZcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbmltcG9ydCB7IGV4dGVuZCwgaGFzQ2hhbmdlZCwgaXNBcnJheSwgaXNJbnRlZ2VyS2V5LCBpc1N5bWJvbCwgaXNNYXAsIGhhc093biwgbWFrZU1hcCwgaXNPYmplY3QsIGNhcGl0YWxpemUsIHRvUmF3VHlwZSwgZGVmLCBpc0Z1bmN0aW9uLCBFTVBUWV9PQkosIGlzU2V0LCBpc1BsYWluT2JqZWN0LCByZW1vdmUsIE5PT1AgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XG4gIGNvbnNvbGUud2FybihgW1Z1ZSB3YXJuXSAke21zZ31gLCAuLi5hcmdzKTtcbn1cblxubGV0IGFjdGl2ZUVmZmVjdFNjb3BlO1xuY2xhc3MgRWZmZWN0U2NvcGUge1xuICBjb25zdHJ1Y3RvcihkZXRhY2hlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5kZXRhY2hlZCA9IGRldGFjaGVkO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIHRyYWNrIGBvbmAgY2FsbHMsIGFsbG93IGBvbmAgY2FsbCBtdWx0aXBsZSB0aW1lc1xuICAgICAqL1xuICAgIHRoaXMuX29uID0gMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmVmZmVjdHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmNsZWFudXBzID0gW107XG4gICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgIGlmICghZGV0YWNoZWQgJiYgYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICAgIHRoaXMuaW5kZXggPSAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzIHx8IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgPSBbXSkpLnB1c2goXG4gICAgICAgIHRoaXNcbiAgICAgICkgLSAxO1xuICAgIH1cbiAgfVxuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xuICAgICAgbGV0IGksIGw7XG4gICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZWZmZWN0c1tpXS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVzdW1lcyB0aGUgZWZmZWN0IHNjb3BlLCBpbmNsdWRpbmcgYWxsIGNoaWxkIHNjb3BlcyBhbmQgZWZmZWN0cy5cbiAgICovXG4gIHJlc3VtZSgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICBpZiAodGhpcy5faXNQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGksIGw7XG4gICAgICAgIGlmICh0aGlzLnNjb3Blcykge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnJlc3VtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuZWZmZWN0c1tpXS5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBydW4oZm4pIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWZmZWN0U2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IGN1cnJlbnRFZmZlY3RTY29wZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oYGNhbm5vdCBydW4gYW4gaW5hY3RpdmUgZWZmZWN0IHNjb3BlLmApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9uKCkge1xuICAgIGlmICgrK3RoaXMuX29uID09PSAxKSB7XG4gICAgICB0aGlzLnByZXZTY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9mZigpIHtcbiAgICBpZiAodGhpcy5fb24gPiAwICYmIC0tdGhpcy5fb24gPT09IDApIHtcbiAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcy5wcmV2U2NvcGU7XG4gICAgICB0aGlzLnByZXZTY29wZSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgc3RvcChmcm9tUGFyZW50KSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICBsZXQgaSwgbDtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZWZmZWN0c1tpXS5zdG9wKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVmZmVjdHMubGVuZ3RoID0gMDtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNsZWFudXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmNsZWFudXBzW2ldKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFudXBzLmxlbmd0aCA9IDA7XG4gICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnN0b3AodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY29wZXMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5kZXRhY2hlZCAmJiB0aGlzLnBhcmVudCAmJiAhZnJvbVBhcmVudCkge1xuICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5wYXJlbnQuc2NvcGVzLnBvcCgpO1xuICAgICAgICBpZiAobGFzdCAmJiBsYXN0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuc2NvcGVzW3RoaXMuaW5kZXhdID0gbGFzdDtcbiAgICAgICAgICBsYXN0LmluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wYXJlbnQgPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlZmZlY3RTY29wZShkZXRhY2hlZCkge1xuICByZXR1cm4gbmV3IEVmZmVjdFNjb3BlKGRldGFjaGVkKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcbiAgcmV0dXJuIGFjdGl2ZUVmZmVjdFNjb3BlO1xufVxuZnVuY3Rpb24gb25TY29wZURpc3Bvc2UoZm4sIGZhaWxTaWxlbnRseSA9IGZhbHNlKSB7XG4gIGlmIChhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmNsZWFudXBzLnB1c2goZm4pO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWZhaWxTaWxlbnRseSkge1xuICAgIHdhcm4oXG4gICAgICBgb25TY29wZURpc3Bvc2UoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgZWZmZWN0IHNjb3BlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXG4gICAgKTtcbiAgfVxufVxuXG5sZXQgYWN0aXZlU3ViO1xuY29uc3QgRWZmZWN0RmxhZ3MgPSB7XG4gIFwiQUNUSVZFXCI6IDEsXG4gIFwiMVwiOiBcIkFDVElWRVwiLFxuICBcIlJVTk5JTkdcIjogMixcbiAgXCIyXCI6IFwiUlVOTklOR1wiLFxuICBcIlRSQUNLSU5HXCI6IDQsXG4gIFwiNFwiOiBcIlRSQUNLSU5HXCIsXG4gIFwiTk9USUZJRURcIjogOCxcbiAgXCI4XCI6IFwiTk9USUZJRURcIixcbiAgXCJESVJUWVwiOiAxNixcbiAgXCIxNlwiOiBcIkRJUlRZXCIsXG4gIFwiQUxMT1dfUkVDVVJTRVwiOiAzMixcbiAgXCIzMlwiOiBcIkFMTE9XX1JFQ1VSU0VcIixcbiAgXCJQQVVTRURcIjogNjQsXG4gIFwiNjRcIjogXCJQQVVTRURcIixcbiAgXCJFVkFMVUFURURcIjogMTI4LFxuICBcIjEyOFwiOiBcIkVWQUxVQVRFRFwiXG59O1xuY29uc3QgcGF1c2VkUXVldWVFZmZlY3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG5jbGFzcyBSZWFjdGl2ZUVmZmVjdCB7XG4gIGNvbnN0cnVjdG9yKGZuKSB7XG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwcyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcHNUYWlsID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZmxhZ3MgPSAxIHwgNDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5jbGVhbnVwID0gdm9pZCAwO1xuICAgIHRoaXMuc2NoZWR1bGVyID0gdm9pZCAwO1xuICAgIGlmIChhY3RpdmVFZmZlY3RTY29wZSAmJiBhY3RpdmVFZmZlY3RTY29wZS5hY3RpdmUpIHtcbiAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmVmZmVjdHMucHVzaCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5mbGFncyB8PSA2NDtcbiAgfVxuICByZXN1bWUoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiA2NCkge1xuICAgICAgdGhpcy5mbGFncyAmPSAtNjU7XG4gICAgICBpZiAocGF1c2VkUXVldWVFZmZlY3RzLmhhcyh0aGlzKSkge1xuICAgICAgICBwYXVzZWRRdWV1ZUVmZmVjdHMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbm90aWZ5KCkge1xuICAgIGlmICh0aGlzLmZsYWdzICYgMiAmJiAhKHRoaXMuZmxhZ3MgJiAzMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEodGhpcy5mbGFncyAmIDgpKSB7XG4gICAgICBiYXRjaCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgcnVuKCkge1xuICAgIGlmICghKHRoaXMuZmxhZ3MgJiAxKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcbiAgICB9XG4gICAgdGhpcy5mbGFncyB8PSAyO1xuICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgcHJlcGFyZURlcHModGhpcyk7XG4gICAgY29uc3QgcHJldkVmZmVjdCA9IGFjdGl2ZVN1YjtcbiAgICBjb25zdCBwcmV2U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcbiAgICBhY3RpdmVTdWIgPSB0aGlzO1xuICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgYWN0aXZlU3ViICE9PSB0aGlzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJBY3RpdmUgZWZmZWN0IHdhcyBub3QgcmVzdG9yZWQgY29ycmVjdGx5IC0gdGhpcyBpcyBsaWtlbHkgYSBWdWUgaW50ZXJuYWwgYnVnLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjbGVhbnVwRGVwcyh0aGlzKTtcbiAgICAgIGFjdGl2ZVN1YiA9IHByZXZFZmZlY3Q7XG4gICAgICBzaG91bGRUcmFjayA9IHByZXZTaG91bGRUcmFjaztcbiAgICAgIHRoaXMuZmxhZ3MgJj0gLTM7XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiAxKSB7XG4gICAgICBmb3IgKGxldCBsaW5rID0gdGhpcy5kZXBzOyBsaW5rOyBsaW5rID0gbGluay5uZXh0RGVwKSB7XG4gICAgICAgIHJlbW92ZVN1YihsaW5rKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVwcyA9IHRoaXMuZGVwc1RhaWwgPSB2b2lkIDA7XG4gICAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xuICAgICAgdGhpcy5vblN0b3AgJiYgdGhpcy5vblN0b3AoKTtcbiAgICAgIHRoaXMuZmxhZ3MgJj0gLTI7XG4gICAgfVxuICB9XG4gIHRyaWdnZXIoKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiA2NCkge1xuICAgICAgcGF1c2VkUXVldWVFZmZlY3RzLmFkZCh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2NoZWR1bGVyKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1bklmRGlydHkoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcnVuSWZEaXJ0eSgpIHtcbiAgICBpZiAoaXNEaXJ0eSh0aGlzKSkge1xuICAgICAgdGhpcy5ydW4oKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGRpcnR5KCkge1xuICAgIHJldHVybiBpc0RpcnR5KHRoaXMpO1xuICB9XG59XG5sZXQgYmF0Y2hEZXB0aCA9IDA7XG5sZXQgYmF0Y2hlZFN1YjtcbmxldCBiYXRjaGVkQ29tcHV0ZWQ7XG5mdW5jdGlvbiBiYXRjaChzdWIsIGlzQ29tcHV0ZWQgPSBmYWxzZSkge1xuICBzdWIuZmxhZ3MgfD0gODtcbiAgaWYgKGlzQ29tcHV0ZWQpIHtcbiAgICBzdWIubmV4dCA9IGJhdGNoZWRDb21wdXRlZDtcbiAgICBiYXRjaGVkQ29tcHV0ZWQgPSBzdWI7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN1Yi5uZXh0ID0gYmF0Y2hlZFN1YjtcbiAgYmF0Y2hlZFN1YiA9IHN1Yjtcbn1cbmZ1bmN0aW9uIHN0YXJ0QmF0Y2goKSB7XG4gIGJhdGNoRGVwdGgrKztcbn1cbmZ1bmN0aW9uIGVuZEJhdGNoKCkge1xuICBpZiAoLS1iYXRjaERlcHRoID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYmF0Y2hlZENvbXB1dGVkKSB7XG4gICAgbGV0IGUgPSBiYXRjaGVkQ29tcHV0ZWQ7XG4gICAgYmF0Y2hlZENvbXB1dGVkID0gdm9pZCAwO1xuICAgIHdoaWxlIChlKSB7XG4gICAgICBjb25zdCBuZXh0ID0gZS5uZXh0O1xuICAgICAgZS5uZXh0ID0gdm9pZCAwO1xuICAgICAgZS5mbGFncyAmPSAtOTtcbiAgICAgIGUgPSBuZXh0O1xuICAgIH1cbiAgfVxuICBsZXQgZXJyb3I7XG4gIHdoaWxlIChiYXRjaGVkU3ViKSB7XG4gICAgbGV0IGUgPSBiYXRjaGVkU3ViO1xuICAgIGJhdGNoZWRTdWIgPSB2b2lkIDA7XG4gICAgd2hpbGUgKGUpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBlLm5leHQ7XG4gICAgICBlLm5leHQgPSB2b2lkIDA7XG4gICAgICBlLmZsYWdzICY9IC05O1xuICAgICAgaWYgKGUuZmxhZ3MgJiAxKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgO1xuICAgICAgICAgIGUudHJpZ2dlcigpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZSA9IG5leHQ7XG4gICAgfVxuICB9XG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG59XG5mdW5jdGlvbiBwcmVwYXJlRGVwcyhzdWIpIHtcbiAgZm9yIChsZXQgbGluayA9IHN1Yi5kZXBzOyBsaW5rOyBsaW5rID0gbGluay5uZXh0RGVwKSB7XG4gICAgbGluay52ZXJzaW9uID0gLTE7XG4gICAgbGluay5wcmV2QWN0aXZlTGluayA9IGxpbmsuZGVwLmFjdGl2ZUxpbms7XG4gICAgbGluay5kZXAuYWN0aXZlTGluayA9IGxpbms7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFudXBEZXBzKHN1Yikge1xuICBsZXQgaGVhZDtcbiAgbGV0IHRhaWwgPSBzdWIuZGVwc1RhaWw7XG4gIGxldCBsaW5rID0gdGFpbDtcbiAgd2hpbGUgKGxpbmspIHtcbiAgICBjb25zdCBwcmV2ID0gbGluay5wcmV2RGVwO1xuICAgIGlmIChsaW5rLnZlcnNpb24gPT09IC0xKSB7XG4gICAgICBpZiAobGluayA9PT0gdGFpbCkgdGFpbCA9IHByZXY7XG4gICAgICByZW1vdmVTdWIobGluayk7XG4gICAgICByZW1vdmVEZXAobGluayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQgPSBsaW5rO1xuICAgIH1cbiAgICBsaW5rLmRlcC5hY3RpdmVMaW5rID0gbGluay5wcmV2QWN0aXZlTGluaztcbiAgICBsaW5rLnByZXZBY3RpdmVMaW5rID0gdm9pZCAwO1xuICAgIGxpbmsgPSBwcmV2O1xuICB9XG4gIHN1Yi5kZXBzID0gaGVhZDtcbiAgc3ViLmRlcHNUYWlsID0gdGFpbDtcbn1cbmZ1bmN0aW9uIGlzRGlydHkoc3ViKSB7XG4gIGZvciAobGV0IGxpbmsgPSBzdWIuZGVwczsgbGluazsgbGluayA9IGxpbmsubmV4dERlcCkge1xuICAgIGlmIChsaW5rLmRlcC52ZXJzaW9uICE9PSBsaW5rLnZlcnNpb24gfHwgbGluay5kZXAuY29tcHV0ZWQgJiYgKHJlZnJlc2hDb21wdXRlZChsaW5rLmRlcC5jb21wdXRlZCkgfHwgbGluay5kZXAudmVyc2lvbiAhPT0gbGluay52ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChzdWIuX2RpcnR5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmVmcmVzaENvbXB1dGVkKGNvbXB1dGVkKSB7XG4gIGlmIChjb21wdXRlZC5mbGFncyAmIDQgJiYgIShjb21wdXRlZC5mbGFncyAmIDE2KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb21wdXRlZC5mbGFncyAmPSAtMTc7XG4gIGlmIChjb21wdXRlZC5nbG9iYWxWZXJzaW9uID09PSBnbG9iYWxWZXJzaW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbXB1dGVkLmdsb2JhbFZlcnNpb24gPSBnbG9iYWxWZXJzaW9uO1xuICBpZiAoIWNvbXB1dGVkLmlzU1NSICYmIGNvbXB1dGVkLmZsYWdzICYgMTI4ICYmICghY29tcHV0ZWQuZGVwcyAmJiAhY29tcHV0ZWQuX2RpcnR5IHx8ICFpc0RpcnR5KGNvbXB1dGVkKSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29tcHV0ZWQuZmxhZ3MgfD0gMjtcbiAgY29uc3QgZGVwID0gY29tcHV0ZWQuZGVwO1xuICBjb25zdCBwcmV2U3ViID0gYWN0aXZlU3ViO1xuICBjb25zdCBwcmV2U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcbiAgYWN0aXZlU3ViID0gY29tcHV0ZWQ7XG4gIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBwcmVwYXJlRGVwcyhjb21wdXRlZCk7XG4gICAgY29uc3QgdmFsdWUgPSBjb21wdXRlZC5mbihjb21wdXRlZC5fdmFsdWUpO1xuICAgIGlmIChkZXAudmVyc2lvbiA9PT0gMCB8fCBoYXNDaGFuZ2VkKHZhbHVlLCBjb21wdXRlZC5fdmFsdWUpKSB7XG4gICAgICBjb21wdXRlZC5mbGFncyB8PSAxMjg7XG4gICAgICBjb21wdXRlZC5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgIGRlcC52ZXJzaW9uKys7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZXAudmVyc2lvbisrO1xuICAgIHRocm93IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICBhY3RpdmVTdWIgPSBwcmV2U3ViO1xuICAgIHNob3VsZFRyYWNrID0gcHJldlNob3VsZFRyYWNrO1xuICAgIGNsZWFudXBEZXBzKGNvbXB1dGVkKTtcbiAgICBjb21wdXRlZC5mbGFncyAmPSAtMztcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlU3ViKGxpbmssIHNvZnQgPSBmYWxzZSkge1xuICBjb25zdCB7IGRlcCwgcHJldlN1YiwgbmV4dFN1YiB9ID0gbGluaztcbiAgaWYgKHByZXZTdWIpIHtcbiAgICBwcmV2U3ViLm5leHRTdWIgPSBuZXh0U3ViO1xuICAgIGxpbmsucHJldlN1YiA9IHZvaWQgMDtcbiAgfVxuICBpZiAobmV4dFN1Yikge1xuICAgIG5leHRTdWIucHJldlN1YiA9IHByZXZTdWI7XG4gICAgbGluay5uZXh0U3ViID0gdm9pZCAwO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGRlcC5zdWJzSGVhZCA9PT0gbGluaykge1xuICAgIGRlcC5zdWJzSGVhZCA9IG5leHRTdWI7XG4gIH1cbiAgaWYgKGRlcC5zdWJzID09PSBsaW5rKSB7XG4gICAgZGVwLnN1YnMgPSBwcmV2U3ViO1xuICAgIGlmICghcHJldlN1YiAmJiBkZXAuY29tcHV0ZWQpIHtcbiAgICAgIGRlcC5jb21wdXRlZC5mbGFncyAmPSAtNTtcbiAgICAgIGZvciAobGV0IGwgPSBkZXAuY29tcHV0ZWQuZGVwczsgbDsgbCA9IGwubmV4dERlcCkge1xuICAgICAgICByZW1vdmVTdWIobCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghc29mdCAmJiAhLS1kZXAuc2MgJiYgZGVwLm1hcCkge1xuICAgIGRlcC5tYXAuZGVsZXRlKGRlcC5rZXkpO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVEZXAobGluaykge1xuICBjb25zdCB7IHByZXZEZXAsIG5leHREZXAgfSA9IGxpbms7XG4gIGlmIChwcmV2RGVwKSB7XG4gICAgcHJldkRlcC5uZXh0RGVwID0gbmV4dERlcDtcbiAgICBsaW5rLnByZXZEZXAgPSB2b2lkIDA7XG4gIH1cbiAgaWYgKG5leHREZXApIHtcbiAgICBuZXh0RGVwLnByZXZEZXAgPSBwcmV2RGVwO1xuICAgIGxpbmsubmV4dERlcCA9IHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gZWZmZWN0KGZuLCBvcHRpb25zKSB7XG4gIGlmIChmbi5lZmZlY3QgaW5zdGFuY2VvZiBSZWFjdGl2ZUVmZmVjdCkge1xuICAgIGZuID0gZm4uZWZmZWN0LmZuO1xuICB9XG4gIGNvbnN0IGUgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZm4pO1xuICBpZiAob3B0aW9ucykge1xuICAgIGV4dGVuZChlLCBvcHRpb25zKTtcbiAgfVxuICB0cnkge1xuICAgIGUucnVuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGUuc3RvcCgpO1xuICAgIHRocm93IGVycjtcbiAgfVxuICBjb25zdCBydW5uZXIgPSBlLnJ1bi5iaW5kKGUpO1xuICBydW5uZXIuZWZmZWN0ID0gZTtcbiAgcmV0dXJuIHJ1bm5lcjtcbn1cbmZ1bmN0aW9uIHN0b3AocnVubmVyKSB7XG4gIHJ1bm5lci5lZmZlY3Quc3RvcCgpO1xufVxubGV0IHNob3VsZFRyYWNrID0gdHJ1ZTtcbmNvbnN0IHRyYWNrU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHBhdXNlVHJhY2tpbmcoKSB7XG4gIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XG4gIHNob3VsZFRyYWNrID0gZmFsc2U7XG59XG5mdW5jdGlvbiBlbmFibGVUcmFja2luZygpIHtcbiAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgc2hvdWxkVHJhY2sgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcbiAgY29uc3QgbGFzdCA9IHRyYWNrU3RhY2sucG9wKCk7XG4gIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IGxhc3Q7XG59XG5mdW5jdGlvbiBvbkVmZmVjdENsZWFudXAoZm4sIGZhaWxTaWxlbnRseSA9IGZhbHNlKSB7XG4gIGlmIChhY3RpdmVTdWIgaW5zdGFuY2VvZiBSZWFjdGl2ZUVmZmVjdCkge1xuICAgIGFjdGl2ZVN1Yi5jbGVhbnVwID0gZm47XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZmFpbFNpbGVudGx5KSB7XG4gICAgd2FybihcbiAgICAgIGBvbkVmZmVjdENsZWFudXAoKSB3YXMgY2FsbGVkIHdoZW4gdGhlcmUgd2FzIG5vIGFjdGl2ZSBlZmZlY3QgdG8gYXNzb2NpYXRlIHdpdGguYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFudXBFZmZlY3QoZSkge1xuICBjb25zdCB7IGNsZWFudXAgfSA9IGU7XG4gIGUuY2xlYW51cCA9IHZvaWQgMDtcbiAgaWYgKGNsZWFudXApIHtcbiAgICBjb25zdCBwcmV2U3ViID0gYWN0aXZlU3ViO1xuICAgIGFjdGl2ZVN1YiA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhY3RpdmVTdWIgPSBwcmV2U3ViO1xuICAgIH1cbiAgfVxufVxuXG5sZXQgZ2xvYmFsVmVyc2lvbiA9IDA7XG5jbGFzcyBMaW5rIHtcbiAgY29uc3RydWN0b3Ioc3ViLCBkZXApIHtcbiAgICB0aGlzLnN1YiA9IHN1YjtcbiAgICB0aGlzLmRlcCA9IGRlcDtcbiAgICB0aGlzLnZlcnNpb24gPSBkZXAudmVyc2lvbjtcbiAgICB0aGlzLm5leHREZXAgPSB0aGlzLnByZXZEZXAgPSB0aGlzLm5leHRTdWIgPSB0aGlzLnByZXZTdWIgPSB0aGlzLnByZXZBY3RpdmVMaW5rID0gdm9pZCAwO1xuICB9XG59XG5jbGFzcyBEZXAge1xuICAvLyBUT0RPIGlzb2xhdGVkRGVjbGFyYXRpb25zIFwiX192X3NraXBcIlxuICBjb25zdHJ1Y3Rvcihjb21wdXRlZCkge1xuICAgIHRoaXMuY29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICB0aGlzLnZlcnNpb24gPSAwO1xuICAgIC8qKlxuICAgICAqIExpbmsgYmV0d2VlbiB0aGlzIGRlcCBhbmQgdGhlIGN1cnJlbnQgYWN0aXZlIGVmZmVjdFxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlTGluayA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBEb3VibHkgbGlua2VkIGxpc3QgcmVwcmVzZW50aW5nIHRoZSBzdWJzY3JpYmluZyBlZmZlY3RzICh0YWlsKVxuICAgICAqL1xuICAgIHRoaXMuc3VicyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBGb3Igb2JqZWN0IHByb3BlcnR5IGRlcHMgY2xlYW51cFxuICAgICAqL1xuICAgIHRoaXMubWFwID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXIgY291bnRlclxuICAgICAqL1xuICAgIHRoaXMuc2MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX192X3NraXAgPSB0cnVlO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0aGlzLnN1YnNIZWFkID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICB0cmFjayhkZWJ1Z0luZm8pIHtcbiAgICBpZiAoIWFjdGl2ZVN1YiB8fCAhc2hvdWxkVHJhY2sgfHwgYWN0aXZlU3ViID09PSB0aGlzLmNvbXB1dGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBsaW5rID0gdGhpcy5hY3RpdmVMaW5rO1xuICAgIGlmIChsaW5rID09PSB2b2lkIDAgfHwgbGluay5zdWIgIT09IGFjdGl2ZVN1Yikge1xuICAgICAgbGluayA9IHRoaXMuYWN0aXZlTGluayA9IG5ldyBMaW5rKGFjdGl2ZVN1YiwgdGhpcyk7XG4gICAgICBpZiAoIWFjdGl2ZVN1Yi5kZXBzKSB7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzID0gYWN0aXZlU3ViLmRlcHNUYWlsID0gbGluaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmsucHJldkRlcCA9IGFjdGl2ZVN1Yi5kZXBzVGFpbDtcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsLm5leHREZXAgPSBsaW5rO1xuICAgICAgICBhY3RpdmVTdWIuZGVwc1RhaWwgPSBsaW5rO1xuICAgICAgfVxuICAgICAgYWRkU3ViKGxpbmspO1xuICAgIH0gZWxzZSBpZiAobGluay52ZXJzaW9uID09PSAtMSkge1xuICAgICAgbGluay52ZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xuICAgICAgaWYgKGxpbmsubmV4dERlcCkge1xuICAgICAgICBjb25zdCBuZXh0ID0gbGluay5uZXh0RGVwO1xuICAgICAgICBuZXh0LnByZXZEZXAgPSBsaW5rLnByZXZEZXA7XG4gICAgICAgIGlmIChsaW5rLnByZXZEZXApIHtcbiAgICAgICAgICBsaW5rLnByZXZEZXAubmV4dERlcCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGluay5wcmV2RGVwID0gYWN0aXZlU3ViLmRlcHNUYWlsO1xuICAgICAgICBsaW5rLm5leHREZXAgPSB2b2lkIDA7XG4gICAgICAgIGFjdGl2ZVN1Yi5kZXBzVGFpbC5uZXh0RGVwID0gbGluaztcbiAgICAgICAgYWN0aXZlU3ViLmRlcHNUYWlsID0gbGluaztcbiAgICAgICAgaWYgKGFjdGl2ZVN1Yi5kZXBzID09PSBsaW5rKSB7XG4gICAgICAgICAgYWN0aXZlU3ViLmRlcHMgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGFjdGl2ZVN1Yi5vblRyYWNrKSB7XG4gICAgICBhY3RpdmVTdWIub25UcmFjayhcbiAgICAgICAgZXh0ZW5kKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVmZmVjdDogYWN0aXZlU3ViXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWJ1Z0luZm9cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbms7XG4gIH1cbiAgdHJpZ2dlcihkZWJ1Z0luZm8pIHtcbiAgICB0aGlzLnZlcnNpb24rKztcbiAgICBnbG9iYWxWZXJzaW9uKys7XG4gICAgdGhpcy5ub3RpZnkoZGVidWdJbmZvKTtcbiAgfVxuICBub3RpZnkoZGVidWdJbmZvKSB7XG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBmb3IgKGxldCBoZWFkID0gdGhpcy5zdWJzSGVhZDsgaGVhZDsgaGVhZCA9IGhlYWQubmV4dFN1Yikge1xuICAgICAgICAgIGlmIChoZWFkLnN1Yi5vblRyaWdnZXIgJiYgIShoZWFkLnN1Yi5mbGFncyAmIDgpKSB7XG4gICAgICAgICAgICBoZWFkLnN1Yi5vblRyaWdnZXIoXG4gICAgICAgICAgICAgIGV4dGVuZChcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlZmZlY3Q6IGhlYWQuc3ViXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWJ1Z0luZm9cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGxpbmsgPSB0aGlzLnN1YnM7IGxpbms7IGxpbmsgPSBsaW5rLnByZXZTdWIpIHtcbiAgICAgICAgaWYgKGxpbmsuc3ViLm5vdGlmeSgpKSB7XG4gICAgICAgICAgO1xuICAgICAgICAgIGxpbmsuc3ViLmRlcC5ub3RpZnkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkU3ViKGxpbmspIHtcbiAgbGluay5kZXAuc2MrKztcbiAgaWYgKGxpbmsuc3ViLmZsYWdzICYgNCkge1xuICAgIGNvbnN0IGNvbXB1dGVkID0gbGluay5kZXAuY29tcHV0ZWQ7XG4gICAgaWYgKGNvbXB1dGVkICYmICFsaW5rLmRlcC5zdWJzKSB7XG4gICAgICBjb21wdXRlZC5mbGFncyB8PSA0IHwgMTY7XG4gICAgICBmb3IgKGxldCBsID0gY29tcHV0ZWQuZGVwczsgbDsgbCA9IGwubmV4dERlcCkge1xuICAgICAgICBhZGRTdWIobCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUYWlsID0gbGluay5kZXAuc3VicztcbiAgICBpZiAoY3VycmVudFRhaWwgIT09IGxpbmspIHtcbiAgICAgIGxpbmsucHJldlN1YiA9IGN1cnJlbnRUYWlsO1xuICAgICAgaWYgKGN1cnJlbnRUYWlsKSBjdXJyZW50VGFpbC5uZXh0U3ViID0gbGluaztcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbGluay5kZXAuc3Vic0hlYWQgPT09IHZvaWQgMCkge1xuICAgICAgbGluay5kZXAuc3Vic0hlYWQgPSBsaW5rO1xuICAgIH1cbiAgICBsaW5rLmRlcC5zdWJzID0gbGluaztcbiAgfVxufVxuY29uc3QgdGFyZ2V0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCBJVEVSQVRFX0tFWSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIk9iamVjdCBpdGVyYXRlXCIgOiBcIlwiXG4pO1xuY29uc3QgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIk1hcCBrZXlzIGl0ZXJhdGVcIiA6IFwiXCJcbik7XG5jb25zdCBBUlJBWV9JVEVSQVRFX0tFWSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXG4gICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBcIkFycmF5IGl0ZXJhdGVcIiA6IFwiXCJcbik7XG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xuICBpZiAoc2hvdWxkVHJhY2sgJiYgYWN0aXZlU3ViKSB7XG4gICAgbGV0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gICAgaWYgKCFkZXBzTWFwKSB7XG4gICAgICB0YXJnZXRNYXAuc2V0KHRhcmdldCwgZGVwc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBsZXQgZGVwID0gZGVwc01hcC5nZXQoa2V5KTtcbiAgICBpZiAoIWRlcCkge1xuICAgICAgZGVwc01hcC5zZXQoa2V5LCBkZXAgPSBuZXcgRGVwKCkpO1xuICAgICAgZGVwLm1hcCA9IGRlcHNNYXA7XG4gICAgICBkZXAua2V5ID0ga2V5O1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgZGVwLnRyYWNrKHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0eXBlLFxuICAgICAgICBrZXlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXAudHJhY2soKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0KSB7XG4gIGNvbnN0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gIGlmICghZGVwc01hcCkge1xuICAgIGdsb2JhbFZlcnNpb24rKztcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcnVuID0gKGRlcCkgPT4ge1xuICAgIGlmIChkZXApIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGRlcC50cmlnZ2VyKHtcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgb2xkVGFyZ2V0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVwLnRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0YXJ0QmF0Y2goKTtcbiAgaWYgKHR5cGUgPT09IFwiY2xlYXJcIikge1xuICAgIGRlcHNNYXAuZm9yRWFjaChydW4pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRhcmdldElzQXJyYXkgPSBpc0FycmF5KHRhcmdldCk7XG4gICAgY29uc3QgaXNBcnJheUluZGV4ID0gdGFyZ2V0SXNBcnJheSAmJiBpc0ludGVnZXJLZXkoa2V5KTtcbiAgICBpZiAodGFyZ2V0SXNBcnJheSAmJiBrZXkgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IE51bWJlcihuZXdWYWx1ZSk7XG4gICAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5MikgPT4ge1xuICAgICAgICBpZiAoa2V5MiA9PT0gXCJsZW5ndGhcIiB8fCBrZXkyID09PSBBUlJBWV9JVEVSQVRFX0tFWSB8fCAhaXNTeW1ib2woa2V5MikgJiYga2V5MiA+PSBuZXdMZW5ndGgpIHtcbiAgICAgICAgICBydW4oZGVwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChrZXkgIT09IHZvaWQgMCB8fCBkZXBzTWFwLmhhcyh2b2lkIDApKSB7XG4gICAgICAgIHJ1bihkZXBzTWFwLmdldChrZXkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5SW5kZXgpIHtcbiAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KEFSUkFZX0lURVJBVEVfS0VZKSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgIGlmICghdGFyZ2V0SXNBcnJheSkge1xuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUluZGV4KSB7XG4gICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoXCJsZW5ndGhcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgICAgIGlmICghdGFyZ2V0SXNBcnJheSkge1xuICAgICAgICAgICAgcnVuKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICBydW4oZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVuZEJhdGNoKCk7XG59XG5mdW5jdGlvbiBnZXREZXBGcm9tUmVhY3RpdmUob2JqZWN0LCBrZXkpIHtcbiAgY29uc3QgZGVwTWFwID0gdGFyZ2V0TWFwLmdldChvYmplY3QpO1xuICByZXR1cm4gZGVwTWFwICYmIGRlcE1hcC5nZXQoa2V5KTtcbn1cblxuZnVuY3Rpb24gcmVhY3RpdmVSZWFkQXJyYXkoYXJyYXkpIHtcbiAgY29uc3QgcmF3ID0gdG9SYXcoYXJyYXkpO1xuICBpZiAocmF3ID09PSBhcnJheSkgcmV0dXJuIHJhdztcbiAgdHJhY2socmF3LCBcIml0ZXJhdGVcIiwgQVJSQVlfSVRFUkFURV9LRVkpO1xuICByZXR1cm4gaXNTaGFsbG93KGFycmF5KSA/IHJhdyA6IHJhdy5tYXAodG9SZWFjdGl2ZSk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVhZEFycmF5KGFycikge1xuICB0cmFjayhhcnIgPSB0b1JhdyhhcnIpLCBcIml0ZXJhdGVcIiwgQVJSQVlfSVRFUkFURV9LRVkpO1xuICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gdG9XcmFwcGVkKHRhcmdldCwgaXRlbSkge1xuICBpZiAoaXNSZWFkb25seSh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIGlzUmVhY3RpdmUodGFyZ2V0KSA/IHRvUmVhZG9ubHkodG9SZWFjdGl2ZShpdGVtKSkgOiB0b1JlYWRvbmx5KGl0ZW0pO1xuICB9XG4gIHJldHVybiB0b1JlYWN0aXZlKGl0ZW0pO1xufVxuY29uc3QgYXJyYXlJbnN0cnVtZW50YXRpb25zID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBTeW1ib2wuaXRlcmF0b3IsIChpdGVtKSA9PiB0b1dyYXBwZWQodGhpcywgaXRlbSkpO1xuICB9LFxuICBjb25jYXQoLi4uYXJncykge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS5jb25jYXQoXG4gICAgICAuLi5hcmdzLm1hcCgoeCkgPT4gaXNBcnJheSh4KSA/IHJlYWN0aXZlUmVhZEFycmF5KHgpIDogeClcbiAgICApO1xuICB9LFxuICBlbnRyaWVzKCkge1xuICAgIHJldHVybiBpdGVyYXRvcih0aGlzLCBcImVudHJpZXNcIiwgKHZhbHVlKSA9PiB7XG4gICAgICB2YWx1ZVsxXSA9IHRvV3JhcHBlZCh0aGlzLCB2YWx1ZVsxXSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gIH0sXG4gIGV2ZXJ5KGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZXZlcnlcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgZmlsdGVyKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KFxuICAgICAgdGhpcyxcbiAgICAgIFwiZmlsdGVyXCIsXG4gICAgICBmbixcbiAgICAgIHRoaXNBcmcsXG4gICAgICAodikgPT4gdi5tYXAoKGl0ZW0pID0+IHRvV3JhcHBlZCh0aGlzLCBpdGVtKSksXG4gICAgICBhcmd1bWVudHNcbiAgICApO1xuICB9LFxuICBmaW5kKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KFxuICAgICAgdGhpcyxcbiAgICAgIFwiZmluZFwiLFxuICAgICAgZm4sXG4gICAgICB0aGlzQXJnLFxuICAgICAgKGl0ZW0pID0+IHRvV3JhcHBlZCh0aGlzLCBpdGVtKSxcbiAgICAgIGFyZ3VtZW50c1xuICAgICk7XG4gIH0sXG4gIGZpbmRJbmRleChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbmRJbmRleFwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBmaW5kTGFzdChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseShcbiAgICAgIHRoaXMsXG4gICAgICBcImZpbmRMYXN0XCIsXG4gICAgICBmbixcbiAgICAgIHRoaXNBcmcsXG4gICAgICAoaXRlbSkgPT4gdG9XcmFwcGVkKHRoaXMsIGl0ZW0pLFxuICAgICAgYXJndW1lbnRzXG4gICAgKTtcbiAgfSxcbiAgZmluZExhc3RJbmRleChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcImZpbmRMYXN0SW5kZXhcIiwgZm4sIHRoaXNBcmcsIHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfSxcbiAgLy8gZmxhdCwgZmxhdE1hcCBjb3VsZCBiZW5lZml0IGZyb20gQVJSQVlfSVRFUkFURSBidXQgYXJlIG5vdCBzdHJhaWdodC1mb3J3YXJkIHRvIGltcGxlbWVudFxuICBmb3JFYWNoKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwiZm9yRWFjaFwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBpbmNsdWRlcyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHNlYXJjaFByb3h5KHRoaXMsIFwiaW5jbHVkZXNcIiwgYXJncyk7XG4gIH0sXG4gIGluZGV4T2YoLi4uYXJncykge1xuICAgIHJldHVybiBzZWFyY2hQcm94eSh0aGlzLCBcImluZGV4T2ZcIiwgYXJncyk7XG4gIH0sXG4gIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLmpvaW4oc2VwYXJhdG9yKTtcbiAgfSxcbiAgLy8ga2V5cygpIGl0ZXJhdG9yIG9ubHkgcmVhZHMgYGxlbmd0aGAsIG5vIG9wdGltaXphdGlvbiByZXF1aXJlZFxuICBsYXN0SW5kZXhPZiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHNlYXJjaFByb3h5KHRoaXMsIFwibGFzdEluZGV4T2ZcIiwgYXJncyk7XG4gIH0sXG4gIG1hcChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBhcHBseSh0aGlzLCBcIm1hcFwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBwb3AoKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJwb3BcIik7XG4gIH0sXG4gIHB1c2goLi4uYXJncykge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwicHVzaFwiLCBhcmdzKTtcbiAgfSxcbiAgcmVkdWNlKGZuLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIHJlZHVjZSh0aGlzLCBcInJlZHVjZVwiLCBmbiwgYXJncyk7XG4gIH0sXG4gIHJlZHVjZVJpZ2h0KGZuLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIHJlZHVjZSh0aGlzLCBcInJlZHVjZVJpZ2h0XCIsIGZuLCBhcmdzKTtcbiAgfSxcbiAgc2hpZnQoKSB7XG4gICAgcmV0dXJuIG5vVHJhY2tpbmcodGhpcywgXCJzaGlmdFwiKTtcbiAgfSxcbiAgLy8gc2xpY2UgY291bGQgdXNlIEFSUkFZX0lURVJBVEUgYnV0IGFsc28gc2VlbXMgdG8gYmVnIGZvciByYW5nZSB0cmFja2luZ1xuICBzb21lKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGFwcGx5KHRoaXMsIFwic29tZVwiLCBmbiwgdGhpc0FyZywgdm9pZCAwLCBhcmd1bWVudHMpO1xuICB9LFxuICBzcGxpY2UoLi4uYXJncykge1xuICAgIHJldHVybiBub1RyYWNraW5nKHRoaXMsIFwic3BsaWNlXCIsIGFyZ3MpO1xuICB9LFxuICB0b1JldmVyc2VkKCkge1xuICAgIHJldHVybiByZWFjdGl2ZVJlYWRBcnJheSh0aGlzKS50b1JldmVyc2VkKCk7XG4gIH0sXG4gIHRvU29ydGVkKGNvbXBhcmVyKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlUmVhZEFycmF5KHRoaXMpLnRvU29ydGVkKGNvbXBhcmVyKTtcbiAgfSxcbiAgdG9TcGxpY2VkKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gcmVhY3RpdmVSZWFkQXJyYXkodGhpcykudG9TcGxpY2VkKC4uLmFyZ3MpO1xuICB9LFxuICB1bnNoaWZ0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbm9UcmFja2luZyh0aGlzLCBcInVuc2hpZnRcIiwgYXJncyk7XG4gIH0sXG4gIHZhbHVlcygpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgXCJ2YWx1ZXNcIiwgKGl0ZW0pID0+IHRvV3JhcHBlZCh0aGlzLCBpdGVtKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBpdGVyYXRvcihzZWxmLCBtZXRob2QsIHdyYXBWYWx1ZSkge1xuICBjb25zdCBhcnIgPSBzaGFsbG93UmVhZEFycmF5KHNlbGYpO1xuICBjb25zdCBpdGVyID0gYXJyW21ldGhvZF0oKTtcbiAgaWYgKGFyciAhPT0gc2VsZiAmJiAhaXNTaGFsbG93KHNlbGYpKSB7XG4gICAgaXRlci5fbmV4dCA9IGl0ZXIubmV4dDtcbiAgICBpdGVyLm5leHQgPSAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBpdGVyLl9uZXh0KCk7XG4gICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHdyYXBWYWx1ZShyZXN1bHQudmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIHJldHVybiBpdGVyO1xufVxuY29uc3QgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbmZ1bmN0aW9uIGFwcGx5KHNlbGYsIG1ldGhvZCwgZm4sIHRoaXNBcmcsIHdyYXBwZWRSZXRGbiwgYXJncykge1xuICBjb25zdCBhcnIgPSBzaGFsbG93UmVhZEFycmF5KHNlbGYpO1xuICBjb25zdCBuZWVkc1dyYXAgPSBhcnIgIT09IHNlbGYgJiYgIWlzU2hhbGxvdyhzZWxmKTtcbiAgY29uc3QgbWV0aG9kRm4gPSBhcnJbbWV0aG9kXTtcbiAgaWYgKG1ldGhvZEZuICE9PSBhcnJheVByb3RvW21ldGhvZF0pIHtcbiAgICBjb25zdCByZXN1bHQyID0gbWV0aG9kRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgcmV0dXJuIG5lZWRzV3JhcCA/IHRvUmVhY3RpdmUocmVzdWx0MikgOiByZXN1bHQyO1xuICB9XG4gIGxldCB3cmFwcGVkRm4gPSBmbjtcbiAgaWYgKGFyciAhPT0gc2VsZikge1xuICAgIGlmIChuZWVkc1dyYXApIHtcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHRvV3JhcHBlZChzZWxmLCBpdGVtKSwgaW5kZXgsIHNlbGYpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZuLmxlbmd0aCA+IDIpIHtcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGl0ZW0sIGluZGV4LCBzZWxmKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG1ldGhvZEZuLmNhbGwoYXJyLCB3cmFwcGVkRm4sIHRoaXNBcmcpO1xuICByZXR1cm4gbmVlZHNXcmFwICYmIHdyYXBwZWRSZXRGbiA/IHdyYXBwZWRSZXRGbihyZXN1bHQpIDogcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVkdWNlKHNlbGYsIG1ldGhvZCwgZm4sIGFyZ3MpIHtcbiAgY29uc3QgYXJyID0gc2hhbGxvd1JlYWRBcnJheShzZWxmKTtcbiAgbGV0IHdyYXBwZWRGbiA9IGZuO1xuICBpZiAoYXJyICE9PSBzZWxmKSB7XG4gICAgaWYgKCFpc1NoYWxsb3coc2VsZikpIHtcbiAgICAgIHdyYXBwZWRGbiA9IGZ1bmN0aW9uKGFjYywgaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgYWNjLCB0b1dyYXBwZWQoc2VsZiwgaXRlbSksIGluZGV4LCBzZWxmKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmbi5sZW5ndGggPiAzKSB7XG4gICAgICB3cmFwcGVkRm4gPSBmdW5jdGlvbihhY2MsIGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGFjYywgaXRlbSwgaW5kZXgsIHNlbGYpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyclttZXRob2RdKHdyYXBwZWRGbiwgLi4uYXJncyk7XG59XG5mdW5jdGlvbiBzZWFyY2hQcm94eShzZWxmLCBtZXRob2QsIGFyZ3MpIHtcbiAgY29uc3QgYXJyID0gdG9SYXcoc2VsZik7XG4gIHRyYWNrKGFyciwgXCJpdGVyYXRlXCIsIEFSUkFZX0lURVJBVEVfS0VZKTtcbiAgY29uc3QgcmVzID0gYXJyW21ldGhvZF0oLi4uYXJncyk7XG4gIGlmICgocmVzID09PSAtMSB8fCByZXMgPT09IGZhbHNlKSAmJiBpc1Byb3h5KGFyZ3NbMF0pKSB7XG4gICAgYXJnc1swXSA9IHRvUmF3KGFyZ3NbMF0pO1xuICAgIHJldHVybiBhcnJbbWV0aG9kXSguLi5hcmdzKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gbm9UcmFja2luZyhzZWxmLCBtZXRob2QsIGFyZ3MgPSBbXSkge1xuICBwYXVzZVRyYWNraW5nKCk7XG4gIHN0YXJ0QmF0Y2goKTtcbiAgY29uc3QgcmVzID0gdG9SYXcoc2VsZilbbWV0aG9kXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgZW5kQmF0Y2goKTtcbiAgcmVzZXRUcmFja2luZygpO1xuICByZXR1cm4gcmVzO1xufVxuXG5jb25zdCBpc05vblRyYWNrYWJsZUtleXMgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChgX19wcm90b19fLF9fdl9pc1JlZixfX2lzVnVlYCk7XG5jb25zdCBidWlsdEluU3ltYm9scyA9IG5ldyBTZXQoXG4gIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhTeW1ib2wpLmZpbHRlcigoa2V5KSA9PiBrZXkgIT09IFwiYXJndW1lbnRzXCIgJiYga2V5ICE9PSBcImNhbGxlclwiKS5tYXAoKGtleSkgPT4gU3ltYm9sW2tleV0pLmZpbHRlcihpc1N5bWJvbClcbik7XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShrZXkpIHtcbiAgaWYgKCFpc1N5bWJvbChrZXkpKSBrZXkgPSBTdHJpbmcoa2V5KTtcbiAgY29uc3Qgb2JqID0gdG9SYXcodGhpcyk7XG4gIHRyYWNrKG9iaiwgXCJoYXNcIiwga2V5KTtcbiAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpO1xufVxuY2xhc3MgQmFzZVJlYWN0aXZlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKF9pc1JlYWRvbmx5ID0gZmFsc2UsIF9pc1NoYWxsb3cgPSBmYWxzZSkge1xuICAgIHRoaXMuX2lzUmVhZG9ubHkgPSBfaXNSZWFkb25seTtcbiAgICB0aGlzLl9pc1NoYWxsb3cgPSBfaXNTaGFsbG93O1xuICB9XG4gIGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9za2lwXCIpIHJldHVybiB0YXJnZXRbXCJfX3Zfc2tpcFwiXTtcbiAgICBjb25zdCBpc1JlYWRvbmx5MiA9IHRoaXMuX2lzUmVhZG9ubHksIGlzU2hhbGxvdzIgPSB0aGlzLl9pc1NoYWxsb3c7XG4gICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiKSB7XG4gICAgICByZXR1cm4gIWlzUmVhZG9ubHkyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNTaGFsbG93XCIpIHtcbiAgICAgIHJldHVybiBpc1NoYWxsb3cyO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIikge1xuICAgICAgaWYgKHJlY2VpdmVyID09PSAoaXNSZWFkb25seTIgPyBpc1NoYWxsb3cyID8gc2hhbGxvd1JlYWRvbmx5TWFwIDogcmVhZG9ubHlNYXAgOiBpc1NoYWxsb3cyID8gc2hhbGxvd1JlYWN0aXZlTWFwIDogcmVhY3RpdmVNYXApLmdldCh0YXJnZXQpIHx8IC8vIHJlY2VpdmVyIGlzIG5vdCB0aGUgcmVhY3RpdmUgcHJveHksIGJ1dCBoYXMgdGhlIHNhbWUgcHJvdG90eXBlXG4gICAgICAvLyB0aGlzIG1lYW5zIHRoZSByZWNlaXZlciBpcyBhIHVzZXIgcHJveHkgb2YgdGhlIHJlYWN0aXZlIHByb3h5XG4gICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHJlY2VpdmVyKSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xuICAgIGlmICghaXNSZWFkb25seTIpIHtcbiAgICAgIGxldCBmbjtcbiAgICAgIGlmICh0YXJnZXRJc0FycmF5ICYmIChmbiA9IGFycmF5SW5zdHJ1bWVudGF0aW9uc1trZXldKSkge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBcImhhc093blByb3BlcnR5XCIpIHtcbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSBSZWZsZWN0LmdldChcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleSxcbiAgICAgIC8vIGlmIHRoaXMgaXMgYSBwcm94eSB3cmFwcGluZyBhIHJlZiwgcmV0dXJuIG1ldGhvZHMgdXNpbmcgdGhlIHJhdyByZWZcbiAgICAgIC8vIGFzIHJlY2VpdmVyIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBjYWxsIGB0b1Jhd2Agb24gdGhlIHJlZiBpbiBhbGxcbiAgICAgIC8vIGl0cyBjbGFzcyBtZXRob2RzXG4gICAgICBpc1JlZih0YXJnZXQpID8gdGFyZ2V0IDogcmVjZWl2ZXJcbiAgICApO1xuICAgIGlmIChpc1N5bWJvbChrZXkpID8gYnVpbHRJblN5bWJvbHMuaGFzKGtleSkgOiBpc05vblRyYWNrYWJsZUtleXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKCFpc1JlYWRvbmx5Mikge1xuICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgIH1cbiAgICBpZiAoaXNTaGFsbG93Mikge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKGlzUmVmKHJlcykpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGFyZ2V0SXNBcnJheSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IHJlcyA6IHJlcy52YWx1ZTtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5MiAmJiBpc09iamVjdCh2YWx1ZSkgPyByZWFkb25seSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIHJldHVybiBpc1JlYWRvbmx5MiA/IHJlYWRvbmx5KHJlcykgOiByZWFjdGl2ZShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59XG5jbGFzcyBNdXRhYmxlUmVhY3RpdmVIYW5kbGVyIGV4dGVuZHMgQmFzZVJlYWN0aXZlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGlzU2hhbGxvdzIgPSBmYWxzZSkge1xuICAgIHN1cGVyKGZhbHNlLCBpc1NoYWxsb3cyKTtcbiAgfVxuICBzZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xuICAgIGxldCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGNvbnN0IGlzQXJyYXlXaXRoSW50ZWdlcktleSA9IGlzQXJyYXkodGFyZ2V0KSAmJiBpc0ludGVnZXJLZXkoa2V5KTtcbiAgICBpZiAoIXRoaXMuX2lzU2hhbGxvdykge1xuICAgICAgY29uc3QgaXNPbGRWYWx1ZVJlYWRvbmx5ID0gaXNSZWFkb25seShvbGRWYWx1ZSk7XG4gICAgICBpZiAoIWlzU2hhbGxvdyh2YWx1ZSkgJiYgIWlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgICAgIG9sZFZhbHVlID0gdG9SYXcob2xkVmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheVdpdGhJbnRlZ2VyS2V5ICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICAgIGlmIChpc09sZFZhbHVlUmVhZG9ubHkpIHtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgICAgICAgICB0YXJnZXRba2V5XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoYWRLZXkgPSBpc0FycmF5V2l0aEludGVnZXJLZXkgPyBOdW1iZXIoa2V5KSA8IHRhcmdldC5sZW5ndGggOiBoYXNPd24odGFyZ2V0LCBrZXkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3Quc2V0KFxuICAgICAgdGFyZ2V0LFxuICAgICAga2V5LFxuICAgICAgdmFsdWUsXG4gICAgICBpc1JlZih0YXJnZXQpID8gdGFyZ2V0IDogcmVjZWl2ZXJcbiAgICApO1xuICAgIGlmICh0YXJnZXQgPT09IHRvUmF3KHJlY2VpdmVyKSkge1xuICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIsIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IGhhZEtleSA9IGhhc093bih0YXJnZXQsIGtleSk7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KTtcbiAgICBpZiAocmVzdWx0ICYmIGhhZEtleSkge1xuICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIsIGtleSwgdm9pZCAwLCBvbGRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaGFzKHRhcmdldCwga2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5oYXModGFyZ2V0LCBrZXkpO1xuICAgIGlmICghaXNTeW1ib2woa2V5KSB8fCAhYnVpbHRJblN5bWJvbHMuaGFzKGtleSkpIHtcbiAgICAgIHRyYWNrKHRhcmdldCwgXCJoYXNcIiwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBvd25LZXlzKHRhcmdldCkge1xuICAgIHRyYWNrKFxuICAgICAgdGFyZ2V0LFxuICAgICAgXCJpdGVyYXRlXCIsXG4gICAgICBpc0FycmF5KHRhcmdldCkgPyBcImxlbmd0aFwiIDogSVRFUkFURV9LRVlcbiAgICApO1xuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgfVxufVxuY2xhc3MgUmVhZG9ubHlSZWFjdGl2ZUhhbmRsZXIgZXh0ZW5kcyBCYXNlUmVhY3RpdmVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoaXNTaGFsbG93MiA9IGZhbHNlKSB7XG4gICAgc3VwZXIodHJ1ZSwgaXNTaGFsbG93Mik7XG4gIH1cbiAgc2V0KHRhcmdldCwga2V5KSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBTZXQgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRGVsZXRlIG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsXG4gICAgICAgIHRhcmdldFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNvbnN0IG11dGFibGVIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTXV0YWJsZVJlYWN0aXZlSGFuZGxlcigpO1xuY29uc3QgcmVhZG9ubHlIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVhZG9ubHlSZWFjdGl2ZUhhbmRsZXIoKTtcbmNvbnN0IHNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNdXRhYmxlUmVhY3RpdmVIYW5kbGVyKHRydWUpO1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlYWRvbmx5UmVhY3RpdmVIYW5kbGVyKHRydWUpO1xuXG5jb25zdCB0b1NoYWxsb3cgPSAodmFsdWUpID0+IHZhbHVlO1xuY29uc3QgZ2V0UHJvdG8gPSAodikgPT4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih2KTtcbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seTIsIGlzU2hhbGxvdzIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgIGNvbnN0IHRhcmdldElzTWFwID0gaXNNYXAocmF3VGFyZ2V0KTtcbiAgICBjb25zdCBpc1BhaXIgPSBtZXRob2QgPT09IFwiZW50cmllc1wiIHx8IG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwO1xuICAgIGNvbnN0IGlzS2V5T25seSA9IG1ldGhvZCA9PT0gXCJrZXlzXCIgJiYgdGFyZ2V0SXNNYXA7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRhcmdldFttZXRob2RdKC4uLmFyZ3MpO1xuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cyID8gdG9TaGFsbG93IDogaXNSZWFkb25seTIgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAhaXNSZWFkb25seTIgJiYgdHJhY2soXG4gICAgICByYXdUYXJnZXQsXG4gICAgICBcIml0ZXJhdGVcIixcbiAgICAgIGlzS2V5T25seSA/IE1BUF9LRVlfSVRFUkFURV9LRVkgOiBJVEVSQVRFX0tFWVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGl0ZXJhdG9yIHByb3RvY29sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGRvbmUgPyB7IHZhbHVlLCBkb25lIH0gOiB7XG4gICAgICAgICAgdmFsdWU6IGlzUGFpciA/IFt3cmFwKHZhbHVlWzBdKSwgd3JhcCh2YWx1ZVsxXSldIDogd3JhcCh2YWx1ZSksXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIC8vIGl0ZXJhYmxlIHByb3RvY29sXG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5TWV0aG9kKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xuICAgICAgd2FybihcbiAgICAgICAgYCR7Y2FwaXRhbGl6ZSh0eXBlKX0gb3BlcmF0aW9uICR7a2V5fWZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsXG4gICAgICAgIHRvUmF3KHRoaXMpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZSA9PT0gXCJkZWxldGVcIiA/IGZhbHNlIDogdHlwZSA9PT0gXCJjbGVhclwiID8gdm9pZCAwIDogdGhpcztcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMocmVhZG9ubHksIHNoYWxsb3cpIHtcbiAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgaWYgKCFyZWFkb25seSkge1xuICAgICAgICBpZiAoaGFzQ2hhbmdlZChrZXksIHJhd0tleSkpIHtcbiAgICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCByYXdLZXkpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBoYXMgfSA9IGdldFByb3RvKHJhd1RhcmdldCk7XG4gICAgICBjb25zdCB3cmFwID0gc2hhbGxvdyA/IHRvU2hhbGxvdyA6IHJlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgICBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwgcmF3S2V5KSkge1xuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KHJhd0tleSkpO1xuICAgICAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xuICAgICAgICB0YXJnZXQuZ2V0KGtleSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCJdO1xuICAgICAgIXJlYWRvbmx5ICYmIHRyYWNrKHRvUmF3KHRhcmdldCksIFwiaXRlcmF0ZVwiLCBJVEVSQVRFX0tFWSk7XG4gICAgICByZXR1cm4gdGFyZ2V0LnNpemU7XG4gICAgfSxcbiAgICBoYXMoa2V5KSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgaWYgKCFyZWFkb25seSkge1xuICAgICAgICBpZiAoaGFzQ2hhbmdlZChrZXksIHJhd0tleSkpIHtcbiAgICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiLCByYXdLZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleSA9PT0gcmF3S2V5ID8gdGFyZ2V0LmhhcyhrZXkpIDogdGFyZ2V0LmhhcyhrZXkpIHx8IHRhcmdldC5oYXMocmF3S2V5KTtcbiAgICB9LFxuICAgIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcztcbiAgICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiXTtcbiAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgICBjb25zdCB3cmFwID0gc2hhbGxvdyA/IHRvU2hhbGxvdyA6IHJlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgICAhcmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICAgICAgcmV0dXJuIHRhcmdldC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHdyYXAodmFsdWUpLCB3cmFwKGtleSksIG9ic2VydmVkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZXh0ZW5kKFxuICAgIGluc3RydW1lbnRhdGlvbnMsXG4gICAgcmVhZG9ubHkgPyB7XG4gICAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIpLFxuICAgICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiKSxcbiAgICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiksXG4gICAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiKVxuICAgIH0gOiB7XG4gICAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgaWYgKCFzaGFsbG93ICYmICFpc1NoYWxsb3codmFsdWUpICYmICFpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICAgICAgICBjb25zdCBwcm90byA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGhhZEtleSA9IHByb3RvLmhhcy5jYWxsKHRhcmdldCwgdmFsdWUpO1xuICAgICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICAgIHRhcmdldC5hZGQodmFsdWUpO1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCB2YWx1ZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghc2hhbGxvdyAmJiAhaXNTaGFsbG93KHZhbHVlKSAmJiAhaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICAgICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgICAgIHRhcmdldC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICAgICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQgPyBnZXQuY2FsbCh0YXJnZXQsIGtleSkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcbiAgICAgICAgaWYgKGhhZEtleSkge1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiLCBrZXksIHZvaWQgMCwgb2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgY2xlYXIoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICAgICAgICBjb25zdCBoYWRJdGVtcyA9IHRhcmdldC5zaXplICE9PSAwO1xuICAgICAgICBjb25zdCBvbGRUYXJnZXQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gaXNNYXAodGFyZ2V0KSA/IG5ldyBNYXAodGFyZ2V0KSA6IG5ldyBTZXQodGFyZ2V0KSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmNsZWFyKCk7XG4gICAgICAgIGlmIChoYWRJdGVtcykge1xuICAgICAgICAgIHRyaWdnZXIoXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBcImNsZWFyXCIsXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICBvbGRUYXJnZXRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICApO1xuICBjb25zdCBpdGVyYXRvck1ldGhvZHMgPSBbXG4gICAgXCJrZXlzXCIsXG4gICAgXCJ2YWx1ZXNcIixcbiAgICBcImVudHJpZXNcIixcbiAgICBTeW1ib2wuaXRlcmF0b3JcbiAgXTtcbiAgaXRlcmF0b3JNZXRob2RzLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICAgIGluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgcmVhZG9ubHksIHNoYWxsb3cpO1xuICB9KTtcbiAgcmV0dXJuIGluc3RydW1lbnRhdGlvbnM7XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoaXNSZWFkb25seTIsIHNoYWxsb3cpIHtcbiAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoaXNSZWFkb25seTIsIHNoYWxsb3cpO1xuICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xuICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIikge1xuICAgICAgcmV0dXJuICFpc1JlYWRvbmx5MjtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTI7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdC5nZXQoXG4gICAgICBoYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0ID8gaW5zdHJ1bWVudGF0aW9ucyA6IHRhcmdldCxcbiAgICAgIGtleSxcbiAgICAgIHJlY2VpdmVyXG4gICAgKTtcbiAgfTtcbn1cbmNvbnN0IG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXG59O1xuY29uc3Qgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCB0cnVlKVxufTtcbmNvbnN0IHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXG59O1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgdHJ1ZSlcbn07XG5mdW5jdGlvbiBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KSB7XG4gIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gIGlmIChyYXdLZXkgIT09IGtleSAmJiBoYXMuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcbiAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHRhcmdldCk7XG4gICAgd2FybihcbiAgICAgIGBSZWFjdGl2ZSAke3R5cGV9IGNvbnRhaW5zIGJvdGggdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgdGhlIHNhbWUgb2JqZWN0JHt0eXBlID09PSBgTWFwYCA/IGAgYXMga2V5c2AgOiBgYH0sIHdoaWNoIGNhbiBsZWFkIHRvIGluY29uc2lzdGVuY2llcy4gQXZvaWQgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgYW4gb2JqZWN0IGFuZCBvbmx5IHVzZSB0aGUgcmVhY3RpdmUgdmVyc2lvbiBpZiBwb3NzaWJsZS5gXG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCByZWFjdGl2ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZWFkb25seU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcbiAgc3dpdGNoIChyYXdUeXBlKSB7XG4gICAgY2FzZSBcIk9iamVjdFwiOlxuICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgcmV0dXJuIDEgLyogQ09NTU9OICovO1xuICAgIGNhc2UgXCJNYXBcIjpcbiAgICBjYXNlIFwiU2V0XCI6XG4gICAgY2FzZSBcIldlYWtNYXBcIjpcbiAgICBjYXNlIFwiV2Vha1NldFwiOlxuICAgICAgcmV0dXJuIDIgLyogQ09MTEVDVElPTiAqLztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDAgLyogSU5WQUxJRCAqLztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVbXCJfX3Zfc2tpcFwiXSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgPyAwIC8qIElOVkFMSUQgKi8gOiB0YXJnZXRUeXBlTWFwKHRvUmF3VHlwZSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XG4gIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgZmFsc2UsXG4gICAgbXV0YWJsZUhhbmRsZXJzLFxuICAgIG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgcmVhY3RpdmVNYXBcbiAgKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KFxuICAgIHRhcmdldCxcbiAgICBmYWxzZSxcbiAgICBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyxcbiAgICBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHNoYWxsb3dSZWFjdGl2ZU1hcFxuICApO1xufVxuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgdHJ1ZSxcbiAgICByZWFkb25seUhhbmRsZXJzLFxuICAgIHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLFxuICAgIHJlYWRvbmx5TWFwXG4gICk7XG59XG5mdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XG4gIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdChcbiAgICB0YXJnZXQsXG4gICAgdHJ1ZSxcbiAgICBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyxcbiAgICBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsXG4gICAgc2hhbGxvd1JlYWRvbmx5TWFwXG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHkyLCBiYXNlSGFuZGxlcnMsIGNvbGxlY3Rpb25IYW5kbGVycywgcHJveHlNYXApIHtcbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSAke2lzUmVhZG9ubHkyID8gXCJyZWFkb25seVwiIDogXCJyZWFjdGl2ZVwifTogJHtTdHJpbmcoXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAodGFyZ2V0W1wiX192X3Jhd1wiXSAmJiAhKGlzUmVhZG9ubHkyICYmIHRhcmdldFtcIl9fdl9pc1JlYWN0aXZlXCJdKSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcbiAgaWYgKHRhcmdldFR5cGUgPT09IDAgLyogSU5WQUxJRCAqLykge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xuICBpZiAoZXhpc3RpbmdQcm94eSkge1xuICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xuICB9XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KFxuICAgIHRhcmdldCxcbiAgICB0YXJnZXRUeXBlID09PSAyIC8qIENPTExFQ1RJT04gKi8gPyBjb2xsZWN0aW9uSGFuZGxlcnMgOiBiYXNlSGFuZGxlcnNcbiAgKTtcbiAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xuICByZXR1cm4gcHJveHk7XG59XG5mdW5jdGlvbiBpc1JlYWN0aXZlKHZhbHVlKSB7XG4gIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiXSk7XG4gIH1cbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIl0pO1xufVxuZnVuY3Rpb24gaXNSZWFkb25seSh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFkb25seVwiXSk7XG59XG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzU2hhbGxvd1wiXSk7XG59XG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/ICEhdmFsdWVbXCJfX3ZfcmF3XCJdIDogZmFsc2U7XG59XG5mdW5jdGlvbiB0b1JhdyhvYnNlcnZlZCkge1xuICBjb25zdCByYXcgPSBvYnNlcnZlZCAmJiBvYnNlcnZlZFtcIl9fdl9yYXdcIl07XG4gIHJldHVybiByYXcgPyB0b1JhdyhyYXcpIDogb2JzZXJ2ZWQ7XG59XG5mdW5jdGlvbiBtYXJrUmF3KHZhbHVlKSB7XG4gIGlmICghaGFzT3duKHZhbHVlLCBcIl9fdl9za2lwXCIpICYmIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpKSB7XG4gICAgZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIsIHRydWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWN0aXZlKHZhbHVlKSA6IHZhbHVlO1xuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XG5cbmZ1bmN0aW9uIGlzUmVmKHIpIHtcbiAgcmV0dXJuIHIgPyByW1wiX192X2lzUmVmXCJdID09PSB0cnVlIDogZmFsc2U7XG59XG5mdW5jdGlvbiByZWYodmFsdWUpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gc2hhbGxvd1JlZih2YWx1ZSkge1xuICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdykge1xuICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XG4gICAgcmV0dXJuIHJhd1ZhbHVlO1xuICB9XG4gIHJldHVybiBuZXcgUmVmSW1wbChyYXdWYWx1ZSwgc2hhbGxvdyk7XG59XG5jbGFzcyBSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIGlzU2hhbGxvdzIpIHtcbiAgICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgICB0aGlzW1wiX192X2lzUmVmXCJdID0gdHJ1ZTtcbiAgICB0aGlzW1wiX192X2lzU2hhbGxvd1wiXSA9IGZhbHNlO1xuICAgIHRoaXMuX3Jhd1ZhbHVlID0gaXNTaGFsbG93MiA/IHZhbHVlIDogdG9SYXcodmFsdWUpO1xuICAgIHRoaXMuX3ZhbHVlID0gaXNTaGFsbG93MiA/IHZhbHVlIDogdG9SZWFjdGl2ZSh2YWx1ZSk7XG4gICAgdGhpc1tcIl9fdl9pc1NoYWxsb3dcIl0gPSBpc1NoYWxsb3cyO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgdGhpcy5kZXAudHJhY2soe1xuICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiZ2V0XCIsXG4gICAgICAgIGtleTogXCJ2YWx1ZVwiXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXAudHJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fcmF3VmFsdWU7XG4gICAgY29uc3QgdXNlRGlyZWN0VmFsdWUgPSB0aGlzW1wiX192X2lzU2hhbGxvd1wiXSB8fCBpc1NoYWxsb3cobmV3VmFsdWUpIHx8IGlzUmVhZG9ubHkobmV3VmFsdWUpO1xuICAgIG5ld1ZhbHVlID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWx1ZSA6IHRvUmF3KG5ld1ZhbHVlKTtcbiAgICBpZiAoaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICB0aGlzLl9yYXdWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy5fdmFsdWUgPSB1c2VEaXJlY3RWYWx1ZSA/IG5ld1ZhbHVlIDogdG9SZWFjdGl2ZShuZXdWYWx1ZSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB0aGlzLmRlcC50cmlnZ2VyKHtcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICBrZXk6IFwidmFsdWVcIixcbiAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICBvbGRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVwLnRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmMikge1xuICBpZiAocmVmMi5kZXApIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgcmVmMi5kZXAudHJpZ2dlcih7XG4gICAgICAgIHRhcmdldDogcmVmMixcbiAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAga2V5OiBcInZhbHVlXCIsXG4gICAgICAgIG5ld1ZhbHVlOiByZWYyLl92YWx1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZjIuZGVwLnRyaWdnZXIoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVucmVmKHJlZjIpIHtcbiAgcmV0dXJuIGlzUmVmKHJlZjIpID8gcmVmMi52YWx1ZSA6IHJlZjI7XG59XG5mdW5jdGlvbiB0b1ZhbHVlKHNvdXJjZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbihzb3VyY2UpID8gc291cmNlKCkgOiB1bnJlZihzb3VyY2UpO1xufVxuY29uc3Qgc2hhbGxvd1Vud3JhcEhhbmRsZXJzID0ge1xuICBnZXQ6ICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IGtleSA9PT0gXCJfX3ZfcmF3XCIgPyB0YXJnZXQgOiB1bnJlZihSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKSxcbiAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikgPT4ge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBwcm94eVJlZnMob2JqZWN0V2l0aFJlZnMpIHtcbiAgcmV0dXJuIGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpID8gb2JqZWN0V2l0aFJlZnMgOiBuZXcgUHJveHkob2JqZWN0V2l0aFJlZnMsIHNoYWxsb3dVbndyYXBIYW5kbGVycyk7XG59XG5jbGFzcyBDdXN0b21SZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoZmFjdG9yeSkge1xuICAgIHRoaXNbXCJfX3ZfaXNSZWZcIl0gPSB0cnVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICAgIGNvbnN0IGRlcCA9IHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IGZhY3RvcnkoZGVwLnRyYWNrLmJpbmQoZGVwKSwgZGVwLnRyaWdnZXIuYmluZChkZXApKTtcbiAgICB0aGlzLl9nZXQgPSBnZXQ7XG4gICAgdGhpcy5fc2V0ID0gc2V0O1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB0aGlzLl9nZXQoKTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgdGhpcy5fc2V0KG5ld1ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XG4gIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcbn1cbmZ1bmN0aW9uIHRvUmVmcyhvYmplY3QpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzUHJveHkob2JqZWN0KSkge1xuICAgIHdhcm4oYHRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLmApO1xuICB9XG4gIGNvbnN0IHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICByZXRba2V5XSA9IHByb3BlcnR5VG9SZWYob2JqZWN0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5jbGFzcyBPYmplY3RSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoX29iamVjdCwgX2tleSwgX2RlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XG4gICAgdGhpcy5fa2V5ID0gX2tleTtcbiAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBfZGVmYXVsdFZhbHVlO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWZcIl0gPSB0cnVlO1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICAgIHRoaXMuX3JhdyA9IHRvUmF3KF9vYmplY3QpO1xuICAgIGxldCBzaGFsbG93ID0gdHJ1ZTtcbiAgICBsZXQgb2JqID0gX29iamVjdDtcbiAgICBpZiAoIWlzQXJyYXkoX29iamVjdCkgfHwgIWlzSW50ZWdlcktleShTdHJpbmcoX2tleSkpKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHNoYWxsb3cgPSAhaXNQcm94eShvYmopIHx8IGlzU2hhbGxvdyhvYmopO1xuICAgICAgfSB3aGlsZSAoc2hhbGxvdyAmJiAob2JqID0gb2JqW1wiX192X3Jhd1wiXSkpO1xuICAgIH1cbiAgICB0aGlzLl9zaGFsbG93ID0gc2hhbGxvdztcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgbGV0IHZhbCA9IHRoaXMuX29iamVjdFt0aGlzLl9rZXldO1xuICAgIGlmICh0aGlzLl9zaGFsbG93KSB7XG4gICAgICB2YWwgPSB1bnJlZih2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPSB2YWwgPT09IHZvaWQgMCA/IHRoaXMuX2RlZmF1bHRWYWx1ZSA6IHZhbDtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgaWYgKHRoaXMuX3NoYWxsb3cgJiYgaXNSZWYodGhpcy5fcmF3W3RoaXMuX2tleV0pKSB7XG4gICAgICBjb25zdCBuZXN0ZWRSZWYgPSB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XTtcbiAgICAgIGlmIChpc1JlZihuZXN0ZWRSZWYpKSB7XG4gICAgICAgIG5lc3RlZFJlZi52YWx1ZSA9IG5ld1ZhbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XSA9IG5ld1ZhbDtcbiAgfVxuICBnZXQgZGVwKCkge1xuICAgIHJldHVybiBnZXREZXBGcm9tUmVhY3RpdmUodGhpcy5fcmF3LCB0aGlzLl9rZXkpO1xuICB9XG59XG5jbGFzcyBHZXR0ZXJSZWZJbXBsIHtcbiAgY29uc3RydWN0b3IoX2dldHRlcikge1xuICAgIHRoaXMuX2dldHRlciA9IF9nZXR0ZXI7XG4gICAgdGhpc1tcIl9fdl9pc1JlZlwiXSA9IHRydWU7XG4gICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCJdID0gdHJ1ZTtcbiAgICB0aGlzLl92YWx1ZSA9IHZvaWQgMDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID0gdGhpcy5fZ2V0dGVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvUmVmKHNvdXJjZSwga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgIHJldHVybiBuZXcgR2V0dGVyUmVmSW1wbChzb3VyY2UpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gcHJvcGVydHlUb1JlZihzb3VyY2UsIGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVmKHNvdXJjZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BlcnR5VG9SZWYoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gbmV3IE9iamVjdFJlZkltcGwoc291cmNlLCBrZXksIGRlZmF1bHRWYWx1ZSk7XG59XG5cbmNsYXNzIENvbXB1dGVkUmVmSW1wbCB7XG4gIGNvbnN0cnVjdG9yKGZuLCBzZXR0ZXIsIGlzU1NSKSB7XG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIHRoaXMuc2V0dGVyID0gc2V0dGVyO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX3ZhbHVlID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuZGVwID0gbmV3IERlcCh0aGlzKTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgLy8gVE9ETyBpc29sYXRlZERlY2xhcmF0aW9ucyBcIl9fdl9pc1JlYWRvbmx5XCJcbiAgICAvLyBBIGNvbXB1dGVkIGlzIGFsc28gYSBzdWJzY3JpYmVyIHRoYXQgdHJhY2tzIG90aGVyIGRlcHNcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmRlcHMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5kZXBzVGFpbCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLmZsYWdzID0gMTY7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5nbG9iYWxWZXJzaW9uID0gZ2xvYmFsVmVyc2lvbiAtIDE7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gdm9pZCAwO1xuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgdGhpcy5lZmZlY3QgPSB0aGlzO1xuICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiXSA9ICFzZXR0ZXI7XG4gICAgdGhpcy5pc1NTUiA9IGlzU1NSO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5vdGlmeSgpIHtcbiAgICB0aGlzLmZsYWdzIHw9IDE2O1xuICAgIGlmICghKHRoaXMuZmxhZ3MgJiA4KSAmJiAvLyBhdm9pZCBpbmZpbml0ZSBzZWxmIHJlY3Vyc2lvblxuICAgIGFjdGl2ZVN1YiAhPT0gdGhpcykge1xuICAgICAgYmF0Y2godGhpcywgdHJ1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIDtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgY29uc3QgbGluayA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB0aGlzLmRlcC50cmFjayh7XG4gICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICB0eXBlOiBcImdldFwiLFxuICAgICAga2V5OiBcInZhbHVlXCJcbiAgICB9KSA6IHRoaXMuZGVwLnRyYWNrKCk7XG4gICAgcmVmcmVzaENvbXB1dGVkKHRoaXMpO1xuICAgIGlmIChsaW5rKSB7XG4gICAgICBsaW5rLnZlcnNpb24gPSB0aGlzLmRlcC52ZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cbiAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc2V0dGVyKSB7XG4gICAgICB0aGlzLnNldHRlcihuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuKFwiV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgdmFsdWUgaXMgcmVhZG9ubHlcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucywgaXNTU1IgPSBmYWxzZSkge1xuICBsZXQgZ2V0dGVyO1xuICBsZXQgc2V0dGVyO1xuICBpZiAoaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpKSB7XG4gICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zO1xuICB9IGVsc2Uge1xuICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucy5nZXQ7XG4gICAgc2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLnNldDtcbiAgfVxuICBjb25zdCBjUmVmID0gbmV3IENvbXB1dGVkUmVmSW1wbChnZXR0ZXIsIHNldHRlciwgaXNTU1IpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBkZWJ1Z09wdGlvbnMgJiYgIWlzU1NSKSB7XG4gICAgY1JlZi5vblRyYWNrID0gZGVidWdPcHRpb25zLm9uVHJhY2s7XG4gICAgY1JlZi5vblRyaWdnZXIgPSBkZWJ1Z09wdGlvbnMub25UcmlnZ2VyO1xuICB9XG4gIHJldHVybiBjUmVmO1xufVxuXG5jb25zdCBUcmFja09wVHlwZXMgPSB7XG4gIFwiR0VUXCI6IFwiZ2V0XCIsXG4gIFwiSEFTXCI6IFwiaGFzXCIsXG4gIFwiSVRFUkFURVwiOiBcIml0ZXJhdGVcIlxufTtcbmNvbnN0IFRyaWdnZXJPcFR5cGVzID0ge1xuICBcIlNFVFwiOiBcInNldFwiLFxuICBcIkFERFwiOiBcImFkZFwiLFxuICBcIkRFTEVURVwiOiBcImRlbGV0ZVwiLFxuICBcIkNMRUFSXCI6IFwiY2xlYXJcIlxufTtcbmNvbnN0IFJlYWN0aXZlRmxhZ3MgPSB7XG4gIFwiU0tJUFwiOiBcIl9fdl9za2lwXCIsXG4gIFwiSVNfUkVBQ1RJVkVcIjogXCJfX3ZfaXNSZWFjdGl2ZVwiLFxuICBcIklTX1JFQURPTkxZXCI6IFwiX192X2lzUmVhZG9ubHlcIixcbiAgXCJJU19TSEFMTE9XXCI6IFwiX192X2lzU2hhbGxvd1wiLFxuICBcIlJBV1wiOiBcIl9fdl9yYXdcIixcbiAgXCJJU19SRUZcIjogXCJfX3ZfaXNSZWZcIlxufTtcblxuY29uc3QgV2F0Y2hFcnJvckNvZGVzID0ge1xuICBcIldBVENIX0dFVFRFUlwiOiAyLFxuICBcIjJcIjogXCJXQVRDSF9HRVRURVJcIixcbiAgXCJXQVRDSF9DQUxMQkFDS1wiOiAzLFxuICBcIjNcIjogXCJXQVRDSF9DQUxMQkFDS1wiLFxuICBcIldBVENIX0NMRUFOVVBcIjogNCxcbiAgXCI0XCI6IFwiV0FUQ0hfQ0xFQU5VUFwiXG59O1xuY29uc3QgSU5JVElBTF9XQVRDSEVSX1ZBTFVFID0ge307XG5jb25zdCBjbGVhbnVwTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5sZXQgYWN0aXZlV2F0Y2hlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIGdldEN1cnJlbnRXYXRjaGVyKCkge1xuICByZXR1cm4gYWN0aXZlV2F0Y2hlcjtcbn1cbmZ1bmN0aW9uIG9uV2F0Y2hlckNsZWFudXAoY2xlYW51cEZuLCBmYWlsU2lsZW50bHkgPSBmYWxzZSwgb3duZXIgPSBhY3RpdmVXYXRjaGVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIGxldCBjbGVhbnVwcyA9IGNsZWFudXBNYXAuZ2V0KG93bmVyKTtcbiAgICBpZiAoIWNsZWFudXBzKSBjbGVhbnVwTWFwLnNldChvd25lciwgY2xlYW51cHMgPSBbXSk7XG4gICAgY2xlYW51cHMucHVzaChjbGVhbnVwRm4pO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWZhaWxTaWxlbnRseSkge1xuICAgIHdhcm4oXG4gICAgICBgb25XYXRjaGVyQ2xlYW51cCgpIHdhcyBjYWxsZWQgd2hlbiB0aGVyZSB3YXMgbm8gYWN0aXZlIHdhdGNoZXIgdG8gYXNzb2NpYXRlIHdpdGguYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcbiAgY29uc3QgeyBpbW1lZGlhdGUsIGRlZXAsIG9uY2UsIHNjaGVkdWxlciwgYXVnbWVudEpvYiwgY2FsbCB9ID0gb3B0aW9ucztcbiAgY29uc3Qgd2FybkludmFsaWRTb3VyY2UgPSAocykgPT4ge1xuICAgIChvcHRpb25zLm9uV2FybiB8fCB3YXJuKShcbiAgICAgIGBJbnZhbGlkIHdhdGNoIHNvdXJjZTogYCxcbiAgICAgIHMsXG4gICAgICBgQSB3YXRjaCBzb3VyY2UgY2FuIG9ubHkgYmUgYSBnZXR0ZXIvZWZmZWN0IGZ1bmN0aW9uLCBhIHJlZiwgYSByZWFjdGl2ZSBvYmplY3QsIG9yIGFuIGFycmF5IG9mIHRoZXNlIHR5cGVzLmBcbiAgICApO1xuICB9O1xuICBjb25zdCByZWFjdGl2ZUdldHRlciA9IChzb3VyY2UyKSA9PiB7XG4gICAgaWYgKGRlZXApIHJldHVybiBzb3VyY2UyO1xuICAgIGlmIChpc1NoYWxsb3coc291cmNlMikgfHwgZGVlcCA9PT0gZmFsc2UgfHwgZGVlcCA9PT0gMClcbiAgICAgIHJldHVybiB0cmF2ZXJzZShzb3VyY2UyLCAxKTtcbiAgICByZXR1cm4gdHJhdmVyc2Uoc291cmNlMik7XG4gIH07XG4gIGxldCBlZmZlY3Q7XG4gIGxldCBnZXR0ZXI7XG4gIGxldCBjbGVhbnVwO1xuICBsZXQgYm91bmRDbGVhbnVwO1xuICBsZXQgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XG4gIGxldCBpc011bHRpU291cmNlID0gZmFsc2U7XG4gIGlmIChpc1JlZihzb3VyY2UpKSB7XG4gICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLnZhbHVlO1xuICAgIGZvcmNlVHJpZ2dlciA9IGlzU2hhbGxvdyhzb3VyY2UpO1xuICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUoc291cmNlKSkge1xuICAgIGdldHRlciA9ICgpID0+IHJlYWN0aXZlR2V0dGVyKHNvdXJjZSk7XG4gICAgZm9yY2VUcmlnZ2VyID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICBpc011bHRpU291cmNlID0gdHJ1ZTtcbiAgICBmb3JjZVRyaWdnZXIgPSBzb3VyY2Uuc29tZSgocykgPT4gaXNSZWFjdGl2ZShzKSB8fCBpc1NoYWxsb3cocykpO1xuICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS5tYXAoKHMpID0+IHtcbiAgICAgIGlmIChpc1JlZihzKSkge1xuICAgICAgICByZXR1cm4gcy52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWFjdGl2ZShzKSkge1xuICAgICAgICByZXR1cm4gcmVhY3RpdmVHZXR0ZXIocyk7XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocykpIHtcbiAgICAgICAgcmV0dXJuIGNhbGwgPyBjYWxsKHMsIDIpIDogcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuSW52YWxpZFNvdXJjZShzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGdldHRlciA9IGNhbGwgPyAoKSA9PiBjYWxsKHNvdXJjZSwgMikgOiBzb3VyY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdldHRlciA9ICgpID0+IHtcbiAgICAgICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50RWZmZWN0ID0gYWN0aXZlV2F0Y2hlcjtcbiAgICAgICAgYWN0aXZlV2F0Y2hlciA9IGVmZmVjdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gY2FsbCA/IGNhbGwoc291cmNlLCAzLCBbYm91bmRDbGVhbnVwXSkgOiBzb3VyY2UoYm91bmRDbGVhbnVwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBhY3RpdmVXYXRjaGVyID0gY3VycmVudEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZ2V0dGVyID0gTk9PUDtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm5JbnZhbGlkU291cmNlKHNvdXJjZSk7XG4gIH1cbiAgaWYgKGNiICYmIGRlZXApIHtcbiAgICBjb25zdCBiYXNlR2V0dGVyID0gZ2V0dGVyO1xuICAgIGNvbnN0IGRlcHRoID0gZGVlcCA9PT0gdHJ1ZSA/IEluZmluaXR5IDogZGVlcDtcbiAgICBnZXR0ZXIgPSAoKSA9PiB0cmF2ZXJzZShiYXNlR2V0dGVyKCksIGRlcHRoKTtcbiAgfVxuICBjb25zdCBzY29wZSA9IGdldEN1cnJlbnRTY29wZSgpO1xuICBjb25zdCB3YXRjaEhhbmRsZSA9ICgpID0+IHtcbiAgICBlZmZlY3Quc3RvcCgpO1xuICAgIGlmIChzY29wZSAmJiBzY29wZS5hY3RpdmUpIHtcbiAgICAgIHJlbW92ZShzY29wZS5lZmZlY3RzLCBlZmZlY3QpO1xuICAgIH1cbiAgfTtcbiAgaWYgKG9uY2UgJiYgY2IpIHtcbiAgICBjb25zdCBfY2IgPSBjYjtcbiAgICBjYiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBfY2IoLi4uYXJncyk7XG4gICAgICB3YXRjaEhhbmRsZSgpO1xuICAgIH07XG4gIH1cbiAgbGV0IG9sZFZhbHVlID0gaXNNdWx0aVNvdXJjZSA/IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKS5maWxsKElOSVRJQUxfV0FUQ0hFUl9WQUxVRSkgOiBJTklUSUFMX1dBVENIRVJfVkFMVUU7XG4gIGNvbnN0IGpvYiA9IChpbW1lZGlhdGVGaXJzdFJ1bikgPT4ge1xuICAgIGlmICghKGVmZmVjdC5mbGFncyAmIDEpIHx8ICFlZmZlY3QuZGlydHkgJiYgIWltbWVkaWF0ZUZpcnN0UnVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYikge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBlZmZlY3QucnVuKCk7XG4gICAgICBpZiAoZGVlcCB8fCBmb3JjZVRyaWdnZXIgfHwgKGlzTXVsdGlTb3VyY2UgPyBuZXdWYWx1ZS5zb21lKCh2LCBpKSA9PiBoYXNDaGFuZ2VkKHYsIG9sZFZhbHVlW2ldKSkgOiBoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpKSB7XG4gICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRXYXRjaGVyID0gYWN0aXZlV2F0Y2hlcjtcbiAgICAgICAgYWN0aXZlV2F0Y2hlciA9IGVmZmVjdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICAvLyBwYXNzIHVuZGVmaW5lZCBhcyB0aGUgb2xkIHZhbHVlIHdoZW4gaXQncyBjaGFuZ2VkIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IHZvaWQgMCA6IGlzTXVsdGlTb3VyY2UgJiYgb2xkVmFsdWVbMF0gPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IFtdIDogb2xkVmFsdWUsXG4gICAgICAgICAgICBib3VuZENsZWFudXBcbiAgICAgICAgICBdO1xuICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgY2FsbCA/IGNhbGwoY2IsIDMsIGFyZ3MpIDogKFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgY2IoLi4uYXJncylcbiAgICAgICAgICApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGFjdGl2ZVdhdGNoZXIgPSBjdXJyZW50V2F0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZmZlY3QucnVuKCk7XG4gICAgfVxuICB9O1xuICBpZiAoYXVnbWVudEpvYikge1xuICAgIGF1Z21lbnRKb2Ioam9iKTtcbiAgfVxuICBlZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZ2V0dGVyKTtcbiAgZWZmZWN0LnNjaGVkdWxlciA9IHNjaGVkdWxlciA/ICgpID0+IHNjaGVkdWxlcihqb2IsIGZhbHNlKSA6IGpvYjtcbiAgYm91bmRDbGVhbnVwID0gKGZuKSA9PiBvbldhdGNoZXJDbGVhbnVwKGZuLCBmYWxzZSwgZWZmZWN0KTtcbiAgY2xlYW51cCA9IGVmZmVjdC5vblN0b3AgPSAoKSA9PiB7XG4gICAgY29uc3QgY2xlYW51cHMgPSBjbGVhbnVwTWFwLmdldChlZmZlY3QpO1xuICAgIGlmIChjbGVhbnVwcykge1xuICAgICAgaWYgKGNhbGwpIHtcbiAgICAgICAgY2FsbChjbGVhbnVwcywgNCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGNsZWFudXAyIG9mIGNsZWFudXBzKSBjbGVhbnVwMigpO1xuICAgICAgfVxuICAgICAgY2xlYW51cE1hcC5kZWxldGUoZWZmZWN0KTtcbiAgICB9XG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgZWZmZWN0Lm9uVHJhY2sgPSBvcHRpb25zLm9uVHJhY2s7XG4gICAgZWZmZWN0Lm9uVHJpZ2dlciA9IG9wdGlvbnMub25UcmlnZ2VyO1xuICB9XG4gIGlmIChjYikge1xuICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgIGpvYih0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkVmFsdWUgPSBlZmZlY3QucnVuKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNjaGVkdWxlcikge1xuICAgIHNjaGVkdWxlcihqb2IuYmluZChudWxsLCB0cnVlKSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZWZmZWN0LnJ1bigpO1xuICB9XG4gIHdhdGNoSGFuZGxlLnBhdXNlID0gZWZmZWN0LnBhdXNlLmJpbmQoZWZmZWN0KTtcbiAgd2F0Y2hIYW5kbGUucmVzdW1lID0gZWZmZWN0LnJlc3VtZS5iaW5kKGVmZmVjdCk7XG4gIHdhdGNoSGFuZGxlLnN0b3AgPSB3YXRjaEhhbmRsZTtcbiAgcmV0dXJuIHdhdGNoSGFuZGxlO1xufVxuZnVuY3Rpb24gdHJhdmVyc2UodmFsdWUsIGRlcHRoID0gSW5maW5pdHksIHNlZW4pIHtcbiAgaWYgKGRlcHRoIDw9IDAgfHwgIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZVtcIl9fdl9za2lwXCJdKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGlmICgoc2Vlbi5nZXQodmFsdWUpIHx8IDApID49IGRlcHRoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHNlZW4uc2V0KHZhbHVlLCBkZXB0aCk7XG4gIGRlcHRoLS07XG4gIGlmIChpc1JlZih2YWx1ZSkpIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZS52YWx1ZSwgZGVwdGgsIHNlZW4pO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdHJhdmVyc2UodmFsdWVbaV0sIGRlcHRoLCBzZWVuKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpIHx8IGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHtcbiAgICAgIHRyYXZlcnNlKHYsIGRlcHRoLCBzZWVuKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZVtrZXldLCBkZXB0aCwgc2Vlbik7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlW2tleV0sIGRlcHRoLCBzZWVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgeyBBUlJBWV9JVEVSQVRFX0tFWSwgRWZmZWN0RmxhZ3MsIEVmZmVjdFNjb3BlLCBJVEVSQVRFX0tFWSwgTUFQX0tFWV9JVEVSQVRFX0tFWSwgUmVhY3RpdmVFZmZlY3QsIFJlYWN0aXZlRmxhZ3MsIFRyYWNrT3BUeXBlcywgVHJpZ2dlck9wVHlwZXMsIFdhdGNoRXJyb3JDb2RlcywgY29tcHV0ZWQsIGN1c3RvbVJlZiwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZW5hYmxlVHJhY2tpbmcsIGdldEN1cnJlbnRTY29wZSwgZ2V0Q3VycmVudFdhdGNoZXIsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG9uRWZmZWN0Q2xlYW51cCwgb25TY29wZURpc3Bvc2UsIG9uV2F0Y2hlckNsZWFudXAsIHBhdXNlVHJhY2tpbmcsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWN0aXZlUmVhZEFycmF5LCByZWFkb25seSwgcmVmLCByZXNldFRyYWNraW5nLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkQXJyYXksIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3RvcCwgdG9SYXcsIHRvUmVhY3RpdmUsIHRvUmVhZG9ubHksIHRvUmVmLCB0b1JlZnMsIHRvVmFsdWUsIHRyYWNrLCB0cmF2ZXJzZSwgdHJpZ2dlciwgdHJpZ2dlclJlZiwgdW5yZWYsIHdhdGNoIH07XG4iLCIvKipcbiogQHZ1ZS9ydW50aW1lLWNvcmUgdjMuNS4yNlxuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuaW1wb3J0IHsgcGF1c2VUcmFja2luZywgcmVzZXRUcmFja2luZywgaXNSZWYsIHRvUmF3LCB0cmF2ZXJzZSwgd2F0Y2ggYXMgd2F0Y2gkMSwgc2hhbGxvd1JlZiwgcmVhZG9ubHksIGlzUmVhY3RpdmUsIHJlZiwgaXNTaGFsbG93LCBpc1JlYWRvbmx5LCBzaGFsbG93UmVhZEFycmF5LCB0b1JlYWRvbmx5LCB0b1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHRyYWNrLCByZWFjdGl2ZSwgY3VzdG9tUmVmLCBzaGFsbG93UmVhY3RpdmUsIHRyaWdnZXIsIFJlYWN0aXZlRWZmZWN0LCBpc1Byb3h5LCBwcm94eVJlZnMsIG1hcmtSYXcsIEVmZmVjdFNjb3BlLCBjb21wdXRlZCBhcyBjb21wdXRlZCQxIH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmV4cG9ydCB7IEVmZmVjdFNjb3BlLCBSZWFjdGl2ZUVmZmVjdCwgVHJhY2tPcFR5cGVzLCBUcmlnZ2VyT3BUeXBlcywgY3VzdG9tUmVmLCBlZmZlY3QsIGVmZmVjdFNjb3BlLCBnZXRDdXJyZW50U2NvcGUsIGdldEN1cnJlbnRXYXRjaGVyLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBvblNjb3BlRGlzcG9zZSwgb25XYXRjaGVyQ2xlYW51cCwgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0b1ZhbHVlLCB0cmlnZ2VyUmVmLCB1bnJlZiB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNGdW5jdGlvbiwgRU1QVFlfT0JKLCBpc1Byb21pc2UsIGlzQXJyYXksIE5PT1AsIGdldEdsb2JhbFRoaXMsIGV4dGVuZCwgaXNCdWlsdEluRGlyZWN0aXZlLCBOTywgaGFzT3duLCByZW1vdmUsIGRlZiwgaXNPbiwgaXNSZXNlcnZlZFByb3AsIG5vcm1hbGl6ZUNsYXNzLCBzdHJpbmdpZnlTdHlsZSwgbm9ybWFsaXplU3R5bGUsIGlzS25vd25TdmdBdHRyLCBpc0Jvb2xlYW5BdHRyLCBpc0tub3duSHRtbEF0dHIsIGluY2x1ZGVCb29sZWFuQXR0ciwgaXNSZW5kZXJhYmxlQXR0clZhbHVlLCBub3JtYWxpemVDc3NWYXJWYWx1ZSwgZ2V0RXNjYXBlZENzc1Zhck5hbWUsIGlzT2JqZWN0LCBpc1JlZ0V4cCwgaW52b2tlQXJyYXlGbnMsIHRvSGFuZGxlcktleSwgY2FtZWxpemUsIGNhcGl0YWxpemUsIGlzU3ltYm9sLCBpc0dsb2JhbGx5QWxsb3dlZCwgaHlwaGVuYXRlLCBoYXNDaGFuZ2VkLCBsb29zZVRvTnVtYmVyLCBpc01vZGVsTGlzdGVuZXIsIEVNUFRZX0FSUiwgbWFrZU1hcCwgdG9SYXdUeXBlLCB0b051bWJlciB9IGZyb20gJ0B2dWUvc2hhcmVkJztcbmV4cG9ydCB7IGNhbWVsaXplLCBjYXBpdGFsaXplLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSkge1xuICBzdGFjay5wdXNoKHZub2RlKTtcbn1cbmZ1bmN0aW9uIHBvcFdhcm5pbmdDb250ZXh0KCkge1xuICBzdGFjay5wb3AoKTtcbn1cbmxldCBpc1dhcm5pbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHdhcm4kMShtc2csIC4uLmFyZ3MpIHtcbiAgaWYgKGlzV2FybmluZykgcmV0dXJuO1xuICBpc1dhcm5pbmcgPSB0cnVlO1xuICBwYXVzZVRyYWNraW5nKCk7XG4gIGNvbnN0IGluc3RhbmNlID0gc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uY29tcG9uZW50IDogbnVsbDtcbiAgY29uc3QgYXBwV2FybkhhbmRsZXIgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy53YXJuSGFuZGxlcjtcbiAgY29uc3QgdHJhY2UgPSBnZXRDb21wb25lbnRUcmFjZSgpO1xuICBpZiAoYXBwV2FybkhhbmRsZXIpIHtcbiAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoXG4gICAgICBhcHBXYXJuSGFuZGxlcixcbiAgICAgIGluc3RhbmNlLFxuICAgICAgMTEsXG4gICAgICBbXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICBtc2cgKyBhcmdzLm1hcCgoYSkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGEudG9TdHJpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGEpKSAhPSBudWxsID8gX2IgOiBKU09OLnN0cmluZ2lmeShhKTtcbiAgICAgICAgfSkuam9pbihcIlwiKSxcbiAgICAgICAgaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHksXG4gICAgICAgIHRyYWNlLm1hcChcbiAgICAgICAgICAoeyB2bm9kZSB9KSA9PiBgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgdm5vZGUudHlwZSl9PmBcbiAgICAgICAgKS5qb2luKFwiXFxuXCIpLFxuICAgICAgICB0cmFjZVxuICAgICAgXVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgd2FybkFyZ3MgPSBbYFtWdWUgd2Fybl06ICR7bXNnfWAsIC4uLmFyZ3NdO1xuICAgIGlmICh0cmFjZS5sZW5ndGggJiYgLy8gYXZvaWQgc3BhbW1pbmcgY29uc29sZSBkdXJpbmcgdGVzdHNcbiAgICB0cnVlKSB7XG4gICAgICB3YXJuQXJncy5wdXNoKGBcbmAsIC4uLmZvcm1hdFRyYWNlKHRyYWNlKSk7XG4gICAgfVxuICAgIGNvbnNvbGUud2FybiguLi53YXJuQXJncyk7XG4gIH1cbiAgcmVzZXRUcmFja2luZygpO1xuICBpc1dhcm5pbmcgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFRyYWNlKCkge1xuICBsZXQgY3VycmVudFZOb2RlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gIGlmICghY3VycmVudFZOb2RlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWRTdGFjayA9IFtdO1xuICB3aGlsZSAoY3VycmVudFZOb2RlKSB7XG4gICAgY29uc3QgbGFzdCA9IG5vcm1hbGl6ZWRTdGFja1swXTtcbiAgICBpZiAobGFzdCAmJiBsYXN0LnZub2RlID09PSBjdXJyZW50Vk5vZGUpIHtcbiAgICAgIGxhc3QucmVjdXJzZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZWRTdGFjay5wdXNoKHtcbiAgICAgICAgdm5vZGU6IGN1cnJlbnRWTm9kZSxcbiAgICAgICAgcmVjdXJzZUNvdW50OiAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50SW5zdGFuY2UgPSBjdXJyZW50Vk5vZGUuY29tcG9uZW50ICYmIGN1cnJlbnRWTm9kZS5jb21wb25lbnQucGFyZW50O1xuICAgIGN1cnJlbnRWTm9kZSA9IHBhcmVudEluc3RhbmNlICYmIHBhcmVudEluc3RhbmNlLnZub2RlO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkU3RhY2s7XG59XG5mdW5jdGlvbiBmb3JtYXRUcmFjZSh0cmFjZSkge1xuICBjb25zdCBsb2dzID0gW107XG4gIHRyYWNlLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XG4gICAgbG9ncy5wdXNoKC4uLmkgPT09IDAgPyBbXSA6IFtgXG5gXSwgLi4uZm9ybWF0VHJhY2VFbnRyeShlbnRyeSkpO1xuICB9KTtcbiAgcmV0dXJuIGxvZ3M7XG59XG5mdW5jdGlvbiBmb3JtYXRUcmFjZUVudHJ5KHsgdm5vZGUsIHJlY3Vyc2VDb3VudCB9KSB7XG4gIGNvbnN0IHBvc3RmaXggPSByZWN1cnNlQ291bnQgPiAwID8gYC4uLiAoJHtyZWN1cnNlQ291bnR9IHJlY3Vyc2l2ZSBjYWxscylgIDogYGA7XG4gIGNvbnN0IGlzUm9vdCA9IHZub2RlLmNvbXBvbmVudCA/IHZub2RlLmNvbXBvbmVudC5wYXJlbnQgPT0gbnVsbCA6IGZhbHNlO1xuICBjb25zdCBvcGVuID0gYCBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKFxuICAgIHZub2RlLmNvbXBvbmVudCxcbiAgICB2bm9kZS50eXBlLFxuICAgIGlzUm9vdFxuICApfWA7XG4gIGNvbnN0IGNsb3NlID0gYD5gICsgcG9zdGZpeDtcbiAgcmV0dXJuIHZub2RlLnByb3BzID8gW29wZW4sIC4uLmZvcm1hdFByb3BzKHZub2RlLnByb3BzKSwgY2xvc2VdIDogW29wZW4gKyBjbG9zZV07XG59XG5mdW5jdGlvbiBmb3JtYXRQcm9wcyhwcm9wcykge1xuICBjb25zdCByZXMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAga2V5cy5zbGljZSgwLCAzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICByZXMucHVzaCguLi5mb3JtYXRQcm9wKGtleSwgcHJvcHNba2V5XSkpO1xuICB9KTtcbiAgaWYgKGtleXMubGVuZ3RoID4gMykge1xuICAgIHJlcy5wdXNoKGAgLi4uYCk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGZvcm1hdFByb3Aoa2V5LCB2YWx1ZSwgcmF3KSB7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xuICB9IGVsc2UgaWYgKGlzUmVmKHZhbHVlKSkge1xuICAgIHZhbHVlID0gZm9ybWF0UHJvcChrZXksIHRvUmF3KHZhbHVlLnZhbHVlKSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09UmVmPGAsIHZhbHVlLCBgPmBdO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgcmV0dXJuIFtgJHtrZXl9PWZuJHt2YWx1ZS5uYW1lID8gYDwke3ZhbHVlLm5hbWV9PmAgOiBgYH1gXTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1gLCB2YWx1ZV07XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydE51bWJlcih2YWwsIHR5cGUpIHtcbiAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSByZXR1cm47XG4gIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsICE9PSBcIm51bWJlclwiKSB7XG4gICAgd2FybiQxKGAke3R5cGV9IGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9LmApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuJDEoYCR7dHlwZX0gaXMgTmFOIC0gdGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LmApO1xuICB9XG59XG5cbmNvbnN0IEVycm9yQ29kZXMgPSB7XG4gIFwiU0VUVVBfRlVOQ1RJT05cIjogMCxcbiAgXCIwXCI6IFwiU0VUVVBfRlVOQ1RJT05cIixcbiAgXCJSRU5ERVJfRlVOQ1RJT05cIjogMSxcbiAgXCIxXCI6IFwiUkVOREVSX0ZVTkNUSU9OXCIsXG4gIFwiTkFUSVZFX0VWRU5UX0hBTkRMRVJcIjogNSxcbiAgXCI1XCI6IFwiTkFUSVZFX0VWRU5UX0hBTkRMRVJcIixcbiAgXCJDT01QT05FTlRfRVZFTlRfSEFORExFUlwiOiA2LFxuICBcIjZcIjogXCJDT01QT05FTlRfRVZFTlRfSEFORExFUlwiLFxuICBcIlZOT0RFX0hPT0tcIjogNyxcbiAgXCI3XCI6IFwiVk5PREVfSE9PS1wiLFxuICBcIkRJUkVDVElWRV9IT09LXCI6IDgsXG4gIFwiOFwiOiBcIkRJUkVDVElWRV9IT09LXCIsXG4gIFwiVFJBTlNJVElPTl9IT09LXCI6IDksXG4gIFwiOVwiOiBcIlRSQU5TSVRJT05fSE9PS1wiLFxuICBcIkFQUF9FUlJPUl9IQU5ETEVSXCI6IDEwLFxuICBcIjEwXCI6IFwiQVBQX0VSUk9SX0hBTkRMRVJcIixcbiAgXCJBUFBfV0FSTl9IQU5ETEVSXCI6IDExLFxuICBcIjExXCI6IFwiQVBQX1dBUk5fSEFORExFUlwiLFxuICBcIkZVTkNUSU9OX1JFRlwiOiAxMixcbiAgXCIxMlwiOiBcIkZVTkNUSU9OX1JFRlwiLFxuICBcIkFTWU5DX0NPTVBPTkVOVF9MT0FERVJcIjogMTMsXG4gIFwiMTNcIjogXCJBU1lOQ19DT01QT05FTlRfTE9BREVSXCIsXG4gIFwiU0NIRURVTEVSXCI6IDE0LFxuICBcIjE0XCI6IFwiU0NIRURVTEVSXCIsXG4gIFwiQ09NUE9ORU5UX1VQREFURVwiOiAxNSxcbiAgXCIxNVwiOiBcIkNPTVBPTkVOVF9VUERBVEVcIixcbiAgXCJBUFBfVU5NT1VOVF9DTEVBTlVQXCI6IDE2LFxuICBcIjE2XCI6IFwiQVBQX1VOTU9VTlRfQ0xFQU5VUFwiXG59O1xuY29uc3QgRXJyb3JUeXBlU3RyaW5ncyQxID0ge1xuICBbXCJzcFwiXTogXCJzZXJ2ZXJQcmVmZXRjaCBob29rXCIsXG4gIFtcImJjXCJdOiBcImJlZm9yZUNyZWF0ZSBob29rXCIsXG4gIFtcImNcIl06IFwiY3JlYXRlZCBob29rXCIsXG4gIFtcImJtXCJdOiBcImJlZm9yZU1vdW50IGhvb2tcIixcbiAgW1wibVwiXTogXCJtb3VudGVkIGhvb2tcIixcbiAgW1wiYnVcIl06IFwiYmVmb3JlVXBkYXRlIGhvb2tcIixcbiAgW1widVwiXTogXCJ1cGRhdGVkXCIsXG4gIFtcImJ1bVwiXTogXCJiZWZvcmVVbm1vdW50IGhvb2tcIixcbiAgW1widW1cIl06IFwidW5tb3VudGVkIGhvb2tcIixcbiAgW1wiYVwiXTogXCJhY3RpdmF0ZWQgaG9va1wiLFxuICBbXCJkYVwiXTogXCJkZWFjdGl2YXRlZCBob29rXCIsXG4gIFtcImVjXCJdOiBcImVycm9yQ2FwdHVyZWQgaG9va1wiLFxuICBbXCJydGNcIl06IFwicmVuZGVyVHJhY2tlZCBob29rXCIsXG4gIFtcInJ0Z1wiXTogXCJyZW5kZXJUcmlnZ2VyZWQgaG9va1wiLFxuICBbMF06IFwic2V0dXAgZnVuY3Rpb25cIixcbiAgWzFdOiBcInJlbmRlciBmdW5jdGlvblwiLFxuICBbMl06IFwid2F0Y2hlciBnZXR0ZXJcIixcbiAgWzNdOiBcIndhdGNoZXIgY2FsbGJhY2tcIixcbiAgWzRdOiBcIndhdGNoZXIgY2xlYW51cCBmdW5jdGlvblwiLFxuICBbNV06IFwibmF0aXZlIGV2ZW50IGhhbmRsZXJcIixcbiAgWzZdOiBcImNvbXBvbmVudCBldmVudCBoYW5kbGVyXCIsXG4gIFs3XTogXCJ2bm9kZSBob29rXCIsXG4gIFs4XTogXCJkaXJlY3RpdmUgaG9va1wiLFxuICBbOV06IFwidHJhbnNpdGlvbiBob29rXCIsXG4gIFsxMF06IFwiYXBwIGVycm9ySGFuZGxlclwiLFxuICBbMTFdOiBcImFwcCB3YXJuSGFuZGxlclwiLFxuICBbMTJdOiBcInJlZiBmdW5jdGlvblwiLFxuICBbMTNdOiBcImFzeW5jIGNvbXBvbmVudCBsb2FkZXJcIixcbiAgWzE0XTogXCJzY2hlZHVsZXIgZmx1c2hcIixcbiAgWzE1XTogXCJjb21wb25lbnQgdXBkYXRlXCIsXG4gIFsxNl06IFwiYXBwIHVubW91bnQgY2xlYW51cCBmdW5jdGlvblwiXG59O1xuZnVuY3Rpb24gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBhcmdzID8gZm4oLi4uYXJncykgOiBmbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XG4gIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xuICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpO1xuICAgIGlmIChyZXMgJiYgaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcy5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKGlzQXJyYXkoZm4pKSB7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzLnB1c2goY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm5baV0sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShcbiAgICAgIGBJbnZhbGlkIHZhbHVlIHR5cGUgcGFzc2VkIHRvIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKCk6ICR7dHlwZW9mIGZufWBcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xuICBjb25zdCBjb250ZXh0Vk5vZGUgPSBpbnN0YW5jZSA/IGluc3RhbmNlLnZub2RlIDogbnVsbDtcbiAgY29uc3QgeyBlcnJvckhhbmRsZXIsIHRocm93VW5oYW5kbGVkRXJyb3JJblByb2R1Y3Rpb24gfSA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnIHx8IEVNUFRZX09CSjtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgbGV0IGN1ciA9IGluc3RhbmNlLnBhcmVudDtcbiAgICBjb25zdCBleHBvc2VkSW5zdGFuY2UgPSBpbnN0YW5jZS5wcm94eTtcbiAgICBjb25zdCBlcnJvckluZm8gPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gRXJyb3JUeXBlU3RyaW5ncyQxW3R5cGVdIDogYGh0dHBzOi8vdnVlanMub3JnL2Vycm9yLXJlZmVyZW5jZS8jcnVudGltZS0ke3R5cGV9YDtcbiAgICB3aGlsZSAoY3VyKSB7XG4gICAgICBjb25zdCBlcnJvckNhcHR1cmVkSG9va3MgPSBjdXIuZWM7XG4gICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JDYXB0dXJlZEhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rc1tpXShlcnIsIGV4cG9zZWRJbnN0YW5jZSwgZXJyb3JJbmZvKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgfVxuICAgIGlmIChlcnJvckhhbmRsZXIpIHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhlcnJvckhhbmRsZXIsIG51bGwsIDEwLCBbXG4gICAgICAgIGVycixcbiAgICAgICAgZXhwb3NlZEluc3RhbmNlLFxuICAgICAgICBlcnJvckluZm9cbiAgICAgIF0pO1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldiwgdGhyb3dVbmhhbmRsZWRFcnJvckluUHJvZHVjdGlvbik7XG59XG5mdW5jdGlvbiBsb2dFcnJvcihlcnIsIHR5cGUsIGNvbnRleHRWTm9kZSwgdGhyb3dJbkRldiA9IHRydWUsIHRocm93SW5Qcm9kID0gZmFsc2UpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBjb25zdCBpbmZvID0gRXJyb3JUeXBlU3RyaW5ncyQxW3R5cGVdO1xuICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcbiAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChjb250ZXh0Vk5vZGUpO1xuICAgIH1cbiAgICB3YXJuJDEoYFVuaGFuZGxlZCBlcnJvciR7aW5mbyA/IGAgZHVyaW5nIGV4ZWN1dGlvbiBvZiAke2luZm99YCA6IGBgfWApO1xuICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcbiAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgfVxuICAgIGlmICh0aHJvd0luRGV2KSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhyb3dJblByb2QpIHtcbiAgICB0aHJvdyBlcnI7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmNvbnN0IHF1ZXVlID0gW107XG5sZXQgZmx1c2hJbmRleCA9IC0xO1xuY29uc3QgcGVuZGluZ1Bvc3RGbHVzaENicyA9IFtdO1xubGV0IGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XG5sZXQgcG9zdEZsdXNoSW5kZXggPSAwO1xuY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gLyogQF9fUFVSRV9fICovIFByb21pc2UucmVzb2x2ZSgpO1xubGV0IGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xuY29uc3QgUkVDVVJTSU9OX0xJTUlUID0gMTAwO1xuZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgY29uc3QgcCA9IGN1cnJlbnRGbHVzaFByb21pc2UgfHwgcmVzb2x2ZWRQcm9taXNlO1xuICByZXR1cm4gZm4gPyBwLnRoZW4odGhpcyA/IGZuLmJpbmQodGhpcykgOiBmbikgOiBwO1xufVxuZnVuY3Rpb24gZmluZEluc2VydGlvbkluZGV4KGlkKSB7XG4gIGxldCBzdGFydCA9IGZsdXNoSW5kZXggKyAxO1xuICBsZXQgZW5kID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICBjb25zdCBtaWRkbGUgPSBzdGFydCArIGVuZCA+Pj4gMTtcbiAgICBjb25zdCBtaWRkbGVKb2IgPSBxdWV1ZVttaWRkbGVdO1xuICAgIGNvbnN0IG1pZGRsZUpvYklkID0gZ2V0SWQobWlkZGxlSm9iKTtcbiAgICBpZiAobWlkZGxlSm9iSWQgPCBpZCB8fCBtaWRkbGVKb2JJZCA9PT0gaWQgJiYgbWlkZGxlSm9iLmZsYWdzICYgMikge1xuICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSBtaWRkbGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFydDtcbn1cbmZ1bmN0aW9uIHF1ZXVlSm9iKGpvYikge1xuICBpZiAoIShqb2IuZmxhZ3MgJiAxKSkge1xuICAgIGNvbnN0IGpvYklkID0gZ2V0SWQoam9iKTtcbiAgICBjb25zdCBsYXN0Sm9iID0gcXVldWVbcXVldWUubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFsYXN0Sm9iIHx8IC8vIGZhc3QgcGF0aCB3aGVuIHRoZSBqb2IgaWQgaXMgbGFyZ2VyIHRoYW4gdGhlIHRhaWxcbiAgICAhKGpvYi5mbGFncyAmIDIpICYmIGpvYklkID49IGdldElkKGxhc3RKb2IpKSB7XG4gICAgICBxdWV1ZS5wdXNoKGpvYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlLnNwbGljZShmaW5kSW5zZXJ0aW9uSW5kZXgoam9iSWQpLCAwLCBqb2IpO1xuICAgIH1cbiAgICBqb2IuZmxhZ3MgfD0gMTtcbiAgICBxdWV1ZUZsdXNoKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHF1ZXVlRmx1c2goKSB7XG4gIGlmICghY3VycmVudEZsdXNoUHJvbWlzZSkge1xuICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSByZXNvbHZlZFByb21pc2UudGhlbihmbHVzaEpvYnMpO1xuICB9XG59XG5mdW5jdGlvbiBxdWV1ZVBvc3RGbHVzaENiKGNiKSB7XG4gIGlmICghaXNBcnJheShjYikpIHtcbiAgICBpZiAoYWN0aXZlUG9zdEZsdXNoQ2JzICYmIGNiLmlkID09PSAtMSkge1xuICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnNwbGljZShwb3N0Rmx1c2hJbmRleCArIDEsIDAsIGNiKTtcbiAgICB9IGVsc2UgaWYgKCEoY2IuZmxhZ3MgJiAxKSkge1xuICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKGNiKTtcbiAgICAgIGNiLmZsYWdzIHw9IDE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMucHVzaCguLi5jYik7XG4gIH1cbiAgcXVldWVGbHVzaCgpO1xufVxuZnVuY3Rpb24gZmx1c2hQcmVGbHVzaENicyhpbnN0YW5jZSwgc2VlbiwgaSA9IGZsdXNoSW5kZXggKyAxKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgc2VlbiA9IHNlZW4gfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBmb3IgKDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2IgPSBxdWV1ZVtpXTtcbiAgICBpZiAoY2IgJiYgY2IuZmxhZ3MgJiAyKSB7XG4gICAgICBpZiAoaW5zdGFuY2UgJiYgY2IuaWQgIT09IGluc3RhbmNlLnVpZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBjYikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICBpLS07XG4gICAgICBpZiAoY2IuZmxhZ3MgJiA0KSB7XG4gICAgICAgIGNiLmZsYWdzICY9IC0yO1xuICAgICAgfVxuICAgICAgY2IoKTtcbiAgICAgIGlmICghKGNiLmZsYWdzICYgNCkpIHtcbiAgICAgICAgY2IuZmxhZ3MgJj0gLTI7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmbHVzaFBvc3RGbHVzaENicyhzZWVuKSB7XG4gIGlmIChwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xuICAgIGNvbnN0IGRlZHVwZWQgPSBbLi4ubmV3IFNldChwZW5kaW5nUG9zdEZsdXNoQ2JzKV0uc29ydChcbiAgICAgIChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpXG4gICAgKTtcbiAgICBwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCA9IDA7XG4gICAgaWYgKGFjdGl2ZVBvc3RGbHVzaENicykge1xuICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnB1c2goLi4uZGVkdXBlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IGRlZHVwZWQ7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHNlZW4gPSBzZWVuIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGZvciAocG9zdEZsdXNoSW5kZXggPSAwOyBwb3N0Rmx1c2hJbmRleCA8IGFjdGl2ZVBvc3RGbHVzaENicy5sZW5ndGg7IHBvc3RGbHVzaEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGNiID0gYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBjYikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoY2IuZmxhZ3MgJiA0KSB7XG4gICAgICAgIGNiLmZsYWdzICY9IC0yO1xuICAgICAgfVxuICAgICAgaWYgKCEoY2IuZmxhZ3MgJiA4KSkgY2IoKTtcbiAgICAgIGNiLmZsYWdzICY9IC0yO1xuICAgIH1cbiAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xuICAgIHBvc3RGbHVzaEluZGV4ID0gMDtcbiAgfVxufVxuY29uc3QgZ2V0SWQgPSAoam9iKSA9PiBqb2IuaWQgPT0gbnVsbCA/IGpvYi5mbGFncyAmIDIgPyAtMSA6IEluZmluaXR5IDogam9iLmlkO1xuZnVuY3Rpb24gZmx1c2hKb2JzKHNlZW4pIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBzZWVuID0gc2VlbiB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGNvbnN0IGNoZWNrID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IChqb2IpID0+IGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBqb2IpIDogTk9PUDtcbiAgdHJ5IHtcbiAgICBmb3IgKGZsdXNoSW5kZXggPSAwOyBmbHVzaEluZGV4IDwgcXVldWUubGVuZ3RoOyBmbHVzaEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xuICAgICAgaWYgKGpvYiAmJiAhKGpvYi5mbGFncyAmIDgpKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNoZWNrKGpvYikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoam9iLmZsYWdzICYgNCkge1xuICAgICAgICAgIGpvYi5mbGFncyAmPSB+MTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoXG4gICAgICAgICAgam9iLFxuICAgICAgICAgIGpvYi5pLFxuICAgICAgICAgIGpvYi5pID8gMTUgOiAxNFxuICAgICAgICApO1xuICAgICAgICBpZiAoIShqb2IuZmxhZ3MgJiA0KSkge1xuICAgICAgICAgIGpvYi5mbGFncyAmPSB+MTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBmb3IgKDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XG4gICAgICBjb25zdCBqb2IgPSBxdWV1ZVtmbHVzaEluZGV4XTtcbiAgICAgIGlmIChqb2IpIHtcbiAgICAgICAgam9iLmZsYWdzICY9IC0yO1xuICAgICAgfVxuICAgIH1cbiAgICBmbHVzaEluZGV4ID0gLTE7XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBmbHVzaFBvc3RGbHVzaENicyhzZWVuKTtcbiAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcbiAgICBpZiAocXVldWUubGVuZ3RoIHx8IHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XG4gICAgICBmbHVzaEpvYnMoc2Vlbik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgZm4pIHtcbiAgY29uc3QgY291bnQgPSBzZWVuLmdldChmbikgfHwgMDtcbiAgaWYgKGNvdW50ID4gUkVDVVJTSU9OX0xJTUlUKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBmbi5pO1xuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBpbnN0YW5jZSAmJiBnZXRDb21wb25lbnROYW1lKGluc3RhbmNlLnR5cGUpO1xuICAgIGhhbmRsZUVycm9yKFxuICAgICAgYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQke2NvbXBvbmVudE5hbWUgPyBgIGluIGNvbXBvbmVudCA8JHtjb21wb25lbnROYW1lfT5gIDogYGB9LiBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmAsXG4gICAgICBudWxsLFxuICAgICAgMTBcbiAgICApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNlZW4uc2V0KGZuLCBjb3VudCArIDEpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmxldCBpc0htclVwZGF0aW5nID0gZmFsc2U7XG5jb25zdCBobXJEaXJ0eUNvbXBvbmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX0hNUl9SVU5USU1FX18gPSB7XG4gICAgY3JlYXRlUmVjb3JkOiB0cnlXcmFwKGNyZWF0ZVJlY29yZCksXG4gICAgcmVyZW5kZXI6IHRyeVdyYXAocmVyZW5kZXIpLFxuICAgIHJlbG9hZDogdHJ5V3JhcChyZWxvYWQpXG4gIH07XG59XG5jb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gcmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcbiAgY29uc3QgaWQgPSBpbnN0YW5jZS50eXBlLl9faG1ySWQ7XG4gIGxldCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpIHtcbiAgICBjcmVhdGVSZWNvcmQoaWQsIGluc3RhbmNlLnR5cGUpO1xuICAgIHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICB9XG4gIHJlY29yZC5pbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcbiAgbWFwLmdldChpbnN0YW5jZS50eXBlLl9faG1ySWQpLmluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVjb3JkKGlkLCBpbml0aWFsRGVmKSB7XG4gIGlmIChtYXAuaGFzKGlkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXAuc2V0KGlkLCB7XG4gICAgaW5pdGlhbERlZjogbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5pdGlhbERlZiksXG4gICAgaW5zdGFuY2VzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gIH0pO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpID8gY29tcG9uZW50Ll9fdmNjT3B0cyA6IGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIHJlcmVuZGVyKGlkLCBuZXdSZW5kZXIpIHtcbiAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gIGlmICghcmVjb3JkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlY29yZC5pbml0aWFsRGVmLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgWy4uLnJlY29yZC5pbnN0YW5jZXNdLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XG4gICAgaWYgKG5ld1JlbmRlcikge1xuICAgICAgaW5zdGFuY2UucmVuZGVyID0gbmV3UmVuZGVyO1xuICAgICAgbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSkucmVuZGVyID0gbmV3UmVuZGVyO1xuICAgIH1cbiAgICBpbnN0YW5jZS5yZW5kZXJDYWNoZSA9IFtdO1xuICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xuICAgIGlmICghKGluc3RhbmNlLmpvYi5mbGFncyAmIDgpKSB7XG4gICAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICB9XG4gICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbG9hZChpZCwgbmV3Q29tcCkge1xuICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgaWYgKCFyZWNvcmQpIHJldHVybjtcbiAgbmV3Q29tcCA9IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KG5ld0NvbXApO1xuICB1cGRhdGVDb21wb25lbnREZWYocmVjb3JkLmluaXRpYWxEZWYsIG5ld0NvbXApO1xuICBjb25zdCBpbnN0YW5jZXMgPSBbLi4ucmVjb3JkLmluc3RhbmNlc107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaV07XG4gICAgY29uc3Qgb2xkQ29tcCA9IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpO1xuICAgIGxldCBkaXJ0eUluc3RhbmNlcyA9IGhtckRpcnR5Q29tcG9uZW50cy5nZXQob2xkQ29tcCk7XG4gICAgaWYgKCFkaXJ0eUluc3RhbmNlcykge1xuICAgICAgaWYgKG9sZENvbXAgIT09IHJlY29yZC5pbml0aWFsRGVmKSB7XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKTtcbiAgICAgIH1cbiAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5zZXQob2xkQ29tcCwgZGlydHlJbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICB9XG4gICAgZGlydHlJbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcbiAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnByb3BzQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgIGluc3RhbmNlLmFwcENvbnRleHQuZW1pdHNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgaW5zdGFuY2UuYXBwQ29udGV4dC5vcHRpb25zQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xuICAgIGlmIChpbnN0YW5jZS5jZVJlbG9hZCkge1xuICAgICAgZGlydHlJbnN0YW5jZXMuYWRkKGluc3RhbmNlKTtcbiAgICAgIGluc3RhbmNlLmNlUmVsb2FkKG5ld0NvbXAuc3R5bGVzKTtcbiAgICAgIGRpcnR5SW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICAgIHF1ZXVlSm9iKCgpID0+IHtcbiAgICAgICAgaWYgKCEoaW5zdGFuY2Uuam9iLmZsYWdzICYgOCkpIHtcbiAgICAgICAgICBpc0htclVwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQudXBkYXRlKCk7XG4gICAgICAgICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgIGRpcnR5SW5zdGFuY2VzLmRlbGV0ZShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQpIHtcbiAgICAgIGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJbSE1SXSBSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2Uucm9vdC5jZSAmJiBpbnN0YW5jZSAhPT0gaW5zdGFuY2Uucm9vdCkge1xuICAgICAgaW5zdGFuY2Uucm9vdC5jZS5fcmVtb3ZlQ2hpbGRTdHlsZShvbGRDb21wKTtcbiAgICB9XG4gIH1cbiAgcXVldWVQb3N0Rmx1c2hDYigoKSA9PiB7XG4gICAgaG1yRGlydHlDb21wb25lbnRzLmNsZWFyKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApIHtcbiAgZXh0ZW5kKG9sZENvbXAsIG5ld0NvbXApO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvbGRDb21wKSB7XG4gICAgaWYgKGtleSAhPT0gXCJfX2ZpbGVcIiAmJiAhKGtleSBpbiBuZXdDb21wKSkge1xuICAgICAgZGVsZXRlIG9sZENvbXBba2V5XTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcbiAgcmV0dXJuIChpZCwgYXJnKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihpZCwgYXJnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW0hNUl0gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIFZ1ZSBjb21wb25lbnQgaG90LXJlbG9hZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbmxldCBkZXZ0b29scyQxO1xubGV0IGJ1ZmZlciA9IFtdO1xubGV0IGRldnRvb2xzTm90SW5zdGFsbGVkID0gZmFsc2U7XG5mdW5jdGlvbiBlbWl0JDEoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgaWYgKGRldnRvb2xzJDEpIHtcbiAgICBkZXZ0b29scyQxLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICB9IGVsc2UgaWYgKCFkZXZ0b29sc05vdEluc3RhbGxlZCkge1xuICAgIGJ1ZmZlci5wdXNoKHsgZXZlbnQsIGFyZ3MgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldERldnRvb2xzSG9vayQxKGhvb2ssIHRhcmdldCkge1xuICB2YXIgX2EsIF9iO1xuICBkZXZ0b29scyQxID0gaG9vaztcbiAgaWYgKGRldnRvb2xzJDEpIHtcbiAgICBkZXZ0b29scyQxLmVuYWJsZWQgPSB0cnVlO1xuICAgIGJ1ZmZlci5mb3JFYWNoKCh7IGV2ZW50LCBhcmdzIH0pID0+IGRldnRvb2xzJDEuZW1pdChldmVudCwgLi4uYXJncykpO1xuICAgIGJ1ZmZlciA9IFtdO1xuICB9IGVsc2UgaWYgKFxuICAgIC8vIGhhbmRsZSBsYXRlIGRldnRvb2xzIGluamVjdGlvbiAtIG9ubHkgZG8gdGhpcyBpZiB3ZSBhcmUgaW4gYW4gYWN0dWFsXG4gICAgLy8gYnJvd3NlciBlbnZpcm9ubWVudCB0byBhdm9pZCB0aGUgdGltZXIgaGFuZGxlIHN0YWxsaW5nIHRlc3QgcnVubmVyIGV4aXRcbiAgICAvLyAoIzQ4MTUpXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvLyBzb21lIGVudnMgbW9jayB3aW5kb3cgYnV0IG5vdCBmdWxseVxuICAgIHdpbmRvdy5IVE1MRWxlbWVudCAmJiAvLyBhbHNvIGV4Y2x1ZGUganNkb21cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAhKChfYiA9IChfYSA9IHdpbmRvdy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfYS51c2VyQWdlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5pbmNsdWRlcyhcImpzZG9tXCIpKVxuICApIHtcbiAgICBjb25zdCByZXBsYXkgPSB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fIHx8IFtdO1xuICAgIHJlcGxheS5wdXNoKChuZXdIb29rKSA9PiB7XG4gICAgICBzZXREZXZ0b29sc0hvb2skMShuZXdIb29rLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFkZXZ0b29scyQxKSB7XG4gICAgICAgIHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID0gbnVsbDtcbiAgICAgICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgIH1cbiAgICB9LCAzZTMpO1xuICB9IGVsc2Uge1xuICAgIGRldnRvb2xzTm90SW5zdGFsbGVkID0gdHJ1ZTtcbiAgICBidWZmZXIgPSBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbikge1xuICBlbWl0JDEoXCJhcHA6aW5pdFwiIC8qIEFQUF9JTklUICovLCBhcHAsIHZlcnNpb24sIHtcbiAgICBGcmFnbWVudCxcbiAgICBUZXh0LFxuICAgIENvbW1lbnQsXG4gICAgU3RhdGljXG4gIH0pO1xufVxuZnVuY3Rpb24gZGV2dG9vbHNVbm1vdW50QXBwKGFwcCkge1xuICBlbWl0JDEoXCJhcHA6dW5tb3VudFwiIC8qIEFQUF9VTk1PVU5UICovLCBhcHApO1xufVxuY29uc3QgZGV2dG9vbHNDb21wb25lbnRBZGRlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6YWRkZWRcIiAvKiBDT01QT05FTlRfQURERUQgKi8pO1xuY29uc3QgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDp1cGRhdGVkXCIgLyogQ09NUE9ORU5UX1VQREFURUQgKi8pO1xuY29uc3QgX2RldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXG4gIFwiY29tcG9uZW50OnJlbW92ZWRcIiAvKiBDT01QT05FTlRfUkVNT1ZFRCAqL1xuKTtcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IChjb21wb25lbnQpID0+IHtcbiAgaWYgKGRldnRvb2xzJDEgJiYgdHlwZW9mIGRldnRvb2xzJDEuY2xlYW51cEJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIC8vIHJlbW92ZSB0aGUgY29tcG9uZW50IGlmIGl0IHdhc24ndCBidWZmZXJlZFxuICAhZGV2dG9vbHMkMS5jbGVhbnVwQnVmZmVyKGNvbXBvbmVudCkpIHtcbiAgICBfZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkKGNvbXBvbmVudCk7XG4gIH1cbn07XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKGhvb2spIHtcbiAgcmV0dXJuIChjb21wb25lbnQpID0+IHtcbiAgICBlbWl0JDEoXG4gICAgICBob29rLFxuICAgICAgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLFxuICAgICAgY29tcG9uZW50LnVpZCxcbiAgICAgIGNvbXBvbmVudC5wYXJlbnQgPyBjb21wb25lbnQucGFyZW50LnVpZCA6IHZvaWQgMCxcbiAgICAgIGNvbXBvbmVudFxuICAgICk7XG4gIH07XG59XG5jb25zdCBkZXZ0b29sc1BlcmZTdGFydCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcInBlcmY6c3RhcnRcIiAvKiBQRVJGT1JNQU5DRV9TVEFSVCAqLyk7XG5jb25zdCBkZXZ0b29sc1BlcmZFbmQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOmVuZFwiIC8qIFBFUkZPUk1BTkNFX0VORCAqLyk7XG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhob29rKSB7XG4gIHJldHVybiAoY29tcG9uZW50LCB0eXBlLCB0aW1lKSA9PiB7XG4gICAgZW1pdCQxKGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LCB0eXBlLCB0aW1lKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRldnRvb2xzQ29tcG9uZW50RW1pdChjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpIHtcbiAgZW1pdCQxKFxuICAgIFwiY29tcG9uZW50OmVtaXRcIiAvKiBDT01QT05FTlRfRU1JVCAqLyxcbiAgICBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsXG4gICAgY29tcG9uZW50LFxuICAgIGV2ZW50LFxuICAgIHBhcmFtc1xuICApO1xufVxuXG5sZXQgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbmxldCBjdXJyZW50U2NvcGVJZCA9IG51bGw7XG5mdW5jdGlvbiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgY29uc3QgcHJldiA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gaW5zdGFuY2U7XG4gIGN1cnJlbnRTY29wZUlkID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZS5fX3Njb3BlSWQgfHwgbnVsbDtcbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiBwdXNoU2NvcGVJZChpZCkge1xuICBjdXJyZW50U2NvcGVJZCA9IGlkO1xufVxuZnVuY3Rpb24gcG9wU2NvcGVJZCgpIHtcbiAgY3VycmVudFNjb3BlSWQgPSBudWxsO1xufVxuY29uc3Qgd2l0aFNjb3BlSWQgPSAoX2lkKSA9PiB3aXRoQ3R4O1xuZnVuY3Rpb24gd2l0aEN0eChmbiwgY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCBpc05vblNjb3BlZFNsb3QpIHtcbiAgaWYgKCFjdHgpIHJldHVybiBmbjtcbiAgaWYgKGZuLl9uKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG4gIGNvbnN0IHJlbmRlckZuV2l0aENvbnRleHQgPSAoLi4uYXJncykgPT4ge1xuICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XG4gICAgICBzZXRCbG9ja1RyYWNraW5nKC0xKTtcbiAgICB9XG4gICAgY29uc3QgcHJldkluc3RhbmNlID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGN0eCk7XG4gICAgbGV0IHJlcztcbiAgICB0cnkge1xuICAgICAgcmVzID0gZm4oLi4uYXJncyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2SW5zdGFuY2UpO1xuICAgICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcbiAgICAgICAgc2V0QmxvY2tUcmFja2luZygxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgcmVuZGVyRm5XaXRoQ29udGV4dC5fbiA9IHRydWU7XG4gIHJlbmRlckZuV2l0aENvbnRleHQuX2MgPSB0cnVlO1xuICByZW5kZXJGbldpdGhDb250ZXh0Ll9kID0gdHJ1ZTtcbiAgcmV0dXJuIHJlbmRlckZuV2l0aENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKSB7XG4gIGlmIChpc0J1aWx0SW5EaXJlY3RpdmUobmFtZSkpIHtcbiAgICB3YXJuJDEoXCJEbyBub3QgdXNlIGJ1aWx0LWluIGRpcmVjdGl2ZSBpZHMgYXMgY3VzdG9tIGRpcmVjdGl2ZSBpZDogXCIgKyBuYW1lKTtcbiAgfVxufVxuZnVuY3Rpb24gd2l0aERpcmVjdGl2ZXModm5vZGUsIGRpcmVjdGl2ZXMpIHtcbiAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGB3aXRoRGlyZWN0aXZlcyBjYW4gb25seSBiZSB1c2VkIGluc2lkZSByZW5kZXIgZnVuY3Rpb25zLmApO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfVxuICBjb25zdCBpbnN0YW5jZSA9IGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSk7XG4gIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycyB8fCAodm5vZGUuZGlycyA9IFtdKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IFtkaXIsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyA9IEVNUFRZX09CSl0gPSBkaXJlY3RpdmVzW2ldO1xuICAgIGlmIChkaXIpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGRpcikpIHtcbiAgICAgICAgZGlyID0ge1xuICAgICAgICAgIG1vdW50ZWQ6IGRpcixcbiAgICAgICAgICB1cGRhdGVkOiBkaXJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXIuZGVlcCkge1xuICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBiaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgZGlyLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9sZFZhbHVlOiB2b2lkIDAsXG4gICAgICAgIGFyZyxcbiAgICAgICAgbW9kaWZpZXJzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZub2RlO1xufVxuZnVuY3Rpb24gaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgcHJldlZOb2RlLCBpbnN0YW5jZSwgbmFtZSkge1xuICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnM7XG4gIGNvbnN0IG9sZEJpbmRpbmdzID0gcHJldlZOb2RlICYmIHByZXZWTm9kZS5kaXJzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgIGlmIChvbGRCaW5kaW5ncykge1xuICAgICAgYmluZGluZy5vbGRWYWx1ZSA9IG9sZEJpbmRpbmdzW2ldLnZhbHVlO1xuICAgIH1cbiAgICBsZXQgaG9vayA9IGJpbmRpbmcuZGlyW25hbWVdO1xuICAgIGlmIChob29rKSB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOCwgW1xuICAgICAgICB2bm9kZS5lbCxcbiAgICAgICAgYmluZGluZyxcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIHByZXZWTm9kZVxuICAgICAgXSk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGlmICghY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRJbnN0YW5jZS5pc01vdW50ZWQpIHtcbiAgICAgIHdhcm4kMShgcHJvdmlkZSgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkuYCk7XG4gICAgfVxuICB9XG4gIGlmIChjdXJyZW50SW5zdGFuY2UpIHtcbiAgICBsZXQgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXM7XG4gICAgY29uc3QgcGFyZW50UHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucGFyZW50ICYmIGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XG4gICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBwcm92aWRlcykge1xuICAgICAgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3ZpZGVzKTtcbiAgICB9XG4gICAgcHJvdmlkZXNba2V5XSA9IHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9IGZhbHNlKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmIChpbnN0YW5jZSB8fCBjdXJyZW50QXBwKSB7XG4gICAgbGV0IHByb3ZpZGVzID0gY3VycmVudEFwcCA/IGN1cnJlbnRBcHAuX2NvbnRleHQucHJvdmlkZXMgOiBpbnN0YW5jZSA/IGluc3RhbmNlLnBhcmVudCA9PSBudWxsIHx8IGluc3RhbmNlLmNlID8gaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dCAmJiBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0LnByb3ZpZGVzIDogaW5zdGFuY2UucGFyZW50LnByb3ZpZGVzIDogdm9pZCAwO1xuICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcbiAgICAgIHJldHVybiBwcm92aWRlc1trZXldO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlLmNhbGwoaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHkpIDogZGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBpbmplY3Rpb24gXCIke1N0cmluZyhrZXkpfVwiIG5vdCBmb3VuZC5gKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShgaW5qZWN0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKSBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMuYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0luamVjdGlvbkNvbnRleHQoKSB7XG4gIHJldHVybiAhIShnZXRDdXJyZW50SW5zdGFuY2UoKSB8fCBjdXJyZW50QXBwKTtcbn1cblxuY29uc3Qgc3NyQ29udGV4dEtleSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwidi1zY3hcIik7XG5jb25zdCB1c2VTU1JDb250ZXh0ID0gKCkgPT4ge1xuICB7XG4gICAgY29uc3QgY3R4ID0gaW5qZWN0KHNzckNvbnRleHRLZXkpO1xuICAgIGlmICghY3R4KSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcbiAgICAgICAgYFNlcnZlciByZW5kZXJpbmcgY29udGV4dCBub3QgcHJvdmlkZWQuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgdXNlU1NSQ29udGV4dCgpIGNvbmRpdGlvbmFsbHkgaW4gdGhlIHNlcnZlciBidWlsZC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY3R4O1xuICB9XG59O1xuXG5mdW5jdGlvbiB3YXRjaEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHdhdGNoUG9zdEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvV2F0Y2goXG4gICAgZWZmZWN0LFxuICAgIG51bGwsXG4gICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGV4dGVuZCh7fSwgb3B0aW9ucywgeyBmbHVzaDogXCJwb3N0XCIgfSkgOiB7IGZsdXNoOiBcInBvc3RcIiB9XG4gICk7XG59XG5mdW5jdGlvbiB3YXRjaFN5bmNFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkb1dhdGNoKFxuICAgIGVmZmVjdCxcbiAgICBudWxsLFxuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBleHRlbmQoe30sIG9wdGlvbnMsIHsgZmx1c2g6IFwic3luY1wiIH0pIDogeyBmbHVzaDogXCJzeW5jXCIgfVxuICApO1xufVxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNGdW5jdGlvbihjYikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgXFxgd2F0Y2goZm4sIG9wdGlvbnM/KVxcYCBzaWduYXR1cmUgaGFzIGJlZW4gbW92ZWQgdG8gYSBzZXBhcmF0ZSBBUEkuIFVzZSBcXGB3YXRjaEVmZmVjdChmbiwgb3B0aW9ucz8pXFxgIGluc3RlYWQuIFxcYHdhdGNoXFxgIG5vdyBvbmx5IHN1cHBvcnRzIFxcYHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGRvV2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcbiAgY29uc3QgeyBpbW1lZGlhdGUsIGRlZXAsIGZsdXNoLCBvbmNlIH0gPSBvcHRpb25zO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY2IpIHtcbiAgICBpZiAoaW1tZWRpYXRlICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYHdhdGNoKCkgXCJpbW1lZGlhdGVcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGVlcCAhPT0gdm9pZCAwKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvbmNlICE9PSB2b2lkIDApIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYHdhdGNoKCkgXCJvbmNlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgYmFzZVdhdGNoT3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSBiYXNlV2F0Y2hPcHRpb25zLm9uV2FybiA9IHdhcm4kMTtcbiAgY29uc3QgcnVuc0ltbWVkaWF0ZWx5ID0gY2IgJiYgaW1tZWRpYXRlIHx8ICFjYiAmJiBmbHVzaCAhPT0gXCJwb3N0XCI7XG4gIGxldCBzc3JDbGVhbnVwO1xuICBpZiAoaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgaWYgKGZsdXNoID09PSBcInN5bmNcIikge1xuICAgICAgY29uc3QgY3R4ID0gdXNlU1NSQ29udGV4dCgpO1xuICAgICAgc3NyQ2xlYW51cCA9IGN0eC5fX3dhdGNoZXJIYW5kbGVzIHx8IChjdHguX193YXRjaGVySGFuZGxlcyA9IFtdKTtcbiAgICB9IGVsc2UgaWYgKCFydW5zSW1tZWRpYXRlbHkpIHtcbiAgICAgIGNvbnN0IHdhdGNoU3RvcEhhbmRsZSA9ICgpID0+IHtcbiAgICAgIH07XG4gICAgICB3YXRjaFN0b3BIYW5kbGUuc3RvcCA9IE5PT1A7XG4gICAgICB3YXRjaFN0b3BIYW5kbGUucmVzdW1lID0gTk9PUDtcbiAgICAgIHdhdGNoU3RvcEhhbmRsZS5wYXVzZSA9IE5PT1A7XG4gICAgICByZXR1cm4gd2F0Y2hTdG9wSGFuZGxlO1xuICAgIH1cbiAgfVxuICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgYmFzZVdhdGNoT3B0aW9ucy5jYWxsID0gKGZuLCB0eXBlLCBhcmdzKSA9PiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpO1xuICBsZXQgaXNQcmUgPSBmYWxzZTtcbiAgaWYgKGZsdXNoID09PSBcInBvc3RcIikge1xuICAgIGJhc2VXYXRjaE9wdGlvbnMuc2NoZWR1bGVyID0gKGpvYikgPT4ge1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGpvYiwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoZmx1c2ggIT09IFwic3luY1wiKSB7XG4gICAgaXNQcmUgPSB0cnVlO1xuICAgIGJhc2VXYXRjaE9wdGlvbnMuc2NoZWR1bGVyID0gKGpvYiwgaXNGaXJzdFJ1bikgPT4ge1xuICAgICAgaWYgKGlzRmlyc3RSdW4pIHtcbiAgICAgICAgam9iKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUpvYihqb2IpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYmFzZVdhdGNoT3B0aW9ucy5hdWdtZW50Sm9iID0gKGpvYikgPT4ge1xuICAgIGlmIChjYikge1xuICAgICAgam9iLmZsYWdzIHw9IDQ7XG4gICAgfVxuICAgIGlmIChpc1ByZSkge1xuICAgICAgam9iLmZsYWdzIHw9IDI7XG4gICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgam9iLmlkID0gaW5zdGFuY2UudWlkO1xuICAgICAgICBqb2IuaSA9IGluc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3Qgd2F0Y2hIYW5kbGUgPSB3YXRjaCQxKHNvdXJjZSwgY2IsIGJhc2VXYXRjaE9wdGlvbnMpO1xuICBpZiAoaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgaWYgKHNzckNsZWFudXApIHtcbiAgICAgIHNzckNsZWFudXAucHVzaCh3YXRjaEhhbmRsZSk7XG4gICAgfSBlbHNlIGlmIChydW5zSW1tZWRpYXRlbHkpIHtcbiAgICAgIHdhdGNoSGFuZGxlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB3YXRjaEhhbmRsZTtcbn1cbmZ1bmN0aW9uIGluc3RhbmNlV2F0Y2goc291cmNlLCB2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCBwdWJsaWNUaGlzID0gdGhpcy5wcm94eTtcbiAgY29uc3QgZ2V0dGVyID0gaXNTdHJpbmcoc291cmNlKSA/IHNvdXJjZS5pbmNsdWRlcyhcIi5cIikgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIHNvdXJjZSkgOiAoKSA9PiBwdWJsaWNUaGlzW3NvdXJjZV0gOiBzb3VyY2UuYmluZChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcbiAgbGV0IGNiO1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBjYiA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGNiID0gdmFsdWUuaGFuZGxlcjtcbiAgICBvcHRpb25zID0gdmFsdWU7XG4gIH1cbiAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UodGhpcyk7XG4gIGNvbnN0IHJlcyA9IGRvV2F0Y2goZ2V0dGVyLCBjYi5iaW5kKHB1YmxpY1RoaXMpLCBvcHRpb25zKTtcbiAgcmVzZXQoKTtcbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhHZXR0ZXIoY3R4LCBwYXRoKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IGN1ciA9IGN0eDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xuICAgICAgY3VyID0gY3VyW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cjtcbiAgfTtcbn1cblxuY29uc3QgVGVsZXBvcnRFbmRLZXkgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKFwiX3Z0ZVwiKTtcbmNvbnN0IGlzVGVsZXBvcnQgPSAodHlwZSkgPT4gdHlwZS5fX2lzVGVsZXBvcnQ7XG5jb25zdCBpc1RlbGVwb3J0RGlzYWJsZWQgPSAocHJvcHMpID0+IHByb3BzICYmIChwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5kaXNhYmxlZCA9PT0gXCJcIik7XG5jb25zdCBpc1RlbGVwb3J0RGVmZXJyZWQgPSAocHJvcHMpID0+IHByb3BzICYmIChwcm9wcy5kZWZlciB8fCBwcm9wcy5kZWZlciA9PT0gXCJcIik7XG5jb25zdCBpc1RhcmdldFNWRyA9ICh0YXJnZXQpID0+IHR5cGVvZiBTVkdFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG5jb25zdCBpc1RhcmdldE1hdGhNTCA9ICh0YXJnZXQpID0+IHR5cGVvZiBNYXRoTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgdGFyZ2V0IGluc3RhbmNlb2YgTWF0aE1MRWxlbWVudDtcbmNvbnN0IHJlc29sdmVUYXJnZXQgPSAocHJvcHMsIHNlbGVjdCkgPT4ge1xuICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHByb3BzICYmIHByb3BzLnRvO1xuICBpZiAoaXNTdHJpbmcodGFyZ2V0U2VsZWN0b3IpKSB7XG4gICAgaWYgKCFzZWxlY3QpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxuICAgICAgICBgQ3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmluZyB0YXJnZXQgZm9yIFRlbGVwb3J0cy4gKG1pc3NpbmcgcXVlcnlTZWxlY3RvciByZW5kZXJlciBvcHRpb24pYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBzZWxlY3QodGFyZ2V0U2VsZWN0b3IpO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXRhcmdldCAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYEZhaWxlZCB0byBsb2NhdGUgVGVsZXBvcnQgdGFyZ2V0IHdpdGggc2VsZWN0b3IgXCIke3RhcmdldFNlbGVjdG9yfVwiLiBOb3RlIHRoZSB0YXJnZXQgZWxlbWVudCBtdXN0IGV4aXN0IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgLSBpLmUuIHRoZSB0YXJnZXQgY2Fubm90IGJlIHJlbmRlcmVkIGJ5IHRoZSBjb21wb25lbnQgaXRzZWxmLCBhbmQgaWRlYWxseSBzaG91bGQgYmUgb3V0c2lkZSBvZiB0aGUgZW50aXJlIFZ1ZSBjb21wb25lbnQgdHJlZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhdGFyZ2V0U2VsZWN0b3IgJiYgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICAgIHdhcm4kMShgSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQ6ICR7dGFyZ2V0U2VsZWN0b3J9YCk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRTZWxlY3RvcjtcbiAgfVxufTtcbmNvbnN0IFRlbGVwb3J0SW1wbCA9IHtcbiAgbmFtZTogXCJUZWxlcG9ydFwiLFxuICBfX2lzVGVsZXBvcnQ6IHRydWUsXG4gIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWM6IG1vdW50Q2hpbGRyZW4sXG4gICAgICBwYzogcGF0Y2hDaGlsZHJlbixcbiAgICAgIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLFxuICAgICAgbzogeyBpbnNlcnQsIHF1ZXJ5U2VsZWN0b3IsIGNyZWF0ZVRleHQsIGNyZWF0ZUNvbW1lbnQgfVxuICAgIH0gPSBpbnRlcm5hbHM7XG4gICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjIucHJvcHMpO1xuICAgIGxldCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiB9ID0gbjI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBuMi5lbCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVDb21tZW50KFwidGVsZXBvcnQgc3RhcnRcIikgOiBjcmVhdGVUZXh0KFwiXCIpO1xuICAgICAgY29uc3QgbWFpbkFuY2hvciA9IG4yLmFuY2hvciA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVDb21tZW50KFwidGVsZXBvcnQgZW5kXCIpIDogY3JlYXRlVGV4dChcIlwiKTtcbiAgICAgIGluc2VydChwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KG1haW5BbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGNvbnN0IG1vdW50ID0gKGNvbnRhaW5lcjIsIGFuY2hvcjIpID0+IHtcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgICAgbW91bnRDaGlsZHJlbihcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgY29udGFpbmVyMixcbiAgICAgICAgICAgIGFuY2hvcjIsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBtb3VudFRvVGFyZ2V0ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBuMi50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KG4yLnByb3BzLCBxdWVyeVNlbGVjdG9yKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gcHJlcGFyZUFuY2hvcih0YXJnZXQsIG4yLCBjcmVhdGVUZXh0LCBpbnNlcnQpO1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKG5hbWVzcGFjZSAhPT0gXCJzdmdcIiAmJiBpc1RhcmdldFNWRyh0YXJnZXQpKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBcInN2Z1wiO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlICE9PSBcIm1hdGhtbFwiICYmIGlzVGFyZ2V0TWF0aE1MKHRhcmdldCkpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IFwibWF0aG1sXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LmlzQ0UpIHtcbiAgICAgICAgICAgIChwYXJlbnRDb21wb25lbnQuY2UuX3RlbGVwb3J0VGFyZ2V0cyB8fCAocGFyZW50Q29tcG9uZW50LmNlLl90ZWxlcG9ydFRhcmdldHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSkuYWRkKHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIG1vdW50KHRhcmdldCwgdGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgICAgIHVwZGF0ZUNzc1ZhcnMobjIsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhZGlzYWJsZWQpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBcIkludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIG1vdW50OlwiLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgYCgke3R5cGVvZiB0YXJnZXR9KWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIG1vdW50KGNvbnRhaW5lciwgbWFpbkFuY2hvcik7XG4gICAgICAgIHVwZGF0ZUNzc1ZhcnMobjIsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzVGVsZXBvcnREZWZlcnJlZChuMi5wcm9wcykpIHtcbiAgICAgICAgbjIuZWwuX19pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICBtb3VudFRvVGFyZ2V0KCk7XG4gICAgICAgICAgZGVsZXRlIG4yLmVsLl9faXNNb3VudGVkO1xuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudFRvVGFyZ2V0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RlbGVwb3J0RGVmZXJyZWQobjIucHJvcHMpICYmIG4xLmVsLl9faXNNb3VudGVkID09PSBmYWxzZSkge1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgIFRlbGVwb3J0SW1wbC5wcm9jZXNzKFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkLFxuICAgICAgICAgICAgaW50ZXJuYWxzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgbjIudGFyZ2V0U3RhcnQgPSBuMS50YXJnZXRTdGFydDtcbiAgICAgIGNvbnN0IG1haW5BbmNob3IgPSBuMi5hbmNob3IgPSBuMS5hbmNob3I7XG4gICAgICBjb25zdCB0YXJnZXQgPSBuMi50YXJnZXQgPSBuMS50YXJnZXQ7XG4gICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSBuMi50YXJnZXRBbmNob3IgPSBuMS50YXJnZXRBbmNob3I7XG4gICAgICBjb25zdCB3YXNEaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMS5wcm9wcyk7XG4gICAgICBjb25zdCBjdXJyZW50Q29udGFpbmVyID0gd2FzRGlzYWJsZWQgPyBjb250YWluZXIgOiB0YXJnZXQ7XG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yID0gd2FzRGlzYWJsZWQgPyBtYWluQW5jaG9yIDogdGFyZ2V0QW5jaG9yO1xuICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJzdmdcIiB8fCBpc1RhcmdldFNWRyh0YXJnZXQpKSB7XG4gICAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIiB8fCBpc1RhcmdldE1hdGhNTCh0YXJnZXQpKSB7XG4gICAgICAgIG5hbWVzcGFjZSA9IFwibWF0aG1sXCI7XG4gICAgICB9XG4gICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihcbiAgICAgICAgICBuMS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICAgIGN1cnJlbnRDb250YWluZXIsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICAgKTtcbiAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsICEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKTtcbiAgICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCkge1xuICAgICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGN1cnJlbnRDb250YWluZXIsXG4gICAgICAgICAgY3VycmVudEFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIGlmICghd2FzRGlzYWJsZWQpIHtcbiAgICAgICAgICBtb3ZlVGVsZXBvcnQoXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIG1haW5BbmNob3IsXG4gICAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgICAxXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobjIucHJvcHMgJiYgbjEucHJvcHMgJiYgbjIucHJvcHMudG8gIT09IG4xLnByb3BzLnRvKSB7XG4gICAgICAgICAgICBuMi5wcm9wcy50byA9IG4xLnByb3BzLnRvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKChuMi5wcm9wcyAmJiBuMi5wcm9wcy50bykgIT09IChuMS5wcm9wcyAmJiBuMS5wcm9wcy50bykpIHtcbiAgICAgICAgICBjb25zdCBuZXh0VGFyZ2V0ID0gbjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChcbiAgICAgICAgICAgIG4yLnByb3BzLFxuICAgICAgICAgICAgcXVlcnlTZWxlY3RvclxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5leHRUYXJnZXQpIHtcbiAgICAgICAgICAgIG1vdmVUZWxlcG9ydChcbiAgICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICAgIG5leHRUYXJnZXQsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGludGVybmFscyxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIFRlbGVwb3J0IHRhcmdldCBvbiB1cGRhdGU6XCIsXG4gICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgYCgke3R5cGVvZiB0YXJnZXR9KWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHdhc0Rpc2FibGVkKSB7XG4gICAgICAgICAgbW92ZVRlbGVwb3J0KFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICB0YXJnZXRBbmNob3IsXG4gICAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgICAxXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlQ3NzVmFycyhuMiwgZGlzYWJsZWQpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB7IHVtOiB1bm1vdW50LCBvOiB7IHJlbW92ZTogaG9zdFJlbW92ZSB9IH0sIGRvUmVtb3ZlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2hhcGVGbGFnLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBhbmNob3IsXG4gICAgICB0YXJnZXRTdGFydCxcbiAgICAgIHRhcmdldEFuY2hvcixcbiAgICAgIHRhcmdldCxcbiAgICAgIHByb3BzXG4gICAgfSA9IHZub2RlO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGhvc3RSZW1vdmUodGFyZ2V0U3RhcnQpO1xuICAgICAgaG9zdFJlbW92ZSh0YXJnZXRBbmNob3IpO1xuICAgIH1cbiAgICBkb1JlbW92ZSAmJiBob3N0UmVtb3ZlKGFuY2hvcik7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICBjb25zdCBzaG91bGRSZW1vdmUgPSBkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgdW5tb3VudChcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2hvdWxkUmVtb3ZlLFxuICAgICAgICAgICEhY2hpbGQuZHluYW1pY0NoaWxkcmVuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3ZlOiBtb3ZlVGVsZXBvcnQsXG4gIGh5ZHJhdGU6IGh5ZHJhdGVUZWxlcG9ydFxufTtcbmZ1bmN0aW9uIG1vdmVUZWxlcG9ydCh2bm9kZSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHsgbzogeyBpbnNlcnQgfSwgbTogbW92ZSB9LCBtb3ZlVHlwZSA9IDIpIHtcbiAgaWYgKG1vdmVUeXBlID09PSAwKSB7XG4gICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG4gIGNvbnN0IHsgZWwsIGFuY2hvciwgc2hhcGVGbGFnLCBjaGlsZHJlbiwgcHJvcHMgfSA9IHZub2RlO1xuICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMjtcbiAgaWYgKGlzUmVvcmRlcikge1xuICAgIGluc2VydChlbCwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICB9XG4gIGlmICghaXNSZW9yZGVyIHx8IGlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW92ZShcbiAgICAgICAgICBjaGlsZHJlbltpXSxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgcGFyZW50QW5jaG9yLFxuICAgICAgICAgIDJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGlzUmVvcmRlcikge1xuICAgIGluc2VydChhbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gaHlkcmF0ZVRlbGVwb3J0KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwge1xuICBvOiB7IG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCBxdWVyeVNlbGVjdG9yLCBpbnNlcnQsIGNyZWF0ZVRleHQgfVxufSwgaHlkcmF0ZUNoaWxkcmVuKSB7XG4gIGZ1bmN0aW9uIGh5ZHJhdGVEaXNhYmxlZFRlbGVwb3J0KG5vZGUyLCB2bm9kZTIsIHRhcmdldFN0YXJ0LCB0YXJnZXRBbmNob3IpIHtcbiAgICB2bm9kZTIuYW5jaG9yID0gaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgbmV4dFNpYmxpbmcobm9kZTIpLFxuICAgICAgdm5vZGUyLFxuICAgICAgcGFyZW50Tm9kZShub2RlMiksXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgIG9wdGltaXplZFxuICAgICk7XG4gICAgdm5vZGUyLnRhcmdldFN0YXJ0ID0gdGFyZ2V0U3RhcnQ7XG4gICAgdm5vZGUyLnRhcmdldEFuY2hvciA9IHRhcmdldEFuY2hvcjtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSB2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KFxuICAgIHZub2RlLnByb3BzLFxuICAgIHF1ZXJ5U2VsZWN0b3JcbiAgKTtcbiAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQodm5vZGUucHJvcHMpO1xuICBpZiAodGFyZ2V0KSB7XG4gICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldC5fbHBhIHx8IHRhcmdldC5maXJzdENoaWxkO1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxNikge1xuICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIGh5ZHJhdGVEaXNhYmxlZFRlbGVwb3J0KFxuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgdGFyZ2V0Tm9kZSxcbiAgICAgICAgICB0YXJnZXROb2RlICYmIG5leHRTaWJsaW5nKHRhcmdldE5vZGUpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgbGV0IHRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XG4gICAgICAgIHdoaWxlICh0YXJnZXRBbmNob3IpIHtcbiAgICAgICAgICBpZiAodGFyZ2V0QW5jaG9yICYmIHRhcmdldEFuY2hvci5ub2RlVHlwZSA9PT0gOCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldEFuY2hvci5kYXRhID09PSBcInRlbGVwb3J0IHN0YXJ0IGFuY2hvclwiKSB7XG4gICAgICAgICAgICAgIHZub2RlLnRhcmdldFN0YXJ0ID0gdGFyZ2V0QW5jaG9yO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRBbmNob3IuZGF0YSA9PT0gXCJ0ZWxlcG9ydCBhbmNob3JcIikge1xuICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXRBbmNob3I7XG4gICAgICAgICAgICAgIHRhcmdldC5fbHBhID0gdm5vZGUudGFyZ2V0QW5jaG9yICYmIG5leHRTaWJsaW5nKHZub2RlLnRhcmdldEFuY2hvcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXRBbmNob3IgPSBuZXh0U2libGluZyh0YXJnZXRBbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdm5vZGUudGFyZ2V0QW5jaG9yKSB7XG4gICAgICAgICAgcHJlcGFyZUFuY2hvcih0YXJnZXQsIHZub2RlLCBjcmVhdGVUZXh0LCBpbnNlcnQpO1xuICAgICAgICB9XG4gICAgICAgIGh5ZHJhdGVDaGlsZHJlbihcbiAgICAgICAgICB0YXJnZXROb2RlICYmIG5leHRTaWJsaW5nKHRhcmdldE5vZGUpLFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVDc3NWYXJzKHZub2RlLCBkaXNhYmxlZCk7XG4gIH0gZWxzZSBpZiAoZGlzYWJsZWQpIHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIGh5ZHJhdGVEaXNhYmxlZFRlbGVwb3J0KG5vZGUsIHZub2RlLCBub2RlLCBuZXh0U2libGluZyhub2RlKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2bm9kZS5hbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yKTtcbn1cbmNvbnN0IFRlbGVwb3J0ID0gVGVsZXBvcnRJbXBsO1xuZnVuY3Rpb24gdXBkYXRlQ3NzVmFycyh2bm9kZSwgaXNEaXNhYmxlZCkge1xuICBjb25zdCBjdHggPSB2bm9kZS5jdHg7XG4gIGlmIChjdHggJiYgY3R4LnV0KSB7XG4gICAgbGV0IG5vZGUsIGFuY2hvcjtcbiAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgbm9kZSA9IHZub2RlLmVsO1xuICAgICAgYW5jaG9yID0gdm5vZGUuYW5jaG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gdm5vZGUudGFyZ2V0U3RhcnQ7XG4gICAgICBhbmNob3IgPSB2bm9kZS50YXJnZXRBbmNob3I7XG4gICAgfVxuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IGFuY2hvcikge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIG5vZGUuc2V0QXR0cmlidXRlKFwiZGF0YS12LW93bmVyXCIsIGN0eC51aWQpO1xuICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIGN0eC51dCgpO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlQW5jaG9yKHRhcmdldCwgdm5vZGUsIGNyZWF0ZVRleHQsIGluc2VydCkge1xuICBjb25zdCB0YXJnZXRTdGFydCA9IHZub2RlLnRhcmdldFN0YXJ0ID0gY3JlYXRlVGV4dChcIlwiKTtcbiAgY29uc3QgdGFyZ2V0QW5jaG9yID0gdm5vZGUudGFyZ2V0QW5jaG9yID0gY3JlYXRlVGV4dChcIlwiKTtcbiAgdGFyZ2V0U3RhcnRbVGVsZXBvcnRFbmRLZXldID0gdGFyZ2V0QW5jaG9yO1xuICBpZiAodGFyZ2V0KSB7XG4gICAgaW5zZXJ0KHRhcmdldFN0YXJ0LCB0YXJnZXQpO1xuICAgIGluc2VydCh0YXJnZXRBbmNob3IsIHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldEFuY2hvcjtcbn1cblxuY29uc3QgbGVhdmVDYktleSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXCJfbGVhdmVDYlwiKTtcbmNvbnN0IGVudGVyQ2JLZXkgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKFwiX2VudGVyQ2JcIik7XG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3RhdGUoKSB7XG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgaXNMZWF2aW5nOiBmYWxzZSxcbiAgICBpc1VubW91bnRpbmc6IGZhbHNlLFxuICAgIGxlYXZpbmdWTm9kZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgfTtcbiAgb25Nb3VudGVkKCgpID0+IHtcbiAgICBzdGF0ZS5pc01vdW50ZWQgPSB0cnVlO1xuICB9KTtcbiAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICBzdGF0ZS5pc1VubW91bnRpbmcgPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuY29uc3QgVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IgPSBbRnVuY3Rpb24sIEFycmF5XTtcbmNvbnN0IEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0ge1xuICBtb2RlOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgcGVyc2lzdGVkOiBCb29sZWFuLFxuICAvLyBlbnRlclxuICBvbkJlZm9yZUVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25FbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQWZ0ZXJFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uRW50ZXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAvLyBsZWF2ZVxuICBvbkJlZm9yZUxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgb25MZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQWZ0ZXJMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uTGVhdmVDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAvLyBhcHBlYXJcbiAgb25CZWZvcmVBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gIG9uQWZ0ZXJBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICBvbkFwcGVhckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3Jcbn07XG5jb25zdCByZWN1cnNpdmVHZXRTdWJ0cmVlID0gKGluc3RhbmNlKSA9PiB7XG4gIGNvbnN0IHN1YlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICByZXR1cm4gc3ViVHJlZS5jb21wb25lbnQgPyByZWN1cnNpdmVHZXRTdWJ0cmVlKHN1YlRyZWUuY29tcG9uZW50KSA6IHN1YlRyZWU7XG59O1xuY29uc3QgQmFzZVRyYW5zaXRpb25JbXBsID0ge1xuICBuYW1lOiBgQmFzZVRyYW5zaXRpb25gLFxuICBwcm9wczogQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpLCB0cnVlKTtcbiAgICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZCA9IGZpbmROb25Db21tZW50Q2hpbGQoY2hpbGRyZW4pO1xuICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgICBjb25zdCB7IG1vZGUgfSA9IHJhd1Byb3BzO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbW9kZSAmJiBtb2RlICE9PSBcImluLW91dFwiICYmIG1vZGUgIT09IFwib3V0LWluXCIgJiYgbW9kZSAhPT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgd2FybiQxKGBpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAke21vZGV9YCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaXNMZWF2aW5nKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlubmVyQ2hpbGQgPSBnZXRJbm5lckNoaWxkJDEoY2hpbGQpO1xuICAgICAgaWYgKCFpbm5lckNoaWxkKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGxldCBlbnRlckhvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgaW5uZXJDaGlsZCxcbiAgICAgICAgcmF3UHJvcHMsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgLy8gIzExMDYxLCBlbnN1cmUgZW50ZXJIb29rcyBpcyBmcmVzaCBhZnRlciBjbG9uZVxuICAgICAgICAoaG9va3MpID0+IGVudGVySG9va3MgPSBob29rc1xuICAgICAgKTtcbiAgICAgIGlmIChpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIGVudGVySG9va3MpO1xuICAgICAgfVxuICAgICAgbGV0IG9sZElubmVyQ2hpbGQgPSBpbnN0YW5jZS5zdWJUcmVlICYmIGdldElubmVyQ2hpbGQkMShpbnN0YW5jZS5zdWJUcmVlKTtcbiAgICAgIGlmIChvbGRJbm5lckNoaWxkICYmIG9sZElubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCAmJiAhaXNTYW1lVk5vZGVUeXBlKG9sZElubmVyQ2hpbGQsIGlubmVyQ2hpbGQpICYmIHJlY3Vyc2l2ZUdldFN1YnRyZWUoaW5zdGFuY2UpLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgbGV0IGxlYXZpbmdIb29rcyA9IHJlc29sdmVUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgb2xkSW5uZXJDaGlsZCxcbiAgICAgICAgICByYXdQcm9wcyxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICApO1xuICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgbGVhdmluZ0hvb2tzKTtcbiAgICAgICAgaWYgKG1vZGUgPT09IFwib3V0LWluXCIgJiYgaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgICBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCEoaW5zdGFuY2Uuam9iLmZsYWdzICYgOCkpIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgbGVhdmluZ0hvb2tzLmFmdGVyTGVhdmU7XG4gICAgICAgICAgICBvbGRJbm5lckNoaWxkID0gdm9pZCAwO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiaW4tb3V0XCIgJiYgaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgICAgbGVhdmluZ0hvb2tzLmRlbGF5TGVhdmUgPSAoZWwsIGVhcmx5UmVtb3ZlLCBkZWxheWVkTGVhdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW1N0cmluZyhvbGRJbm5lckNoaWxkLmtleSldID0gb2xkSW5uZXJDaGlsZDtcbiAgICAgICAgICAgIGVsW2xlYXZlQ2JLZXldID0gKCkgPT4ge1xuICAgICAgICAgICAgICBlYXJseVJlbW92ZSgpO1xuICAgICAgICAgICAgICBlbFtsZWF2ZUNiS2V5XSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgZGVsZXRlIGVudGVySG9va3MuZGVsYXllZExlYXZlO1xuICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkID0gdm9pZCAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVudGVySG9va3MuZGVsYXllZExlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICBkZWxheWVkTGVhdmUoKTtcbiAgICAgICAgICAgICAgZGVsZXRlIGVudGVySG9va3MuZGVsYXllZExlYXZlO1xuICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkID0gdm9pZCAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZElubmVyQ2hpbGQgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2xkSW5uZXJDaGlsZCkge1xuICAgICAgICBvbGRJbm5lckNoaWxkID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBmaW5kTm9uQ29tbWVudENoaWxkKGNoaWxkcmVuKSB7XG4gIGxldCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgIGxldCBoYXNGb3VuZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgYyBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKGMudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBoYXNGb3VuZCkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIFwiPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudCBvciBjb21wb25lbnQuIFVzZSA8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGM7XG4gICAgICAgIGhhc0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKCEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkO1xufVxuY29uc3QgQmFzZVRyYW5zaXRpb24gPSBCYXNlVHJhbnNpdGlvbkltcGw7XG5mdW5jdGlvbiBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSkge1xuICBjb25zdCB7IGxlYXZpbmdWTm9kZXMgfSA9IHN0YXRlO1xuICBsZXQgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gbGVhdmluZ1ZOb2Rlcy5nZXQodm5vZGUudHlwZSk7XG4gIGlmICghbGVhdmluZ1ZOb2Rlc0NhY2hlKSB7XG4gICAgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGVhdmluZ1ZOb2Rlcy5zZXQodm5vZGUudHlwZSwgbGVhdmluZ1ZOb2Rlc0NhY2hlKTtcbiAgfVxuICByZXR1cm4gbGVhdmluZ1ZOb2Rlc0NhY2hlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyh2bm9kZSwgcHJvcHMsIHN0YXRlLCBpbnN0YW5jZSwgcG9zdENsb25lKSB7XG4gIGNvbnN0IHtcbiAgICBhcHBlYXIsXG4gICAgbW9kZSxcbiAgICBwZXJzaXN0ZWQgPSBmYWxzZSxcbiAgICBvbkJlZm9yZUVudGVyLFxuICAgIG9uRW50ZXIsXG4gICAgb25BZnRlckVudGVyLFxuICAgIG9uRW50ZXJDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVMZWF2ZSxcbiAgICBvbkxlYXZlLFxuICAgIG9uQWZ0ZXJMZWF2ZSxcbiAgICBvbkxlYXZlQ2FuY2VsbGVkLFxuICAgIG9uQmVmb3JlQXBwZWFyLFxuICAgIG9uQXBwZWFyLFxuICAgIG9uQWZ0ZXJBcHBlYXIsXG4gICAgb25BcHBlYXJDYW5jZWxsZWRcbiAgfSA9IHByb3BzO1xuICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpO1xuICBjb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgaG9vayAmJiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIGhvb2ssXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIDksXG4gICAgICBhcmdzXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgY2FsbEFzeW5jSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgY29uc3QgZG9uZSA9IGFyZ3NbMV07XG4gICAgY2FsbEhvb2soaG9vaywgYXJncyk7XG4gICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgIGlmIChob29rLmV2ZXJ5KChob29rMikgPT4gaG9vazIubGVuZ3RoIDw9IDEpKSBkb25lKCk7XG4gICAgfSBlbHNlIGlmIChob29rLmxlbmd0aCA8PSAxKSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBob29rcyA9IHtcbiAgICBtb2RlLFxuICAgIHBlcnNpc3RlZCxcbiAgICBiZWZvcmVFbnRlcihlbCkge1xuICAgICAgbGV0IGhvb2sgPSBvbkJlZm9yZUVudGVyO1xuICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICAgIGhvb2sgPSBvbkJlZm9yZUFwcGVhciB8fCBvbkJlZm9yZUVudGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVsW2xlYXZlQ2JLZXldKSB7XG4gICAgICAgIGVsW2xlYXZlQ2JLZXldKFxuICAgICAgICAgIHRydWVcbiAgICAgICAgICAvKiBjYW5jZWxsZWQgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZSA9IGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xuICAgICAgaWYgKGxlYXZpbmdWTm9kZSAmJiBpc1NhbWVWTm9kZVR5cGUodm5vZGUsIGxlYXZpbmdWTm9kZSkgJiYgbGVhdmluZ1ZOb2RlLmVsW2xlYXZlQ2JLZXldKSB7XG4gICAgICAgIGxlYXZpbmdWTm9kZS5lbFtsZWF2ZUNiS2V5XSgpO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2soaG9vaywgW2VsXSk7XG4gICAgfSxcbiAgICBlbnRlcihlbCkge1xuICAgICAgbGV0IGhvb2sgPSBvbkVudGVyO1xuICAgICAgbGV0IGFmdGVySG9vayA9IG9uQWZ0ZXJFbnRlcjtcbiAgICAgIGxldCBjYW5jZWxIb29rID0gb25FbnRlckNhbmNlbGxlZDtcbiAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgICBob29rID0gb25BcHBlYXIgfHwgb25FbnRlcjtcbiAgICAgICAgICBhZnRlckhvb2sgPSBvbkFmdGVyQXBwZWFyIHx8IG9uQWZ0ZXJFbnRlcjtcbiAgICAgICAgICBjYW5jZWxIb29rID0gb25BcHBlYXJDYW5jZWxsZWQgfHwgb25FbnRlckNhbmNlbGxlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRvbmUgPSBlbFtlbnRlckNiS2V5XSA9IChjYW5jZWxsZWQpID0+IHtcbiAgICAgICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgY2FsbEhvb2soY2FuY2VsSG9vaywgW2VsXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbEhvb2soYWZ0ZXJIb29rLCBbZWxdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MuZGVsYXllZExlYXZlKSB7XG4gICAgICAgICAgaG9va3MuZGVsYXllZExlYXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxbZW50ZXJDYktleV0gPSB2b2lkIDA7XG4gICAgICB9O1xuICAgICAgaWYgKGhvb2spIHtcbiAgICAgICAgY2FsbEFzeW5jSG9vayhob29rLCBbZWwsIGRvbmVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxlYXZlKGVsLCByZW1vdmUpIHtcbiAgICAgIGNvbnN0IGtleTIgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgICAgIGlmIChlbFtlbnRlckNiS2V5XSkge1xuICAgICAgICBlbFtlbnRlckNiS2V5XShcbiAgICAgICAgICB0cnVlXG4gICAgICAgICAgLyogY2FuY2VsbGVkICovXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaXNVbm1vdW50aW5nKSB7XG4gICAgICAgIHJldHVybiByZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlTGVhdmUsIFtlbF0pO1xuICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgZG9uZSA9IGVsW2xlYXZlQ2JLZXldID0gKGNhbmNlbGxlZCkgPT4ge1xuICAgICAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIHJlbW92ZSgpO1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbEhvb2sob25BZnRlckxlYXZlLCBbZWxdKTtcbiAgICAgICAgfVxuICAgICAgICBlbFtsZWF2ZUNiS2V5XSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGxlYXZpbmdWTm9kZXNDYWNoZVtrZXkyXSA9PT0gdm5vZGUpIHtcbiAgICAgICAgICBkZWxldGUgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleTJdID0gdm5vZGU7XG4gICAgICBpZiAob25MZWF2ZSkge1xuICAgICAgICBjYWxsQXN5bmNIb29rKG9uTGVhdmUsIFtlbCwgZG9uZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xvbmUodm5vZGUyKSB7XG4gICAgICBjb25zdCBob29rczIgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICB2bm9kZTIsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIHBvc3RDbG9uZVxuICAgICAgKTtcbiAgICAgIGlmIChwb3N0Q2xvbmUpIHBvc3RDbG9uZShob29rczIpO1xuICAgICAgcmV0dXJuIGhvb2tzMjtcbiAgICB9XG4gIH07XG4gIHJldHVybiBob29rcztcbn1cbmZ1bmN0aW9uIGVtcHR5UGxhY2Vob2xkZXIodm5vZGUpIHtcbiAgaWYgKGlzS2VlcEFsaXZlKHZub2RlKSkge1xuICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgdm5vZGUuY2hpbGRyZW4gPSBudWxsO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCQxKHZub2RlKSB7XG4gIGlmICghaXNLZWVwQWxpdmUodm5vZGUpKSB7XG4gICAgaWYgKGlzVGVsZXBvcnQodm5vZGUudHlwZSkgJiYgdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBmaW5kTm9uQ29tbWVudENoaWxkKHZub2RlLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG4gIGlmICh2bm9kZS5jb21wb25lbnQpIHtcbiAgICByZXR1cm4gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XG4gIH1cbiAgY29uc3QgeyBzaGFwZUZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5bMF07XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiAzMiAmJiBpc0Z1bmN0aW9uKGNoaWxkcmVuLmRlZmF1bHQpKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW4uZGVmYXVsdCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCBob29rcykge1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNiAmJiB2bm9kZS5jb21wb25lbnQpIHtcbiAgICB2bm9kZS50cmFuc2l0aW9uID0gaG9va3M7XG4gICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBob29rcyk7XG4gIH0gZWxzZSBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgdm5vZGUuc3NDb250ZW50LnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0NvbnRlbnQpO1xuICAgIHZub2RlLnNzRmFsbGJhY2sudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzRmFsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHZub2RlLnRyYW5zaXRpb24gPSBob29rcztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkcmVuLCBrZWVwQ29tbWVudCA9IGZhbHNlLCBwYXJlbnRLZXkpIHtcbiAgbGV0IHJldCA9IFtdO1xuICBsZXQga2V5ZWRGcmFnbWVudENvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IGtleSA9IHBhcmVudEtleSA9PSBudWxsID8gY2hpbGQua2V5IDogU3RyaW5nKHBhcmVudEtleSkgKyBTdHJpbmcoY2hpbGQua2V5ICE9IG51bGwgPyBjaGlsZC5rZXkgOiBpKTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGlmIChjaGlsZC5wYXRjaEZsYWcgJiAxMjgpIGtleWVkRnJhZ21lbnRDb3VudCsrO1xuICAgICAgcmV0ID0gcmV0LmNvbmNhdChcbiAgICAgICAgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkLmNoaWxkcmVuLCBrZWVwQ29tbWVudCwga2V5KVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGtlZXBDb21tZW50IHx8IGNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgIHJldC5wdXNoKGtleSAhPSBudWxsID8gY2xvbmVWTm9kZShjaGlsZCwgeyBrZXkgfSkgOiBjaGlsZCk7XG4gICAgfVxuICB9XG4gIGlmIChrZXllZEZyYWdtZW50Q291bnQgPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldFtpXS5wYXRjaEZsYWcgPSAtMjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChvcHRpb25zLCBleHRyYU9wdGlvbnMpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24ob3B0aW9ucykgPyAoXG4gICAgLy8gIzgyMzY6IGV4dGVuZCBjYWxsIGFuZCBvcHRpb25zLm5hbWUgYWNjZXNzIGFyZSBjb25zaWRlcmVkIHNpZGUtZWZmZWN0c1xuICAgIC8vIGJ5IFJvbGx1cCwgc28gd2UgaGF2ZSB0byB3cmFwIGl0IGluIGEgcHVyZS1hbm5vdGF0ZWQgSUlGRS5cbiAgICAvKiBAX19QVVJFX18gKi8gKCgpID0+IGV4dGVuZCh7IG5hbWU6IG9wdGlvbnMubmFtZSB9LCBleHRyYU9wdGlvbnMsIHsgc2V0dXA6IG9wdGlvbnMgfSkpKClcbiAgKSA6IG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHVzZUlkKCkge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGlmIChpKSB7XG4gICAgcmV0dXJuIChpLmFwcENvbnRleHQuY29uZmlnLmlkUHJlZml4IHx8IFwidlwiKSArIFwiLVwiICsgaS5pZHNbMF0gKyBpLmlkc1sxXSsrO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgdXNlSWQoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIG1hcmtBc3luY0JvdW5kYXJ5KGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLmlkcyA9IFtpbnN0YW5jZS5pZHNbMF0gKyBpbnN0YW5jZS5pZHNbMl0rKyArIFwiLVwiLCAwLCAwXTtcbn1cblxuY29uc3Qga25vd25UZW1wbGF0ZVJlZnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uIHVzZVRlbXBsYXRlUmVmKGtleSkge1xuICBjb25zdCBpID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGNvbnN0IHIgPSBzaGFsbG93UmVmKG51bGwpO1xuICBpZiAoaSkge1xuICAgIGNvbnN0IHJlZnMgPSBpLnJlZnMgPT09IEVNUFRZX09CSiA/IGkucmVmcyA9IHt9IDogaS5yZWZzO1xuICAgIGxldCBkZXNjO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIChkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyZWZzLCBrZXkpKSAmJiAhZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgIHdhcm4kMShgdXNlVGVtcGxhdGVSZWYoJyR7a2V5fScpIGFscmVhZHkgZXhpc3RzLmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVmcywga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gci52YWx1ZSxcbiAgICAgICAgc2V0OiAodmFsKSA9PiByLnZhbHVlID0gdmFsXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShcbiAgICAgIGB1c2VUZW1wbGF0ZVJlZigpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IHJldCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyByZWFkb25seShyKSA6IHI7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAga25vd25UZW1wbGF0ZVJlZnMuYWRkKHJldCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuY29uc3QgcGVuZGluZ1NldFJlZk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc2V0UmVmKHJhd1JlZiwgb2xkUmF3UmVmLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIGlzVW5tb3VudCA9IGZhbHNlKSB7XG4gIGlmIChpc0FycmF5KHJhd1JlZikpIHtcbiAgICByYXdSZWYuZm9yRWFjaChcbiAgICAgIChyLCBpKSA9PiBzZXRSZWYoXG4gICAgICAgIHIsXG4gICAgICAgIG9sZFJhd1JlZiAmJiAoaXNBcnJheShvbGRSYXdSZWYpID8gb2xkUmF3UmVmW2ldIDogb2xkUmF3UmVmKSxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIHZub2RlLFxuICAgICAgICBpc1VubW91bnRcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpICYmICFpc1VubW91bnQpIHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNTEyICYmIHZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkICYmIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLmNvbXBvbmVudCkge1xuICAgICAgc2V0UmVmKHJhd1JlZiwgb2xkUmF3UmVmLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVmVmFsdWUgPSB2bm9kZS5zaGFwZUZsYWcgJiA0ID8gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2Uodm5vZGUuY29tcG9uZW50KSA6IHZub2RlLmVsO1xuICBjb25zdCB2YWx1ZSA9IGlzVW5tb3VudCA/IG51bGwgOiByZWZWYWx1ZTtcbiAgY29uc3QgeyBpOiBvd25lciwgcjogcmVmIH0gPSByYXdSZWY7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFvd25lcikge1xuICAgIHdhcm4kMShcbiAgICAgIGBNaXNzaW5nIHJlZiBvd25lciBjb250ZXh0LiByZWYgY2Fubm90IGJlIHVzZWQgb24gaG9pc3RlZCB2bm9kZXMuIEEgdm5vZGUgd2l0aCByZWYgbXVzdCBiZSBjcmVhdGVkIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uLmBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvbGRSZWYgPSBvbGRSYXdSZWYgJiYgb2xkUmF3UmVmLnI7XG4gIGNvbnN0IHJlZnMgPSBvd25lci5yZWZzID09PSBFTVBUWV9PQkogPyBvd25lci5yZWZzID0ge30gOiBvd25lci5yZWZzO1xuICBjb25zdCBzZXR1cFN0YXRlID0gb3duZXIuc2V0dXBTdGF0ZTtcbiAgY29uc3QgcmF3U2V0dXBTdGF0ZSA9IHRvUmF3KHNldHVwU3RhdGUpO1xuICBjb25zdCBjYW5TZXRTZXR1cFJlZiA9IHNldHVwU3RhdGUgPT09IEVNUFRZX09CSiA/IE5PIDogKGtleSkgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBpZiAoaGFzT3duKHJhd1NldHVwU3RhdGUsIGtleSkgJiYgIWlzUmVmKHJhd1NldHVwU3RhdGVba2V5XSkpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBUZW1wbGF0ZSByZWYgXCIke2tleX1cIiB1c2VkIG9uIGEgbm9uLXJlZiB2YWx1ZS4gSXQgd2lsbCBub3Qgd29yayBpbiB0aGUgcHJvZHVjdGlvbiBidWlsZC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoa25vd25UZW1wbGF0ZVJlZnMuaGFzKHJhd1NldHVwU3RhdGVba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFzT3duKHJhd1NldHVwU3RhdGUsIGtleSk7XG4gIH07XG4gIGNvbnN0IGNhblNldFJlZiA9IChyZWYyKSA9PiB7XG4gICAgcmV0dXJuICEhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8ICFrbm93blRlbXBsYXRlUmVmcy5oYXMocmVmMik7XG4gIH07XG4gIGlmIChvbGRSZWYgIT0gbnVsbCAmJiBvbGRSZWYgIT09IHJlZikge1xuICAgIGludmFsaWRhdGVQZW5kaW5nU2V0UmVmKG9sZFJhd1JlZik7XG4gICAgaWYgKGlzU3RyaW5nKG9sZFJlZikpIHtcbiAgICAgIHJlZnNbb2xkUmVmXSA9IG51bGw7XG4gICAgICBpZiAoY2FuU2V0U2V0dXBSZWYob2xkUmVmKSkge1xuICAgICAgICBzZXR1cFN0YXRlW29sZFJlZl0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNSZWYob2xkUmVmKSkge1xuICAgICAgaWYgKGNhblNldFJlZihvbGRSZWYpKSB7XG4gICAgICAgIG9sZFJlZi52YWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRSYXdSZWZBdG9tID0gb2xkUmF3UmVmO1xuICAgICAgaWYgKG9sZFJhd1JlZkF0b20uaykgcmVmc1tvbGRSYXdSZWZBdG9tLmtdID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24ocmVmKSkge1xuICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhyZWYsIG93bmVyLCAxMiwgW3ZhbHVlLCByZWZzXSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgX2lzU3RyaW5nID0gaXNTdHJpbmcocmVmKTtcbiAgICBjb25zdCBfaXNSZWYgPSBpc1JlZihyZWYpO1xuICAgIGlmIChfaXNTdHJpbmcgfHwgX2lzUmVmKSB7XG4gICAgICBjb25zdCBkb1NldCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHJhd1JlZi5mKSB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBfaXNTdHJpbmcgPyBjYW5TZXRTZXR1cFJlZihyZWYpID8gc2V0dXBTdGF0ZVtyZWZdIDogcmVmc1tyZWZdIDogY2FuU2V0UmVmKHJlZikgfHwgIXJhd1JlZi5rID8gcmVmLnZhbHVlIDogcmVmc1tyYXdSZWYua107XG4gICAgICAgICAgaWYgKGlzVW5tb3VudCkge1xuICAgICAgICAgICAgaXNBcnJheShleGlzdGluZykgJiYgcmVtb3ZlKGV4aXN0aW5nLCByZWZWYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNBcnJheShleGlzdGluZykpIHtcbiAgICAgICAgICAgICAgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGNhblNldFNldHVwUmVmKHJlZikpIHtcbiAgICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHJlZnNbcmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsID0gW3JlZlZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuU2V0UmVmKHJlZikpIHtcbiAgICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5rKSByZWZzW3Jhd1JlZi5rXSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghZXhpc3RpbmcuaW5jbHVkZXMocmVmVmFsdWUpKSB7XG4gICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2gocmVmVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfaXNTdHJpbmcpIHtcbiAgICAgICAgICByZWZzW3JlZl0gPSB2YWx1ZTtcbiAgICAgICAgICBpZiAoY2FuU2V0U2V0dXBSZWYocmVmKSkge1xuICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9pc1JlZikge1xuICAgICAgICAgIGlmIChjYW5TZXRSZWYocmVmKSkge1xuICAgICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyYXdSZWYuaykgcmVmc1tyYXdSZWYua10gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgd2FybiQxKFwiSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTpcIiwgcmVmLCBgKCR7dHlwZW9mIHJlZn0pYCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgam9iID0gKCkgPT4ge1xuICAgICAgICAgIGRvU2V0KCk7XG4gICAgICAgICAgcGVuZGluZ1NldFJlZk1hcC5kZWxldGUocmF3UmVmKTtcbiAgICAgICAgfTtcbiAgICAgICAgam9iLmlkID0gLTE7XG4gICAgICAgIHBlbmRpbmdTZXRSZWZNYXAuc2V0KHJhd1JlZiwgam9iKTtcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGpvYiwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YWxpZGF0ZVBlbmRpbmdTZXRSZWYocmF3UmVmKTtcbiAgICAgICAgZG9TZXQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHdhcm4kMShcIkludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6XCIsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW52YWxpZGF0ZVBlbmRpbmdTZXRSZWYocmF3UmVmKSB7XG4gIGNvbnN0IHBlbmRpbmdTZXRSZWYgPSBwZW5kaW5nU2V0UmVmTWFwLmdldChyYXdSZWYpO1xuICBpZiAocGVuZGluZ1NldFJlZikge1xuICAgIHBlbmRpbmdTZXRSZWYuZmxhZ3MgfD0gODtcbiAgICBwZW5kaW5nU2V0UmVmTWFwLmRlbGV0ZShyYXdSZWYpO1xuICB9XG59XG5cbmxldCBoYXNMb2dnZWRNaXNtYXRjaEVycm9yID0gZmFsc2U7XG5jb25zdCBsb2dNaXNtYXRjaEVycm9yID0gKCkgPT4ge1xuICBpZiAoaGFzTG9nZ2VkTWlzbWF0Y2hFcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLmVycm9yKFwiSHlkcmF0aW9uIGNvbXBsZXRlZCBidXQgY29udGFpbnMgbWlzbWF0Y2hlcy5cIik7XG4gIGhhc0xvZ2dlZE1pc21hdGNoRXJyb3IgPSB0cnVlO1xufTtcbmNvbnN0IGlzU1ZHQ29udGFpbmVyID0gKGNvbnRhaW5lcikgPT4gY29udGFpbmVyLm5hbWVzcGFjZVVSSS5pbmNsdWRlcyhcInN2Z1wiKSAmJiBjb250YWluZXIudGFnTmFtZSAhPT0gXCJmb3JlaWduT2JqZWN0XCI7XG5jb25zdCBpc01hdGhNTENvbnRhaW5lciA9IChjb250YWluZXIpID0+IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkuaW5jbHVkZXMoXCJNYXRoTUxcIik7XG5jb25zdCBnZXRDb250YWluZXJUeXBlID0gKGNvbnRhaW5lcikgPT4ge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlICE9PSAxKSByZXR1cm4gdm9pZCAwO1xuICBpZiAoaXNTVkdDb250YWluZXIoY29udGFpbmVyKSkgcmV0dXJuIFwic3ZnXCI7XG4gIGlmIChpc01hdGhNTENvbnRhaW5lcihjb250YWluZXIpKSByZXR1cm4gXCJtYXRobWxcIjtcbiAgcmV0dXJuIHZvaWQgMDtcbn07XG5jb25zdCBpc0NvbW1lbnQgPSAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gODtcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyhyZW5kZXJlckludGVybmFscykge1xuICBjb25zdCB7XG4gICAgbXQ6IG1vdW50Q29tcG9uZW50LFxuICAgIHA6IHBhdGNoLFxuICAgIG86IHtcbiAgICAgIHBhdGNoUHJvcCxcbiAgICAgIGNyZWF0ZVRleHQsXG4gICAgICBuZXh0U2libGluZyxcbiAgICAgIHBhcmVudE5vZGUsXG4gICAgICByZW1vdmUsXG4gICAgICBpbnNlcnQsXG4gICAgICBjcmVhdGVDb21tZW50XG4gICAgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGNvbnN0IGh5ZHJhdGUgPSAodm5vZGUsIGNvbnRhaW5lcikgPT4ge1xuICAgIGlmICghY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiB3YXJuJDEoXG4gICAgICAgIGBBdHRlbXB0aW5nIHRvIGh5ZHJhdGUgZXhpc3RpbmcgbWFya3VwIGJ1dCBjb250YWluZXIgaXMgZW1wdHkuIFBlcmZvcm1pbmcgZnVsbCBtb3VudCBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyKTtcbiAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGh5ZHJhdGVOb2RlKGNvbnRhaW5lci5maXJzdENoaWxkLCB2bm9kZSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVOb2RlID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IGlzRnJhZ21lbnRTdGFydCA9IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09IFwiW1wiO1xuICAgIGNvbnN0IG9uTWlzbWF0Y2ggPSAoKSA9PiBoYW5kbGVNaXNtYXRjaChcbiAgICAgIG5vZGUsXG4gICAgICB2bm9kZSxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgaXNGcmFnbWVudFN0YXJ0XG4gICAgKTtcbiAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnLCBwYXRjaEZsYWcgfSA9IHZub2RlO1xuICAgIGxldCBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICB2bm9kZS5lbCA9IG5vZGU7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBkZWYobm9kZSwgXCJfX3Zub2RlXCIsIHZub2RlLCB0cnVlKTtcbiAgICAgIGRlZihub2RlLCBcIl9fdnVlUGFyZW50Q29tcG9uZW50XCIsIHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgPT09IC0yKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGxldCBuZXh0Tm9kZSA9IG51bGw7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFRleHQ6XG4gICAgICAgIGlmIChkb21UeXBlICE9PSAzKSB7XG4gICAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuID09PSBcIlwiKSB7XG4gICAgICAgICAgICBpbnNlcnQodm5vZGUuZWwgPSBjcmVhdGVUZXh0KFwiXCIpLCBwYXJlbnROb2RlKG5vZGUpLCBub2RlKTtcbiAgICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChub2RlLmRhdGEgIT09IHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIHdhcm4kMShcbiAgICAgICAgICAgICAgYEh5ZHJhdGlvbiB0ZXh0IG1pc21hdGNoIGluYCxcbiAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICBgXG4gIC0gcmVuZGVyZWQgb24gc2VydmVyOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIG5vZGUuZGF0YVxuICAgICAgICAgICAgICApfVxuICAtIGV4cGVjdGVkIG9uIGNsaWVudDogJHtKU09OLnN0cmluZ2lmeSh2bm9kZS5jaGlsZHJlbil9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDb21tZW50OlxuICAgICAgICBpZiAoaXNUZW1wbGF0ZU5vZGUobm9kZSkpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIHJlcGxhY2VOb2RlKFxuICAgICAgICAgICAgdm5vZGUuZWwgPSBub2RlLmNvbnRlbnQuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKGRvbVR5cGUgIT09IDggfHwgaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGljOlxuICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIGRvbVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb21UeXBlID09PSAxIHx8IGRvbVR5cGUgPT09IDMpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgY29uc3QgbmVlZFRvQWRvcHRDb250ZW50ID0gIXZub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLnN0YXRpY0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZWVkVG9BZG9wdENvbnRlbnQpXG4gICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuICs9IG5leHROb2RlLm5vZGVUeXBlID09PSAxID8gbmV4dE5vZGUub3V0ZXJIVE1MIDogbmV4dE5vZGUuZGF0YTtcbiAgICAgICAgICAgIGlmIChpID09PSB2bm9kZS5zdGF0aWNDb3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5leHROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlzRnJhZ21lbnRTdGFydCA/IG5leHRTaWJsaW5nKG5leHROb2RlKSA6IG5leHROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uTWlzbWF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIGlmICghaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRnJhZ21lbnQoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSkge1xuICAgICAgICAgIGlmICgoZG9tVHlwZSAhPT0gMSB8fCB2bm9kZS50eXBlLnRvTG93ZXJDYXNlKCkgIT09IG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAmJiAhaXNUZW1wbGF0ZU5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVFbGVtZW50KFxuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgICB2bm9kZS5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IGxvY2F0ZUNsb3NpbmdBbmNob3Iobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcInRlbGVwb3J0IHN0YXJ0XCIpIHtcbiAgICAgICAgICAgIG5leHROb2RlID0gbG9jYXRlQ2xvc2luZ0FuY2hvcihub2RlLCBub2RlLmRhdGEsIFwidGVsZXBvcnQgZW5kXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3VudENvbXBvbmVudChcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgZ2V0Q29udGFpbmVyVHlwZShjb250YWluZXIpLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpICYmICF2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCkge1xuICAgICAgICAgICAgbGV0IHN1YlRyZWU7XG4gICAgICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICAgIHN1YlRyZWUgPSBjcmVhdGVWTm9kZShGcmFnbWVudCk7XG4gICAgICAgICAgICAgIHN1YlRyZWUuYW5jaG9yID0gbmV4dE5vZGUgPyBuZXh0Tm9kZS5wcmV2aW91c1NpYmxpbmcgOiBjb250YWluZXIubGFzdENoaWxkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3ViVHJlZSA9IG5vZGUubm9kZVR5cGUgPT09IDMgPyBjcmVhdGVUZXh0Vk5vZGUoXCJcIikgOiBjcmVhdGVWTm9kZShcImRpdlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YlRyZWUuZWwgPSBub2RlO1xuICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50LnN1YlRyZWUgPSBzdWJUcmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCkge1xuICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4KSB7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUoXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgICAgICAgICAgIGh5ZHJhdGVDaGlsZHJlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUoXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIGdldENvbnRhaW5lclR5cGUocGFyZW50Tm9kZShub2RlKSksXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICByZW5kZXJlckludGVybmFscyxcbiAgICAgICAgICAgIGh5ZHJhdGVOb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykge1xuICAgICAgICAgIHdhcm4kMShcIkludmFsaWQgSG9zdFZOb2RlIHR5cGU6XCIsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dE5vZGU7XG4gIH07XG4gIGNvbnN0IGh5ZHJhdGVFbGVtZW50ID0gKGVsLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISF2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcGF0Y2hGbGFnLCBzaGFwZUZsYWcsIGRpcnMsIHRyYW5zaXRpb24gfSA9IHZub2RlO1xuICAgIGNvbnN0IGZvcmNlUGF0Y2ggPSB0eXBlID09PSBcImlucHV0XCIgfHwgdHlwZSA9PT0gXCJvcHRpb25cIjtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBmb3JjZVBhdGNoIHx8IHBhdGNoRmxhZyAhPT0gLTEpIHtcbiAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJjcmVhdGVkXCIpO1xuICAgICAgfVxuICAgICAgbGV0IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gZmFsc2U7XG4gICAgICBpZiAoaXNUZW1wbGF0ZU5vZGUoZWwpKSB7XG4gICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gbmVlZFRyYW5zaXRpb24oXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAvLyBubyBuZWVkIGNoZWNrIHBhcmVudFN1c3BlbnNlIGluIGh5ZHJhdGlvblxuICAgICAgICAgIHRyYW5zaXRpb25cbiAgICAgICAgKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnZub2RlLnByb3BzICYmIHBhcmVudENvbXBvbmVudC52bm9kZS5wcm9wcy5hcHBlYXI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbC5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgICAgIGNvbnN0IGNscyA9IGNvbnRlbnQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgICAgICAgaWYgKGNscykgY29udGVudC4kY2xzID0gY2xzO1xuICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZU5vZGUoY29udGVudCwgZWwsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgIHZub2RlLmVsID0gZWwgPSBjb250ZW50O1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2ICYmIC8vIHNraXAgaWYgZWxlbWVudCBoYXMgaW5uZXJIVE1MIC8gdGV4dENvbnRlbnRcbiAgICAgICEocHJvcHMgJiYgKHByb3BzLmlubmVySFRNTCB8fCBwcm9wcy50ZXh0Q29udGVudCkpKSB7XG4gICAgICAgIGxldCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKFxuICAgICAgICAgIGVsLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQoZWwsIDEgLyogQ0hJTERSRU4gKi8pKSB7XG4gICAgICAgICAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiAhaGFzV2FybmVkKSB7XG4gICAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgICBgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIG9uYCxcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICBgXG5TZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjdXIgPSBuZXh0O1xuICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgIHJlbW92ZShjdXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgICAgbGV0IGNsaWVudFRleHQgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKGNsaWVudFRleHRbMF0gPT09IFwiXFxuXCIgJiYgKGVsLnRhZ05hbWUgPT09IFwiUFJFXCIgfHwgZWwudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSkge1xuICAgICAgICAgIGNsaWVudFRleHQgPSBjbGllbnRUZXh0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdGV4dENvbnRlbnQgfSA9IGVsO1xuICAgICAgICBpZiAodGV4dENvbnRlbnQgIT09IGNsaWVudFRleHQgJiYgLy8gaW5uZXJIVE1MIG5vcm1hbGl6ZSBcXHJcXG4gb3IgXFxyIGludG8gYSBzaW5nbGUgXFxuIGluIHRoZSBET01cbiAgICAgICAgdGV4dENvbnRlbnQgIT09IGNsaWVudFRleHQucmVwbGFjZSgvXFxyXFxufFxcci9nLCBcIlxcblwiKSkge1xuICAgICAgICAgIGlmICghaXNNaXNtYXRjaEFsbG93ZWQoZWwsIDAgLyogVEVYVCAqLykpIHtcbiAgICAgICAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIHRleHQgY29udGVudCBtaXNtYXRjaCBvbmAsXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICBgXG4gIC0gcmVuZGVyZWQgb24gc2VydmVyOiAke3RleHRDb250ZW50fVxuICAtIGV4cGVjdGVkIG9uIGNsaWVudDogJHtjbGllbnRUZXh0fWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcykge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18gfHwgZm9yY2VQYXRjaCB8fCAhb3B0aW1pemVkIHx8IHBhdGNoRmxhZyAmICgxNiB8IDMyKSkge1xuICAgICAgICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGVsLnRhZ05hbWUuaW5jbHVkZXMoXCItXCIpO1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiAvLyAjMTExODkgc2tpcCBpZiB0aGlzIG5vZGUgaGFzIGRpcmVjdGl2ZXMgdGhhdCBoYXZlIGNyZWF0ZWQgaG9va3NcbiAgICAgICAgICAgIC8vIGFzIGl0IGNvdWxkIGhhdmUgbXV0YXRlZCB0aGUgRE9NIGluIGFueSBwb3NzaWJsZSB3YXlcbiAgICAgICAgICAgICEoZGlycyAmJiBkaXJzLnNvbWUoKGQpID0+IGQuZGlyLmNyZWF0ZWQpKSAmJiBwcm9wSGFzTWlzbWF0Y2goZWwsIGtleSwgcHJvcHNba2V5XSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcmNlUGF0Y2ggJiYgKGtleS5lbmRzV2l0aChcInZhbHVlXCIpIHx8IGtleSA9PT0gXCJpbmRldGVybWluYXRlXCIpIHx8IGlzT24oa2V5KSAmJiAhaXNSZXNlcnZlZFByb3Aoa2V5KSB8fCAvLyBmb3JjZSBoeWRyYXRlIHYtYmluZCB3aXRoIC5wcm9wIG1vZGlmaWVyc1xuICAgICAgICAgICAga2V5WzBdID09PSBcIi5cIiB8fCBpc0N1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgcGF0Y2hQcm9wKGVsLCBrZXksIG51bGwsIHByb3BzW2tleV0sIHZvaWQgMCwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcHMub25DbGljaykge1xuICAgICAgICAgIHBhdGNoUHJvcChcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgXCJvbkNsaWNrXCIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcHJvcHMub25DbGljayxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgNCAmJiBpc1JlYWN0aXZlKHByb3BzLnN0eWxlKSkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzLnN0eWxlKSBwcm9wcy5zdHlsZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgdm5vZGVIb29rcztcbiAgICAgIGlmICh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSB7XG4gICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVNb3VudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICgodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBkaXJzIHx8IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzKSB7XG4gICAgICAgIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKCgpID0+IHtcbiAgICAgICAgICB2bm9kZUhvb2tzICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyAmJiB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJtb3VudGVkXCIpO1xuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbC5uZXh0U2libGluZztcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUNoaWxkcmVuID0gKG5vZGUsIHBhcmVudFZOb2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhcGFyZW50Vk5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50Vk5vZGUuY2hpbGRyZW47XG4gICAgY29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IHZub2RlID0gb3B0aW1pemVkID8gY2hpbGRyZW5baV0gOiBjaGlsZHJlbltpXSA9IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKTtcbiAgICAgIGNvbnN0IGlzVGV4dCA9IHZub2RlLnR5cGUgPT09IFRleHQ7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBpZiAoaXNUZXh0ICYmICFvcHRpbWl6ZWQpIHtcbiAgICAgICAgICBpZiAoaSArIDEgPCBsICYmIG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2kgKyAxXSkudHlwZSA9PT0gVGV4dCkge1xuICAgICAgICAgICAgaW5zZXJ0KFxuICAgICAgICAgICAgICBjcmVhdGVUZXh0KFxuICAgICAgICAgICAgICAgIG5vZGUuZGF0YS5zbGljZSh2bm9kZS5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgbmV4dFNpYmxpbmcobm9kZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IGh5ZHJhdGVOb2RlKFxuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNUZXh0ICYmICF2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICBpbnNlcnQodm5vZGUuZWwgPSBjcmVhdGVUZXh0KFwiXCIpLCBjb250YWluZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFpc01pc21hdGNoQWxsb3dlZChjb250YWluZXIsIDEgLyogQ0hJTERSRU4gKi8pKSB7XG4gICAgICAgICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIG9uYCxcbiAgICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgICBgXG5TZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBmZXdlciBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dNaXNtYXRjaEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2goXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgZ2V0Q29udGFpbmVyVHlwZShjb250YWluZXIpLFxuICAgICAgICAgIHNsb3RTY29wZUlkc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcbiAgY29uc3QgaHlkcmF0ZUZyYWdtZW50ID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IHsgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gdm5vZGU7XG4gICAgaWYgKGZyYWdtZW50U2xvdFNjb3BlSWRzKSB7XG4gICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHMgPyBzbG90U2NvcGVJZHMuY29uY2F0KGZyYWdtZW50U2xvdFNjb3BlSWRzKSA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xuICAgIGNvbnN0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4oXG4gICAgICBuZXh0U2libGluZyhub2RlKSxcbiAgICAgIHZub2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICBzbG90U2NvcGVJZHMsXG4gICAgICBvcHRpbWl6ZWRcbiAgICApO1xuICAgIGlmIChuZXh0ICYmIGlzQ29tbWVudChuZXh0KSAmJiBuZXh0LmRhdGEgPT09IFwiXVwiKSB7XG4gICAgICByZXR1cm4gbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yID0gbmV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ01pc21hdGNoRXJyb3IoKTtcbiAgICAgIGluc2VydCh2bm9kZS5hbmNob3IgPSBjcmVhdGVDb21tZW50KGBdYCksIGNvbnRhaW5lciwgbmV4dCk7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhhbmRsZU1pc21hdGNoID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnQpID0+IHtcbiAgICBpZiAoIWlzTWlzbWF0Y2hBbGxvd2VkKG5vZGUucGFyZW50RWxlbWVudCwgMSAvKiBDSElMRFJFTiAqLykpIHtcbiAgICAgICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgd2FybiQxKFxuICAgICAgICBgSHlkcmF0aW9uIG5vZGUgbWlzbWF0Y2g6XG4tIHJlbmRlcmVkIG9uIHNlcnZlcjpgLFxuICAgICAgICBub2RlLFxuICAgICAgICBub2RlLm5vZGVUeXBlID09PSAzID8gYCh0ZXh0KWAgOiBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcIltcIiA/IGAoc3RhcnQgb2YgZnJhZ21lbnQpYCA6IGBgLFxuICAgICAgICBgXG4tIGV4cGVjdGVkIG9uIGNsaWVudDpgLFxuICAgICAgICB2bm9kZS50eXBlXG4gICAgICApO1xuICAgICAgbG9nTWlzbWF0Y2hFcnJvcigpO1xuICAgIH1cbiAgICB2bm9kZS5lbCA9IG51bGw7XG4gICAgaWYgKGlzRnJhZ21lbnQpIHtcbiAgICAgIGNvbnN0IGVuZCA9IGxvY2F0ZUNsb3NpbmdBbmNob3Iobm9kZSk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBuZXh0MiA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICBpZiAobmV4dDIgJiYgbmV4dDIgIT09IGVuZCkge1xuICAgICAgICAgIHJlbW92ZShuZXh0Mik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgcmVtb3ZlKG5vZGUpO1xuICAgIHBhdGNoKFxuICAgICAgbnVsbCxcbiAgICAgIHZub2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgbmV4dCxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgZ2V0Q29udGFpbmVyVHlwZShjb250YWluZXIpLFxuICAgICAgc2xvdFNjb3BlSWRzXG4gICAgKTtcbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBwYXJlbnRDb21wb25lbnQudm5vZGUuZWwgPSB2bm9kZS5lbDtcbiAgICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIHZub2RlLmVsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQ7XG4gIH07XG4gIGNvbnN0IGxvY2F0ZUNsb3NpbmdBbmNob3IgPSAobm9kZSwgb3BlbiA9IFwiW1wiLCBjbG9zZSA9IFwiXVwiKSA9PiB7XG4gICAgbGV0IG1hdGNoID0gMDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgaWYgKG5vZGUgJiYgaXNDb21tZW50KG5vZGUpKSB7XG4gICAgICAgIGlmIChub2RlLmRhdGEgPT09IG9wZW4pIG1hdGNoKys7XG4gICAgICAgIGlmIChub2RlLmRhdGEgPT09IGNsb3NlKSB7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuICBjb25zdCByZXBsYWNlTm9kZSA9IChuZXdOb2RlLCBvbGROb2RlLCBwYXJlbnRDb21wb25lbnQpID0+IHtcbiAgICBjb25zdCBwYXJlbnROb2RlMiA9IG9sZE5vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZTIpIHtcbiAgICAgIHBhcmVudE5vZGUyLnJlcGxhY2VDaGlsZChuZXdOb2RlLCBvbGROb2RlKTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IHBhcmVudENvbXBvbmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LnZub2RlLmVsID09PSBvbGROb2RlKSB7XG4gICAgICAgIHBhcmVudC52bm9kZS5lbCA9IHBhcmVudC5zdWJUcmVlLmVsID0gbmV3Tm9kZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9O1xuICBjb25zdCBpc1RlbXBsYXRlTm9kZSA9IChub2RlKSA9PiB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9kZS50YWdOYW1lID09PSBcIlRFTVBMQVRFXCI7XG4gIH07XG4gIHJldHVybiBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdO1xufVxuZnVuY3Rpb24gcHJvcEhhc01pc21hdGNoKGVsLCBrZXksIGNsaWVudFZhbHVlLCB2bm9kZSwgaW5zdGFuY2UpIHtcbiAgbGV0IG1pc21hdGNoVHlwZTtcbiAgbGV0IG1pc21hdGNoS2V5O1xuICBsZXQgYWN0dWFsO1xuICBsZXQgZXhwZWN0ZWQ7XG4gIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xuICAgIGlmIChlbC4kY2xzKSB7XG4gICAgICBhY3R1YWwgPSBlbC4kY2xzO1xuICAgICAgZGVsZXRlIGVsLiRjbHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdHVhbCA9IGVsLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgIH1cbiAgICBleHBlY3RlZCA9IG5vcm1hbGl6ZUNsYXNzKGNsaWVudFZhbHVlKTtcbiAgICBpZiAoIWlzU2V0RXF1YWwodG9DbGFzc1NldChhY3R1YWwgfHwgXCJcIiksIHRvQ2xhc3NTZXQoZXhwZWN0ZWQpKSkge1xuICAgICAgbWlzbWF0Y2hUeXBlID0gMiAvKiBDTEFTUyAqLztcbiAgICAgIG1pc21hdGNoS2V5ID0gYGNsYXNzYDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICBhY3R1YWwgPSBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSB8fCBcIlwiO1xuICAgIGV4cGVjdGVkID0gaXNTdHJpbmcoY2xpZW50VmFsdWUpID8gY2xpZW50VmFsdWUgOiBzdHJpbmdpZnlTdHlsZShub3JtYWxpemVTdHlsZShjbGllbnRWYWx1ZSkpO1xuICAgIGNvbnN0IGFjdHVhbE1hcCA9IHRvU3R5bGVNYXAoYWN0dWFsKTtcbiAgICBjb25zdCBleHBlY3RlZE1hcCA9IHRvU3R5bGVNYXAoZXhwZWN0ZWQpO1xuICAgIGlmICh2bm9kZS5kaXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IHsgZGlyLCB2YWx1ZSB9IG9mIHZub2RlLmRpcnMpIHtcbiAgICAgICAgaWYgKGRpci5uYW1lID09PSBcInNob3dcIiAmJiAhdmFsdWUpIHtcbiAgICAgICAgICBleHBlY3RlZE1hcC5zZXQoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIHJlc29sdmVDc3NWYXJzKGluc3RhbmNlLCB2bm9kZSwgZXhwZWN0ZWRNYXApO1xuICAgIH1cbiAgICBpZiAoIWlzTWFwRXF1YWwoYWN0dWFsTWFwLCBleHBlY3RlZE1hcCkpIHtcbiAgICAgIG1pc21hdGNoVHlwZSA9IDMgLyogU1RZTEUgKi87XG4gICAgICBtaXNtYXRjaEtleSA9IFwic3R5bGVcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZWwgaW5zdGFuY2VvZiBTVkdFbGVtZW50ICYmIGlzS25vd25TdmdBdHRyKGtleSkgfHwgZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAoaXNCb29sZWFuQXR0cihrZXkpIHx8IGlzS25vd25IdG1sQXR0cihrZXkpKSkge1xuICAgIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAgIGFjdHVhbCA9IGVsLmhhc0F0dHJpYnV0ZShrZXkpO1xuICAgICAgZXhwZWN0ZWQgPSBpbmNsdWRlQm9vbGVhbkF0dHIoY2xpZW50VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoY2xpZW50VmFsdWUgPT0gbnVsbCkge1xuICAgICAgYWN0dWFsID0gZWwuaGFzQXR0cmlidXRlKGtleSk7XG4gICAgICBleHBlY3RlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgYWN0dWFsID0gZWwuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJ2YWx1ZVwiICYmIGVsLnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICBhY3R1YWwgPSBlbC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdHVhbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZXhwZWN0ZWQgPSBpc1JlbmRlcmFibGVBdHRyVmFsdWUoY2xpZW50VmFsdWUpID8gU3RyaW5nKGNsaWVudFZhbHVlKSA6IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgICAgbWlzbWF0Y2hUeXBlID0gNCAvKiBBVFRSSUJVVEUgKi87XG4gICAgICBtaXNtYXRjaEtleSA9IGtleTtcbiAgICB9XG4gIH1cbiAgaWYgKG1pc21hdGNoVHlwZSAhPSBudWxsICYmICFpc01pc21hdGNoQWxsb3dlZChlbCwgbWlzbWF0Y2hUeXBlKSkge1xuICAgIGNvbnN0IGZvcm1hdCA9ICh2KSA9PiB2ID09PSBmYWxzZSA/IGAobm90IHJlbmRlcmVkKWAgOiBgJHttaXNtYXRjaEtleX09XCIke3Z9XCJgO1xuICAgIGNvbnN0IHByZVNlZ21lbnQgPSBgSHlkcmF0aW9uICR7TWlzbWF0Y2hUeXBlU3RyaW5nW21pc21hdGNoVHlwZV19IG1pc21hdGNoIG9uYDtcbiAgICBjb25zdCBwb3N0U2VnbWVudCA9IGBcbiAgLSByZW5kZXJlZCBvbiBzZXJ2ZXI6ICR7Zm9ybWF0KGFjdHVhbCl9XG4gIC0gZXhwZWN0ZWQgb24gY2xpZW50OiAke2Zvcm1hdChleHBlY3RlZCl9XG4gIE5vdGU6IHRoaXMgbWlzbWF0Y2ggaXMgY2hlY2stb25seS4gVGhlIERPTSB3aWxsIG5vdCBiZSByZWN0aWZpZWQgaW4gcHJvZHVjdGlvbiBkdWUgdG8gcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuXG4gIFlvdSBzaG91bGQgZml4IHRoZSBzb3VyY2Ugb2YgdGhlIG1pc21hdGNoLmA7XG4gICAge1xuICAgICAgd2FybiQxKHByZVNlZ21lbnQsIGVsLCBwb3N0U2VnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHRvQ2xhc3NTZXQoc3RyKSB7XG4gIHJldHVybiBuZXcgU2V0KHN0ci50cmltKCkuc3BsaXQoL1xccysvKSk7XG59XG5mdW5jdGlvbiBpc1NldEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoY29uc3QgcyBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRvU3R5bGVNYXAoc3RyKSB7XG4gIGNvbnN0IHN0eWxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIHN0ci5zcGxpdChcIjtcIikpIHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gaXRlbS5zcGxpdChcIjpcIik7XG4gICAga2V5ID0ga2V5LnRyaW0oKTtcbiAgICB2YWx1ZSA9IHZhbHVlICYmIHZhbHVlLnRyaW0oKTtcbiAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XG4gICAgICBzdHlsZU1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZU1hcDtcbn1cbmZ1bmN0aW9uIGlzTWFwRXF1YWwoYSwgYikge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYSkge1xuICAgIGlmICh2YWx1ZSAhPT0gYi5nZXQoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDc3NWYXJzKGluc3RhbmNlLCB2bm9kZSwgZXhwZWN0ZWRNYXApIHtcbiAgY29uc3Qgcm9vdCA9IGluc3RhbmNlLnN1YlRyZWU7XG4gIGlmIChpbnN0YW5jZS5nZXRDc3NWYXJzICYmICh2bm9kZSA9PT0gcm9vdCB8fCByb290ICYmIHJvb3QudHlwZSA9PT0gRnJhZ21lbnQgJiYgcm9vdC5jaGlsZHJlbi5pbmNsdWRlcyh2bm9kZSkpKSB7XG4gICAgY29uc3QgY3NzVmFycyA9IGluc3RhbmNlLmdldENzc1ZhcnMoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjc3NWYXJzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG5vcm1hbGl6ZUNzc1ZhclZhbHVlKGNzc1ZhcnNba2V5XSk7XG4gICAgICBleHBlY3RlZE1hcC5zZXQoYC0tJHtnZXRFc2NhcGVkQ3NzVmFyTmFtZShrZXksIGZhbHNlKX1gLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGlmICh2bm9kZSA9PT0gcm9vdCAmJiBpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICByZXNvbHZlQ3NzVmFycyhpbnN0YW5jZS5wYXJlbnQsIGluc3RhbmNlLnZub2RlLCBleHBlY3RlZE1hcCk7XG4gIH1cbn1cbmNvbnN0IGFsbG93TWlzbWF0Y2hBdHRyID0gXCJkYXRhLWFsbG93LW1pc21hdGNoXCI7XG5jb25zdCBNaXNtYXRjaFR5cGVTdHJpbmcgPSB7XG4gIFswIC8qIFRFWFQgKi9dOiBcInRleHRcIixcbiAgWzEgLyogQ0hJTERSRU4gKi9dOiBcImNoaWxkcmVuXCIsXG4gIFsyIC8qIENMQVNTICovXTogXCJjbGFzc1wiLFxuICBbMyAvKiBTVFlMRSAqL106IFwic3R5bGVcIixcbiAgWzQgLyogQVRUUklCVVRFICovXTogXCJhdHRyaWJ1dGVcIlxufTtcbmZ1bmN0aW9uIGlzTWlzbWF0Y2hBbGxvd2VkKGVsLCBhbGxvd2VkVHlwZSkge1xuICBpZiAoYWxsb3dlZFR5cGUgPT09IDAgLyogVEVYVCAqLyB8fCBhbGxvd2VkVHlwZSA9PT0gMSAvKiBDSElMRFJFTiAqLykge1xuICAgIHdoaWxlIChlbCAmJiAhZWwuaGFzQXR0cmlidXRlKGFsbG93TWlzbWF0Y2hBdHRyKSkge1xuICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuICBjb25zdCBhbGxvd2VkQXR0ciA9IGVsICYmIGVsLmdldEF0dHJpYnV0ZShhbGxvd01pc21hdGNoQXR0cik7XG4gIGlmIChhbGxvd2VkQXR0ciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGFsbG93ZWRBdHRyID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGlzdCA9IGFsbG93ZWRBdHRyLnNwbGl0KFwiLFwiKTtcbiAgICBpZiAoYWxsb3dlZFR5cGUgPT09IDAgLyogVEVYVCAqLyAmJiBsaXN0LmluY2x1ZGVzKFwiY2hpbGRyZW5cIikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdC5pbmNsdWRlcyhNaXNtYXRjaFR5cGVTdHJpbmdbYWxsb3dlZFR5cGVdKTtcbiAgfVxufVxuXG5jb25zdCByZXF1ZXN0SWRsZUNhbGxiYWNrID0gZ2V0R2xvYmFsVGhpcygpLnJlcXVlc3RJZGxlQ2FsbGJhY2sgfHwgKChjYikgPT4gc2V0VGltZW91dChjYiwgMSkpO1xuY29uc3QgY2FuY2VsSWRsZUNhbGxiYWNrID0gZ2V0R2xvYmFsVGhpcygpLmNhbmNlbElkbGVDYWxsYmFjayB8fCAoKGlkKSA9PiBjbGVhclRpbWVvdXQoaWQpKTtcbmNvbnN0IGh5ZHJhdGVPbklkbGUgPSAodGltZW91dCA9IDFlNCkgPT4gKGh5ZHJhdGUpID0+IHtcbiAgY29uc3QgaWQgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKGh5ZHJhdGUsIHsgdGltZW91dCB9KTtcbiAgcmV0dXJuICgpID0+IGNhbmNlbElkbGVDYWxsYmFjayhpZCk7XG59O1xuZnVuY3Rpb24gZWxlbWVudElzVmlzaWJsZUluVmlld3BvcnQoZWwpIHtcbiAgY29uc3QgeyB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQgfSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB7IGlubmVySGVpZ2h0LCBpbm5lcldpZHRoIH0gPSB3aW5kb3c7XG4gIHJldHVybiAodG9wID4gMCAmJiB0b3AgPCBpbm5lckhlaWdodCB8fCBib3R0b20gPiAwICYmIGJvdHRvbSA8IGlubmVySGVpZ2h0KSAmJiAobGVmdCA+IDAgJiYgbGVmdCA8IGlubmVyV2lkdGggfHwgcmlnaHQgPiAwICYmIHJpZ2h0IDwgaW5uZXJXaWR0aCk7XG59XG5jb25zdCBoeWRyYXRlT25WaXNpYmxlID0gKG9wdHMpID0+IChoeWRyYXRlLCBmb3JFYWNoKSA9PiB7XG4gIGNvbnN0IG9iID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgIGlmICghZS5pc0ludGVyc2VjdGluZykgY29udGludWU7XG4gICAgICBvYi5kaXNjb25uZWN0KCk7XG4gICAgICBoeWRyYXRlKCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0sIG9wdHMpO1xuICBmb3JFYWNoKChlbCkgPT4ge1xuICAgIGlmICghKGVsIGluc3RhbmNlb2YgRWxlbWVudCkpIHJldHVybjtcbiAgICBpZiAoZWxlbWVudElzVmlzaWJsZUluVmlld3BvcnQoZWwpKSB7XG4gICAgICBoeWRyYXRlKCk7XG4gICAgICBvYi5kaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iLm9ic2VydmUoZWwpO1xuICB9KTtcbiAgcmV0dXJuICgpID0+IG9iLmRpc2Nvbm5lY3QoKTtcbn07XG5jb25zdCBoeWRyYXRlT25NZWRpYVF1ZXJ5ID0gKHF1ZXJ5KSA9PiAoaHlkcmF0ZSkgPT4ge1xuICBpZiAocXVlcnkpIHtcbiAgICBjb25zdCBtcWwgPSBtYXRjaE1lZGlhKHF1ZXJ5KTtcbiAgICBpZiAobXFsLm1hdGNoZXMpIHtcbiAgICAgIGh5ZHJhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbXFsLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaHlkcmF0ZSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgcmV0dXJuICgpID0+IG1xbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGh5ZHJhdGUpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGh5ZHJhdGVPbkludGVyYWN0aW9uID0gKGludGVyYWN0aW9ucyA9IFtdKSA9PiAoaHlkcmF0ZSwgZm9yRWFjaCkgPT4ge1xuICBpZiAoaXNTdHJpbmcoaW50ZXJhY3Rpb25zKSkgaW50ZXJhY3Rpb25zID0gW2ludGVyYWN0aW9uc107XG4gIGxldCBoYXNIeWRyYXRlZCA9IGZhbHNlO1xuICBjb25zdCBkb0h5ZHJhdGUgPSAoZSkgPT4ge1xuICAgIGlmICghaGFzSHlkcmF0ZWQpIHtcbiAgICAgIGhhc0h5ZHJhdGVkID0gdHJ1ZTtcbiAgICAgIHRlYXJkb3duKCk7XG4gICAgICBoeWRyYXRlKCk7XG4gICAgICBlLnRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBlLmNvbnN0cnVjdG9yKGUudHlwZSwgZSkpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdGVhcmRvd24gPSAoKSA9PiB7XG4gICAgZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGZvciAoY29uc3QgaSBvZiBpbnRlcmFjdGlvbnMpIHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihpLCBkb0h5ZHJhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmb3JFYWNoKChlbCkgPT4ge1xuICAgIGZvciAoY29uc3QgaSBvZiBpbnRlcmFjdGlvbnMpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoaSwgZG9IeWRyYXRlLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRlYXJkb3duO1xufTtcbmZ1bmN0aW9uIGZvckVhY2hFbGVtZW50KG5vZGUsIGNiKSB7XG4gIGlmIChpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSBcIltcIikge1xuICAgIGxldCBkZXB0aCA9IDE7XG4gICAgbGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjYihuZXh0KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0NvbW1lbnQobmV4dCkpIHtcbiAgICAgICAgaWYgKG5leHQuZGF0YSA9PT0gXCJdXCIpIHtcbiAgICAgICAgICBpZiAoLS1kZXB0aCA9PT0gMCkgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dC5kYXRhID09PSBcIltcIikge1xuICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjYihub2RlKTtcbiAgfVxufVxuXG5jb25zdCBpc0FzeW5jV3JhcHBlciA9IChpKSA9PiAhIWkudHlwZS5fX2FzeW5jTG9hZGVyO1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGRlZmluZUFzeW5jQ29tcG9uZW50KHNvdXJjZSkge1xuICBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XG4gICAgc291cmNlID0geyBsb2FkZXI6IHNvdXJjZSB9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBsb2FkZXIsXG4gICAgbG9hZGluZ0NvbXBvbmVudCxcbiAgICBlcnJvckNvbXBvbmVudCxcbiAgICBkZWxheSA9IDIwMCxcbiAgICBoeWRyYXRlOiBoeWRyYXRlU3RyYXRlZ3ksXG4gICAgdGltZW91dCxcbiAgICAvLyB1bmRlZmluZWQgPSBuZXZlciB0aW1lcyBvdXRcbiAgICBzdXNwZW5zaWJsZSA9IHRydWUsXG4gICAgb25FcnJvcjogdXNlck9uRXJyb3JcbiAgfSA9IHNvdXJjZTtcbiAgbGV0IHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgbGV0IHJlc29sdmVkQ29tcDtcbiAgbGV0IHJldHJpZXMgPSAwO1xuICBjb25zdCByZXRyeSA9ICgpID0+IHtcbiAgICByZXRyaWVzKys7XG4gICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgIHJldHVybiBsb2FkKCk7XG4gIH07XG4gIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgbGV0IHRoaXNSZXF1ZXN0O1xuICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdCB8fCAodGhpc1JlcXVlc3QgPSBwZW5kaW5nUmVxdWVzdCA9IGxvYWRlcigpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGVyciA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFN0cmluZyhlcnIpKTtcbiAgICAgIGlmICh1c2VyT25FcnJvcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHVzZXJSZXRyeSA9ICgpID0+IHJlc29sdmUocmV0cnkoKSk7XG4gICAgICAgICAgY29uc3QgdXNlckZhaWwgPSAoKSA9PiByZWplY3QoZXJyKTtcbiAgICAgICAgICB1c2VyT25FcnJvcihlcnIsIHVzZXJSZXRyeSwgdXNlckZhaWwsIHJldHJpZXMgKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSkudGhlbigoY29tcCkgPT4ge1xuICAgICAgaWYgKHRoaXNSZXF1ZXN0ICE9PSBwZW5kaW5nUmVxdWVzdCAmJiBwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3Q7XG4gICAgICB9XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY29tcCkge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYEFzeW5jIGNvbXBvbmVudCBsb2FkZXIgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkLiBJZiB5b3UgYXJlIHVzaW5nIHJldHJ5KCksIG1ha2Ugc3VyZSB0byByZXR1cm4gaXRzIHJldHVybiB2YWx1ZS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcCAmJiAoY29tcC5fX2VzTW9kdWxlIHx8IGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJNb2R1bGVcIikpIHtcbiAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbXAgJiYgIWlzT2JqZWN0KGNvbXApICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3luYyBjb21wb25lbnQgbG9hZCByZXN1bHQ6ICR7Y29tcH1gKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVkQ29tcCA9IGNvbXA7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9KSk7XG4gIH07XG4gIHJldHVybiBkZWZpbmVDb21wb25lbnQoe1xuICAgIG5hbWU6IFwiQXN5bmNDb21wb25lbnRXcmFwcGVyXCIsXG4gICAgX19hc3luY0xvYWRlcjogbG9hZCxcbiAgICBfX2FzeW5jSHlkcmF0ZShlbCwgaW5zdGFuY2UsIGh5ZHJhdGUpIHtcbiAgICAgIGxldCBwYXRjaGVkID0gZmFsc2U7XG4gICAgICAoaW5zdGFuY2UuYnUgfHwgKGluc3RhbmNlLmJ1ID0gW10pKS5wdXNoKCgpID0+IHBhdGNoZWQgPSB0cnVlKTtcbiAgICAgIGNvbnN0IHBlcmZvcm1IeWRyYXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAocGF0Y2hlZCkge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIGBTa2lwcGluZyBsYXp5IGh5ZHJhdGlvbiBmb3IgY29tcG9uZW50ICcke2dldENvbXBvbmVudE5hbWUocmVzb2x2ZWRDb21wKSB8fCByZXNvbHZlZENvbXAuX19maWxlfSc6IGl0IHdhcyB1cGRhdGVkIGJlZm9yZSBsYXp5IGh5ZHJhdGlvbiBwZXJmb3JtZWQuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGh5ZHJhdGUoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkb0h5ZHJhdGUgPSBoeWRyYXRlU3RyYXRlZ3kgPyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlYXJkb3duID0gaHlkcmF0ZVN0cmF0ZWd5KFxuICAgICAgICAgIHBlcmZvcm1IeWRyYXRlLFxuICAgICAgICAgIChjYikgPT4gZm9yRWFjaEVsZW1lbnQoZWwsIGNiKVxuICAgICAgICApO1xuICAgICAgICBpZiAodGVhcmRvd24pIHtcbiAgICAgICAgICAoaW5zdGFuY2UuYnVtIHx8IChpbnN0YW5jZS5idW0gPSBbXSkpLnB1c2godGVhcmRvd24pO1xuICAgICAgICB9XG4gICAgICB9IDogcGVyZm9ybUh5ZHJhdGU7XG4gICAgICBpZiAocmVzb2x2ZWRDb21wKSB7XG4gICAgICAgIGRvSHlkcmF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZCgpLnRoZW4oKCkgPT4gIWluc3RhbmNlLmlzVW5tb3VudGVkICYmIGRvSHlkcmF0ZSgpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCBfX2FzeW5jUmVzb2x2ZWQoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZWRDb21wO1xuICAgIH0sXG4gICAgc2V0dXAoKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgIG1hcmtBc3luY0JvdW5kYXJ5KGluc3RhbmNlKTtcbiAgICAgIGlmIChyZXNvbHZlZENvbXApIHtcbiAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgaGFuZGxlRXJyb3IoXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIDEzLFxuICAgICAgICAgICFlcnJvckNvbXBvbmVudFxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGlmIChzdXNwZW5zaWJsZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSB8fCBpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcbiAgICAgICAgcmV0dXJuIGxvYWQoKS50aGVuKChjb21wKSA9PiB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChjb21wLCBpbnN0YW5jZSk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuICgpID0+IGVycm9yQ29tcG9uZW50ID8gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICB9KSA6IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVkID0gcmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGVycm9yID0gcmVmKCk7XG4gICAgICBjb25zdCBkZWxheWVkID0gcmVmKCEhZGVsYXkpO1xuICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGRlbGF5ZWQudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIWxvYWRlZC52YWx1ZSAmJiAhZXJyb3IudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEFzeW5jIGNvbXBvbmVudCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0fW1zLmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgbG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBsb2FkZWQudmFsdWUgPSB0cnVlO1xuICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50ICYmIGlzS2VlcEFsaXZlKGluc3RhbmNlLnBhcmVudC52bm9kZSkpIHtcbiAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGxvYWRlZC52YWx1ZSAmJiByZXNvbHZlZENvbXApIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnZhbHVlICYmIGVycm9yQ29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3IudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2FkaW5nQ29tcG9uZW50ICYmICFkZWxheWVkLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUlubmVyQ29tcChcbiAgICAgICAgICAgIGxvYWRpbmdDb21wb25lbnQsXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUlubmVyQ29tcChjb21wLCBwYXJlbnQpIHtcbiAgY29uc3QgeyByZWY6IHJlZjIsIHByb3BzLCBjaGlsZHJlbiwgY2UgfSA9IHBhcmVudC52bm9kZTtcbiAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShjb21wLCBwcm9wcywgY2hpbGRyZW4pO1xuICB2bm9kZS5yZWYgPSByZWYyO1xuICB2bm9kZS5jZSA9IGNlO1xuICBkZWxldGUgcGFyZW50LnZub2RlLmNlO1xuICByZXR1cm4gdm5vZGU7XG59XG5cbmNvbnN0IGlzS2VlcEFsaXZlID0gKHZub2RlKSA9PiB2bm9kZS50eXBlLl9faXNLZWVwQWxpdmU7XG5jb25zdCBLZWVwQWxpdmVJbXBsID0ge1xuICBuYW1lOiBgS2VlcEFsaXZlYCxcbiAgLy8gTWFya2VyIGZvciBzcGVjaWFsIGhhbmRsaW5nIGluc2lkZSB0aGUgcmVuZGVyZXIuIFdlIGFyZSBub3QgdXNpbmcgYSA9PT1cbiAgLy8gY2hlY2sgZGlyZWN0bHkgb24gS2VlcEFsaXZlIGluIHRoZSByZW5kZXJlciwgYmVjYXVzZSBpbXBvcnRpbmcgaXQgZGlyZWN0bHlcbiAgLy8gd291bGQgcHJldmVudCBpdCBmcm9tIGJlaW5nIHRyZWUtc2hha2VuLlxuICBfX2lzS2VlcEFsaXZlOiB0cnVlLFxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxuICAgIGV4Y2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBjb25zdCBzaGFyZWRDb250ZXh0ID0gaW5zdGFuY2UuY3R4O1xuICAgIGlmICghc2hhcmVkQ29udGV4dC5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIHNsb3RzLmRlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSA/IGNoaWxkcmVuWzBdIDogY2hpbGRyZW47XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBjYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3Qga2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbGV0IGN1cnJlbnQgPSBudWxsO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgaW5zdGFuY2UuX192X2NhY2hlID0gY2FjaGU7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudFN1c3BlbnNlID0gaW5zdGFuY2Uuc3VzcGVuc2U7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyZXI6IHtcbiAgICAgICAgcDogcGF0Y2gsXG4gICAgICAgIG06IG1vdmUsXG4gICAgICAgIHVtOiBfdW5tb3VudCxcbiAgICAgICAgbzogeyBjcmVhdGVFbGVtZW50IH1cbiAgICAgIH1cbiAgICB9ID0gc2hhcmVkQ29udGV4dDtcbiAgICBjb25zdCBzdG9yYWdlQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBzaGFyZWRDb250ZXh0LmFjdGl2YXRlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbmFtZXNwYWNlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlMiA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgIG1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCAwLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBwYXRjaChcbiAgICAgICAgaW5zdGFuY2UyLnZub2RlLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGluc3RhbmNlMixcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgdm5vZGUuc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpbnN0YW5jZTIuaXNEZWFjdGl2YXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5zdGFuY2UyLmEpIHtcbiAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZTIuYSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZU1vdW50ZWQ7XG4gICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZTIucGFyZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlMik7XG4gICAgICB9XG4gICAgfTtcbiAgICBzaGFyZWRDb250ZXh0LmRlYWN0aXZhdGUgPSAodm5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlMiA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgIGludmFsaWRhdGVNb3VudChpbnN0YW5jZTIubSk7XG4gICAgICBpbnZhbGlkYXRlTW91bnQoaW5zdGFuY2UyLmEpO1xuICAgICAgbW92ZSh2bm9kZSwgc3RvcmFnZUNvbnRhaW5lciwgbnVsbCwgMSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGluc3RhbmNlMi5kYSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlMi5kYSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZVVubW91bnRlZDtcbiAgICAgICAgaWYgKHZub2RlSG9vaykge1xuICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlMi5wYXJlbnQsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZTIuaXNEZWFjdGl2YXRlZCA9IHRydWU7XG4gICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZTIpO1xuICAgICAgfVxuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgdHJ1ZSkge1xuICAgICAgICBpbnN0YW5jZTIuX19rZWVwQWxpdmVTdG9yYWdlQ29udGFpbmVyID0gc3RvcmFnZUNvbnRhaW5lcjtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVubW91bnQodm5vZGUpIHtcbiAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcbiAgICAgIF91bm1vdW50KHZub2RlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcnVuZUNhY2hlKGZpbHRlcikge1xuICAgICAgY2FjaGUuZm9yRWFjaCgodm5vZGUsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShcbiAgICAgICAgICBpc0FzeW5jV3JhcHBlcih2bm9kZSkgPyB2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCB8fCB7fSA6IHZub2RlLnR5cGVcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5KGtleSkge1xuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAoY2FjaGVkICYmICghY3VycmVudCB8fCAhaXNTYW1lVk5vZGVUeXBlKGNhY2hlZCwgY3VycmVudCkpKSB7XG4gICAgICAgIHVubW91bnQoY2FjaGVkKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudCkge1xuICAgICAgICByZXNldFNoYXBlRmxhZyhjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAga2V5cy5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgd2F0Y2goXG4gICAgICAoKSA9PiBbcHJvcHMuaW5jbHVkZSwgcHJvcHMuZXhjbHVkZV0sXG4gICAgICAoW2luY2x1ZGUsIGV4Y2x1ZGVdKSA9PiB7XG4gICAgICAgIGluY2x1ZGUgJiYgcHJ1bmVDYWNoZSgobmFtZSkgPT4gbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSk7XG4gICAgICAgIGV4Y2x1ZGUgJiYgcHJ1bmVDYWNoZSgobmFtZSkgPT4gIW1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpO1xuICAgICAgfSxcbiAgICAgIC8vIHBydW5lIHBvc3QtcmVuZGVyIGFmdGVyIGBjdXJyZW50YCBoYXMgYmVlbiB1cGRhdGVkXG4gICAgICB7IGZsdXNoOiBcInBvc3RcIiwgZGVlcDogdHJ1ZSB9XG4gICAgKTtcbiAgICBsZXQgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICBjb25zdCBjYWNoZVN1YnRyZWUgPSAoKSA9PiB7XG4gICAgICBpZiAocGVuZGluZ0NhY2hlS2V5ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGlzU3VzcGVuc2UoaW5zdGFuY2Uuc3ViVHJlZS50eXBlKSkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcbiAgICAgICAgICB9LCBpbnN0YW5jZS5zdWJUcmVlLnN1c3BlbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgb25Nb3VudGVkKGNhY2hlU3VidHJlZSk7XG4gICAgb25VcGRhdGVkKGNhY2hlU3VidHJlZSk7XG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcbiAgICAgIGNhY2hlLmZvckVhY2goKGNhY2hlZCkgPT4ge1xuICAgICAgICBjb25zdCB7IHN1YlRyZWUsIHN1c3BlbnNlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSBnZXRJbm5lckNoaWxkKHN1YlRyZWUpO1xuICAgICAgICBpZiAoY2FjaGVkLnR5cGUgPT09IHZub2RlLnR5cGUgJiYgY2FjaGVkLmtleSA9PT0gdm5vZGUua2V5KSB7XG4gICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xuICAgICAgICAgIGNvbnN0IGRhID0gdm5vZGUuY29tcG9uZW50LmRhO1xuICAgICAgICAgIGRhICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkYSwgc3VzcGVuc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICAgIGlmICghc2xvdHMuZGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHJhd1ZOb2RlID0gY2hpbGRyZW5bMF07XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShgS2VlcEFsaXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgfSBlbHNlIGlmICghaXNWTm9kZShyYXdWTm9kZSkgfHwgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiA0KSAmJiAhKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCkpIHtcbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgIH1cbiAgICAgIGxldCB2bm9kZSA9IGdldElubmVyQ2hpbGQocmF3Vk5vZGUpO1xuICAgICAgaWYgKHZub2RlLnR5cGUgPT09IENvbW1lbnQpIHtcbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbXAgPSB2bm9kZS50eXBlO1xuICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoXG4gICAgICAgIGlzQXN5bmNXcmFwcGVyKHZub2RlKSA/IHZub2RlLnR5cGUuX19hc3luY1Jlc29sdmVkIHx8IHt9IDogY29tcFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHsgaW5jbHVkZSwgZXhjbHVkZSwgbWF4IH0gPSBwcm9wcztcbiAgICAgIGlmIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkgfHwgZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpIHtcbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnICY9IC0yNTc7XG4gICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcbiAgICAgICAgcmV0dXJuIHJhd1ZOb2RlO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5ID0gdm5vZGUua2V5ID09IG51bGwgPyBjb21wIDogdm5vZGUua2V5O1xuICAgICAgY29uc3QgY2FjaGVkVk5vZGUgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgIGlmICh2bm9kZS5lbCkge1xuICAgICAgICB2bm9kZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgICAgICBpZiAocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgICAgICAgcmF3Vk5vZGUuc3NDb250ZW50ID0gdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlbmRpbmdDYWNoZUtleSA9IGtleTtcbiAgICAgIGlmIChjYWNoZWRWTm9kZSkge1xuICAgICAgICB2bm9kZS5lbCA9IGNhY2hlZFZOb2RlLmVsO1xuICAgICAgICB2bm9kZS5jb21wb25lbnQgPSBjYWNoZWRWTm9kZS5jb21wb25lbnQ7XG4gICAgICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCB2bm9kZS50cmFuc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gNTEyO1xuICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgICAgaWYgKG1heCAmJiBrZXlzLnNpemUgPiBwYXJzZUludChtYXgsIDEwKSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSAyNTY7XG4gICAgICBjdXJyZW50ID0gdm5vZGU7XG4gICAgICByZXR1cm4gaXNTdXNwZW5zZShyYXdWTm9kZS50eXBlKSA/IHJhd1ZOb2RlIDogdm5vZGU7XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IEtlZXBBbGl2ZSA9IEtlZXBBbGl2ZUltcGw7XG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKGlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zb21lKChwKSA9PiBtYXRjaGVzKHAsIG5hbWUpKTtcbiAgfSBlbHNlIGlmIChpc1N0cmluZyhwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KFwiLFwiKS5pbmNsdWRlcyhuYW1lKTtcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9uQWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xuICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJhXCIsIHRhcmdldCk7XG59XG5mdW5jdGlvbiBvbkRlYWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xuICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJkYVwiLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIHR5cGUsIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZGMgfHwgKGhvb2suX193ZGMgPSAoKSA9PiB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50LmlzRGVhY3RpdmF0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gaG9vaygpO1xuICB9KTtcbiAgaW5qZWN0SG9vayh0eXBlLCB3cmFwcGVkSG9vaywgdGFyZ2V0KTtcbiAgaWYgKHRhcmdldCkge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0LnBhcmVudDtcbiAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50LnBhcmVudCkge1xuICAgICAgaWYgKGlzS2VlcEFsaXZlKGN1cnJlbnQucGFyZW50LnZub2RlKSkge1xuICAgICAgICBpbmplY3RUb0tlZXBBbGl2ZVJvb3Qod3JhcHBlZEhvb2ssIHR5cGUsIHRhcmdldCwgY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpbmplY3RUb0tlZXBBbGl2ZVJvb3QoaG9vaywgdHlwZSwgdGFyZ2V0LCBrZWVwQWxpdmVSb290KSB7XG4gIGNvbnN0IGluamVjdGVkID0gaW5qZWN0SG9vayhcbiAgICB0eXBlLFxuICAgIGhvb2ssXG4gICAga2VlcEFsaXZlUm9vdCxcbiAgICB0cnVlXG4gICAgLyogcHJlcGVuZCAqL1xuICApO1xuICBvblVubW91bnRlZCgoKSA9PiB7XG4gICAgcmVtb3ZlKGtlZXBBbGl2ZVJvb3RbdHlwZV0sIGluamVjdGVkKTtcbiAgfSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlc2V0U2hhcGVGbGFnKHZub2RlKSB7XG4gIHZub2RlLnNoYXBlRmxhZyAmPSAtMjU3O1xuICB2bm9kZS5zaGFwZUZsYWcgJj0gLTUxMztcbn1cbmZ1bmN0aW9uIGdldElubmVyQ2hpbGQodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmIDEyOCA/IHZub2RlLnNzQ29udGVudCA6IHZub2RlO1xufVxuXG5mdW5jdGlvbiBpbmplY3RIb29rKHR5cGUsIGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSwgcHJlcGVuZCA9IGZhbHNlKSB7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBjb25zdCBob29rcyA9IHRhcmdldFt0eXBlXSB8fCAodGFyZ2V0W3R5cGVdID0gW10pO1xuICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dlaCB8fCAoaG9vay5fX3dlaCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBjb25zdCByZXNldCA9IHNldEN1cnJlbnRJbnN0YW5jZSh0YXJnZXQpO1xuICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgdGFyZ2V0LCB0eXBlLCBhcmdzKTtcbiAgICAgIHJlc2V0KCk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICBob29rcy51bnNoaWZ0KHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9va3MucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfVxuICAgIHJldHVybiB3cmFwcGVkSG9vaztcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgYXBpTmFtZSA9IHRvSGFuZGxlcktleShFcnJvclR5cGVTdHJpbmdzJDFbdHlwZV0ucmVwbGFjZSgvIGhvb2skLywgXCJcIikpO1xuICAgIHdhcm4kMShcbiAgICAgIGAke2FwaU5hbWV9IGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLiBMaWZlY3ljbGUgaW5qZWN0aW9uIEFQSXMgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHNldHVwKCkuYCArIChgIElmIHlvdSBhcmUgdXNpbmcgYXN5bmMgc2V0dXAoKSwgbWFrZSBzdXJlIHRvIHJlZ2lzdGVyIGxpZmVjeWNsZSBob29rcyBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0IHN0YXRlbWVudC5gIClcbiAgICApO1xuICB9XG59XG5jb25zdCBjcmVhdGVIb29rID0gKGxpZmVjeWNsZSkgPT4gKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkgPT4ge1xuICBpZiAoIWlzSW5TU1JDb21wb25lbnRTZXR1cCB8fCBsaWZlY3ljbGUgPT09IFwic3BcIikge1xuICAgIGluamVjdEhvb2sobGlmZWN5Y2xlLCAoLi4uYXJncykgPT4gaG9vayguLi5hcmdzKSwgdGFyZ2V0KTtcbiAgfVxufTtcbmNvbnN0IG9uQmVmb3JlTW91bnQgPSBjcmVhdGVIb29rKFwiYm1cIik7XG5jb25zdCBvbk1vdW50ZWQgPSBjcmVhdGVIb29rKFwibVwiKTtcbmNvbnN0IG9uQmVmb3JlVXBkYXRlID0gY3JlYXRlSG9vayhcbiAgXCJidVwiXG4pO1xuY29uc3Qgb25VcGRhdGVkID0gY3JlYXRlSG9vayhcInVcIik7XG5jb25zdCBvbkJlZm9yZVVubW91bnQgPSBjcmVhdGVIb29rKFxuICBcImJ1bVwiXG4pO1xuY29uc3Qgb25Vbm1vdW50ZWQgPSBjcmVhdGVIb29rKFwidW1cIik7XG5jb25zdCBvblNlcnZlclByZWZldGNoID0gY3JlYXRlSG9vayhcbiAgXCJzcFwiXG4pO1xuY29uc3Qgb25SZW5kZXJUcmlnZ2VyZWQgPSBjcmVhdGVIb29rKFwicnRnXCIpO1xuY29uc3Qgb25SZW5kZXJUcmFja2VkID0gY3JlYXRlSG9vayhcInJ0Y1wiKTtcbmZ1bmN0aW9uIG9uRXJyb3JDYXB0dXJlZChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgaW5qZWN0SG9vayhcImVjXCIsIGhvb2ssIHRhcmdldCk7XG59XG5cbmNvbnN0IENPTVBPTkVOVFMgPSBcImNvbXBvbmVudHNcIjtcbmNvbnN0IERJUkVDVElWRVMgPSBcImRpcmVjdGl2ZXNcIjtcbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQobmFtZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgbmFtZSwgdHJ1ZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB8fCBuYW1lO1xufVxuY29uc3QgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwidi1uZGNcIik7XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgaWYgKGlzU3RyaW5nKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIGNvbXBvbmVudCwgZmFsc2UpIHx8IGNvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29tcG9uZW50IHx8IE5VTExfRFlOQU1JQ19DT01QT05FTlQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVEaXJlY3RpdmUobmFtZSkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KERJUkVDVElWRVMsIG5hbWUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KHR5cGUsIG5hbWUsIHdhcm5NaXNzaW5nID0gdHJ1ZSwgbWF5YmVTZWxmUmVmZXJlbmNlID0gZmFsc2UpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEluc3RhbmNlO1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICAgIGlmICh0eXBlID09PSBDT01QT05FTlRTKSB7XG4gICAgICBjb25zdCBzZWxmTmFtZSA9IGdldENvbXBvbmVudE5hbWUoXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgICBpZiAoc2VsZk5hbWUgJiYgKHNlbGZOYW1lID09PSBuYW1lIHx8IHNlbGZOYW1lID09PSBjYW1lbGl6ZShuYW1lKSB8fCBzZWxmTmFtZSA9PT0gY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSkpKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IChcbiAgICAgIC8vIGxvY2FsIHJlZ2lzdHJhdGlvblxuICAgICAgLy8gY2hlY2sgaW5zdGFuY2VbdHlwZV0gZmlyc3Qgd2hpY2ggaXMgcmVzb2x2ZWQgZm9yIG9wdGlvbnMgQVBJXG4gICAgICByZXNvbHZlKGluc3RhbmNlW3R5cGVdIHx8IENvbXBvbmVudFt0eXBlXSwgbmFtZSkgfHwgLy8gZ2xvYmFsIHJlZ2lzdHJhdGlvblxuICAgICAgcmVzb2x2ZShpbnN0YW5jZS5hcHBDb250ZXh0W3R5cGVdLCBuYW1lKVxuICAgICk7XG4gICAgaWYgKCFyZXMgJiYgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgICBjb25zdCBleHRyYSA9IHR5cGUgPT09IENPTVBPTkVOVFMgPyBgXG5JZiB0aGlzIGlzIGEgbmF0aXZlIGN1c3RvbSBlbGVtZW50LCBtYWtlIHN1cmUgdG8gZXhjbHVkZSBpdCBmcm9tIGNvbXBvbmVudCByZXNvbHV0aW9uIHZpYSBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50LmAgOiBgYDtcbiAgICAgIHdhcm4kMShgRmFpbGVkIHRvIHJlc29sdmUgJHt0eXBlLnNsaWNlKDAsIC0xKX06ICR7bmFtZX0ke2V4dHJhfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgcmVzb2x2ZSR7Y2FwaXRhbGl6ZSh0eXBlLnNsaWNlKDAsIC0xKSl9IGNhbiBvbmx5IGJlIHVzZWQgaW4gcmVuZGVyKCkgb3Igc2V0dXAoKS5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZShyZWdpc3RyeSwgbmFtZSkge1xuICByZXR1cm4gcmVnaXN0cnkgJiYgKHJlZ2lzdHJ5W25hbWVdIHx8IHJlZ2lzdHJ5W2NhbWVsaXplKG5hbWUpXSB8fCByZWdpc3RyeVtjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKV0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJMaXN0KHNvdXJjZSwgcmVuZGVySXRlbSwgY2FjaGUsIGluZGV4KSB7XG4gIGxldCByZXQ7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlICYmIGNhY2hlW2luZGV4XTtcbiAgY29uc3Qgc291cmNlSXNBcnJheSA9IGlzQXJyYXkoc291cmNlKTtcbiAgaWYgKHNvdXJjZUlzQXJyYXkgfHwgaXNTdHJpbmcoc291cmNlKSkge1xuICAgIGNvbnN0IHNvdXJjZUlzUmVhY3RpdmVBcnJheSA9IHNvdXJjZUlzQXJyYXkgJiYgaXNSZWFjdGl2ZShzb3VyY2UpO1xuICAgIGxldCBuZWVkc1dyYXAgPSBmYWxzZTtcbiAgICBsZXQgaXNSZWFkb25seVNvdXJjZSA9IGZhbHNlO1xuICAgIGlmIChzb3VyY2VJc1JlYWN0aXZlQXJyYXkpIHtcbiAgICAgIG5lZWRzV3JhcCA9ICFpc1NoYWxsb3coc291cmNlKTtcbiAgICAgIGlzUmVhZG9ubHlTb3VyY2UgPSBpc1JlYWRvbmx5KHNvdXJjZSk7XG4gICAgICBzb3VyY2UgPSBzaGFsbG93UmVhZEFycmF5KHNvdXJjZSk7XG4gICAgfVxuICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oXG4gICAgICAgIG5lZWRzV3JhcCA/IGlzUmVhZG9ubHlTb3VyY2UgPyB0b1JlYWRvbmx5KHRvUmVhY3RpdmUoc291cmNlW2ldKSkgOiB0b1JlYWN0aXZlKHNvdXJjZVtpXSkgOiBzb3VyY2VbaV0sXG4gICAgICAgIGksXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgY2FjaGVkICYmIGNhY2hlZFtpXVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFOdW1iZXIuaXNJbnRlZ2VyKHNvdXJjZSkpIHtcbiAgICAgIHdhcm4kMShgVGhlIHYtZm9yIHJhbmdlIGV4cGVjdCBhbiBpbnRlZ2VyIHZhbHVlIGJ1dCBnb3QgJHtzb3VyY2V9LmApO1xuICAgIH1cbiAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXJJdGVtKGkgKyAxLCBpLCB2b2lkIDAsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgaWYgKHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICByZXQgPSBBcnJheS5mcm9tKFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIChpdGVtLCBpKSA9PiByZW5kZXJJdGVtKGl0ZW0sIGksIHZvaWQgMCwgY2FjaGVkICYmIGNhY2hlZFtpXSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2Vba2V5XSwga2V5LCBpLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0ID0gW107XG4gIH1cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGVbaW5kZXhdID0gcmV0O1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNsb3RzKHNsb3RzLCBkeW5hbWljU2xvdHMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljU2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbG90ID0gZHluYW1pY1Nsb3RzW2ldO1xuICAgIGlmIChpc0FycmF5KHNsb3QpKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsb3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc2xvdHNbc2xvdFtqXS5uYW1lXSA9IHNsb3Rbal0uZm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICBzbG90c1tzbG90Lm5hbWVdID0gc2xvdC5rZXkgPyAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSBzbG90LmZuKC4uLmFyZ3MpO1xuICAgICAgICBpZiAocmVzKSByZXMua2V5ID0gc2xvdC5rZXk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9IDogc2xvdC5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTbG90KHNsb3RzLCBuYW1lLCBwcm9wcyA9IHt9LCBmYWxsYmFjaywgbm9TbG90dGVkKSB7XG4gIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCAmJiBpc0FzeW5jV3JhcHBlcihjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50KSAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50LmNlKSB7XG4gICAgY29uc3QgaGFzUHJvcHMgPSBPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID4gMDtcbiAgICBpZiAobmFtZSAhPT0gXCJkZWZhdWx0XCIpIHByb3BzLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiBvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soXG4gICAgICBGcmFnbWVudCxcbiAgICAgIG51bGwsXG4gICAgICBbY3JlYXRlVk5vZGUoXCJzbG90XCIsIHByb3BzLCBmYWxsYmFjayAmJiBmYWxsYmFjaygpKV0sXG4gICAgICBoYXNQcm9wcyA/IC0yIDogNjRcbiAgICApO1xuICB9XG4gIGxldCBzbG90ID0gc2xvdHNbbmFtZV07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNsb3QgJiYgc2xvdC5sZW5ndGggPiAxKSB7XG4gICAgd2FybiQxKFxuICAgICAgYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBwYXJlbnQgdGVtcGxhdGUuYFxuICAgICk7XG4gICAgc2xvdCA9ICgpID0+IFtdO1xuICB9XG4gIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcbiAgICBzbG90Ll9kID0gZmFsc2U7XG4gIH1cbiAgb3BlbkJsb2NrKCk7XG4gIGNvbnN0IHZhbGlkU2xvdENvbnRlbnQgPSBzbG90ICYmIGVuc3VyZVZhbGlkVk5vZGUoc2xvdChwcm9wcykpO1xuICBjb25zdCBzbG90S2V5ID0gcHJvcHMua2V5IHx8IC8vIHNsb3QgY29udGVudCBhcnJheSBvZiBhIGR5bmFtaWMgY29uZGl0aW9uYWwgc2xvdCBtYXkgaGF2ZSBhIGJyYW5jaFxuICAvLyBrZXkgYXR0YWNoZWQgaW4gdGhlIGBjcmVhdGVTbG90c2AgaGVscGVyLCByZXNwZWN0IHRoYXRcbiAgdmFsaWRTbG90Q29udGVudCAmJiB2YWxpZFNsb3RDb250ZW50LmtleTtcbiAgY29uc3QgcmVuZGVyZWQgPSBjcmVhdGVCbG9jayhcbiAgICBGcmFnbWVudCxcbiAgICB7XG4gICAgICBrZXk6IChzbG90S2V5ICYmICFpc1N5bWJvbChzbG90S2V5KSA/IHNsb3RLZXkgOiBgXyR7bmFtZX1gKSArIC8vICM3MjU2IGZvcmNlIGRpZmZlcmVudGlhdGUgZmFsbGJhY2sgY29udGVudCBmcm9tIGFjdHVhbCBjb250ZW50XG4gICAgICAoIXZhbGlkU2xvdENvbnRlbnQgJiYgZmFsbGJhY2sgPyBcIl9mYlwiIDogXCJcIilcbiAgICB9LFxuICAgIHZhbGlkU2xvdENvbnRlbnQgfHwgKGZhbGxiYWNrID8gZmFsbGJhY2soKSA6IFtdKSxcbiAgICB2YWxpZFNsb3RDb250ZW50ICYmIHNsb3RzLl8gPT09IDEgPyA2NCA6IC0yXG4gICk7XG4gIGlmICghbm9TbG90dGVkICYmIHJlbmRlcmVkLnNjb3BlSWQpIHtcbiAgICByZW5kZXJlZC5zbG90U2NvcGVJZHMgPSBbcmVuZGVyZWQuc2NvcGVJZCArIFwiLXNcIl07XG4gIH1cbiAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xuICAgIHNsb3QuX2QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZW5kZXJlZDtcbn1cbmZ1bmN0aW9uIGVuc3VyZVZhbGlkVk5vZGUodm5vZGVzKSB7XG4gIHJldHVybiB2bm9kZXMuc29tZSgoY2hpbGQpID0+IHtcbiAgICBpZiAoIWlzVk5vZGUoY2hpbGQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCAmJiAhZW5zdXJlVmFsaWRWTm9kZShjaGlsZC5jaGlsZHJlbikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pID8gdm5vZGVzIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9IYW5kbGVycyhvYmosIHByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNPYmplY3Qob2JqKSkge1xuICAgIHdhcm4kMShgdi1vbiB3aXRoIG5vIGFyZ3VtZW50IGV4cGVjdHMgYW4gb2JqZWN0IHZhbHVlLmApO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgcmV0W3ByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5ICYmIC9bQS1aXS8udGVzdChrZXkpID8gYG9uOiR7a2V5fWAgOiB0b0hhbmRsZXJLZXkoa2V5KV0gPSBvYmpba2V5XTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBnZXRQdWJsaWNJbnN0YW5jZSA9IChpKSA9PiB7XG4gIGlmICghaSkgcmV0dXJuIG51bGw7XG4gIGlmIChpc1N0YXRlZnVsQ29tcG9uZW50KGkpKSByZXR1cm4gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2UoaSk7XG4gIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCk7XG59O1xuY29uc3QgcHVibGljUHJvcGVydGllc01hcCA9IChcbiAgLy8gTW92ZSBQVVJFIG1hcmtlciB0byBuZXcgbGluZSB0byB3b3JrYXJvdW5kIGNvbXBpbGVyIGRpc2NhcmRpbmcgaXRcbiAgLy8gZHVlIHRvIHR5cGUgYW5ub3RhdGlvblxuICAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgJDogKGkpID0+IGksXG4gICAgJGVsOiAoaSkgPT4gaS52bm9kZS5lbCxcbiAgICAkZGF0YTogKGkpID0+IGkuZGF0YSxcbiAgICAkcHJvcHM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkucHJvcHMpIDogaS5wcm9wcyxcbiAgICAkYXR0cnM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkuYXR0cnMpIDogaS5hdHRycyxcbiAgICAkc2xvdHM6IChpKSA9PiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGkuc2xvdHMpIDogaS5zbG90cyxcbiAgICAkcmVmczogKGkpID0+ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkoaS5yZWZzKSA6IGkucmVmcyxcbiAgICAkcGFyZW50OiAoaSkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpLFxuICAgICRyb290OiAoaSkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5yb290KSxcbiAgICAkaG9zdDogKGkpID0+IGkuY2UsXG4gICAgJGVtaXQ6IChpKSA9PiBpLmVtaXQsXG4gICAgJG9wdGlvbnM6IChpKSA9PiBfX1ZVRV9PUFRJT05TX0FQSV9fID8gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaSkgOiBpLnR5cGUsXG4gICAgJGZvcmNlVXBkYXRlOiAoaSkgPT4gaS5mIHx8IChpLmYgPSAoKSA9PiB7XG4gICAgICBxdWV1ZUpvYihpLnVwZGF0ZSk7XG4gICAgfSksXG4gICAgJG5leHRUaWNrOiAoaSkgPT4gaS5uIHx8IChpLm4gPSBuZXh0VGljay5iaW5kKGkucHJveHkpKSxcbiAgICAkd2F0Y2g6IChpKSA9PiBfX1ZVRV9PUFRJT05TX0FQSV9fID8gaW5zdGFuY2VXYXRjaC5iaW5kKGkpIDogTk9PUFxuICB9KVxuKTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcmVmaXggPSAoa2V5KSA9PiBrZXkgPT09IFwiX1wiIHx8IGtleSA9PT0gXCIkXCI7XG5jb25zdCBoYXNTZXR1cEJpbmRpbmcgPSAoc3RhdGUsIGtleSkgPT4gc3RhdGUgIT09IEVNUFRZX09CSiAmJiAhc3RhdGUuX19pc1NjcmlwdFNldHVwICYmIGhhc093bihzdGF0ZSwga2V5KTtcbmNvbnN0IFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IHtcbiAgZ2V0KHsgXzogaW5zdGFuY2UgfSwga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gXCJfX3Zfc2tpcFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUsIGRhdGEsIHByb3BzLCBhY2Nlc3NDYWNoZSwgdHlwZSwgYXBwQ29udGV4dCB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5ID09PSBcIl9faXNWdWVcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChrZXlbMF0gIT09IFwiJFwiKSB7XG4gICAgICBjb25zdCBuID0gYWNjZXNzQ2FjaGVba2V5XTtcbiAgICAgIGlmIChuICE9PSB2b2lkIDApIHtcbiAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgY2FzZSAxIC8qIFNFVFVQICovOlxuICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcbiAgICAgICAgICBjYXNlIDIgLyogREFUQSAqLzpcbiAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICAgICAgY2FzZSA0IC8qIENPTlRFWFQgKi86XG4gICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgICAgICAgY2FzZSAzIC8qIFBST1BTICovOlxuICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDEgLyogU0VUVVAgKi87XG4gICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XG4gICAgICB9IGVsc2UgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAyIC8qIERBVEEgKi87XG4gICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICB9IGVsc2UgaWYgKGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMyAvKiBQUk9QUyAqLztcbiAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICB9IGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcbiAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogQ09OVEVYVCAqLztcbiAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgfSBlbHNlIGlmICghX19WVUVfT1BUSU9OU19BUElfXyB8fCBzaG91bGRDYWNoZUFjY2Vzcykge1xuICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMCAvKiBPVEhFUiAqLztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHVibGljR2V0dGVyID0gcHVibGljUHJvcGVydGllc01hcFtrZXldO1xuICAgIGxldCBjc3NNb2R1bGUsIGdsb2JhbFByb3BlcnRpZXM7XG4gICAgaWYgKHB1YmxpY0dldHRlcikge1xuICAgICAgaWYgKGtleSA9PT0gXCIkYXR0cnNcIikge1xuICAgICAgICB0cmFjayhpbnN0YW5jZS5hdHRycywgXCJnZXRcIiwgXCJcIik7XG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXkgPT09IFwiJHNsb3RzXCIpIHtcbiAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVibGljR2V0dGVyKGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gY3NzIG1vZHVsZSAoaW5qZWN0ZWQgYnkgdnVlLWxvYWRlcilcbiAgICAgIChjc3NNb2R1bGUgPSB0eXBlLl9fY3NzTW9kdWxlcykgJiYgKGNzc01vZHVsZSA9IGNzc01vZHVsZVtrZXldKVxuICAgICkge1xuICAgICAgcmV0dXJuIGNzc01vZHVsZTtcbiAgICB9IGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcbiAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XG4gICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIGdsb2JhbCBwcm9wZXJ0aWVzXG4gICAgICBnbG9iYWxQcm9wZXJ0aWVzID0gYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywgaGFzT3duKGdsb2JhbFByb3BlcnRpZXMsIGtleSlcbiAgICApIHtcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFByb3BlcnRpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlICYmICghaXNTdHJpbmcoa2V5KSB8fCAvLyAjMTA5MSBhdm9pZCBpbnRlcm5hbCBpc1JlZi9pc1ZOb2RlIGNoZWNrcyBvbiBjb21wb25lbnQgaW5zdGFuY2UgbGVhZGluZ1xuICAgIC8vIHRvIGluZmluaXRlIHdhcm5pbmcgbG9vcFxuICAgIGtleS5pbmRleE9mKFwiX192XCIpICE9PSAwKSkge1xuICAgICAgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBpc1Jlc2VydmVkUHJlZml4KGtleVswXSkgJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKX0gbXVzdCBiZSBhY2Nlc3NlZCB2aWEgJGRhdGEgYmVjYXVzZSBpdCBzdGFydHMgd2l0aCBhIHJlc2VydmVkIGNoYXJhY3RlciAoXCIkXCIgb3IgXCJfXCIpIGFuZCBpcyBub3QgcHJveGllZCBvbiB0aGUgcmVuZGVyIGNvbnRleHQuYFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChpbnN0YW5jZSA9PT0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSB3YXMgYWNjZXNzZWQgZHVyaW5nIHJlbmRlciBidXQgaXMgbm90IGRlZmluZWQgb24gaW5zdGFuY2UuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2V0KHsgXzogaW5zdGFuY2UgfSwga2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4IH0gPSBpbnN0YW5jZTtcbiAgICBpZiAoaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgIHNldHVwU3RhdGVba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICB3YXJuJDEoYENhbm5vdCBtdXRhdGUgPHNjcmlwdCBzZXR1cD4gYmluZGluZyBcIiR7a2V5fVwiIGZyb20gT3B0aW9ucyBBUEkuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmIGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xuICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGhhc093bihpbnN0YW5jZS5wcm9wcywga2V5KSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHByb3AgXCIke2tleX1cIi4gUHJvcHMgYXJlIHJlYWRvbmx5LmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoa2V5WzBdID09PSBcIiRcIiAmJiBrZXkuc2xpY2UoMSkgaW4gaW5zdGFuY2UpIHtcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKFxuICAgICAgICBgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIFByb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCAkIGFyZSByZXNlcnZlZCBhbmQgcmVhZG9ubHkuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5IGluIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHhba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgaGFzKHtcbiAgICBfOiB7IGRhdGEsIHNldHVwU3RhdGUsIGFjY2Vzc0NhY2hlLCBjdHgsIGFwcENvbnRleHQsIHByb3BzLCB0eXBlIH1cbiAgfSwga2V5KSB7XG4gICAgbGV0IGNzc01vZHVsZXM7XG4gICAgcmV0dXJuICEhKGFjY2Vzc0NhY2hlW2tleV0gfHwgX19WVUVfT1BUSU9OU19BUElfXyAmJiBkYXRhICE9PSBFTVBUWV9PQkogJiYga2V5WzBdICE9PSBcIiRcIiAmJiBoYXNPd24oZGF0YSwga2V5KSB8fCBoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSB8fCBoYXNPd24ocHJvcHMsIGtleSkgfHwgaGFzT3duKGN0eCwga2V5KSB8fCBoYXNPd24ocHVibGljUHJvcGVydGllc01hcCwga2V5KSB8fCBoYXNPd24oYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywga2V5KSB8fCAoY3NzTW9kdWxlcyA9IHR5cGUuX19jc3NNb2R1bGVzKSAmJiBjc3NNb2R1bGVzW2tleV0pO1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIGlmIChkZXNjcmlwdG9yLmdldCAhPSBudWxsKSB7XG4gICAgICB0YXJnZXQuXy5hY2Nlc3NDYWNoZVtrZXldID0gMDtcbiAgICB9IGVsc2UgaWYgKGhhc093bihkZXNjcmlwdG9yLCBcInZhbHVlXCIpKSB7XG4gICAgICB0aGlzLnNldCh0YXJnZXQsIGtleSwgZGVzY3JpcHRvci52YWx1ZSwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufTtcbmlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUpIHtcbiAgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLm93bktleXMgPSAodGFyZ2V0KSA9PiB7XG4gICAgd2FybiQxKFxuICAgICAgYEF2b2lkIGFwcCBsb2dpYyB0aGF0IHJlbGllcyBvbiBlbnVtZXJhdGluZyBrZXlzIG9uIGEgY29tcG9uZW50IGluc3RhbmNlLiBUaGUga2V5cyB3aWxsIGJlIGVtcHR5IGluIHByb2R1Y3Rpb24gbW9kZSB0byBhdm9pZCBwZXJmb3JtYW5jZSBvdmVyaGVhZC5gXG4gICAgKTtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gIH07XG59XG5jb25zdCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKHt9LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMsIHtcbiAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gU3ltYm9sLnVuc2NvcGFibGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuZ2V0KHRhcmdldCwga2V5LCB0YXJnZXQpO1xuICB9LFxuICBoYXMoXywga2V5KSB7XG4gICAgY29uc3QgaGFzID0ga2V5WzBdICE9PSBcIl9cIiAmJiAhaXNHbG9iYWxseUFsbG93ZWQoa2V5KTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaGFzICYmIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5oYXMoXywga2V5KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBrZXlcbiAgICAgICAgKX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIF8gd2hpY2ggaXMgYSByZXNlcnZlZCBwcmVmaXggZm9yIFZ1ZSBpbnRlcm5hbHMuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhcztcbiAgfVxufSk7XG5mdW5jdGlvbiBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IHRhcmdldCA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBgX2AsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiAoKSA9PiBpbnN0YW5jZVxuICB9KTtcbiAgT2JqZWN0LmtleXMocHVibGljUHJvcGVydGllc01hcCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogKCkgPT4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKSxcbiAgICAgIC8vIGludGVyY2VwdGVkIGJ5IHRoZSBwcm94eSBzbyBubyBuZWVkIGZvciBpbXBsZW1lbnRhdGlvbixcbiAgICAgIC8vIGJ1dCBuZWVkZWQgdG8gcHJldmVudCBzZXQgZXJyb3JzXG4gICAgICBzZXQ6IE5PT1BcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB7XG4gICAgY3R4LFxuICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc11cbiAgfSA9IGluc3RhbmNlO1xuICBpZiAocHJvcHNPcHRpb25zKSB7XG4gICAgT2JqZWN0LmtleXMocHJvcHNPcHRpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gaW5zdGFuY2UucHJvcHNba2V5XSxcbiAgICAgICAgc2V0OiBOT09QXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSB9ID0gaW5zdGFuY2U7XG4gIE9iamVjdC5rZXlzKHRvUmF3KHNldHVwU3RhdGUpKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoIXNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgc2V0dXAoKSByZXR1cm4gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBcIiRcIiBvciBcIl9cIiB3aGljaCBhcmUgcmVzZXJ2ZWQgcHJlZml4ZXMgZm9yIFZ1ZSBpbnRlcm5hbHMuYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IHNldHVwU3RhdGVba2V5XSxcbiAgICAgICAgc2V0OiBOT09QXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCB3YXJuUnVudGltZVVzYWdlID0gKG1ldGhvZCkgPT4gd2FybiQxKFxuICBgJHttZXRob2R9KCkgaXMgYSBjb21waWxlci1oaW50IGhlbHBlciB0aGF0IGlzIG9ubHkgdXNhYmxlIGluc2lkZSA8c2NyaXB0IHNldHVwPiBvZiBhIHNpbmdsZSBmaWxlIGNvbXBvbmVudC4gSXRzIGFyZ3VtZW50cyBzaG91bGQgYmUgY29tcGlsZWQgYXdheSBhbmQgcGFzc2luZyBpdCBhdCBydW50aW1lIGhhcyBubyBlZmZlY3QuYFxuKTtcbmZ1bmN0aW9uIGRlZmluZVByb3BzKCkge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVByb3BzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkZWZpbmVFbWl0cygpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFbWl0c2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lRXhwb3NlKGV4cG9zZWQpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFeHBvc2VgKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lT3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lT3B0aW9uc2ApO1xuICB9XG59XG5mdW5jdGlvbiBkZWZpbmVTbG90cygpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVTbG90c2ApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVmaW5lTW9kZWwoKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShcImRlZmluZU1vZGVsXCIpO1xuICB9XG59XG5mdW5jdGlvbiB3aXRoRGVmYXVsdHMocHJvcHMsIGRlZmF1bHRzKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgd2FyblJ1bnRpbWVVc2FnZShgd2l0aERlZmF1bHRzYCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1c2VTbG90cygpIHtcbiAgcmV0dXJuIGdldENvbnRleHQoXCJ1c2VTbG90c1wiKS5zbG90cztcbn1cbmZ1bmN0aW9uIHVzZUF0dHJzKCkge1xuICByZXR1cm4gZ2V0Q29udGV4dChcInVzZUF0dHJzXCIpLmF0dHJzO1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dChjYWxsZWRGdW5jdGlvbk5hbWUpIHtcbiAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaSkge1xuICAgIHdhcm4kMShgJHtjYWxsZWRGdW5jdGlvbk5hbWV9KCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xuICB9XG4gIHJldHVybiBpLnNldHVwQ29udGV4dCB8fCAoaS5zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQoaSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHNPckVtaXRzKHByb3BzKSB7XG4gIHJldHVybiBpc0FycmF5KHByb3BzKSA/IHByb3BzLnJlZHVjZShcbiAgICAobm9ybWFsaXplZCwgcCkgPT4gKG5vcm1hbGl6ZWRbcF0gPSBudWxsLCBub3JtYWxpemVkKSxcbiAgICB7fVxuICApIDogcHJvcHM7XG59XG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKHJhdywgZGVmYXVsdHMpIHtcbiAgY29uc3QgcHJvcHMgPSBub3JtYWxpemVQcm9wc09yRW1pdHMocmF3KTtcbiAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJfX3NraXBcIikpIGNvbnRpbnVlO1xuICAgIGxldCBvcHQgPSBwcm9wc1trZXldO1xuICAgIGlmIChvcHQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpKSB7XG4gICAgICAgIG9wdCA9IHByb3BzW2tleV0gPSB7IHR5cGU6IG9wdCwgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0LmRlZmF1bHQgPSBkZWZhdWx0c1trZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0ID09PSBudWxsKSB7XG4gICAgICBvcHQgPSBwcm9wc1trZXldID0geyBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB3YXJuJDEoYHByb3BzIGRlZmF1bHQga2V5IFwiJHtrZXl9XCIgaGFzIG5vIGNvcnJlc3BvbmRpbmcgZGVjbGFyYXRpb24uYCk7XG4gICAgfVxuICAgIGlmIChvcHQgJiYgZGVmYXVsdHNbYF9fc2tpcF8ke2tleX1gXSkge1xuICAgICAgb3B0LnNraXBGYWN0b3J5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BzO1xufVxuZnVuY3Rpb24gbWVyZ2VNb2RlbHMoYSwgYikge1xuICBpZiAoIWEgfHwgIWIpIHJldHVybiBhIHx8IGI7XG4gIGlmIChpc0FycmF5KGEpICYmIGlzQXJyYXkoYikpIHJldHVybiBhLmNvbmNhdChiKTtcbiAgcmV0dXJuIGV4dGVuZCh7fSwgbm9ybWFsaXplUHJvcHNPckVtaXRzKGEpLCBub3JtYWxpemVQcm9wc09yRW1pdHMoYikpO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvcHNSZXN0UHJveHkocHJvcHMsIGV4Y2x1ZGVkS2V5cykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoIWV4Y2x1ZGVkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmV0LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBwcm9wc1trZXldXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHdpdGhBc3luY0NvbnRleHQoZ2V0QXdhaXRhYmxlKSB7XG4gIGNvbnN0IGN0eCA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhY3R4KSB7XG4gICAgd2FybiQxKFxuICAgICAgYHdpdGhBc3luY0NvbnRleHQgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGN1cnJlbnQgaW5zdGFuY2UuIFRoaXMgaXMgbGlrZWx5IGEgYnVnLmBcbiAgICApO1xuICB9XG4gIGxldCBhd2FpdGFibGUgPSBnZXRBd2FpdGFibGUoKTtcbiAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKGlzUHJvbWlzZShhd2FpdGFibGUpKSB7XG4gICAgYXdhaXRhYmxlID0gYXdhaXRhYmxlLmNhdGNoKChlKSA9PiB7XG4gICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KTtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFthd2FpdGFibGUsICgpID0+IHNldEN1cnJlbnRJbnN0YW5jZShjdHgpXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuICh0eXBlLCBrZXkpID0+IHtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgd2FybiQxKGAke3R5cGV9IHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluICR7Y2FjaGVba2V5XX0uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlW2tleV0gPSB0eXBlO1xuICAgIH1cbiAgfTtcbn1cbmxldCBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XG5mdW5jdGlvbiBhcHBseU9wdGlvbnMoaW5zdGFuY2UpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKTtcbiAgY29uc3QgcHVibGljVGhpcyA9IGluc3RhbmNlLnByb3h5O1xuICBjb25zdCBjdHggPSBpbnN0YW5jZS5jdHg7XG4gIHNob3VsZENhY2hlQWNjZXNzID0gZmFsc2U7XG4gIGlmIChvcHRpb25zLmJlZm9yZUNyZWF0ZSkge1xuICAgIGNhbGxIb29rKG9wdGlvbnMuYmVmb3JlQ3JlYXRlLCBpbnN0YW5jZSwgXCJiY1wiKTtcbiAgfVxuICBjb25zdCB7XG4gICAgLy8gc3RhdGVcbiAgICBkYXRhOiBkYXRhT3B0aW9ucyxcbiAgICBjb21wdXRlZDogY29tcHV0ZWRPcHRpb25zLFxuICAgIG1ldGhvZHMsXG4gICAgd2F0Y2g6IHdhdGNoT3B0aW9ucyxcbiAgICBwcm92aWRlOiBwcm92aWRlT3B0aW9ucyxcbiAgICBpbmplY3Q6IGluamVjdE9wdGlvbnMsXG4gICAgLy8gbGlmZWN5Y2xlXG4gICAgY3JlYXRlZCxcbiAgICBiZWZvcmVNb3VudCxcbiAgICBtb3VudGVkLFxuICAgIGJlZm9yZVVwZGF0ZSxcbiAgICB1cGRhdGVkLFxuICAgIGFjdGl2YXRlZCxcbiAgICBkZWFjdGl2YXRlZCxcbiAgICBiZWZvcmVEZXN0cm95LFxuICAgIGJlZm9yZVVubW91bnQsXG4gICAgZGVzdHJveWVkLFxuICAgIHVubW91bnRlZCxcbiAgICByZW5kZXIsXG4gICAgcmVuZGVyVHJhY2tlZCxcbiAgICByZW5kZXJUcmlnZ2VyZWQsXG4gICAgZXJyb3JDYXB0dXJlZCxcbiAgICBzZXJ2ZXJQcmVmZXRjaCxcbiAgICAvLyBwdWJsaWMgQVBJXG4gICAgZXhwb3NlLFxuICAgIGluaGVyaXRBdHRycyxcbiAgICAvLyBhc3NldHNcbiAgICBjb21wb25lbnRzLFxuICAgIGRpcmVjdGl2ZXMsXG4gICAgZmlsdGVyc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSA6IG51bGw7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgW3Byb3BzT3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gICAgaWYgKHByb3BzT3B0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHNPcHRpb25zKSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIlByb3BzXCIgLyogUFJPUFMgKi8sIGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpbmplY3RPcHRpb25zKSB7XG4gICAgcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMpO1xuICB9XG4gIGlmIChtZXRob2RzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgY29uc3QgbWV0aG9kSGFuZGxlciA9IG1ldGhvZHNba2V5XTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG1ldGhvZEhhbmRsZXIpKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4W2tleV0gPSBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJNZXRob2RzXCIgLyogTUVUSE9EUyAqLywga2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIHR5cGUgXCIke3R5cGVvZiBtZXRob2RIYW5kbGVyfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChkYXRhT3B0aW9ucykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0Z1bmN0aW9uKGRhdGFPcHRpb25zKSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgVGhlIGRhdGEgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbi4gUGxhaW4gb2JqZWN0IHVzYWdlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGRhdGFPcHRpb25zLmNhbGwocHVibGljVGhpcywgcHVibGljVGhpcyk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNQcm9taXNlKGRhdGEpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBkYXRhKCkgcmV0dXJuZWQgYSBQcm9taXNlIC0gbm90ZSBkYXRhKCkgY2Fubm90IGJlIGFzeW5jOyBJZiB5b3UgaW50ZW5kIHRvIHBlcmZvcm0gZGF0YSBmZXRjaGluZyBiZWZvcmUgY29tcG9uZW50IHJlbmRlcnMsIHVzZSBhc3luYyBzZXR1cCgpICsgPFN1c3BlbnNlPi5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShgZGF0YSgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5kYXRhID0gcmVhY3RpdmUoZGF0YSk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiRGF0YVwiIC8qIERBVEEgKi8sIGtleSk7XG4gICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGdldDogKCkgPT4gZGF0YVtrZXldLFxuICAgICAgICAgICAgICBzZXQ6IE5PT1BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XG4gIGlmIChjb21wdXRlZE9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdCA9IGNvbXB1dGVkT3B0aW9uc1trZXldO1xuICAgICAgY29uc3QgZ2V0ID0gaXNGdW5jdGlvbihvcHQpID8gb3B0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcykgOiBpc0Z1bmN0aW9uKG9wdC5nZXQpID8gb3B0LmdldC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpIDogTk9PUDtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGdldCA9PT0gTk9PUCkge1xuICAgICAgICB3YXJuJDEoYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaGFzIG5vIGdldHRlci5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNldCA9ICFpc0Z1bmN0aW9uKG9wdCkgJiYgaXNGdW5jdGlvbihvcHQuc2V0KSA/IG9wdC5zZXQuYmluZChwdWJsaWNUaGlzKSA6ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyAoKSA9PiB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBgV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyByZWFkb25seS5gXG4gICAgICAgICk7XG4gICAgICB9IDogTk9PUDtcbiAgICAgIGNvbnN0IGMgPSBjb21wdXRlZCh7XG4gICAgICAgIGdldCxcbiAgICAgICAgc2V0XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gYy52YWx1ZSxcbiAgICAgICAgc2V0OiAodikgPT4gYy52YWx1ZSA9IHZcbiAgICAgIH0pO1xuICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiQ29tcHV0ZWRcIiAvKiBDT01QVVRFRCAqLywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHdhdGNoT3B0aW9ucykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHdhdGNoT3B0aW9ucykge1xuICAgICAgY3JlYXRlV2F0Y2hlcih3YXRjaE9wdGlvbnNba2V5XSwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpO1xuICAgIH1cbiAgfVxuICBpZiAocHJvdmlkZU9wdGlvbnMpIHtcbiAgICBjb25zdCBwcm92aWRlcyA9IGlzRnVuY3Rpb24ocHJvdmlkZU9wdGlvbnMpID8gcHJvdmlkZU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzKSA6IHByb3ZpZGVPcHRpb25zO1xuICAgIFJlZmxlY3Qub3duS2V5cyhwcm92aWRlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBwcm92aWRlKGtleSwgcHJvdmlkZXNba2V5XSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGNyZWF0ZWQpIHtcbiAgICBjYWxsSG9vayhjcmVhdGVkLCBpbnN0YW5jZSwgXCJjXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhyZWdpc3RlciwgaG9vaykge1xuICAgIGlmIChpc0FycmF5KGhvb2spKSB7XG4gICAgICBob29rLmZvckVhY2goKF9ob29rKSA9PiByZWdpc3RlcihfaG9vay5iaW5kKHB1YmxpY1RoaXMpKSk7XG4gICAgfSBlbHNlIGlmIChob29rKSB7XG4gICAgICByZWdpc3Rlcihob29rLmJpbmQocHVibGljVGhpcykpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVNb3VudCwgYmVmb3JlTW91bnQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Nb3VudGVkLCBtb3VudGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVXBkYXRlLCBiZWZvcmVVcGRhdGUpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25VcGRhdGVkLCB1cGRhdGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQWN0aXZhdGVkLCBhY3RpdmF0ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25EZWFjdGl2YXRlZCwgZGVhY3RpdmF0ZWQpO1xuICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25FcnJvckNhcHR1cmVkLCBlcnJvckNhcHR1cmVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJhY2tlZCwgcmVuZGVyVHJhY2tlZCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyaWdnZXJlZCwgcmVuZGVyVHJpZ2dlcmVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVW5tb3VudCwgYmVmb3JlVW5tb3VudCk7XG4gIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVubW91bnRlZCwgdW5tb3VudGVkKTtcbiAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uU2VydmVyUHJlZmV0Y2gsIHNlcnZlclByZWZldGNoKTtcbiAgaWYgKGlzQXJyYXkoZXhwb3NlKSkge1xuICAgIGlmIChleHBvc2UubGVuZ3RoKSB7XG4gICAgICBjb25zdCBleHBvc2VkID0gaW5zdGFuY2UuZXhwb3NlZCB8fCAoaW5zdGFuY2UuZXhwb3NlZCA9IHt9KTtcbiAgICAgIGV4cG9zZS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9zZWQsIGtleSwge1xuICAgICAgICAgIGdldDogKCkgPT4gcHVibGljVGhpc1trZXldLFxuICAgICAgICAgIHNldDogKHZhbCkgPT4gcHVibGljVGhpc1trZXldID0gdmFsLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgICBpbnN0YW5jZS5leHBvc2VkID0ge307XG4gICAgfVxuICB9XG4gIGlmIChyZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QKSB7XG4gICAgaW5zdGFuY2UucmVuZGVyID0gcmVuZGVyO1xuICB9XG4gIGlmIChpbmhlcml0QXR0cnMgIT0gbnVsbCkge1xuICAgIGluc3RhbmNlLmluaGVyaXRBdHRycyA9IGluaGVyaXRBdHRycztcbiAgfVxuICBpZiAoY29tcG9uZW50cykgaW5zdGFuY2UuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gIGlmIChkaXJlY3RpdmVzKSBpbnN0YW5jZS5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgaWYgKHNlcnZlclByZWZldGNoKSB7XG4gICAgbWFya0FzeW5jQm91bmRhcnkoaW5zdGFuY2UpO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9IE5PT1ApIHtcbiAgaWYgKGlzQXJyYXkoaW5qZWN0T3B0aW9ucykpIHtcbiAgICBpbmplY3RPcHRpb25zID0gbm9ybWFsaXplSW5qZWN0KGluamVjdE9wdGlvbnMpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGluamVjdE9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XG4gICAgbGV0IGluamVjdGVkO1xuICAgIGlmIChpc09iamVjdChvcHQpKSB7XG4gICAgICBpZiAoXCJkZWZhdWx0XCIgaW4gb3B0KSB7XG4gICAgICAgIGluamVjdGVkID0gaW5qZWN0KFxuICAgICAgICAgIG9wdC5mcm9tIHx8IGtleSxcbiAgICAgICAgICBvcHQuZGVmYXVsdCxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQuZnJvbSB8fCBrZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmplY3RlZCA9IGluamVjdChvcHQpO1xuICAgIH1cbiAgICBpZiAoaXNSZWYoaW5qZWN0ZWQpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGluamVjdGVkLnZhbHVlLFxuICAgICAgICBzZXQ6ICh2KSA9PiBpbmplY3RlZC52YWx1ZSA9IHZcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHhba2V5XSA9IGluamVjdGVkO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiSW5qZWN0XCIgLyogSU5KRUNUICovLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2FsbEhvb2soaG9vaywgaW5zdGFuY2UsIHR5cGUpIHtcbiAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoXG4gICAgaXNBcnJheShob29rKSA/IGhvb2subWFwKChoKSA9PiBoLmJpbmQoaW5zdGFuY2UucHJveHkpKSA6IGhvb2suYmluZChpbnN0YW5jZS5wcm94eSksXG4gICAgaW5zdGFuY2UsXG4gICAgdHlwZVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlcihyYXcsIGN0eCwgcHVibGljVGhpcywga2V5KSB7XG4gIGxldCBnZXR0ZXIgPSBrZXkuaW5jbHVkZXMoXCIuXCIpID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBrZXkpIDogKCkgPT4gcHVibGljVGhpc1trZXldO1xuICBpZiAoaXNTdHJpbmcocmF3KSkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBjdHhbcmF3XTtcbiAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAge1xuICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgd2FybiQxKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3fVwiYCwgaGFuZGxlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocmF3KSkge1xuICAgIHtcbiAgICAgIHdhdGNoKGdldHRlciwgcmF3LmJpbmQocHVibGljVGhpcykpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChyYXcpKSB7XG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgICAgcmF3LmZvckVhY2goKHIpID0+IGNyZWF0ZVdhdGNoZXIociwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGlzRnVuY3Rpb24ocmF3LmhhbmRsZXIpID8gcmF3LmhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSA6IGN0eFtyYXcuaGFuZGxlcl07XG4gICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIsIHJhdyk7XG4gICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgd2FybiQxKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3LmhhbmRsZXJ9XCJgLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShgSW52YWxpZCB3YXRjaCBvcHRpb246IFwiJHtrZXl9XCJgLCByYXcpO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkge1xuICBjb25zdCBiYXNlID0gaW5zdGFuY2UudHlwZTtcbiAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBiYXNlO1xuICBjb25zdCB7XG4gICAgbWl4aW5zOiBnbG9iYWxNaXhpbnMsXG4gICAgb3B0aW9uc0NhY2hlOiBjYWNoZSxcbiAgICBjb25maWc6IHsgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzIH1cbiAgfSA9IGluc3RhbmNlLmFwcENvbnRleHQ7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChiYXNlKTtcbiAgbGV0IHJlc29sdmVkO1xuICBpZiAoY2FjaGVkKSB7XG4gICAgcmVzb2x2ZWQgPSBjYWNoZWQ7XG4gIH0gZWxzZSBpZiAoIWdsb2JhbE1peGlucy5sZW5ndGggJiYgIW1peGlucyAmJiAhZXh0ZW5kc09wdGlvbnMpIHtcbiAgICB7XG4gICAgICByZXNvbHZlZCA9IGJhc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc29sdmVkID0ge307XG4gICAgaWYgKGdsb2JhbE1peGlucy5sZW5ndGgpIHtcbiAgICAgIGdsb2JhbE1peGlucy5mb3JFYWNoKFxuICAgICAgICAobSkgPT4gbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBtLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMsIHRydWUpXG4gICAgICApO1xuICAgIH1cbiAgICBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIGJhc2UsIG9wdGlvbk1lcmdlU3RyYXRlZ2llcyk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGJhc2UpKSB7XG4gICAgY2FjaGUuc2V0KGJhc2UsIHJlc29sdmVkKTtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5mdW5jdGlvbiBtZXJnZU9wdGlvbnModG8sIGZyb20sIHN0cmF0cywgYXNNaXhpbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gZnJvbTtcbiAgaWYgKGV4dGVuZHNPcHRpb25zKSB7XG4gICAgbWVyZ2VPcHRpb25zKHRvLCBleHRlbmRzT3B0aW9ucywgc3RyYXRzLCB0cnVlKTtcbiAgfVxuICBpZiAobWl4aW5zKSB7XG4gICAgbWl4aW5zLmZvckVhY2goXG4gICAgICAobSkgPT4gbWVyZ2VPcHRpb25zKHRvLCBtLCBzdHJhdHMsIHRydWUpXG4gICAgKTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgaWYgKGFzTWl4aW4gJiYga2V5ID09PSBcImV4cG9zZVwiKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4kMShcbiAgICAgICAgYFwiZXhwb3NlXCIgb3B0aW9uIGlzIGlnbm9yZWQgd2hlbiBkZWNsYXJlZCBpbiBtaXhpbnMgb3IgZXh0ZW5kcy4gSXQgc2hvdWxkIG9ubHkgYmUgZGVjbGFyZWQgaW4gdGhlIGJhc2UgY29tcG9uZW50IGl0c2VsZi5gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHJhdCA9IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHNba2V5XSB8fCBzdHJhdHMgJiYgc3RyYXRzW2tleV07XG4gICAgICB0b1trZXldID0gc3RyYXQgPyBzdHJhdCh0b1trZXldLCBmcm9tW2tleV0pIDogZnJvbVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5jb25zdCBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzID0ge1xuICBkYXRhOiBtZXJnZURhdGFGbixcbiAgcHJvcHM6IG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyxcbiAgZW1pdHM6IG1lcmdlRW1pdHNPclByb3BzT3B0aW9ucyxcbiAgLy8gb2JqZWN0c1xuICBtZXRob2RzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIGNvbXB1dGVkOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIC8vIGxpZmVjeWNsZVxuICBiZWZvcmVDcmVhdGU6IG1lcmdlQXNBcnJheSxcbiAgY3JlYXRlZDogbWVyZ2VBc0FycmF5LFxuICBiZWZvcmVNb3VudDogbWVyZ2VBc0FycmF5LFxuICBtb3VudGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZVVwZGF0ZTogbWVyZ2VBc0FycmF5LFxuICB1cGRhdGVkOiBtZXJnZUFzQXJyYXksXG4gIGJlZm9yZURlc3Ryb3k6IG1lcmdlQXNBcnJheSxcbiAgYmVmb3JlVW5tb3VudDogbWVyZ2VBc0FycmF5LFxuICBkZXN0cm95ZWQ6IG1lcmdlQXNBcnJheSxcbiAgdW5tb3VudGVkOiBtZXJnZUFzQXJyYXksXG4gIGFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxuICBkZWFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxuICBlcnJvckNhcHR1cmVkOiBtZXJnZUFzQXJyYXksXG4gIHNlcnZlclByZWZldGNoOiBtZXJnZUFzQXJyYXksXG4gIC8vIGFzc2V0c1xuICBjb21wb25lbnRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gIGRpcmVjdGl2ZXM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgLy8gd2F0Y2hcbiAgd2F0Y2g6IG1lcmdlV2F0Y2hPcHRpb25zLFxuICAvLyBwcm92aWRlIC8gaW5qZWN0XG4gIHByb3ZpZGU6IG1lcmdlRGF0YUZuLFxuICBpbmplY3Q6IG1lcmdlSW5qZWN0XG59O1xuZnVuY3Rpb24gbWVyZ2VEYXRhRm4odG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7XG4gICAgcmV0dXJuIHRvO1xuICB9XG4gIGlmICghdG8pIHtcbiAgICByZXR1cm4gZnJvbTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xuICAgIHJldHVybiAoZXh0ZW5kKShcbiAgICAgIGlzRnVuY3Rpb24odG8pID8gdG8uY2FsbCh0aGlzLCB0aGlzKSA6IHRvLFxuICAgICAgaXNGdW5jdGlvbihmcm9tKSA/IGZyb20uY2FsbCh0aGlzLCB0aGlzKSA6IGZyb21cbiAgICApO1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VJbmplY3QodG8sIGZyb20pIHtcbiAgcmV0dXJuIG1lcmdlT2JqZWN0T3B0aW9ucyhub3JtYWxpemVJbmplY3QodG8pLCBub3JtYWxpemVJbmplY3QoZnJvbSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0KHJhdykge1xuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tyYXdbaV1dID0gcmF3W2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHJldHVybiByYXc7XG59XG5mdW5jdGlvbiBtZXJnZUFzQXJyYXkodG8sIGZyb20pIHtcbiAgcmV0dXJuIHRvID8gWy4uLm5ldyBTZXQoW10uY29uY2F0KHRvLCBmcm9tKSldIDogZnJvbTtcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0T3B0aW9ucyh0bywgZnJvbSkge1xuICByZXR1cm4gdG8gPyBleHRlbmQoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRvLCBmcm9tKSA6IGZyb207XG59XG5mdW5jdGlvbiBtZXJnZUVtaXRzT3JQcm9wc09wdGlvbnModG8sIGZyb20pIHtcbiAgaWYgKHRvKSB7XG4gICAgaWYgKGlzQXJyYXkodG8pICYmIGlzQXJyYXkoZnJvbSkpIHtcbiAgICAgIHJldHVybiBbLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLnRvLCAuLi5mcm9tXSldO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kKFxuICAgICAgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBub3JtYWxpemVQcm9wc09yRW1pdHModG8pLFxuICAgICAgbm9ybWFsaXplUHJvcHNPckVtaXRzKGZyb20gIT0gbnVsbCA/IGZyb20gOiB7fSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcm9tO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZVdhdGNoT3B0aW9ucyh0bywgZnJvbSkge1xuICBpZiAoIXRvKSByZXR1cm4gZnJvbTtcbiAgaWYgKCFmcm9tKSByZXR1cm4gdG87XG4gIGNvbnN0IG1lcmdlZCA9IGV4dGVuZCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8pO1xuICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgbWVyZ2VkW2tleV0gPSBtZXJnZUFzQXJyYXkodG9ba2V5XSwgZnJvbVtrZXldKTtcbiAgfVxuICByZXR1cm4gbWVyZ2VkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcHBDb250ZXh0KCkge1xuICByZXR1cm4ge1xuICAgIGFwcDogbnVsbCxcbiAgICBjb25maWc6IHtcbiAgICAgIGlzTmF0aXZlVGFnOiBOTyxcbiAgICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcbiAgICAgIGdsb2JhbFByb3BlcnRpZXM6IHt9LFxuICAgICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiB7fSxcbiAgICAgIGVycm9ySGFuZGxlcjogdm9pZCAwLFxuICAgICAgd2FybkhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIGNvbXBpbGVyT3B0aW9uczoge31cbiAgICB9LFxuICAgIG1peGluczogW10sXG4gICAgY29tcG9uZW50czoge30sXG4gICAgZGlyZWN0aXZlczoge30sXG4gICAgcHJvdmlkZXM6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIG9wdGlvbnNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksXG4gICAgcHJvcHNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksXG4gICAgZW1pdHNDYWNoZTogLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKClcbiAgfTtcbn1cbmxldCB1aWQkMSA9IDA7XG5mdW5jdGlvbiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcHAocm9vdENvbXBvbmVudCwgcm9vdFByb3BzID0gbnVsbCkge1xuICAgIGlmICghaXNGdW5jdGlvbihyb290Q29tcG9uZW50KSkge1xuICAgICAgcm9vdENvbXBvbmVudCA9IGV4dGVuZCh7fSwgcm9vdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGlmIChyb290UHJvcHMgIT0gbnVsbCAmJiAhaXNPYmplY3Qocm9vdFByb3BzKSkge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuJDEoYHJvb3QgcHJvcHMgcGFzc2VkIHRvIGFwcC5tb3VudCgpIG11c3QgYmUgYW4gb2JqZWN0LmApO1xuICAgICAgcm9vdFByb3BzID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcbiAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgY29uc3QgcGx1Z2luQ2xlYW51cEZucyA9IFtdO1xuICAgIGxldCBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBhcHAgPSBjb250ZXh0LmFwcCA9IHtcbiAgICAgIF91aWQ6IHVpZCQxKyssXG4gICAgICBfY29tcG9uZW50OiByb290Q29tcG9uZW50LFxuICAgICAgX3Byb3BzOiByb290UHJvcHMsXG4gICAgICBfY29udGFpbmVyOiBudWxsLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfaW5zdGFuY2U6IG51bGwsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgZ2V0IGNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uZmlnO1xuICAgICAgfSxcbiAgICAgIHNldCBjb25maWcodikge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBhcHAuY29uZmlnIGNhbm5vdCBiZSByZXBsYWNlZC4gTW9kaWZ5IGluZGl2aWR1YWwgb3B0aW9ucyBpbnN0ZWFkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlKHBsdWdpbiwgLi4ub3B0aW9ucykge1xuICAgICAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5oYXMocGx1Z2luKSkge1xuICAgICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybiQxKGBQbHVnaW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHAuYCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGx1Z2luICYmIGlzRnVuY3Rpb24ocGx1Z2luLmluc3RhbGwpKSB7XG4gICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcbiAgICAgICAgICBwbHVnaW4uaW5zdGFsbChhcHAsIC4uLm9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocGx1Z2luKSkge1xuICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICAgICAgcGx1Z2luKGFwcCwgLi4ub3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBBIHBsdWdpbiBtdXN0IGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCB3aXRoIGFuIFwiaW5zdGFsbFwiIGZ1bmN0aW9uLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgbWl4aW4obWl4aW4pIHtcbiAgICAgICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18pIHtcbiAgICAgICAgICBpZiAoIWNvbnRleHQubWl4aW5zLmluY2x1ZGVzKG1peGluKSkge1xuICAgICAgICAgICAgY29udGV4dC5taXhpbnMucHVzaChtaXhpbik7XG4gICAgICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIFwiTWl4aW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHBcIiArIChtaXhpbi5uYW1lID8gYDogJHttaXhpbi5uYW1lfWAgOiBcIlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcIk1peGlucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYnVpbGRzIHN1cHBvcnRpbmcgT3B0aW9ucyBBUElcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBjb21wb25lbnQobmFtZSwgY29tcG9uZW50KSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIGNvbnRleHQuY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY29udGV4dC5jb21wb25lbnRzW25hbWVdKSB7XG4gICAgICAgICAgd2FybiQxKGBDb21wb25lbnQgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jb21wb25lbnRzW25hbWVdID0gY29tcG9uZW50O1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgfSxcbiAgICAgIGRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkaXJlY3RpdmUpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXJlY3RpdmVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSkge1xuICAgICAgICAgIHdhcm4kMShgRGlyZWN0aXZlIFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgIH0sXG4gICAgICBtb3VudChyb290Q29udGFpbmVyLCBpc0h5ZHJhdGUsIG5hbWVzcGFjZSkge1xuICAgICAgICBpZiAoIWlzTW91bnRlZCkge1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHJvb3RDb250YWluZXIuX192dWVfYXBwX18pIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgYFRoZXJlIGlzIGFscmVhZHkgYW4gYXBwIGluc3RhbmNlIG1vdW50ZWQgb24gdGhlIGhvc3QgY29udGFpbmVyLlxuIElmIHlvdSB3YW50IHRvIG1vdW50IGFub3RoZXIgYXBwIG9uIHRoZSBzYW1lIGhvc3QgY29udGFpbmVyLCB5b3UgbmVlZCB0byB1bm1vdW50IHRoZSBwcmV2aW91cyBhcHAgYnkgY2FsbGluZyBcXGBhcHAudW5tb3VudCgpXFxgIGZpcnN0LmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHZub2RlID0gYXBwLl9jZVZOb2RlIHx8IGNyZWF0ZVZOb2RlKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyk7XG4gICAgICAgICAgdm5vZGUuYXBwQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gXCJzdmdcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5hbWVzcGFjZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGNvbnRleHQucmVsb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgICAgICAgICAgY2xvbmVkLmVsID0gbnVsbDtcbiAgICAgICAgICAgICAgcmVuZGVyKGNsb25lZCwgcm9vdENvbnRhaW5lciwgbmFtZXNwYWNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0h5ZHJhdGUgJiYgaHlkcmF0ZSkge1xuICAgICAgICAgICAgaHlkcmF0ZSh2bm9kZSwgcm9vdENvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcih2bm9kZSwgcm9vdENvbnRhaW5lciwgbmFtZXNwYWNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICBhcHAuX2NvbnRhaW5lciA9IHJvb3RDb250YWluZXI7XG4gICAgICAgICAgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXyA9IGFwcDtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICAgICAgICBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlKHZub2RlLmNvbXBvbmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBBcHAgaGFzIGFscmVhZHkgYmVlbiBtb3VudGVkLlxuSWYgeW91IHdhbnQgdG8gcmVtb3VudCB0aGUgc2FtZSBhcHAsIG1vdmUgeW91ciBhcHAgY3JlYXRpb24gbG9naWMgaW50byBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIGNyZWF0ZSBmcmVzaCBhcHAgaW5zdGFuY2VzIGZvciBlYWNoIG1vdW50IC0gZS5nLiBcXGBjb25zdCBjcmVhdGVNeUFwcCA9ICgpID0+IGNyZWF0ZUFwcChBcHApXFxgYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblVubW91bnQoY2xlYW51cEZuKSB7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHR5cGVvZiBjbGVhbnVwRm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBFeHBlY3RlZCBmdW5jdGlvbiBhcyBmaXJzdCBhcmd1bWVudCB0byBhcHAub25Vbm1vdW50KCksIGJ1dCBnb3QgJHt0eXBlb2YgY2xlYW51cEZufWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHBsdWdpbkNsZWFudXBGbnMucHVzaChjbGVhbnVwRm4pO1xuICAgICAgfSxcbiAgICAgIHVubW91bnQoKSB7XG4gICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgICAgICAgIHBsdWdpbkNsZWFudXBGbnMsXG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlLFxuICAgICAgICAgICAgMTZcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlbmRlcihudWxsLCBhcHAuX2NvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIGRldnRvb2xzVW5tb3VudEFwcChhcHApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgYXBwLl9jb250YWluZXIuX192dWVfYXBwX187XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShgQ2Fubm90IHVubW91bnQgYW4gYXBwIHRoYXQgaXMgbm90IG1vdW50ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYga2V5IGluIGNvbnRleHQucHJvdmlkZXMpIHtcbiAgICAgICAgICBpZiAoaGFzT3duKGNvbnRleHQucHJvdmlkZXMsIGtleSkpIHtcbiAgICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgICAgYEFwcCBhbHJlYWR5IHByb3ZpZGVzIHByb3BlcnR5IHdpdGgga2V5IFwiJHtTdHJpbmcoa2V5KX1cIi4gSXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIHRoZSBuZXcgdmFsdWUuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgQXBwIGFscmVhZHkgcHJvdmlkZXMgcHJvcGVydHkgd2l0aCBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGluaGVyaXRlZCBmcm9tIGl0cyBwYXJlbnQgZWxlbWVudC4gSXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIHRoZSBuZXcgdmFsdWUuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcm92aWRlc1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhcHA7XG4gICAgICB9LFxuICAgICAgcnVuV2l0aENvbnRleHQoZm4pIHtcbiAgICAgICAgY29uc3QgbGFzdEFwcCA9IGN1cnJlbnRBcHA7XG4gICAgICAgIGN1cnJlbnRBcHAgPSBhcHA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgY3VycmVudEFwcCA9IGxhc3RBcHA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhcHA7XG4gIH07XG59XG5sZXQgY3VycmVudEFwcCA9IG51bGw7XG5cbmZ1bmN0aW9uIHVzZU1vZGVsKHByb3BzLCBuYW1lLCBvcHRpb25zID0gRU1QVFlfT0JKKSB7XG4gIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWkpIHtcbiAgICB3YXJuJDEoYHVzZU1vZGVsKCkgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGluc3RhbmNlLmApO1xuICAgIHJldHVybiByZWYoKTtcbiAgfVxuICBjb25zdCBjYW1lbGl6ZWROYW1lID0gY2FtZWxpemUobmFtZSk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpLnByb3BzT3B0aW9uc1swXVtjYW1lbGl6ZWROYW1lXSkge1xuICAgIHdhcm4kMShgdXNlTW9kZWwoKSBjYWxsZWQgd2l0aCBwcm9wIFwiJHtuYW1lfVwiIHdoaWNoIGlzIG5vdCBkZWNsYXJlZC5gKTtcbiAgICByZXR1cm4gcmVmKCk7XG4gIH1cbiAgY29uc3QgaHlwaGVuYXRlZE5hbWUgPSBoeXBoZW5hdGUobmFtZSk7XG4gIGNvbnN0IG1vZGlmaWVycyA9IGdldE1vZGVsTW9kaWZpZXJzKHByb3BzLCBjYW1lbGl6ZWROYW1lKTtcbiAgY29uc3QgcmVzID0gY3VzdG9tUmVmKCh0cmFjaywgdHJpZ2dlcikgPT4ge1xuICAgIGxldCBsb2NhbFZhbHVlO1xuICAgIGxldCBwcmV2U2V0VmFsdWUgPSBFTVBUWV9PQko7XG4gICAgbGV0IHByZXZFbWl0dGVkVmFsdWU7XG4gICAgd2F0Y2hTeW5jRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IHByb3BWYWx1ZSA9IHByb3BzW2NhbWVsaXplZE5hbWVdO1xuICAgICAgaWYgKGhhc0NoYW5nZWQobG9jYWxWYWx1ZSwgcHJvcFZhbHVlKSkge1xuICAgICAgICBsb2NhbFZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICB0cmlnZ2VyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgdHJhY2soKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZ2V0ID8gb3B0aW9ucy5nZXQobG9jYWxWYWx1ZSkgOiBsb2NhbFZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBlbWl0dGVkVmFsdWUgPSBvcHRpb25zLnNldCA/IG9wdGlvbnMuc2V0KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICBpZiAoIWhhc0NoYW5nZWQoZW1pdHRlZFZhbHVlLCBsb2NhbFZhbHVlKSAmJiAhKHByZXZTZXRWYWx1ZSAhPT0gRU1QVFlfT0JKICYmIGhhc0NoYW5nZWQodmFsdWUsIHByZXZTZXRWYWx1ZSkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhd1Byb3BzID0gaS52bm9kZS5wcm9wcztcbiAgICAgICAgaWYgKCEocmF3UHJvcHMgJiYgLy8gY2hlY2sgaWYgcGFyZW50IGhhcyBwYXNzZWQgdi1tb2RlbFxuICAgICAgICAobmFtZSBpbiByYXdQcm9wcyB8fCBjYW1lbGl6ZWROYW1lIGluIHJhd1Byb3BzIHx8IGh5cGhlbmF0ZWROYW1lIGluIHJhd1Byb3BzKSAmJiAoYG9uVXBkYXRlOiR7bmFtZX1gIGluIHJhd1Byb3BzIHx8IGBvblVwZGF0ZToke2NhbWVsaXplZE5hbWV9YCBpbiByYXdQcm9wcyB8fCBgb25VcGRhdGU6JHtoeXBoZW5hdGVkTmFtZX1gIGluIHJhd1Byb3BzKSkpIHtcbiAgICAgICAgICBsb2NhbFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdHJpZ2dlcigpO1xuICAgICAgICB9XG4gICAgICAgIGkuZW1pdChgdXBkYXRlOiR7bmFtZX1gLCBlbWl0dGVkVmFsdWUpO1xuICAgICAgICBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgZW1pdHRlZFZhbHVlKSAmJiBoYXNDaGFuZ2VkKHZhbHVlLCBwcmV2U2V0VmFsdWUpICYmICFoYXNDaGFuZ2VkKGVtaXR0ZWRWYWx1ZSwgcHJldkVtaXR0ZWRWYWx1ZSkpIHtcbiAgICAgICAgICB0cmlnZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldlNldFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHByZXZFbWl0dGVkVmFsdWUgPSBlbWl0dGVkVmFsdWU7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJlc1tTeW1ib2wuaXRlcmF0b3JdID0gKCkgPT4ge1xuICAgIGxldCBpMiA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGlmIChpMiA8IDIpIHtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaTIrKyA/IG1vZGlmaWVycyB8fCBFTVBUWV9PQkogOiByZXMsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHJlcztcbn1cbmNvbnN0IGdldE1vZGVsTW9kaWZpZXJzID0gKHByb3BzLCBtb2RlbE5hbWUpID0+IHtcbiAgcmV0dXJuIG1vZGVsTmFtZSA9PT0gXCJtb2RlbFZhbHVlXCIgfHwgbW9kZWxOYW1lID09PSBcIm1vZGVsLXZhbHVlXCIgPyBwcm9wcy5tb2RlbE1vZGlmaWVycyA6IHByb3BzW2Ake21vZGVsTmFtZX1Nb2RpZmllcnNgXSB8fCBwcm9wc1tgJHtjYW1lbGl6ZShtb2RlbE5hbWUpfU1vZGlmaWVyc2BdIHx8IHByb3BzW2Ake2h5cGhlbmF0ZShtb2RlbE5hbWUpfU1vZGlmaWVyc2BdO1xufTtcblxuZnVuY3Rpb24gZW1pdChpbnN0YW5jZSwgZXZlbnQsIC4uLnJhd0FyZ3MpIHtcbiAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkKSByZXR1cm47XG4gIGNvbnN0IHByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVtaXRzT3B0aW9ucyxcbiAgICAgIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc11cbiAgICB9ID0gaW5zdGFuY2U7XG4gICAgaWYgKGVtaXRzT3B0aW9ucykge1xuICAgICAgaWYgKCEoZXZlbnQgaW4gZW1pdHNPcHRpb25zKSAmJiB0cnVlKSB7XG4gICAgICAgIGlmICghcHJvcHNPcHRpb25zIHx8ICEodG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSkgaW4gcHJvcHNPcHRpb25zKSkge1xuICAgICAgICAgIHdhcm4kMShcbiAgICAgICAgICAgIGBDb21wb25lbnQgZW1pdHRlZCBldmVudCBcIiR7ZXZlbnR9XCIgYnV0IGl0IGlzIG5laXRoZXIgZGVjbGFyZWQgaW4gdGhlIGVtaXRzIG9wdGlvbiBub3IgYXMgYW4gXCIke3RvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpfVwiIHByb3AuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbGlkYXRvcikpIHtcbiAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdG9yKC4uLnJhd0FyZ3MpO1xuICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgSW52YWxpZCBldmVudCBhcmd1bWVudHM6IGV2ZW50IHZhbGlkYXRpb24gZmFpbGVkIGZvciBldmVudCBcIiR7ZXZlbnR9XCIuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGFyZ3MgPSByYXdBcmdzO1xuICBjb25zdCBpc01vZGVsTGlzdGVuZXIgPSBldmVudC5zdGFydHNXaXRoKFwidXBkYXRlOlwiKTtcbiAgY29uc3QgbW9kaWZpZXJzID0gaXNNb2RlbExpc3RlbmVyICYmIGdldE1vZGVsTW9kaWZpZXJzKHByb3BzLCBldmVudC5zbGljZSg3KSk7XG4gIGlmIChtb2RpZmllcnMpIHtcbiAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcCgoYSkgPT4gaXNTdHJpbmcoYSkgPyBhLnRyaW0oKSA6IGEpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKGxvb3NlVG9OdW1iZXIpO1xuICAgIH1cbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBkZXZ0b29sc0NvbXBvbmVudEVtaXQoaW5zdGFuY2UsIGV2ZW50LCBhcmdzKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHByb3BzW3RvSGFuZGxlcktleShsb3dlckNhc2VFdmVudCldKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBFdmVudCBcIiR7bG93ZXJDYXNlRXZlbnR9XCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgJHtmb3JtYXRDb21wb25lbnROYW1lKFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIGluc3RhbmNlLnR5cGVcbiAgICAgICAgKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2Ugdi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoXG4gICAgICAgICAgZXZlbnRcbiAgICAgICAgKX1cIiBpbnN0ZWFkIG9mIFwiJHtldmVudH1cIi5gXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBsZXQgaGFuZGxlck5hbWU7XG4gIGxldCBoYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoZXZlbnQpXSB8fCAvLyBhbHNvIHRyeSBjYW1lbENhc2UgZXZlbnQgaGFuZGxlciAoIzIyNDkpXG4gIHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSldO1xuICBpZiAoIWhhbmRsZXIgJiYgaXNNb2RlbExpc3RlbmVyKSB7XG4gICAgaGFuZGxlciA9IHByb3BzW2hhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGh5cGhlbmF0ZShldmVudCkpXTtcbiAgfVxuICBpZiAoaGFuZGxlcikge1xuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKFxuICAgICAgaGFuZGxlcixcbiAgICAgIGluc3RhbmNlLFxuICAgICAgNixcbiAgICAgIGFyZ3NcbiAgICApO1xuICB9XG4gIGNvbnN0IG9uY2VIYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgKyBgT25jZWBdO1xuICBpZiAob25jZUhhbmRsZXIpIHtcbiAgICBpZiAoIWluc3RhbmNlLmVtaXR0ZWQpIHtcbiAgICAgIGluc3RhbmNlLmVtaXR0ZWQgPSB7fTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdID0gdHJ1ZTtcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIG9uY2VIYW5kbGVyLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA2LFxuICAgICAgYXJnc1xuICAgICk7XG4gIH1cbn1cbmNvbnN0IG1peGluRW1pdHNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbm9ybWFsaXplRW1pdHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xuICBjb25zdCBjYWNoZSA9IF9fVlVFX09QVElPTlNfQVBJX18gJiYgYXNNaXhpbiA/IG1peGluRW1pdHNDYWNoZSA6IGFwcENvbnRleHQuZW1pdHNDYWNoZTtcbiAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xuICBpZiAoY2FjaGVkICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGNvbnN0IHJhdyA9IGNvbXAuZW1pdHM7XG4gIGxldCBub3JtYWxpemVkID0ge307XG4gIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XG4gICAgY29uc3QgZXh0ZW5kRW1pdHMgPSAocmF3MikgPT4ge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEZyb21FeHRlbmQgPSBub3JtYWxpemVFbWl0c09wdGlvbnMocmF3MiwgYXBwQ29udGV4dCwgdHJ1ZSk7XG4gICAgICBpZiAobm9ybWFsaXplZEZyb21FeHRlbmQpIHtcbiAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XG4gICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBub3JtYWxpemVkRnJvbUV4dGVuZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XG4gICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAuZXh0ZW5kcykge1xuICAgICAgZXh0ZW5kRW1pdHMoY29tcC5leHRlbmRzKTtcbiAgICB9XG4gICAgaWYgKGNvbXAubWl4aW5zKSB7XG4gICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcbiAgICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICAgIGNhY2hlLnNldChjb21wLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgIHJhdy5mb3JFYWNoKChrZXkpID0+IG5vcm1hbGl6ZWRba2V5XSA9IG51bGwpO1xuICB9IGVsc2Uge1xuICAgIGV4dGVuZChub3JtYWxpemVkLCByYXcpO1xuICB9XG4gIGlmIChpc09iamVjdChjb21wKSkge1xuICAgIGNhY2hlLnNldChjb21wLCBub3JtYWxpemVkKTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbmZ1bmN0aW9uIGlzRW1pdExpc3RlbmVyKG9wdGlvbnMsIGtleSkge1xuICBpZiAoIW9wdGlvbnMgfHwgIWlzT24oa2V5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBrZXkgPSBrZXkuc2xpY2UoMikucmVwbGFjZSgvT25jZSQvLCBcIlwiKTtcbiAgcmV0dXJuIGhhc093bihvcHRpb25zLCBrZXlbMF0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgxKSkgfHwgaGFzT3duKG9wdGlvbnMsIGh5cGhlbmF0ZShrZXkpKSB8fCBoYXNPd24ob3B0aW9ucywga2V5KTtcbn1cblxubGV0IGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcbmZ1bmN0aW9uIG1hcmtBdHRyc0FjY2Vzc2VkKCkge1xuICBhY2Nlc3NlZEF0dHJzID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpIHtcbiAgY29uc3Qge1xuICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICB2bm9kZSxcbiAgICBwcm94eSxcbiAgICB3aXRoUHJveHksXG4gICAgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSxcbiAgICBzbG90cyxcbiAgICBhdHRycyxcbiAgICBlbWl0LFxuICAgIHJlbmRlcixcbiAgICByZW5kZXJDYWNoZSxcbiAgICBwcm9wcyxcbiAgICBkYXRhLFxuICAgIHNldHVwU3RhdGUsXG4gICAgY3R4LFxuICAgIGluaGVyaXRBdHRyc1xuICB9ID0gaW5zdGFuY2U7XG4gIGNvbnN0IHByZXYgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpO1xuICBsZXQgcmVzdWx0O1xuICBsZXQgZmFsbHRocm91Z2hBdHRycztcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCkge1xuICAgICAgY29uc3QgcHJveHlUb1VzZSA9IHdpdGhQcm94eSB8fCBwcm94eTtcbiAgICAgIGNvbnN0IHRoaXNQcm94eSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXAgPyBuZXcgUHJveHkocHJveHlUb1VzZSwge1xuICAgICAgICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYFByb3BlcnR5ICcke1N0cmluZyhcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApfScgd2FzIGFjY2Vzc2VkIHZpYSAndGhpcycuIEF2b2lkIHVzaW5nICd0aGlzJyBpbiB0ZW1wbGF0ZXMuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICAgIH0pIDogcHJveHlUb1VzZTtcbiAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKFxuICAgICAgICByZW5kZXIuY2FsbChcbiAgICAgICAgICB0aGlzUHJveHksXG4gICAgICAgICAgcHJveHlUb1VzZSxcbiAgICAgICAgICByZW5kZXJDYWNoZSxcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHByb3BzKSA6IHByb3BzLFxuICAgICAgICAgIHNldHVwU3RhdGUsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBjdHhcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBhdHRycztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVuZGVyMiA9IENvbXBvbmVudDtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGF0dHJzID09PSBwcm9wcykge1xuICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUoXG4gICAgICAgIHJlbmRlcjIubGVuZ3RoID4gMSA/IHJlbmRlcjIoXG4gICAgICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IHNoYWxsb3dSZWFkb25seShwcm9wcykgOiBwcm9wcyxcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8ge1xuICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgICAgICAgICByZXR1cm4gc2hhbGxvd1JlYWRvbmx5KGF0dHJzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbG90cyxcbiAgICAgICAgICAgIGVtaXRcbiAgICAgICAgICB9IDogeyBhdHRycywgc2xvdHMsIGVtaXQgfVxuICAgICAgICApIDogcmVuZGVyMihcbiAgICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KHByb3BzKSA6IHByb3BzLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBDb21wb25lbnQucHJvcHMgPyBhdHRycyA6IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaChhdHRycyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBibG9ja1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMSk7XG4gICAgcmVzdWx0ID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gIH1cbiAgbGV0IHJvb3QgPSByZXN1bHQ7XG4gIGxldCBzZXRSb290ID0gdm9pZCAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByZXN1bHQucGF0Y2hGbGFnID4gMCAmJiByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCkge1xuICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xuICB9XG4gIGlmIChmYWxsdGhyb3VnaEF0dHJzICYmIGluaGVyaXRBdHRycyAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmFsbHRocm91Z2hBdHRycyk7XG4gICAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHJvb3Q7XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBpZiAoc2hhcGVGbGFnICYgKDEgfCA2KSkge1xuICAgICAgICBpZiAocHJvcHNPcHRpb25zICYmIGtleXMuc29tZShpc01vZGVsTGlzdGVuZXIpKSB7XG4gICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGZpbHRlck1vZGVsTGlzdGVuZXJzKFxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyxcbiAgICAgICAgICAgIHByb3BzT3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgZmFsbHRocm91Z2hBdHRycywgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFhY2Nlc3NlZEF0dHJzICYmIHJvb3QudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICBjb25zdCBhbGxBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKTtcbiAgICAgICAgY29uc3QgZXZlbnRBdHRycyA9IFtdO1xuICAgICAgICBjb25zdCBleHRyYUF0dHJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYWxsQXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYWxsQXR0cnNbaV07XG4gICAgICAgICAgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xuICAgICAgICAgICAgICBldmVudEF0dHJzLnB1c2goa2V5WzJdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHRyYUF0dHJzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgYEV4dHJhbmVvdXMgbm9uLXByb3BzIGF0dHJpYnV0ZXMgKCR7ZXh0cmFBdHRycy5qb2luKFwiLCBcIil9KSB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgb3IgdGVsZXBvcnQgcm9vdCBub2Rlcy5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgRXh0cmFuZW91cyBub24tZW1pdHMgZXZlbnQgbGlzdGVuZXJzICgke2V2ZW50QXR0cnMuam9pbihcIiwgXCIpfSkgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYmVjYXVzZSBjb21wb25lbnQgcmVuZGVycyBmcmFnbWVudCBvciB0ZXh0IHJvb3Qgbm9kZXMuIElmIHRoZSBsaXN0ZW5lciBpcyBpbnRlbmRlZCB0byBiZSBhIGNvbXBvbmVudCBjdXN0b20gZXZlbnQgbGlzdGVuZXIgb25seSwgZGVjbGFyZSBpdCB1c2luZyB0aGUgXCJlbWl0c1wiIG9wdGlvbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm5vZGUuZGlycykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBSdW50aW1lIGRpcmVjdGl2ZSB1c2VkIG9uIGNvbXBvbmVudCB3aXRoIG5vbi1lbGVtZW50IHJvb3Qgbm9kZS4gVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgbnVsbCwgZmFsc2UsIHRydWUpO1xuICAgIHJvb3QuZGlycyA9IHJvb3QuZGlycyA/IHJvb3QuZGlycy5jb25jYXQodm5vZGUuZGlycykgOiB2bm9kZS5kaXJzO1xuICB9XG4gIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYENvbXBvbmVudCBpbnNpZGUgPFRyYW5zaXRpb24+IHJlbmRlcnMgbm9uLWVsZW1lbnQgcm9vdCBub2RlIHRoYXQgY2Fubm90IGJlIGFuaW1hdGVkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHNldFRyYW5zaXRpb25Ib29rcyhyb290LCB2bm9kZS50cmFuc2l0aW9uKTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzZXRSb290KSB7XG4gICAgc2V0Um9vdChyb290KTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSByb290O1xuICB9XG4gIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGdldENoaWxkUm9vdCA9ICh2bm9kZSkgPT4ge1xuICBjb25zdCByYXdDaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICBjb25zdCBkeW5hbWljQ2hpbGRyZW4gPSB2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gIGNvbnN0IGNoaWxkUm9vdCA9IGZpbHRlclNpbmdsZVJvb3QocmF3Q2hpbGRyZW4sIGZhbHNlKTtcbiAgaWYgKCFjaGlsZFJvb3QpIHtcbiAgICByZXR1cm4gW3Zub2RlLCB2b2lkIDBdO1xuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgY2hpbGRSb290LnBhdGNoRmxhZyA+IDAgJiYgY2hpbGRSb290LnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICByZXR1cm4gZ2V0Q2hpbGRSb290KGNoaWxkUm9vdCk7XG4gIH1cbiAgY29uc3QgaW5kZXggPSByYXdDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCk7XG4gIGNvbnN0IGR5bmFtaWNJbmRleCA9IGR5bmFtaWNDaGlsZHJlbiA/IGR5bmFtaWNDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCkgOiAtMTtcbiAgY29uc3Qgc2V0Um9vdCA9ICh1cGRhdGVkUm9vdCkgPT4ge1xuICAgIHJhd0NoaWxkcmVuW2luZGV4XSA9IHVwZGF0ZWRSb290O1xuICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChkeW5hbWljSW5kZXggPiAtMSkge1xuICAgICAgICBkeW5hbWljQ2hpbGRyZW5bZHluYW1pY0luZGV4XSA9IHVwZGF0ZWRSb290O1xuICAgICAgfSBlbHNlIGlmICh1cGRhdGVkUm9vdC5wYXRjaEZsYWcgPiAwKSB7XG4gICAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IFsuLi5keW5hbWljQ2hpbGRyZW4sIHVwZGF0ZWRSb290XTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBbbm9ybWFsaXplVk5vZGUoY2hpbGRSb290KSwgc2V0Um9vdF07XG59O1xuZnVuY3Rpb24gZmlsdGVyU2luZ2xlUm9vdChjaGlsZHJlbiwgcmVjdXJzZSA9IHRydWUpIHtcbiAgbGV0IHNpbmdsZVJvb3Q7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IENvbW1lbnQgfHwgY2hpbGQuY2hpbGRyZW4gPT09IFwidi1pZlwiKSB7XG4gICAgICAgIGlmIChzaW5nbGVSb290KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpbmdsZVJvb3QgPSBjaGlsZDtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiByZWN1cnNlICYmIHNpbmdsZVJvb3QucGF0Y2hGbGFnID4gMCAmJiBzaW5nbGVSb290LnBhdGNoRmxhZyAmIDIwNDgpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJTaW5nbGVSb290KHNpbmdsZVJvb3QuY2hpbGRyZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJldHVybiBzaW5nbGVSb290O1xufVxuY29uc3QgZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoID0gKGF0dHJzKSA9PiB7XG4gIGxldCByZXM7XG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiIHx8IGtleSA9PT0gXCJzdHlsZVwiIHx8IGlzT24oa2V5KSkge1xuICAgICAgKHJlcyB8fCAocmVzID0ge30pKVtrZXldID0gYXR0cnNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBmaWx0ZXJNb2RlbExpc3RlbmVycyA9IChhdHRycywgcHJvcHMpID0+IHtcbiAgY29uc3QgcmVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSB8fCAhKGtleS5zbGljZSg5KSBpbiBwcm9wcykpIHtcbiAgICAgIHJlc1trZXldID0gYXR0cnNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBpc0VsZW1lbnRSb290ID0gKHZub2RlKSA9PiB7XG4gIHJldHVybiB2bm9kZS5zaGFwZUZsYWcgJiAoNiB8IDEpIHx8IHZub2RlLnR5cGUgPT09IENvbW1lbnQ7XG59O1xuZnVuY3Rpb24gc2hvdWxkVXBkYXRlQ29tcG9uZW50KHByZXZWTm9kZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpIHtcbiAgY29uc3QgeyBwcm9wczogcHJldlByb3BzLCBjaGlsZHJlbjogcHJldkNoaWxkcmVuLCBjb21wb25lbnQgfSA9IHByZXZWTm9kZTtcbiAgY29uc3QgeyBwcm9wczogbmV4dFByb3BzLCBjaGlsZHJlbjogbmV4dENoaWxkcmVuLCBwYXRjaEZsYWcgfSA9IG5leHRWTm9kZTtcbiAgY29uc3QgZW1pdHMgPSBjb21wb25lbnQuZW1pdHNPcHRpb25zO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChuZXh0Vk5vZGUuZGlycyB8fCBuZXh0Vk5vZGUudHJhbnNpdGlvbikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChvcHRpbWl6ZWQgJiYgcGF0Y2hGbGFnID49IDApIHtcbiAgICBpZiAocGF0Y2hGbGFnICYgMTAyNCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgJiAxNikge1xuICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xuICAgIH0gZWxzZSBpZiAocGF0Y2hGbGFnICYgOCkge1xuICAgICAgY29uc3QgZHluYW1pY1Byb3BzID0gbmV4dFZOb2RlLmR5bmFtaWNQcm9wcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Byb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGR5bmFtaWNQcm9wc1tpXTtcbiAgICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJiAhaXNFbWl0TGlzdGVuZXIoZW1pdHMsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gfHwgIW5leHRDaGlsZHJlbi4kc3RhYmxlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldlByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgIHJldHVybiAhIW5leHRQcm9wcztcbiAgICB9XG4gICAgaWYgKCFuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0c09wdGlvbnMpIHtcbiAgY29uc3QgbmV4dEtleXMgPSBPYmplY3Qua2V5cyhuZXh0UHJvcHMpO1xuICBpZiAobmV4dEtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhwcmV2UHJvcHMpLmxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBuZXh0S2V5c1tpXTtcbiAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmICFpc0VtaXRMaXN0ZW5lcihlbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB1cGRhdGVIT0NIb3N0RWwoeyB2bm9kZSwgcGFyZW50IH0sIGVsKSB7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBjb25zdCByb290ID0gcGFyZW50LnN1YlRyZWU7XG4gICAgaWYgKHJvb3Quc3VzcGVuc2UgJiYgcm9vdC5zdXNwZW5zZS5hY3RpdmVCcmFuY2ggPT09IHZub2RlKSB7XG4gICAgICByb290LmVsID0gdm5vZGUuZWw7XG4gICAgfVxuICAgIGlmIChyb290ID09PSB2bm9kZSkge1xuICAgICAgKHZub2RlID0gcGFyZW50LnZub2RlKS5lbCA9IGVsO1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGludGVybmFsT2JqZWN0UHJvdG8gPSB7fTtcbmNvbnN0IGNyZWF0ZUludGVybmFsT2JqZWN0ID0gKCkgPT4gT2JqZWN0LmNyZWF0ZShpbnRlcm5hbE9iamVjdFByb3RvKTtcbmNvbnN0IGlzSW50ZXJuYWxPYmplY3QgPSAob2JqKSA9PiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gaW50ZXJuYWxPYmplY3RQcm90bztcblxuZnVuY3Rpb24gaW5pdFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgaXNTdGF0ZWZ1bCwgaXNTU1IgPSBmYWxzZSkge1xuICBjb25zdCBwcm9wcyA9IHt9O1xuICBjb25zdCBhdHRycyA9IGNyZWF0ZUludGVybmFsT2JqZWN0KCk7XG4gIGluc3RhbmNlLnByb3BzRGVmYXVsdHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSB7XG4gICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgcHJvcHNba2V5XSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xuICB9XG4gIGlmIChpc1N0YXRlZnVsKSB7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBpc1NTUiA/IHByb3BzIDogc2hhbGxvd1JlYWN0aXZlKHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWluc3RhbmNlLnR5cGUucHJvcHMpIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gYXR0cnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnByb3BzID0gcHJvcHM7XG4gICAgfVxuICB9XG4gIGluc3RhbmNlLmF0dHJzID0gYXR0cnM7XG59XG5mdW5jdGlvbiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkge1xuICB3aGlsZSAoaW5zdGFuY2UpIHtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5fX2htcklkKSByZXR1cm4gdHJ1ZTtcbiAgICBpbnN0YW5jZSA9IGluc3RhbmNlLnBhcmVudDtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCByYXdQcmV2UHJvcHMsIG9wdGltaXplZCkge1xuICBjb25zdCB7XG4gICAgcHJvcHMsXG4gICAgYXR0cnMsXG4gICAgdm5vZGU6IHsgcGF0Y2hGbGFnIH1cbiAgfSA9IGluc3RhbmNlO1xuICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gIGNvbnN0IFtvcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xuICBpZiAoXG4gICAgLy8gYWx3YXlzIGZvcmNlIGZ1bGwgZGlmZiBpbiBkZXZcbiAgICAvLyAtICMxOTQyIGlmIGhtciBpcyBlbmFibGVkIHdpdGggc2ZjIGNvbXBvbmVudFxuICAgIC8vIC0gdml0ZSM4NzIgbm9uLXNmYyBjb21wb25lbnQgdXNlZCBieSBzZmMgY29tcG9uZW50XG4gICAgISghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSW5IbXJDb250ZXh0KGluc3RhbmNlKSkgJiYgKG9wdGltaXplZCB8fCBwYXRjaEZsYWcgPiAwKSAmJiAhKHBhdGNoRmxhZyAmIDE2KVxuICApIHtcbiAgICBpZiAocGF0Y2hGbGFnICYgOCkge1xuICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IGluc3RhbmNlLnZub2RlLmR5bmFtaWNQcm9wcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgaWYgKGlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoaGFzT3duKGF0dHJzLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICAgICAgcHJvcHNbY2FtZWxpemVkS2V5XSA9IHJlc29sdmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIHJhd0N1cnJlbnRQcm9wcyxcbiAgICAgICAgICAgICAgY2FtZWxpemVkS2V5LFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpKSB7XG4gICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQga2ViYWJLZXk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3Q3VycmVudFByb3BzKSB7XG4gICAgICBpZiAoIXJhd1Byb3BzIHx8IC8vIGZvciBjYW1lbENhc2VcbiAgICAgICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgLy8gaXQncyBwb3NzaWJsZSB0aGUgb3JpZ2luYWwgcHJvcHMgd2FzIHBhc3NlZCBpbiBhcyBrZWJhYi1jYXNlXG4gICAgICAvLyBhbmQgY29udmVydGVkIHRvIGNhbWVsQ2FzZSAoIzk1NSlcbiAgICAgICgoa2ViYWJLZXkgPSBoeXBoZW5hdGUoa2V5KSkgPT09IGtleSB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZWJhYktleSkpKSB7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHJhd1ByZXZQcm9wcyAmJiAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAgICAgKHJhd1ByZXZQcm9wc1trZXldICE9PSB2b2lkIDAgfHwgLy8gZm9yIGtlYmFiLWNhc2VcbiAgICAgICAgICByYXdQcmV2UHJvcHNba2ViYWJLZXldICE9PSB2b2lkIDApKSB7XG4gICAgICAgICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgcmF3Q3VycmVudFByb3BzLFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRycyAhPT0gcmF3Q3VycmVudFByb3BzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgICBpZiAoIXJhd1Byb3BzIHx8ICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgdHJ1ZSkge1xuICAgICAgICAgIGRlbGV0ZSBhdHRyc1trZXldO1xuICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGhhc0F0dHJzQ2hhbmdlZCkge1xuICAgIHRyaWdnZXIoaW5zdGFuY2UuYXR0cnMsIFwic2V0XCIsIFwiXCIpO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSB7XG4gIGNvbnN0IFtvcHRpb25zLCBuZWVkQ2FzdEtleXNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XG4gIGxldCByYXdDYXN0VmFsdWVzO1xuICBpZiAocmF3UHJvcHMpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gcmF3UHJvcHMpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xuICAgICAgbGV0IGNhbWVsS2V5O1xuICAgICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsIGNhbWVsS2V5ID0gY2FtZWxpemUoa2V5KSkpIHtcbiAgICAgICAgaWYgKCFuZWVkQ2FzdEtleXMgfHwgIW5lZWRDYXN0S2V5cy5pbmNsdWRlcyhjYW1lbEtleSkpIHtcbiAgICAgICAgICBwcm9wc1tjYW1lbEtleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAocmF3Q2FzdFZhbHVlcyB8fCAocmF3Q2FzdFZhbHVlcyA9IHt9KSlbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gYXR0cnMpIHx8IHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5lZWRDYXN0S2V5cykge1xuICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICBjb25zdCBjYXN0VmFsdWVzID0gcmF3Q2FzdFZhbHVlcyB8fCBFTVBUWV9PQko7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkQ2FzdEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IG5lZWRDYXN0S2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICByYXdDdXJyZW50UHJvcHMsXG4gICAgICAgIGtleSxcbiAgICAgICAgY2FzdFZhbHVlc1trZXldLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgIWhhc093bihjYXN0VmFsdWVzLCBrZXkpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzQXR0cnNDaGFuZ2VkO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCBwcm9wcywga2V5LCB2YWx1ZSwgaW5zdGFuY2UsIGlzQWJzZW50KSB7XG4gIGNvbnN0IG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgaWYgKG9wdCAhPSBudWxsKSB7XG4gICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHQsIFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBvcHQuZGVmYXVsdDtcbiAgICAgIGlmIChvcHQudHlwZSAhPT0gRnVuY3Rpb24gJiYgIW9wdC5za2lwRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wc0RlZmF1bHRzIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgaWYgKGtleSBpbiBwcm9wc0RlZmF1bHRzKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldID0gZGVmYXVsdFZhbHVlLmNhbGwoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGluc3RhbmNlLmNlKSB7XG4gICAgICAgIGluc3RhbmNlLmNlLl9zZXRQcm9wKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0WzAgLyogc2hvdWxkQ2FzdCAqL10pIHtcbiAgICAgIGlmIChpc0Fic2VudCAmJiAhaGFzRGVmYXVsdCkge1xuICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChvcHRbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gJiYgKHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBtaXhpblByb3BzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcbiAgY29uc3QgY2FjaGUgPSBfX1ZVRV9PUFRJT05TX0FQSV9fICYmIGFzTWl4aW4gPyBtaXhpblByb3BzQ2FjaGUgOiBhcHBDb250ZXh0LnByb3BzQ2FjaGU7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgY29uc3QgcmF3ID0gY29tcC5wcm9wcztcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICBjb25zdCBuZWVkQ2FzdEtleXMgPSBbXTtcbiAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICBjb25zdCBleHRlbmRQcm9wcyA9IChyYXcyKSA9PiB7XG4gICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcbiAgICAgIGNvbnN0IFtwcm9wcywga2V5c10gPSBub3JtYWxpemVQcm9wc09wdGlvbnMocmF3MiwgYXBwQ29udGV4dCwgdHJ1ZSk7XG4gICAgICBleHRlbmQobm9ybWFsaXplZCwgcHJvcHMpO1xuICAgICAgaWYgKGtleXMpIG5lZWRDYXN0S2V5cy5wdXNoKC4uLmtleXMpO1xuICAgIH07XG4gICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgfVxuICAgIGlmIChjb21wLmV4dGVuZHMpIHtcbiAgICAgIGV4dGVuZFByb3BzKGNvbXAuZXh0ZW5kcyk7XG4gICAgfVxuICAgIGlmIChjb21wLm1peGlucykge1xuICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgfVxuICB9XG4gIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgICBjYWNoZS5zZXQoY29tcCwgRU1QVFlfQVJSKTtcbiAgICB9XG4gICAgcmV0dXJuIEVNUFRZX0FSUjtcbiAgfVxuICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc1N0cmluZyhyYXdbaV0pKSB7XG4gICAgICAgIHdhcm4kMShgcHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LmAsIHJhd1tpXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUocmF3W2ldKTtcbiAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBFTVBUWV9PQko7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHJhdykge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFpc09iamVjdChyYXcpKSB7XG4gICAgICB3YXJuJDEoYGludmFsaWQgcHJvcHMgb3B0aW9uc2AsIHJhdyk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHJhdykge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xuICAgICAgICBjb25zdCBvcHQgPSByYXdba2V5XTtcbiAgICAgICAgY29uc3QgcHJvcCA9IG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpID8geyB0eXBlOiBvcHQgfSA6IGV4dGVuZCh7fSwgb3B0KTtcbiAgICAgICAgY29uc3QgcHJvcFR5cGUgPSBwcm9wLnR5cGU7XG4gICAgICAgIGxldCBzaG91bGRDYXN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBzaG91bGRDYXN0VHJ1ZSA9IHRydWU7XG4gICAgICAgIGlmIChpc0FycmF5KHByb3BUeXBlKSkge1xuICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwcm9wVHlwZS5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBwcm9wVHlwZVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCB0eXBlTmFtZSA9IGlzRnVuY3Rpb24odHlwZSkgJiYgdHlwZS5uYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGVOYW1lID09PSBcIkJvb2xlYW5cIikge1xuICAgICAgICAgICAgICBzaG91bGRDYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSBcIlN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHNob3VsZENhc3RUcnVlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3VsZENhc3QgPSBpc0Z1bmN0aW9uKHByb3BUeXBlKSAmJiBwcm9wVHlwZS5uYW1lID09PSBcIkJvb2xlYW5cIjtcbiAgICAgICAgfVxuICAgICAgICBwcm9wWzAgLyogc2hvdWxkQ2FzdCAqL10gPSBzaG91bGRDYXN0O1xuICAgICAgICBwcm9wWzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dID0gc2hvdWxkQ2FzdFRydWU7XG4gICAgICAgIGlmIChzaG91bGRDYXN0IHx8IGhhc093bihwcm9wLCBcImRlZmF1bHRcIikpIHtcbiAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCByZXMgPSBbbm9ybWFsaXplZCwgbmVlZENhc3RLZXlzXTtcbiAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgY2FjaGUuc2V0KGNvbXAsIHJlcyk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcE5hbWUoa2V5KSB7XG4gIGlmIChrZXlbMF0gIT09IFwiJFwiICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIHdhcm4kMShgSW52YWxpZCBwcm9wIG5hbWU6IFwiJHtrZXl9XCIgaXMgYSByZXNlcnZlZCBwcm9wZXJ0eS5gKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRUeXBlKGN0b3IpIHtcbiAgaWYgKGN0b3IgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gY3Rvci5uYW1lIHx8IFwiXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGN0b3IgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBuYW1lID0gY3Rvci5jb25zdHJ1Y3RvciAmJiBjdG9yLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgfHwgXCJcIjtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMsIHByb3BzLCBpbnN0YW5jZSkge1xuICBjb25zdCByZXNvbHZlZFZhbHVlcyA9IHRvUmF3KHByb3BzKTtcbiAgY29uc3Qgb3B0aW9ucyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXTtcbiAgY29uc3QgY2FtZWxpemVQcm9wc0tleSA9IE9iamVjdC5rZXlzKHJhd1Byb3BzKS5tYXAoKGtleSkgPT4gY2FtZWxpemUoa2V5KSk7XG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICBsZXQgb3B0ID0gb3B0aW9uc1trZXldO1xuICAgIGlmIChvcHQgPT0gbnVsbCkgY29udGludWU7XG4gICAgdmFsaWRhdGVQcm9wKFxuICAgICAga2V5LFxuICAgICAgcmVzb2x2ZWRWYWx1ZXNba2V5XSxcbiAgICAgIG9wdCxcbiAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzaGFsbG93UmVhZG9ubHkocmVzb2x2ZWRWYWx1ZXMpIDogcmVzb2x2ZWRWYWx1ZXMsXG4gICAgICAhY2FtZWxpemVQcm9wc0tleS5pbmNsdWRlcyhrZXkpXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKG5hbWUsIHZhbHVlLCBwcm9wLCBwcm9wcywgaXNBYnNlbnQpIHtcbiAgY29uc3QgeyB0eXBlLCByZXF1aXJlZCwgdmFsaWRhdG9yLCBza2lwQ2hlY2sgfSA9IHByb3A7XG4gIGlmIChyZXF1aXJlZCAmJiBpc0Fic2VudCkge1xuICAgIHdhcm4kMSgnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFyZXF1aXJlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZSAhPSBudWxsICYmIHR5cGUgIT09IHRydWUgJiYgIXNraXBDaGVjaykge1xuICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XG4gICAgY29uc3QgdHlwZXMgPSBpc0FycmF5KHR5cGUpID8gdHlwZSA6IFt0eXBlXTtcbiAgICBjb25zdCBleHBlY3RlZFR5cGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGggJiYgIWlzVmFsaWQ7IGkrKykge1xuICAgICAgY29uc3QgeyB2YWxpZCwgZXhwZWN0ZWRUeXBlIH0gPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlc1tpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goZXhwZWN0ZWRUeXBlIHx8IFwiXCIpO1xuICAgICAgaXNWYWxpZCA9IHZhbGlkO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHdhcm4kMShnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKHZhbGlkYXRvciAmJiAhdmFsaWRhdG9yKHZhbHVlLCBwcm9wcykpIHtcbiAgICB3YXJuJDEoJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nKTtcbiAgfVxufVxuY29uc3QgaXNTaW1wbGVUeXBlID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIFwiU3RyaW5nLE51bWJlcixCb29sZWFuLEZ1bmN0aW9uLFN5bWJvbCxCaWdJbnRcIlxuKTtcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcbiAgbGV0IHZhbGlkO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIm51bGxcIikge1xuICAgIHZhbGlkID0gdmFsdWUgPT09IG51bGw7XG4gIH0gZWxzZSBpZiAoaXNTaW1wbGVUeXBlKGV4cGVjdGVkVHlwZSkpIHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIk9iamVjdFwiKSB7XG4gICAgdmFsaWQgPSBpc09iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBcIkFycmF5XCIpIHtcbiAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGBQcm9wIHR5cGUgW10gZm9yIHByb3AgXCIke25hbWV9XCIgd29uJ3QgbWF0Y2ggYW55dGhpbmcuIERpZCB5b3UgbWVhbiB0byB1c2UgdHlwZSBBcnJheSBpbnN0ZWFkP2A7XG4gIH1cbiAgbGV0IG1lc3NhZ2UgPSBgSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIiR7bmFtZX1cIi4gRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKFwiIHwgXCIpfWA7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XG4gIGNvbnN0IHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XG4gIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xuICBjb25zdCByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBgIHdpdGggdmFsdWUgJHtleHBlY3RlZFZhbHVlfWA7XG4gIH1cbiAgbWVzc2FnZSArPSBgLCBnb3QgJHtyZWNlaXZlZFR5cGV9IGA7XG4gIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtyZWNlaXZlZFZhbHVlfS5gO1xuICB9XG4gIHJldHVybiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gc3R5bGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gXCJTdHJpbmdcIikge1xuICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcIk51bWJlclwiKSB7XG4gICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCR7dmFsdWV9YDtcbiAgfVxufVxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHR5cGUpIHtcbiAgY29uc3QgZXhwbGljaXRUeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl07XG4gIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoKGVsZW0pID0+IHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSk7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4oLi4uYXJncykge1xuICByZXR1cm4gYXJncy5zb21lKChlbGVtKSA9PiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09IFwiYm9vbGVhblwiKTtcbn1cblxuY29uc3QgaXNJbnRlcm5hbEtleSA9IChrZXkpID0+IGtleSA9PT0gXCJfXCIgfHwga2V5ID09PSBcIl9jdHhcIiB8fCBrZXkgPT09IFwiJHN0YWJsZVwiO1xuY29uc3Qgbm9ybWFsaXplU2xvdFZhbHVlID0gKHZhbHVlKSA9PiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcChub3JtYWxpemVWTm9kZSkgOiBbbm9ybWFsaXplVk5vZGUodmFsdWUpXTtcbmNvbnN0IG5vcm1hbGl6ZVNsb3QgPSAoa2V5LCByYXdTbG90LCBjdHgpID0+IHtcbiAgaWYgKHJhd1Nsb3QuX24pIHtcbiAgICByZXR1cm4gcmF3U2xvdDtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkID0gd2l0aEN0eCgoLi4uYXJncykgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGN1cnJlbnRJbnN0YW5jZSAmJiAhKGN0eCA9PT0gbnVsbCAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpICYmICEoY3R4ICYmIGN0eC5yb290ICE9PSBjdXJyZW50SW5zdGFuY2Uucm9vdCkpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYFNsb3QgXCIke2tleX1cIiBpbnZva2VkIG91dHNpZGUgb2YgdGhlIHJlbmRlciBmdW5jdGlvbjogdGhpcyB3aWxsIG5vdCB0cmFjayBkZXBlbmRlbmNpZXMgdXNlZCBpbiB0aGUgc2xvdC4gSW52b2tlIHRoZSBzbG90IGZ1bmN0aW9uIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVNsb3RWYWx1ZShyYXdTbG90KC4uLmFyZ3MpKTtcbiAgfSwgY3R4KTtcbiAgbm9ybWFsaXplZC5fYyA9IGZhbHNlO1xuICByZXR1cm4gbm9ybWFsaXplZDtcbn07XG5jb25zdCBub3JtYWxpemVPYmplY3RTbG90cyA9IChyYXdTbG90cywgc2xvdHMsIGluc3RhbmNlKSA9PiB7XG4gIGNvbnN0IGN0eCA9IHJhd1Nsb3RzLl9jdHg7XG4gIGZvciAoY29uc3Qga2V5IGluIHJhd1Nsb3RzKSB7XG4gICAgaWYgKGlzSW50ZXJuYWxLZXkoa2V5KSkgY29udGludWU7XG4gICAgY29uc3QgdmFsdWUgPSByYXdTbG90c1trZXldO1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgc2xvdHNba2V5XSA9IG5vcm1hbGl6ZVNsb3Qoa2V5LCB2YWx1ZSwgY3R4KTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUpIHtcbiAgICAgICAgd2FybiQxKFxuICAgICAgICAgIGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIHNsb3QgXCIke2tleX1cIi4gUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZSh2YWx1ZSk7XG4gICAgICBzbG90c1trZXldID0gKCkgPT4gbm9ybWFsaXplZDtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBub3JtYWxpemVWTm9kZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaXNLZWVwQWxpdmUoaW5zdGFuY2Uudm5vZGUpICYmIHRydWUpIHtcbiAgICB3YXJuJDEoXG4gICAgICBgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBkZWZhdWx0IHNsb3QuIFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUoY2hpbGRyZW4pO1xuICBpbnN0YW5jZS5zbG90cy5kZWZhdWx0ID0gKCkgPT4gbm9ybWFsaXplZDtcbn07XG5jb25zdCBhc3NpZ25TbG90cyA9IChzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZHJlbikge1xuICAgIGlmIChvcHRpbWl6ZWQgfHwgIWlzSW50ZXJuYWxLZXkoa2V5KSkge1xuICAgICAgc2xvdHNba2V5XSA9IGNoaWxkcmVuW2tleV07XG4gICAgfVxuICB9XG59O1xuY29uc3QgaW5pdFNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XG4gIGNvbnN0IHNsb3RzID0gaW5zdGFuY2Uuc2xvdHMgPSBjcmVhdGVJbnRlcm5hbE9iamVjdCgpO1xuICBpZiAoaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgMzIpIHtcbiAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcbiAgICBpZiAodHlwZSkge1xuICAgICAgYXNzaWduU2xvdHMoc2xvdHMsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgICAgaWYgKG9wdGltaXplZCkge1xuICAgICAgICBkZWYoc2xvdHMsIFwiX1wiLCB0eXBlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIHNsb3RzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XG4gIH1cbn07XG5jb25zdCB1cGRhdGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xuICBjb25zdCB7IHZub2RlLCBzbG90cyB9ID0gaW5zdGFuY2U7XG4gIGxldCBuZWVkRGVsZXRpb25DaGVjayA9IHRydWU7XG4gIGxldCBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBFTVBUWV9PQko7XG4gIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAzMikge1xuICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICAgIGFzc2lnblNsb3RzKHNsb3RzLCBjaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICAgICAgdHJpZ2dlcihpbnN0YW5jZSwgXCJzZXRcIiwgXCIkc2xvdHNcIik7XG4gICAgICB9IGVsc2UgaWYgKG9wdGltaXplZCAmJiB0eXBlID09PSAxKSB7XG4gICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NpZ25TbG90cyhzbG90cywgY2hpbGRyZW4sIG9wdGltaXplZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gIWNoaWxkcmVuLiRzdGFibGU7XG4gICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xuICAgIH1cbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSB7IGRlZmF1bHQ6IDEgfTtcbiAgfVxuICBpZiAobmVlZERlbGV0aW9uQ2hlY2spIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgaWYgKCFpc0ludGVybmFsS2V5KGtleSkgJiYgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgc2xvdHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmxldCBzdXBwb3J0ZWQ7XG5sZXQgcGVyZjtcbmZ1bmN0aW9uIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xuICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xuICAgIHBlcmYubWFyayhgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YCk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNQZXJmU3RhcnQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuZE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcbiAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcbiAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gO1xuICAgIGNvbnN0IGVuZFRhZyA9IHN0YXJ0VGFnICsgYDplbmRgO1xuICAgIGNvbnN0IG1lYXN1cmVOYW1lID0gYDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpfT4gJHt0eXBlfWA7XG4gICAgcGVyZi5tYXJrKGVuZFRhZyk7XG4gICAgcGVyZi5tZWFzdXJlKG1lYXN1cmVOYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXMobWVhc3VyZU5hbWUpO1xuICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgZGV2dG9vbHNQZXJmRW5kKGluc3RhbmNlLCB0eXBlLCBpc1N1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xuICB9XG59XG5mdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgaWYgKHN1cHBvcnRlZCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIH0gZWxzZSB7XG4gICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRlZDtcbn1cblxuZnVuY3Rpb24gaW5pdEZlYXR1cmVGbGFncygpIHtcbiAgY29uc3QgbmVlZFdhcm4gPSBbXTtcbiAgaWYgKHR5cGVvZiBfX1ZVRV9PUFRJT05TX0FQSV9fICE9PSBcImJvb2xlYW5cIikge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfT1BUSU9OU19BUElfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9PUFRJT05TX0FQSV9fID0gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX1BST0RfREVWVE9PTFNfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0RFVlRPT0xTX18gPSBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfX2ApO1xuICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18gPSBmYWxzZTtcbiAgfVxuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBuZWVkV2Fybi5sZW5ndGgpIHtcbiAgICBjb25zdCBtdWx0aSA9IG5lZWRXYXJuLmxlbmd0aCA+IDE7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYEZlYXR1cmUgZmxhZyR7bXVsdGkgPyBgc2AgOiBgYH0gJHtuZWVkV2Fybi5qb2luKFwiLCBcIil9ICR7bXVsdGkgPyBgYXJlYCA6IGBpc2B9IG5vdCBleHBsaWNpdGx5IGRlZmluZWQuIFlvdSBhcmUgcnVubmluZyB0aGUgZXNtLWJ1bmRsZXIgYnVpbGQgb2YgVnVlLCB3aGljaCBleHBlY3RzIHRoZXNlIGNvbXBpbGUtdGltZSBmZWF0dXJlIGZsYWdzIHRvIGJlIGdsb2JhbGx5IGluamVjdGVkIHZpYSB0aGUgYnVuZGxlciBjb25maWcgaW4gb3JkZXIgdG8gZ2V0IGJldHRlciB0cmVlLXNoYWtpbmcgaW4gdGhlIHByb2R1Y3Rpb24gYnVuZGxlLlxuXG5Gb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9saW5rLnZ1ZWpzLm9yZy9mZWF0dXJlLWZsYWdzLmBcbiAgICApO1xuICB9XG59XG5cbmNvbnN0IHF1ZXVlUG9zdFJlbmRlckVmZmVjdCA9IHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlIDtcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMpO1xufVxuZnVuY3Rpb24gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZucykge1xuICB7XG4gICAgaW5pdEZlYXR1cmVGbGFncygpO1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IGdldEdsb2JhbFRoaXMoKTtcbiAgdGFyZ2V0Ll9fVlVFX18gPSB0cnVlO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICBzZXREZXZ0b29sc0hvb2skMSh0YXJnZXQuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXywgdGFyZ2V0KTtcbiAgfVxuICBjb25zdCB7XG4gICAgaW5zZXJ0OiBob3N0SW5zZXJ0LFxuICAgIHJlbW92ZTogaG9zdFJlbW92ZSxcbiAgICBwYXRjaFByb3A6IGhvc3RQYXRjaFByb3AsXG4gICAgY3JlYXRlRWxlbWVudDogaG9zdENyZWF0ZUVsZW1lbnQsXG4gICAgY3JlYXRlVGV4dDogaG9zdENyZWF0ZVRleHQsXG4gICAgY3JlYXRlQ29tbWVudDogaG9zdENyZWF0ZUNvbW1lbnQsXG4gICAgc2V0VGV4dDogaG9zdFNldFRleHQsXG4gICAgc2V0RWxlbWVudFRleHQ6IGhvc3RTZXRFbGVtZW50VGV4dCxcbiAgICBwYXJlbnROb2RlOiBob3N0UGFyZW50Tm9kZSxcbiAgICBuZXh0U2libGluZzogaG9zdE5leHRTaWJsaW5nLFxuICAgIHNldFNjb3BlSWQ6IGhvc3RTZXRTY29wZUlkID0gTk9PUCxcbiAgICBpbnNlcnRTdGF0aWNDb250ZW50OiBob3N0SW5zZXJ0U3RhdGljQ29udGVudFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcGF0Y2ggPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciA9IG51bGwsIHBhcmVudENvbXBvbmVudCA9IG51bGwsIHBhcmVudFN1c3BlbnNlID0gbnVsbCwgbmFtZXNwYWNlID0gdm9pZCAwLCBzbG90U2NvcGVJZHMgPSBudWxsLCBvcHRpbWl6ZWQgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcgPyBmYWxzZSA6ICEhbjIuZHluYW1pY0NoaWxkcmVuKSA9PiB7XG4gICAgaWYgKG4xID09PSBuMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobjEgJiYgIWlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICBhbmNob3IgPSBnZXROZXh0SG9zdE5vZGUobjEpO1xuICAgICAgdW5tb3VudChuMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICBuMSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChuMi5wYXRjaEZsYWcgPT09IC0yKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgIG4yLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcgfSA9IG4yO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBUZXh0OlxuICAgICAgICBwcm9jZXNzVGV4dChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbW1lbnQ6XG4gICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRpYzpcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICBtb3VudFN0YXRpY05vZGUobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBuYW1lc3BhY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwYXRjaFN0YXRpY05vZGUobjEsIG4yLCBjb250YWluZXIsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICBwcm9jZXNzRnJhZ21lbnQoXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMSkge1xuICAgICAgICAgIHByb2Nlc3NFbGVtZW50KFxuICAgICAgICAgICAgbjEsXG4gICAgICAgICAgICBuMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQpIHtcbiAgICAgICAgICB0eXBlLnByb2Nlc3MoXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgICAgICBpbnRlcm5hbHNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICAgIHR5cGUucHJvY2VzcyhcbiAgICAgICAgICAgIG4xLFxuICAgICAgICAgICAgbjIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZCxcbiAgICAgICAgICAgIGludGVybmFsc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHdhcm4kMShcIkludmFsaWQgVk5vZGUgdHlwZTpcIiwgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVmICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBzZXRSZWYocmVmLCBuMSAmJiBuMS5yZWYsIHBhcmVudFN1c3BlbnNlLCBuMiB8fCBuMSwgIW4yKTtcbiAgICB9IGVsc2UgaWYgKHJlZiA9PSBudWxsICYmIG4xICYmIG4xLnJlZiAhPSBudWxsKSB7XG4gICAgICBzZXRSZWYobjEucmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgbjEsIHRydWUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc1RleHQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KFxuICAgICAgICBuMi5lbCA9IGhvc3RDcmVhdGVUZXh0KG4yLmNoaWxkcmVuKSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVsID0gbjIuZWwgPSBuMS5lbDtcbiAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZyAmJiBuMi5wYXRjaEZsYWcgPT09IC0xICYmIFwiX19lbEluZGV4XCIgaW4gbjEpIHtcbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gY29udGFpbmVyLmNoaWxkTm9kZXM7XG4gICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSBob3N0Q3JlYXRlVGV4dChuMi5jaGlsZHJlbik7XG4gICAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBjaGlsZE5vZGVzW24yLl9fZWxJbmRleCA9IG4xLl9fZWxJbmRleF07XG4gICAgICAgICAgaG9zdEluc2VydChuZXdDaGlsZCwgY29udGFpbmVyLCBvbGRDaGlsZCk7XG4gICAgICAgICAgaG9zdFJlbW92ZShvbGRDaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaG9zdFNldFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0NvbW1lbnROb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcbiAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgaG9zdEluc2VydChcbiAgICAgICAgbjIuZWwgPSBob3N0Q3JlYXRlQ29tbWVudChuMi5jaGlsZHJlbiB8fCBcIlwiKSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudFN0YXRpY05vZGUgPSAobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBuYW1lc3BhY2UpID0+IHtcbiAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChcbiAgICAgIG4yLmNoaWxkcmVuLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgYW5jaG9yLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgbjIuZWwsXG4gICAgICBuMi5hbmNob3JcbiAgICApO1xuICB9O1xuICBjb25zdCBwYXRjaFN0YXRpY05vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIG5hbWVzcGFjZSkgPT4ge1xuICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IGhvc3ROZXh0U2libGluZyhuMS5hbmNob3IpO1xuICAgICAgcmVtb3ZlU3RhdGljTm9kZShuMSk7XG4gICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChcbiAgICAgICAgbjIuY2hpbGRyZW4sXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICBuMi5hbmNob3IgPSBuMS5hbmNob3I7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSwgY29udGFpbmVyLCBuZXh0U2libGluZykgPT4ge1xuICAgIGxldCBuZXh0O1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gYW5jaG9yKSB7XG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xuICAgICAgZWwgPSBuZXh0O1xuICAgIH1cbiAgICBob3N0SW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XG4gIH07XG4gIGNvbnN0IHJlbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0pID0+IHtcbiAgICBsZXQgbmV4dDtcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xuICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XG4gICAgICBob3N0UmVtb3ZlKGVsKTtcbiAgICAgIGVsID0gbmV4dDtcbiAgICB9XG4gICAgaG9zdFJlbW92ZShhbmNob3IpO1xuICB9O1xuICBjb25zdCBwcm9jZXNzRWxlbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgaWYgKG4yLnR5cGUgPT09IFwic3ZnXCIpIHtcbiAgICAgIG5hbWVzcGFjZSA9IFwic3ZnXCI7XG4gICAgfSBlbHNlIGlmIChuMi50eXBlID09PSBcIm1hdGhcIikge1xuICAgICAgbmFtZXNwYWNlID0gXCJtYXRobWxcIjtcbiAgICB9XG4gICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgIG1vdW50RWxlbWVudChcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjdXN0b21FbGVtZW50ID0gISEobjEuZWwgJiYgbjEuZWwuX2lzVnVlQ0UpID8gbjEuZWwgOiBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGN1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgICBjdXN0b21FbGVtZW50Ll9iZWdpblBhdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2hFbGVtZW50KFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGN1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgICBjdXN0b21FbGVtZW50Ll9lbmRQYXRjaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudEVsZW1lbnQgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbGV0IGVsO1xuICAgIGxldCB2bm9kZUhvb2s7XG4gICAgY29uc3QgeyBwcm9wcywgc2hhcGVGbGFnLCB0cmFuc2l0aW9uLCBkaXJzIH0gPSB2bm9kZTtcbiAgICBlbCA9IHZub2RlLmVsID0gaG9zdENyZWF0ZUVsZW1lbnQoXG4gICAgICB2bm9kZS50eXBlLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgcHJvcHMgJiYgcHJvcHMuaXMsXG4gICAgICBwcm9wc1xuICAgICk7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDgpIHtcbiAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xuICAgIH0gZWxzZSBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIHZub2RlLmNoaWxkcmVuLFxuICAgICAgICBlbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKHZub2RlLCBuYW1lc3BhY2UpLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJjcmVhdGVkXCIpO1xuICAgIH1cbiAgICBzZXRTY29wZUlkKGVsLCB2bm9kZSwgdm5vZGUuc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gXCJ2YWx1ZVwiICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBuYW1lc3BhY2UsIHBhcmVudENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChcInZhbHVlXCIgaW4gcHJvcHMpIHtcbiAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJ2YWx1ZVwiLCBudWxsLCBwcm9wcy52YWx1ZSwgbmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICAgIGlmICh2bm9kZUhvb2sgPSBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpIHtcbiAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgZGVmKGVsLCBcIl9fdm5vZGVcIiwgdm5vZGUsIHRydWUpO1xuICAgICAgZGVmKGVsLCBcIl9fdnVlUGFyZW50Q29tcG9uZW50XCIsIHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChkaXJzKSB7XG4gICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwiYmVmb3JlTW91bnRcIik7XG4gICAgfVxuICAgIGNvbnN0IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gbmVlZFRyYW5zaXRpb24ocGFyZW50U3VzcGVuc2UsIHRyYW5zaXRpb24pO1xuICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgfVxuICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fCBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyB8fCBkaXJzKSB7XG4gICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJtb3VudGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgdm5vZGUsIHNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gICAgaWYgKHNjb3BlSWQpIHtcbiAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzY29wZUlkKTtcbiAgICB9XG4gICAgaWYgKHNsb3RTY29wZUlkcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbG90U2NvcGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNsb3RTY29wZUlkc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzdWJUcmVlLnBhdGNoRmxhZyA+IDAgJiYgc3ViVHJlZS5wYXRjaEZsYWcgJiAyMDQ4KSB7XG4gICAgICAgIHN1YlRyZWUgPSBmaWx0ZXJTaW5nbGVSb290KHN1YlRyZWUuY2hpbGRyZW4pIHx8IHN1YlRyZWU7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGUgPT09IHN1YlRyZWUgfHwgaXNTdXNwZW5zZShzdWJUcmVlLnR5cGUpICYmIChzdWJUcmVlLnNzQ29udGVudCA9PT0gdm5vZGUgfHwgc3ViVHJlZS5zc0ZhbGxiYWNrID09PSB2bm9kZSkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Vk5vZGUgPSBwYXJlbnRDb21wb25lbnQudm5vZGU7XG4gICAgICAgIHNldFNjb3BlSWQoXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgcGFyZW50Vk5vZGUsXG4gICAgICAgICAgcGFyZW50Vk5vZGUuc2NvcGVJZCxcbiAgICAgICAgICBwYXJlbnRWTm9kZS5zbG90U2NvcGVJZHMsXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LnBhcmVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHN0YXJ0ID0gMCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoY2hpbGRyZW5baV0pIDogbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pO1xuICAgICAgcGF0Y2goXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoRWxlbWVudCA9IChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBlbCA9IG4yLmVsID0gbjEuZWw7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICBlbC5fX3Zub2RlID0gbjI7XG4gICAgfVxuICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBkaXJzIH0gPSBuMjtcbiAgICBwYXRjaEZsYWcgfD0gbjEucGF0Y2hGbGFnICYgMTY7XG4gICAgY29uc3Qgb2xkUHJvcHMgPSBuMS5wcm9wcyB8fCBFTVBUWV9PQko7XG4gICAgY29uc3QgbmV3UHJvcHMgPSBuMi5wcm9wcyB8fCBFTVBUWV9PQko7XG4gICAgbGV0IHZub2RlSG9vaztcbiAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIGZhbHNlKTtcbiAgICBpZiAodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkge1xuICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xuICAgIH1cbiAgICBpZiAoZGlycykge1xuICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVVcGRhdGVcIik7XG4gICAgfVxuICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgcGF0Y2hGbGFnID0gMDtcbiAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG9sZFByb3BzLmlubmVySFRNTCAmJiBuZXdQcm9wcy5pbm5lckhUTUwgPT0gbnVsbCB8fCBvbGRQcm9wcy50ZXh0Q29udGVudCAmJiBuZXdQcm9wcy50ZXh0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIFwiXCIpO1xuICAgIH1cbiAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4oXG4gICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICBlbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgcmVzb2x2ZUNoaWxkcmVuTmFtZXNwYWNlKG4yLCBuYW1lc3BhY2UpLFxuICAgICAgICBzbG90U2NvcGVJZHNcbiAgICAgICk7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghb3B0aW1pemVkKSB7XG4gICAgICBwYXRjaENoaWxkcmVuKFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIGVsLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICByZXNvbHZlQ2hpbGRyZW5OYW1lc3BhY2UobjIsIG5hbWVzcGFjZSksXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMTYpIHtcbiAgICAgICAgcGF0Y2hQcm9wcyhlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMikge1xuICAgICAgICAgIGlmIChvbGRQcm9wcy5jbGFzcyAhPT0gbmV3UHJvcHMuY2xhc3MpIHtcbiAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIFwiY2xhc3NcIiwgbnVsbCwgbmV3UHJvcHMuY2xhc3MsIG5hbWVzcGFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA0KSB7XG4gICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgXCJzdHlsZVwiLCBvbGRQcm9wcy5zdHlsZSwgbmV3UHJvcHMuc3R5bGUsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDgpIHtcbiAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gbjIuZHluYW1pY1Byb3BzO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fCBrZXkgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXRjaEZsYWcgJiAxKSB7XG4gICAgICAgIGlmIChuMS5jaGlsZHJlbiAhPT0gbjIuY2hpbGRyZW4pIHtcbiAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW9wdGltaXplZCAmJiBkeW5hbWljQ2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgcGF0Y2hQcm9wcyhlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSk7XG4gICAgfVxuICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZVVwZGF0ZWQpIHx8IGRpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgXCJ1cGRhdGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hCbG9ja0NoaWxkcmVuID0gKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgZmFsbGJhY2tDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgb2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IG5ld1ZOb2RlID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICBjb25zdCBjb250YWluZXIgPSAoXG4gICAgICAgIC8vIG9sZFZOb2RlIG1heSBiZSBhbiBlcnJvcmVkIGFzeW5jIHNldHVwKCkgY29tcG9uZW50IGluc2lkZSBTdXNwZW5zZVxuICAgICAgICAvLyB3aGljaCB3aWxsIG5vdCBoYXZlIGEgbW91bnRlZCBlbGVtZW50XG4gICAgICAgIG9sZFZOb2RlLmVsICYmIC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBGcmFnbWVudCwgd2UgbmVlZCB0byBwcm92aWRlIHRoZSBhY3R1YWwgcGFyZW50XG4gICAgICAgIC8vIG9mIHRoZSBGcmFnbWVudCBpdHNlbGYgc28gaXQgY2FuIG1vdmUgaXRzIGNoaWxkcmVuLlxuICAgICAgICAob2xkVk5vZGUudHlwZSA9PT0gRnJhZ21lbnQgfHwgLy8gLSBJbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgbm9kZXMsIHRoZXJlIGlzIGdvaW5nIHRvIGJlIGEgcmVwbGFjZW1lbnRcbiAgICAgICAgLy8gd2hpY2ggYWxzbyByZXF1aXJlcyB0aGUgY29ycmVjdCBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgICFpc1NhbWVWTm9kZVR5cGUob2xkVk5vZGUsIG5ld1ZOb2RlKSB8fCAvLyAtIEluIHRoZSBjYXNlIG9mIGEgY29tcG9uZW50LCBpdCBjb3VsZCBjb250YWluIGFueXRoaW5nLlxuICAgICAgICBvbGRWTm9kZS5zaGFwZUZsYWcgJiAoNiB8IDY0IHwgMTI4KSkgPyBob3N0UGFyZW50Tm9kZShvbGRWTm9kZS5lbCkgOiAoXG4gICAgICAgICAgLy8gSW4gb3RoZXIgY2FzZXMsIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIG5vdCBhY3R1YWxseSB1c2VkIHNvIHdlXG4gICAgICAgICAgLy8ganVzdCBwYXNzIHRoZSBibG9jayBlbGVtZW50IGhlcmUgdG8gYXZvaWQgYSBET00gcGFyZW50Tm9kZSBjYWxsLlxuICAgICAgICAgIGZhbGxiYWNrQ29udGFpbmVyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBwYXRjaChcbiAgICAgICAgb2xkVk5vZGUsXG4gICAgICAgIG5ld1ZOb2RlLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hQcm9wcyA9IChlbCwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIG5hbWVzcGFjZSkgPT4ge1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgIGlmIChvbGRQcm9wcyAhPT0gRU1QVFlfT0JKKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpICYmICEoa2V5IGluIG5ld1Byb3BzKSkge1xuICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgb2xkUHJvcHNba2V5XSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wcykge1xuICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xuICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcbiAgICAgICAgaWYgKG5leHQgIT09IHByZXYgJiYga2V5ICE9PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIG5hbWVzcGFjZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFwidmFsdWVcIiBpbiBuZXdQcm9wcykge1xuICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBcInZhbHVlXCIsIG9sZFByb3BzLnZhbHVlLCBuZXdQcm9wcy52YWx1ZSwgbmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NGcmFnbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgY29uc3QgZnJhZ21lbnRTdGFydEFuY2hvciA9IG4yLmVsID0gbjEgPyBuMS5lbCA6IGhvc3RDcmVhdGVUZXh0KFwiXCIpO1xuICAgIGNvbnN0IGZyYWdtZW50RW5kQW5jaG9yID0gbjIuYW5jaG9yID0gbjEgPyBuMS5hbmNob3IgOiBob3N0Q3JlYXRlVGV4dChcIlwiKTtcbiAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgc2xvdFNjb3BlSWRzOiBmcmFnbWVudFNsb3RTY29wZUlkcyB9ID0gbjI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgLy8gIzU1MjMgZGV2IHJvb3QgZnJhZ21lbnQgbWF5IGluaGVyaXQgZGlyZWN0aXZlc1xuICAgIChpc0htclVwZGF0aW5nIHx8IHBhdGNoRmxhZyAmIDIwNDgpKSB7XG4gICAgICBwYXRjaEZsYWcgPSAwO1xuICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcyA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XG4gICAgfVxuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBob3N0SW5zZXJ0KGZyYWdtZW50U3RhcnRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRFbmRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgIC8vICMxMDAwN1xuICAgICAgICAvLyBzdWNoIGZyYWdtZW50IGxpa2UgYDw+PC8+YCB3aWxsIGJlIGNvbXBpbGVkIGludG9cbiAgICAgICAgLy8gYSBmcmFnbWVudCB3aGljaCBkb2Vzbid0IGhhdmUgYSBjaGlsZHJlbi5cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIGZhbGxiYWNrIHRvIGFuIGVtcHR5IGFycmF5XG4gICAgICAgIG4yLmNoaWxkcmVuIHx8IFtdLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGZyYWdtZW50RW5kQW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCAmJiBkeW5hbWljQ2hpbGRyZW4gJiYgLy8gIzI3MTUgdGhlIHByZXZpb3VzIGZyYWdtZW50IGNvdWxkJ3ZlIGJlZW4gYSBCQUlMZWQgb25lIGFzIGEgcmVzdWx0XG4gICAgICAvLyBvZiByZW5kZXJTbG90KCkgd2l0aCBubyB2YWxpZCBjaGlsZHJlblxuICAgICAgbjEuZHluYW1pY0NoaWxkcmVuICYmIG4xLmR5bmFtaWNDaGlsZHJlbi5sZW5ndGggPT09IGR5bmFtaWNDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKFxuICAgICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzXG4gICAgICAgICk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIC8vICMyMDgwIGlmIHRoZSBzdGFibGUgZnJhZ21lbnQgaGFzIGEga2V5LCBpdCdzIGEgPHRlbXBsYXRlIHYtZm9yPiB0aGF0IG1heVxuICAgICAgICAgIC8vICBnZXQgbW92ZWQgYXJvdW5kLiBNYWtlIHN1cmUgYWxsIHJvb3QgbGV2ZWwgdm5vZGVzIGluaGVyaXQgZWwuXG4gICAgICAgICAgLy8gIzIxMzQgb3IgaWYgaXQncyBhIGNvbXBvbmVudCByb290LCBpdCBtYXkgYWxzbyBnZXQgbW92ZWQgYXJvdW5kXG4gICAgICAgICAgLy8gYXMgdGhlIGNvbXBvbmVudCBpcyBiZWluZyBtb3ZlZC5cbiAgICAgICAgICBuMi5rZXkgIT0gbnVsbCB8fCBwYXJlbnRDb21wb25lbnQgJiYgbjIgPT09IHBhcmVudENvbXBvbmVudC5zdWJUcmVlXG4gICAgICAgICkge1xuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oXG4gICAgICAgICAgICBuMSxcbiAgICAgICAgICAgIG4yLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgLyogc2hhbGxvdyAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGNoQ2hpbGRyZW4oXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGZyYWdtZW50RW5kQW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJvY2Vzc0NvbXBvbmVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbjIuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBpZiAobjIuc2hhcGVGbGFnICYgNTEyKSB7XG4gICAgICAgIHBhcmVudENvbXBvbmVudC5jdHguYWN0aXZhdGUoXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudENvbXBvbmVudChcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudENvbXBvbmVudCA9IChpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gKGluaXRpYWxWTm9kZS5jb21wb25lbnQgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZShcbiAgICAgIGluaXRpYWxWTm9kZSxcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIHBhcmVudFN1c3BlbnNlXG4gICAgKSk7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XG4gICAgICByZWdpc3RlckhNUihpbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBwdXNoV2FybmluZ0NvbnRleHQoaW5pdGlhbFZOb2RlKTtcbiAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYG1vdW50YCk7XG4gICAgfVxuICAgIGlmIChpc0tlZXBBbGl2ZShpbml0aWFsVk5vZGUpKSB7XG4gICAgICBpbnN0YW5jZS5jdHgucmVuZGVyZXIgPSBpbnRlcm5hbHM7XG4gICAgfVxuICAgIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcbiAgICAgIH1cbiAgICAgIHNldHVwQ29tcG9uZW50KGluc3RhbmNlLCBmYWxzZSwgb3B0aW1pemVkKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGlzSG1yVXBkYXRpbmcpIGluaXRpYWxWTm9kZS5lbCA9IG51bGw7XG4gICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwKSB7XG4gICAgICBwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5yZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QsIG9wdGltaXplZCk7XG4gICAgICBpZiAoIWluaXRpYWxWTm9kZS5lbCkge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGluc3RhbmNlLnN1YlRyZWUgPSBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG51bGwsIHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgIGluaXRpYWxWTm9kZS5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyLmVsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXR1cFJlbmRlckVmZmVjdChcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIGluaXRpYWxWTm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUNvbXBvbmVudCA9IChuMSwgbjIsIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlID0gbjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50O1xuICAgIGlmIChzaG91bGRVcGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXAgJiYgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQpIHtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobjIpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbjI7XG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgaW5zdGFuY2Uudm5vZGUgPSBuMjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldHVwUmVuZGVyRWZmZWN0ID0gKGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCBjb21wb25lbnRVcGRhdGVGbiA9ICgpID0+IHtcbiAgICAgIGlmICghaW5zdGFuY2UuaXNNb3VudGVkKSB7XG4gICAgICAgIGxldCB2bm9kZUhvb2s7XG4gICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XG4gICAgICAgIGNvbnN0IHsgYm0sIG0sIHBhcmVudCwgcm9vdCwgdHlwZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGNvbnN0IGlzQXN5bmNXcmFwcGVyVk5vZGUgPSBpc0FzeW5jV3JhcHBlcihpbml0aWFsVk5vZGUpO1xuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XG4gICAgICAgIGlmIChibSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIGluaXRpYWxWTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChlbCAmJiBoeWRyYXRlTm9kZSkge1xuICAgICAgICAgIGNvbnN0IGh5ZHJhdGVTdWJUcmVlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoeWRyYXRlTm9kZShcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXJWTm9kZSAmJiB0eXBlLl9fYXN5bmNIeWRyYXRlKSB7XG4gICAgICAgICAgICB0eXBlLl9fYXN5bmNIeWRyYXRlKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoeWRyYXRlU3ViVHJlZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocm9vdC5jZSAmJiAvLyBAdHMtZXhwZWN0LWVycm9yIF9kZWYgaXMgcHJpdmF0ZVxuICAgICAgICAgIHJvb3QuY2UuX2RlZi5zaGFkb3dSb290ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcm9vdC5jZS5faW5qZWN0Q2hpbGRTdHlsZSh0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdWJUcmVlID0gaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBzdWJUcmVlLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbml0aWFsVk5vZGUuZWwgPSBzdWJUcmVlLmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xuICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcbiAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoXG4gICAgICAgICAgICAoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIHNjb3BlZEluaXRpYWxWTm9kZSksXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxWTm9kZS5zaGFwZUZsYWcgJiAyNTYgfHwgcGFyZW50ICYmIGlzQXN5bmNXcmFwcGVyKHBhcmVudC52bm9kZSkgJiYgcGFyZW50LnZub2RlLnNoYXBlRmxhZyAmIDI1Nikge1xuICAgICAgICAgIGluc3RhbmNlLmEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGluc3RhbmNlLmEsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHsgbmV4dCwgYnUsIHUsIHBhcmVudCwgdm5vZGUgfSA9IGluc3RhbmNlO1xuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgbm9uSHlkcmF0ZWRBc3luY1Jvb3QgPSBsb2NhdGVOb25IeWRyYXRlZEFzeW5jUm9vdChpbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKG5vbkh5ZHJhdGVkQXN5bmNSb290KSB7XG4gICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XG4gICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbmV4dCwgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vbkh5ZHJhdGVkQXN5bmNSb290LmFzeW5jRGVwLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWluc3RhbmNlLmlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50VXBkYXRlRm4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobmV4dCB8fCBpbnN0YW5jZS52bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgZmFsc2UpO1xuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIG5leHQuZWwgPSB2bm9kZS5lbDtcbiAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG5leHQsIG9wdGltaXplZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IHZub2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidSkge1xuICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpIHtcbiAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0VHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2VHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XG4gICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSBuZXh0VHJlZTtcbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIHByZXZUcmVlLFxuICAgICAgICAgIG5leHRUcmVlLFxuICAgICAgICAgIC8vIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSB0ZWxlcG9ydFxuICAgICAgICAgIGhvc3RQYXJlbnROb2RlKHByZXZUcmVlLmVsKSxcbiAgICAgICAgICAvLyBhbmNob3IgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgZnJhZ21lbnRcbiAgICAgICAgICBnZXROZXh0SG9zdE5vZGUocHJldlRyZWUpLFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZVxuICAgICAgICApO1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICB9XG4gICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcbiAgICAgICAgaWYgKG9yaWdpbk5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlVXBkYXRlZCkge1xuICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChcbiAgICAgICAgICAgICgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpLFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpbnN0YW5jZS5zY29wZS5vbigpO1xuICAgIGNvbnN0IGVmZmVjdCA9IGluc3RhbmNlLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChjb21wb25lbnRVcGRhdGVGbik7XG4gICAgaW5zdGFuY2Uuc2NvcGUub2ZmKCk7XG4gICAgY29uc3QgdXBkYXRlID0gaW5zdGFuY2UudXBkYXRlID0gZWZmZWN0LnJ1bi5iaW5kKGVmZmVjdCk7XG4gICAgY29uc3Qgam9iID0gaW5zdGFuY2Uuam9iID0gZWZmZWN0LnJ1bklmRGlydHkuYmluZChlZmZlY3QpO1xuICAgIGpvYi5pID0gaW5zdGFuY2U7XG4gICAgam9iLmlkID0gaW5zdGFuY2UudWlkO1xuICAgIGVmZmVjdC5zY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZUpvYihqb2IpO1xuICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICBlZmZlY3Qub25UcmFjayA9IGluc3RhbmNlLnJ0YyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGMsIGUpIDogdm9pZCAwO1xuICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IGluc3RhbmNlLnJ0ZyA/IChlKSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGcsIGUpIDogdm9pZCAwO1xuICAgIH1cbiAgICB1cGRhdGUoKTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyID0gKGluc3RhbmNlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkgPT4ge1xuICAgIG5leHRWTm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcbiAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcztcbiAgICBpbnN0YW5jZS52bm9kZSA9IG5leHRWTm9kZTtcbiAgICBpbnN0YW5jZS5uZXh0ID0gbnVsbDtcbiAgICB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgbmV4dFZOb2RlLnByb3BzLCBwcmV2UHJvcHMsIG9wdGltaXplZCk7XG4gICAgdXBkYXRlU2xvdHMoaW5zdGFuY2UsIG5leHRWTm9kZS5jaGlsZHJlbiwgb3B0aW1pemVkKTtcbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgZmx1c2hQcmVGbHVzaENicyhpbnN0YW5jZSk7XG4gICAgcmVzZXRUcmFja2luZygpO1xuICB9O1xuICBjb25zdCBwYXRjaENoaWxkcmVuID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IGMxID0gbjEgJiYgbjEuY2hpbGRyZW47XG4gICAgY29uc3QgcHJldlNoYXBlRmxhZyA9IG4xID8gbjEuc2hhcGVGbGFnIDogMDtcbiAgICBjb25zdCBjMiA9IG4yLmNoaWxkcmVuO1xuICAgIGNvbnN0IHsgcGF0Y2hGbGFnLCBzaGFwZUZsYWcgfSA9IG4yO1xuICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICBpZiAocGF0Y2hGbGFnICYgMTI4KSB7XG4gICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICBjMSxcbiAgICAgICAgICBjMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHBhdGNoRmxhZyAmIDI1Nikge1xuICAgICAgICBwYXRjaFVua2V5ZWRDaGlsZHJlbihcbiAgICAgICAgICBjMSxcbiAgICAgICAgICBjMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiA4KSB7XG4gICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2KSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9XG4gICAgICBpZiAoYzIgIT09IGMxKSB7XG4gICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIGMyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNikge1xuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYpIHtcbiAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oXG4gICAgICAgICAgICBjMSxcbiAgICAgICAgICAgIGMyLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgOCkge1xuICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICAgIG1vdW50Q2hpbGRyZW4oXG4gICAgICAgICAgICBjMixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgICAgb3B0aW1pemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcGF0Y2hVbmtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgbmFtZXNwYWNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgIGMxID0gYzEgfHwgRU1QVFlfQVJSO1xuICAgIGMyID0gYzIgfHwgRU1QVFlfQVJSO1xuICAgIGNvbnN0IG9sZExlbmd0aCA9IGMxLmxlbmd0aDtcbiAgICBjb25zdCBuZXdMZW5ndGggPSBjMi5sZW5ndGg7XG4gICAgY29uc3QgY29tbW9uTGVuZ3RoID0gTWF0aC5taW4ob2xkTGVuZ3RoLCBuZXdMZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb21tb25MZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICBwYXRjaChcbiAgICAgICAgYzFbaV0sXG4gICAgICAgIG5leHRDaGlsZCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgb3B0aW1pemVkXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XG4gICAgICB1bm1vdW50Q2hpbGRyZW4oXG4gICAgICAgIGMxLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICB0cnVlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgY29tbW9uTGVuZ3RoXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb3VudENoaWxkcmVuKFxuICAgICAgICBjMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIGNvbW1vbkxlbmd0aFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHBhdGNoS2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGwyID0gYzIubGVuZ3RoO1xuICAgIGxldCBlMSA9IGMxLmxlbmd0aCAtIDE7XG4gICAgbGV0IGUyID0gbDIgLSAxO1xuICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcbiAgICAgIGNvbnN0IG4xID0gYzFbaV07XG4gICAgICBjb25zdCBuMiA9IGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pO1xuICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcbiAgICAgIGNvbnN0IG4xID0gYzFbZTFdO1xuICAgICAgY29uc3QgbjIgPSBjMltlMl0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltlMl0pIDogbm9ybWFsaXplVk5vZGUoYzJbZTJdKTtcbiAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBuMSxcbiAgICAgICAgICBuMixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZTEtLTtcbiAgICAgIGUyLS07XG4gICAgfVxuICAgIGlmIChpID4gZTEpIHtcbiAgICAgIGlmIChpIDw9IGUyKSB7XG4gICAgICAgIGNvbnN0IG5leHRQb3MgPSBlMiArIDE7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRQb3MgPCBsMiA/IGMyW25leHRQb3NdLmVsIDogcGFyZW50QW5jaG9yO1xuICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGMyW2ldID0gb3B0aW1pemVkID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaSA+IGUyKSB7XG4gICAgICB3aGlsZSAoaSA8PSBlMSkge1xuICAgICAgICB1bm1vdW50KGMxW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzMSA9IGk7XG4gICAgICBjb25zdCBzMiA9IGk7XG4gICAgICBjb25zdCBrZXlUb05ld0luZGV4TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAoaSA9IHMyOyBpIDw9IGUyOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbaV0gPSBvcHRpbWl6ZWQgPyBjbG9uZUlmTW91bnRlZChjMltpXSkgOiBub3JtYWxpemVWTm9kZShjMltpXSk7XG4gICAgICAgIGlmIChuZXh0Q2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBrZXlUb05ld0luZGV4TWFwLmhhcyhuZXh0Q2hpbGQua2V5KSkge1xuICAgICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgICBgRHVwbGljYXRlIGtleXMgZm91bmQgZHVyaW5nIHVwZGF0ZTpgLFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXh0Q2hpbGQua2V5KSxcbiAgICAgICAgICAgICAgYE1ha2Ugc3VyZSBrZXlzIGFyZSB1bmlxdWUuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5VG9OZXdJbmRleE1hcC5zZXQobmV4dENoaWxkLmtleSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBqO1xuICAgICAgbGV0IHBhdGNoZWQgPSAwO1xuICAgICAgY29uc3QgdG9CZVBhdGNoZWQgPSBlMiAtIHMyICsgMTtcbiAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgbGV0IG1heE5ld0luZGV4U29GYXIgPSAwO1xuICAgICAgY29uc3QgbmV3SW5kZXhUb09sZEluZGV4TWFwID0gbmV3IEFycmF5KHRvQmVQYXRjaGVkKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0JlUGF0Y2hlZDsgaSsrKSBuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPSAwO1xuICAgICAgZm9yIChpID0gczE7IGkgPD0gZTE7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcbiAgICAgICAgaWYgKHBhdGNoZWQgPj0gdG9CZVBhdGNoZWQpIHtcbiAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0luZGV4O1xuICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3SW5kZXggPSBrZXlUb05ld0luZGV4TWFwLmdldChwcmV2Q2hpbGQua2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGogPSBzMjsgaiA8PSBlMjsgaisrKSB7XG4gICAgICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ogLSBzMl0gPT09IDAgJiYgaXNTYW1lVk5vZGVUeXBlKHByZXZDaGlsZCwgYzJbal0pKSB7XG4gICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdJbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0luZGV4VG9PbGRJbmRleE1hcFtuZXdJbmRleCAtIHMyXSA9IGkgKyAxO1xuICAgICAgICAgIGlmIChuZXdJbmRleCA+PSBtYXhOZXdJbmRleFNvRmFyKSB7XG4gICAgICAgICAgICBtYXhOZXdJbmRleFNvRmFyID0gbmV3SW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2goXG4gICAgICAgICAgICBwcmV2Q2hpbGQsXG4gICAgICAgICAgICBjMltuZXdJbmRleF0sXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHBhdGNoZWQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UgPSBtb3ZlZCA/IGdldFNlcXVlbmNlKG5ld0luZGV4VG9PbGRJbmRleE1hcCkgOiBFTVBUWV9BUlI7XG4gICAgICBqID0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UubGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoaSA9IHRvQmVQYXRjaGVkIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gczIgKyBpO1xuICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltuZXh0SW5kZXhdO1xuICAgICAgICBjb25zdCBhbmNob3JWTm9kZSA9IGMyW25leHRJbmRleCArIDFdO1xuICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0SW5kZXggKyAxIDwgbDIgPyAoXG4gICAgICAgICAgLy8gIzEzNTU5LCAjMTQxNzMgZmFsbGJhY2sgdG8gZWwgcGxhY2Vob2xkZXIgZm9yIHVucmVzb2x2ZWQgYXN5bmMgY29tcG9uZW50XG4gICAgICAgICAgYW5jaG9yVk5vZGUuZWwgfHwgcmVzb2x2ZUFzeW5jQ29tcG9uZW50UGxhY2Vob2xkZXIoYW5jaG9yVk5vZGUpXG4gICAgICAgICkgOiBwYXJlbnRBbmNob3I7XG4gICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPT09IDApIHtcbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBuZXh0Q2hpbGQsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAobW92ZWQpIHtcbiAgICAgICAgICBpZiAoaiA8IDAgfHwgaSAhPT0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2Vbal0pIHtcbiAgICAgICAgICAgIG1vdmUobmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdmUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSwgcGFyZW50U3VzcGVuc2UgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgeyBlbCwgdHlwZSwgdHJhbnNpdGlvbiwgY2hpbGRyZW4sIHNoYXBlRmxhZyB9ID0gdm5vZGU7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDYpIHtcbiAgICAgIG1vdmUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHZub2RlLnN1c3BlbnNlLm1vdmUoY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICB0eXBlLm1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnRlcm5hbHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgIH1cbiAgICAgIGhvc3RJbnNlcnQodm5vZGUuYW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcbiAgICAgIG1vdmVTdGF0aWNOb2RlKHZub2RlLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5lZWRUcmFuc2l0aW9uMiA9IG1vdmVUeXBlICE9PSAyICYmIHNoYXBlRmxhZyAmIDEgJiYgdHJhbnNpdGlvbjtcbiAgICBpZiAobmVlZFRyYW5zaXRpb24yKSB7XG4gICAgICBpZiAobW92ZVR5cGUgPT09IDApIHtcbiAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHRyYW5zaXRpb24uZW50ZXIoZWwpLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlLCBhZnRlckxlYXZlIH0gPSB0cmFuc2l0aW9uO1xuICAgICAgICBjb25zdCByZW1vdmUyID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh2bm9kZS5jdHguaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoZWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGVsLl9pc0xlYXZpbmcpIHtcbiAgICAgICAgICAgIGVsW2xlYXZlQ2JLZXldKFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgIC8qIGNhbmNlbGxlZCAqL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVhdmUoZWwsICgpID0+IHtcbiAgICAgICAgICAgIHJlbW92ZTIoKTtcbiAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgICAgIGRlbGF5TGVhdmUoZWwsIHJlbW92ZTIsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVyZm9ybUxlYXZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdW5tb3VudCA9ICh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgcHJvcHMsXG4gICAgICByZWYsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGR5bmFtaWNDaGlsZHJlbixcbiAgICAgIHNoYXBlRmxhZyxcbiAgICAgIHBhdGNoRmxhZyxcbiAgICAgIGRpcnMsXG4gICAgICBjYWNoZUluZGV4XG4gICAgfSA9IHZub2RlO1xuICAgIGlmIChwYXRjaEZsYWcgPT09IC0yKSB7XG4gICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIHRydWUpO1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgIH1cbiAgICBpZiAoY2FjaGVJbmRleCAhPSBudWxsKSB7XG4gICAgICBwYXJlbnRDb21wb25lbnQucmVuZGVyQ2FjaGVbY2FjaGVJbmRleF0gPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiAyNTYpIHtcbiAgICAgIHBhcmVudENvbXBvbmVudC5jdHguZGVhY3RpdmF0ZSh2bm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZEludm9rZURpcnMgPSBzaGFwZUZsYWcgJiAxICYmIGRpcnM7XG4gICAgY29uc3Qgc2hvdWxkSW52b2tlVm5vZGVIb29rID0gIWlzQXN5bmNXcmFwcGVyKHZub2RlKTtcbiAgICBsZXQgdm5vZGVIb29rO1xuICAgIGlmIChzaG91bGRJbnZva2VWbm9kZUhvb2sgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVVbm1vdW50KSkge1xuICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgfVxuICAgIGlmIChzaGFwZUZsYWcgJiA2KSB7XG4gICAgICB1bm1vdW50Q29tcG9uZW50KHZub2RlLmNvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCkge1xuICAgICAgICB2bm9kZS5zdXNwZW5zZS51bm1vdW50KHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRJbnZva2VEaXJzKSB7XG4gICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgXCJiZWZvcmVVbm1vdW50XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICAgIHZub2RlLnR5cGUucmVtb3ZlKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICAgICAgICBpbnRlcm5hbHMsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoZHluYW1pY0NoaWxkcmVuICYmIC8vICM1MTU0XG4gICAgICAvLyB3aGVuIHYtb25jZSBpcyB1c2VkIGluc2lkZSBhIGJsb2NrLCBzZXRCbG9ja1RyYWNraW5nKC0xKSBtYXJrcyB0aGVcbiAgICAgIC8vIHBhcmVudCBibG9jayB3aXRoIGhhc09uY2U6IHRydWVcbiAgICAgIC8vIHNvIHRoYXQgaXQgZG9lc24ndCB0YWtlIHRoZSBmYXN0IHBhdGggZHVyaW5nIHVubW91bnQgLSBvdGhlcndpc2VcbiAgICAgIC8vIGNvbXBvbmVudHMgbmVzdGVkIGluIHYtb25jZSBhcmUgbmV2ZXIgdW5tb3VudGVkLlxuICAgICAgIWR5bmFtaWNDaGlsZHJlbi5oYXNPbmNlICYmIC8vICMxMTUzOiBmYXN0IHBhdGggc2hvdWxkIG5vdCBiZSB0YWtlbiBmb3Igbm9uLXN0YWJsZSAodi1mb3IpIGZyYWdtZW50c1xuICAgICAgKHR5cGUgIT09IEZyYWdtZW50IHx8IHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQpKSB7XG4gICAgICAgIHVubW91bnRDaGlsZHJlbihcbiAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4sXG4gICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgIHBhcmVudFN1c3BlbnNlLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gRnJhZ21lbnQgJiYgcGF0Y2hGbGFnICYgKDEyOCB8IDI1NikgfHwgIW9wdGltaXplZCAmJiBzaGFwZUZsYWcgJiAxNikge1xuICAgICAgICB1bm1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgaWYgKGRvUmVtb3ZlKSB7XG4gICAgICAgIHJlbW92ZSh2bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRJbnZva2VWbm9kZUhvb2sgJiYgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVVbm1vdW50ZWQpIHx8IHNob3VsZEludm9rZURpcnMpIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgc2hvdWxkSW52b2tlRGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIFwidW5tb3VudGVkXCIpO1xuICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVtb3ZlID0gKHZub2RlKSA9PiB7XG4gICAgY29uc3QgeyB0eXBlLCBlbCwgYW5jaG9yLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcbiAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHZub2RlLnBhdGNoRmxhZyA+IDAgJiYgdm5vZGUucGF0Y2hGbGFnICYgMjA0OCAmJiB0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCkge1xuICAgICAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KSB7XG4gICAgICAgICAgICBob3N0UmVtb3ZlKGNoaWxkLmVsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRnJhZ21lbnQoZWwsIGFuY2hvcik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcbiAgICAgIHJlbW92ZVN0YXRpY05vZGUodm5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwZXJmb3JtUmVtb3ZlID0gKCkgPT4ge1xuICAgICAgaG9zdFJlbW92ZShlbCk7XG4gICAgICBpZiAodHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQgJiYgdHJhbnNpdGlvbi5hZnRlckxlYXZlKSB7XG4gICAgICAgIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgJiYgdHJhbnNpdGlvbiAmJiAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcbiAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUgfSA9IHRyYW5zaXRpb247XG4gICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiBsZWF2ZShlbCwgcGVyZm9ybVJlbW92ZSk7XG4gICAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgICBkZWxheUxlYXZlKHZub2RlLmVsLCBwZXJmb3JtUmVtb3ZlLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVyZm9ybUxlYXZlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlcmZvcm1SZW1vdmUoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlbW92ZUZyYWdtZW50ID0gKGN1ciwgZW5kKSA9PiB7XG4gICAgbGV0IG5leHQ7XG4gICAgd2hpbGUgKGN1ciAhPT0gZW5kKSB7XG4gICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGN1cik7XG4gICAgICBob3N0UmVtb3ZlKGN1cik7XG4gICAgICBjdXIgPSBuZXh0O1xuICAgIH1cbiAgICBob3N0UmVtb3ZlKGVuZCk7XG4gIH07XG4gIGNvbnN0IHVubW91bnRDb21wb25lbnQgPSAoaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkgPT4ge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xuICAgICAgdW5yZWdpc3RlckhNUihpbnN0YW5jZSk7XG4gICAgfVxuICAgIGNvbnN0IHsgYnVtLCBzY29wZSwgam9iLCBzdWJUcmVlLCB1bSwgbSwgYSB9ID0gaW5zdGFuY2U7XG4gICAgaW52YWxpZGF0ZU1vdW50KG0pO1xuICAgIGludmFsaWRhdGVNb3VudChhKTtcbiAgICBpZiAoYnVtKSB7XG4gICAgICBpbnZva2VBcnJheUZucyhidW0pO1xuICAgIH1cbiAgICBzY29wZS5zdG9wKCk7XG4gICAgaWYgKGpvYikge1xuICAgICAgam9iLmZsYWdzIHw9IDg7XG4gICAgICB1bm1vdW50KHN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgIH1cbiAgICBpZiAodW0pIHtcbiAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1bSwgcGFyZW50U3VzcGVuc2UpO1xuICAgIH1cbiAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgaW5zdGFuY2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChpbnN0YW5jZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCB1bm1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlLCBzdGFydCA9IDApID0+IHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdW5tb3VudChjaGlsZHJlbltpXSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUsIG9wdGltaXplZCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSAodm5vZGUpID0+IHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNikge1xuICAgICAgcmV0dXJuIGdldE5leHRIb3N0Tm9kZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gaG9zdE5leHRTaWJsaW5nKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCk7XG4gICAgY29uc3QgdGVsZXBvcnRFbmQgPSBlbCAmJiBlbFtUZWxlcG9ydEVuZEtleV07XG4gICAgcmV0dXJuIHRlbGVwb3J0RW5kID8gaG9zdE5leHRTaWJsaW5nKHRlbGVwb3J0RW5kKSA6IGVsO1xuICB9O1xuICBsZXQgaXNGbHVzaGluZyA9IGZhbHNlO1xuICBjb25zdCByZW5kZXIgPSAodm5vZGUsIGNvbnRhaW5lciwgbmFtZXNwYWNlKSA9PiB7XG4gICAgbGV0IGluc3RhbmNlO1xuICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XG4gICAgICBpZiAoY29udGFpbmVyLl92bm9kZSkge1xuICAgICAgICB1bm1vdW50KGNvbnRhaW5lci5fdm5vZGUsIG51bGwsIG51bGwsIHRydWUpO1xuICAgICAgICBpbnN0YW5jZSA9IGNvbnRhaW5lci5fdm5vZGUuY29tcG9uZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXRjaChcbiAgICAgICAgY29udGFpbmVyLl92bm9kZSB8fCBudWxsLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgICBpZiAoIWlzRmx1c2hpbmcpIHtcbiAgICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xuICAgICAgZmx1c2hQcmVGbHVzaENicyhpbnN0YW5jZSk7XG4gICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgICAgaXNGbHVzaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHA6IHBhdGNoLFxuICAgIHVtOiB1bm1vdW50LFxuICAgIG06IG1vdmUsXG4gICAgcjogcmVtb3ZlLFxuICAgIG10OiBtb3VudENvbXBvbmVudCxcbiAgICBtYzogbW91bnRDaGlsZHJlbixcbiAgICBwYzogcGF0Y2hDaGlsZHJlbixcbiAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcbiAgICBuOiBnZXROZXh0SG9zdE5vZGUsXG4gICAgbzogb3B0aW9uc1xuICB9O1xuICBsZXQgaHlkcmF0ZTtcbiAgbGV0IGh5ZHJhdGVOb2RlO1xuICBpZiAoY3JlYXRlSHlkcmF0aW9uRm5zKSB7XG4gICAgW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXSA9IGNyZWF0ZUh5ZHJhdGlvbkZucyhcbiAgICAgIGludGVybmFsc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZW5kZXIsXG4gICAgaHlkcmF0ZSxcbiAgICBjcmVhdGVBcHA6IGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlQ2hpbGRyZW5OYW1lc3BhY2UoeyB0eXBlLCBwcm9wcyB9LCBjdXJyZW50TmFtZXNwYWNlKSB7XG4gIHJldHVybiBjdXJyZW50TmFtZXNwYWNlID09PSBcInN2Z1wiICYmIHR5cGUgPT09IFwiZm9yZWlnbk9iamVjdFwiIHx8IGN1cnJlbnROYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgJiYgdHlwZSA9PT0gXCJhbm5vdGF0aW9uLXhtbFwiICYmIHByb3BzICYmIHByb3BzLmVuY29kaW5nICYmIHByb3BzLmVuY29kaW5nLmluY2x1ZGVzKFwiaHRtbFwiKSA/IHZvaWQgMCA6IGN1cnJlbnROYW1lc3BhY2U7XG59XG5mdW5jdGlvbiB0b2dnbGVSZWN1cnNlKHsgZWZmZWN0LCBqb2IgfSwgYWxsb3dlZCkge1xuICBpZiAoYWxsb3dlZCkge1xuICAgIGVmZmVjdC5mbGFncyB8PSAzMjtcbiAgICBqb2IuZmxhZ3MgfD0gNDtcbiAgfSBlbHNlIHtcbiAgICBlZmZlY3QuZmxhZ3MgJj0gLTMzO1xuICAgIGpvYi5mbGFncyAmPSAtNTtcbiAgfVxufVxuZnVuY3Rpb24gbmVlZFRyYW5zaXRpb24ocGFyZW50U3VzcGVuc2UsIHRyYW5zaXRpb24pIHtcbiAgcmV0dXJuICghcGFyZW50U3VzcGVuc2UgfHwgcGFyZW50U3VzcGVuc2UgJiYgIXBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpICYmIHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHNoYWxsb3cgPSBmYWxzZSkge1xuICBjb25zdCBjaDEgPSBuMS5jaGlsZHJlbjtcbiAgY29uc3QgY2gyID0gbjIuY2hpbGRyZW47XG4gIGlmIChpc0FycmF5KGNoMSkgJiYgaXNBcnJheShjaDIpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMxID0gY2gxW2ldO1xuICAgICAgbGV0IGMyID0gY2gyW2ldO1xuICAgICAgaWYgKGMyLnNoYXBlRmxhZyAmIDEgJiYgIWMyLmR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBpZiAoYzIucGF0Y2hGbGFnIDw9IDAgfHwgYzIucGF0Y2hGbGFnID09PSAzMikge1xuICAgICAgICAgIGMyID0gY2gyW2ldID0gY2xvbmVJZk1vdW50ZWQoY2gyW2ldKTtcbiAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2hhbGxvdyAmJiBjMi5wYXRjaEZsYWcgIT09IC0yKVxuICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4oYzEsIGMyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjMi50eXBlID09PSBUZXh0KSB7XG4gICAgICAgIGlmIChjMi5wYXRjaEZsYWcgIT09IC0xKSB7XG4gICAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjMi5fX2VsSW5kZXggPSBpICsgLy8gdGFrZSBmcmFnbWVudCBzdGFydCBhbmNob3IgaW50byBhY2NvdW50XG4gICAgICAgICAgKG4xLnR5cGUgPT09IEZyYWdtZW50ID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcbiAgICAgICAgYzIuZWwgPSBjMS5lbDtcbiAgICAgIH1cbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGMyLmVsICYmIChjMi5lbC5fX3Zub2RlID0gYzIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2VxdWVuY2UoYXJyKSB7XG4gIGNvbnN0IHAgPSBhcnIuc2xpY2UoKTtcbiAgY29uc3QgcmVzdWx0ID0gWzBdO1xuICBsZXQgaSwgaiwgdSwgdiwgYztcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgYXJySSA9IGFycltpXTtcbiAgICBpZiAoYXJySSAhPT0gMCkge1xuICAgICAgaiA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoYXJyW2pdIDwgYXJySSkge1xuICAgICAgICBwW2ldID0gajtcbiAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdSA9IDA7XG4gICAgICB2ID0gcmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAodSA8IHYpIHtcbiAgICAgICAgYyA9IHUgKyB2ID4+IDE7XG4gICAgICAgIGlmIChhcnJbcmVzdWx0W2NdXSA8IGFyckkpIHtcbiAgICAgICAgICB1ID0gYyArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdiA9IGM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhcnJJIDwgYXJyW3Jlc3VsdFt1XV0pIHtcbiAgICAgICAgaWYgKHUgPiAwKSB7XG4gICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3VdID0gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdSA9IHJlc3VsdC5sZW5ndGg7XG4gIHYgPSByZXN1bHRbdSAtIDFdO1xuICB3aGlsZSAodS0tID4gMCkge1xuICAgIHJlc3VsdFt1XSA9IHY7XG4gICAgdiA9IHBbdl07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxvY2F0ZU5vbkh5ZHJhdGVkQXN5bmNSb290KGluc3RhbmNlKSB7XG4gIGNvbnN0IHN1YkNvbXBvbmVudCA9IGluc3RhbmNlLnN1YlRyZWUuY29tcG9uZW50O1xuICBpZiAoc3ViQ29tcG9uZW50KSB7XG4gICAgaWYgKHN1YkNvbXBvbmVudC5hc3luY0RlcCAmJiAhc3ViQ29tcG9uZW50LmFzeW5jUmVzb2x2ZWQpIHtcbiAgICAgIHJldHVybiBzdWJDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsb2NhdGVOb25IeWRyYXRlZEFzeW5jUm9vdChzdWJDb21wb25lbnQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW52YWxpZGF0ZU1vdW50KGhvb2tzKSB7XG4gIGlmIChob29rcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspXG4gICAgICBob29rc1tpXS5mbGFncyB8PSA4O1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnRQbGFjZWhvbGRlcihhbmNob3JWbm9kZSkge1xuICBpZiAoYW5jaG9yVm5vZGUucGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gYW5jaG9yVm5vZGUucGxhY2Vob2xkZXI7XG4gIH1cbiAgY29uc3QgaW5zdGFuY2UgPSBhbmNob3JWbm9kZS5jb21wb25lbnQ7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIHJldHVybiByZXNvbHZlQXN5bmNDb21wb25lbnRQbGFjZWhvbGRlcihpbnN0YW5jZS5zdWJUcmVlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgaXNTdXNwZW5zZSA9ICh0eXBlKSA9PiB0eXBlLl9faXNTdXNwZW5zZTtcbmxldCBzdXNwZW5zZUlkID0gMDtcbmNvbnN0IFN1c3BlbnNlSW1wbCA9IHtcbiAgbmFtZTogXCJTdXNwZW5zZVwiLFxuICAvLyBJbiBvcmRlciB0byBtYWtlIFN1c3BlbnNlIHRyZWUtc2hha2FibGUsIHdlIG5lZWQgdG8gYXZvaWQgaW1wb3J0aW5nIGl0XG4gIC8vIGRpcmVjdGx5IGluIHRoZSByZW5kZXJlci4gVGhlIHJlbmRlcmVyIGNoZWNrcyBmb3IgdGhlIF9faXNTdXNwZW5zZSBmbGFnXG4gIC8vIG9uIGEgdm5vZGUncyB0eXBlIGFuZCBjYWxscyB0aGUgYHByb2Nlc3NgIG1ldGhvZCwgcGFzc2luZyBpbiByZW5kZXJlclxuICAvLyBpbnRlcm5hbHMuXG4gIF9faXNTdXNwZW5zZTogdHJ1ZSxcbiAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykge1xuICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICBtb3VudFN1c3BlbnNlKFxuICAgICAgICBuMixcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgcGFyZW50U3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UuZGVwcyA+IDAgJiYgIW4xLnN1c3BlbnNlLmlzSW5GYWxsYmFjaykge1xuICAgICAgICBuMi5zdXNwZW5zZSA9IG4xLnN1c3BlbnNlO1xuICAgICAgICBuMi5zdXNwZW5zZS52bm9kZSA9IG4yO1xuICAgICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwYXRjaFN1c3BlbnNlKFxuICAgICAgICBuMSxcbiAgICAgICAgbjIsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWQsXG4gICAgICAgIHJlbmRlcmVySW50ZXJuYWxzXG4gICAgICApO1xuICAgIH1cbiAgfSxcbiAgaHlkcmF0ZTogaHlkcmF0ZVN1c3BlbnNlLFxuICBub3JtYWxpemU6IG5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW5cbn07XG5jb25zdCBTdXNwZW5zZSA9IFN1c3BlbnNlSW1wbCA7XG5mdW5jdGlvbiB0cmlnZ2VyRXZlbnQodm5vZGUsIG5hbWUpIHtcbiAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzW25hbWVdO1xuICBpZiAoaXNGdW5jdGlvbihldmVudExpc3RlbmVyKSkge1xuICAgIGV2ZW50TGlzdGVuZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gIGNvbnN0IHtcbiAgICBwOiBwYXRjaCxcbiAgICBvOiB7IGNyZWF0ZUVsZW1lbnQgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGNvbnN0IGhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KFxuICAgIHZub2RlLFxuICAgIHBhcmVudFN1c3BlbnNlLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBjb250YWluZXIsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIGFuY2hvcixcbiAgICBuYW1lc3BhY2UsXG4gICAgc2xvdFNjb3BlSWRzLFxuICAgIG9wdGltaXplZCxcbiAgICByZW5kZXJlckludGVybmFsc1xuICApO1xuICBwYXRjaChcbiAgICBudWxsLFxuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQsXG4gICAgaGlkZGVuQ29udGFpbmVyLFxuICAgIG51bGwsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIHN1c3BlbnNlLFxuICAgIG5hbWVzcGFjZSxcbiAgICBzbG90U2NvcGVJZHNcbiAgKTtcbiAgaWYgKHN1c3BlbnNlLmRlcHMgPiAwKSB7XG4gICAgdHJpZ2dlckV2ZW50KHZub2RlLCBcIm9uUGVuZGluZ1wiKTtcbiAgICB0cmlnZ2VyRXZlbnQodm5vZGUsIFwib25GYWxsYmFja1wiKTtcbiAgICBwYXRjaChcbiAgICAgIG51bGwsXG4gICAgICB2bm9kZS5zc0ZhbGxiYWNrLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgYW5jaG9yLFxuICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgbnVsbCxcbiAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBzbG90U2NvcGVJZHNcbiAgICApO1xuICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgdm5vZGUuc3NGYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgc3VzcGVuc2UucmVzb2x2ZShmYWxzZSwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBuYW1lc3BhY2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IHA6IHBhdGNoLCB1bTogdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSkge1xuICBjb25zdCBzdXNwZW5zZSA9IG4yLnN1c3BlbnNlID0gbjEuc3VzcGVuc2U7XG4gIHN1c3BlbnNlLnZub2RlID0gbjI7XG4gIG4yLmVsID0gbjEuZWw7XG4gIGNvbnN0IG5ld0JyYW5jaCA9IG4yLnNzQ29udGVudDtcbiAgY29uc3QgbmV3RmFsbGJhY2sgPSBuMi5zc0ZhbGxiYWNrO1xuICBjb25zdCB7IGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgaXNJbkZhbGxiYWNrLCBpc0h5ZHJhdGluZyB9ID0gc3VzcGVuc2U7XG4gIGlmIChwZW5kaW5nQnJhbmNoKSB7XG4gICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcbiAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKHBlbmRpbmdCcmFuY2gsIG5ld0JyYW5jaCkpIHtcbiAgICAgIHBhdGNoKFxuICAgICAgICBwZW5kaW5nQnJhbmNoLFxuICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIGlmIChpc0luRmFsbGJhY2spIHtcbiAgICAgICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgICAgIHBhdGNoKFxuICAgICAgICAgICAgYWN0aXZlQnJhbmNoLFxuICAgICAgICAgICAgbmV3RmFsbGJhY2ssXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBhbmNob3IsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuc2UucGVuZGluZ0lkID0gc3VzcGVuc2VJZCsrO1xuICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IHBlbmRpbmdCcmFuY2g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bm1vdW50KHBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UpO1xuICAgICAgfVxuICAgICAgc3VzcGVuc2UuZGVwcyA9IDA7XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzLmxlbmd0aCA9IDA7XG4gICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgaWYgKGlzSW5GYWxsYmFjaykge1xuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG5ld0JyYW5jaCxcbiAgICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRjaChcbiAgICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICAgIG5ld0ZhbGxiYWNrLFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUoYWN0aXZlQnJhbmNoLCBuZXdCcmFuY2gpKSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgICBuZXdCcmFuY2gsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICAgIHNsb3RTY29wZUlkcyxcbiAgICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICAgKTtcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGNoKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKGFjdGl2ZUJyYW5jaCwgbmV3QnJhbmNoKSkge1xuICAgICAgcGF0Y2goXG4gICAgICAgIGFjdGl2ZUJyYW5jaCxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBzbG90U2NvcGVJZHMsXG4gICAgICAgIG9wdGltaXplZFxuICAgICAgKTtcbiAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3QnJhbmNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlckV2ZW50KG4yLCBcIm9uUGVuZGluZ1wiKTtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XG4gICAgICBpZiAobmV3QnJhbmNoLnNoYXBlRmxhZyAmIDUxMikge1xuICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgPSBuZXdCcmFuY2guY29tcG9uZW50LnN1c3BlbnNlSWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgPSBzdXNwZW5zZUlkKys7XG4gICAgICB9XG4gICAgICBwYXRjaChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbmV3QnJhbmNoLFxuICAgICAgICBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICBvcHRpbWl6ZWRcbiAgICAgICk7XG4gICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgdGltZW91dCwgcGVuZGluZ0lkIH0gPSBzdXNwZW5zZTtcbiAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0lkID09PSBwZW5kaW5nSWQpIHtcbiAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudFN1c3BlbnNlLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaGlkZGVuQ29udGFpbmVyLCBhbmNob3IsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBpc0h5ZHJhdGluZyA9IGZhbHNlKSB7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRydWUgJiYgIWhhc1dhcm5lZCkge1xuICAgIGhhc1dhcm5lZCA9IHRydWU7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyBcImluZm9cIiA6IFwibG9nXCJdKFxuICAgICAgYDxTdXNwZW5zZT4gaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgYW5kIGl0cyBBUEkgd2lsbCBsaWtlbHkgY2hhbmdlLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwOiBwYXRjaCxcbiAgICBtOiBtb3ZlLFxuICAgIHVtOiB1bm1vdW50LFxuICAgIG46IG5leHQsXG4gICAgbzogeyBwYXJlbnROb2RlLCByZW1vdmUgfVxuICB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gIGxldCBwYXJlbnRTdXNwZW5zZUlkO1xuICBjb25zdCBpc1N1c3BlbnNpYmxlID0gaXNWTm9kZVN1c3BlbnNpYmxlKHZub2RlKTtcbiAgaWYgKGlzU3VzcGVuc2libGUpIHtcbiAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgcGFyZW50U3VzcGVuc2VJZCA9IHBhcmVudFN1c3BlbnNlLnBlbmRpbmdJZDtcbiAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMrKztcbiAgICB9XG4gIH1cbiAgY29uc3QgdGltZW91dCA9IHZub2RlLnByb3BzID8gdG9OdW1iZXIodm5vZGUucHJvcHMudGltZW91dCkgOiB2b2lkIDA7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgYXNzZXJ0TnVtYmVyKHRpbWVvdXQsIGBTdXNwZW5zZSB0aW1lb3V0YCk7XG4gIH1cbiAgY29uc3QgaW5pdGlhbEFuY2hvciA9IGFuY2hvcjtcbiAgY29uc3Qgc3VzcGVuc2UgPSB7XG4gICAgdm5vZGUsXG4gICAgcGFyZW50OiBwYXJlbnRTdXNwZW5zZSxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgbmFtZXNwYWNlLFxuICAgIGNvbnRhaW5lcixcbiAgICBoaWRkZW5Db250YWluZXIsXG4gICAgZGVwczogMCxcbiAgICBwZW5kaW5nSWQ6IHN1c3BlbnNlSWQrKyxcbiAgICB0aW1lb3V0OiB0eXBlb2YgdGltZW91dCA9PT0gXCJudW1iZXJcIiA/IHRpbWVvdXQgOiAtMSxcbiAgICBhY3RpdmVCcmFuY2g6IG51bGwsXG4gICAgcGVuZGluZ0JyYW5jaDogbnVsbCxcbiAgICBpc0luRmFsbGJhY2s6ICFpc0h5ZHJhdGluZyxcbiAgICBpc0h5ZHJhdGluZyxcbiAgICBpc1VubW91bnRlZDogZmFsc2UsXG4gICAgZWZmZWN0czogW10sXG4gICAgcmVzb2x2ZShyZXN1bWUgPSBmYWxzZSwgc3luYyA9IGZhbHNlKSB7XG4gICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICBpZiAoIXJlc3VtZSAmJiAhc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIHdpdGhvdXQgYSBwZW5kaW5nIGJyYW5jaC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VzcGVuc2UuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHVubW91bnRlZCBzdXNwZW5zZSBib3VuZGFyeS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICB2bm9kZTogdm5vZGUyLFxuICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgIHBlbmRpbmdCcmFuY2gsXG4gICAgICAgIHBlbmRpbmdJZCxcbiAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgcGFyZW50Q29tcG9uZW50OiBwYXJlbnRDb21wb25lbnQyLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcjIsXG4gICAgICAgIGlzSW5GYWxsYmFja1xuICAgICAgfSA9IHN1c3BlbnNlO1xuICAgICAgbGV0IGRlbGF5RW50ZXIgPSBmYWxzZTtcbiAgICAgIGlmIChzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xuICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghcmVzdW1lKSB7XG4gICAgICAgIGRlbGF5RW50ZXIgPSBhY3RpdmVCcmFuY2ggJiYgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uICYmIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbi5tb2RlID09PSBcIm91dC1pblwiO1xuICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xuICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVuZGluZ0lkID09PSBzdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgICAgICAgICAgbW92ZShcbiAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjIsXG4gICAgICAgICAgICAgICAgYW5jaG9yID09PSBpbml0aWFsQW5jaG9yID8gbmV4dChhY3RpdmVCcmFuY2gpIDogYW5jaG9yLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcbiAgICAgICAgICAgICAgaWYgKGlzSW5GYWxsYmFjayAmJiB2bm9kZTIuc3NGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZub2RlMi5zc0ZhbGxiYWNrLmVsID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2ZUJyYW5jaCkge1xuICAgICAgICAgIGlmIChwYXJlbnROb2RlKGFjdGl2ZUJyYW5jaC5lbCkgPT09IGNvbnRhaW5lcjIpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudDIsIHN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgICBpZiAoIWRlbGF5RW50ZXIgJiYgaXNJbkZhbGxiYWNrICYmIHZub2RlMi5zc0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gdm5vZGUyLnNzRmFsbGJhY2suZWwgPSBudWxsLCBzdXNwZW5zZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZGVsYXlFbnRlcikge1xuICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyMiwgYW5jaG9yLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBwZW5kaW5nQnJhbmNoKTtcbiAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBudWxsO1xuICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gZmFsc2U7XG4gICAgICBsZXQgcGFyZW50ID0gc3VzcGVuc2UucGFyZW50O1xuICAgICAgbGV0IGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IGZhbHNlO1xuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICBwYXJlbnQuZWZmZWN0cy5wdXNoKC4uLmVmZmVjdHMpO1xuICAgICAgICAgIGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzVW5yZXNvbHZlZEFuY2VzdG9yICYmICFkZWxheUVudGVyKSB7XG4gICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZWZmZWN0cyk7XG4gICAgICB9XG4gICAgICBzdXNwZW5zZS5lZmZlY3RzID0gW107XG4gICAgICBpZiAoaXNTdXNwZW5zaWJsZSkge1xuICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UgJiYgcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiBwYXJlbnRTdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzLS07XG4gICAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlLmRlcHMgPT09IDAgJiYgIXN5bmMpIHtcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyaWdnZXJFdmVudCh2bm9kZTIsIFwib25SZXNvbHZlXCIpO1xuICAgIH0sXG4gICAgZmFsbGJhY2soZmFsbGJhY2tWTm9kZSkge1xuICAgICAgaWYgKCFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdm5vZGU6IHZub2RlMiwgYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQ6IHBhcmVudENvbXBvbmVudDIsIGNvbnRhaW5lcjogY29udGFpbmVyMiwgbmFtZXNwYWNlOiBuYW1lc3BhY2UyIH0gPSBzdXNwZW5zZTtcbiAgICAgIHRyaWdnZXJFdmVudCh2bm9kZTIsIFwib25GYWxsYmFja1wiKTtcbiAgICAgIGNvbnN0IGFuY2hvcjIgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XG4gICAgICBjb25zdCBtb3VudEZhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXN1c3BlbnNlLmlzSW5GYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYXRjaChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIGZhbGxiYWNrVk5vZGUsXG4gICAgICAgICAgY29udGFpbmVyMixcbiAgICAgICAgICBhbmNob3IyLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudDIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgIG5hbWVzcGFjZTIsXG4gICAgICAgICAgc2xvdFNjb3BlSWRzLFxuICAgICAgICAgIG9wdGltaXplZFxuICAgICAgICApO1xuICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGZhbGxiYWNrVk5vZGUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24gJiYgZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uLm1vZGUgPT09IFwib3V0LWluXCI7XG4gICAgICBpZiAoZGVsYXlFbnRlcikge1xuICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gbW91bnRGYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IHRydWU7XG4gICAgICB1bm1vdW50KFxuICAgICAgICBhY3RpdmVCcmFuY2gsXG4gICAgICAgIHBhcmVudENvbXBvbmVudDIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIG5vIHN1c3BlbnNlIHNvIHVubW91bnQgaG9va3MgZmlyZSBub3dcbiAgICAgICAgdHJ1ZVxuICAgICAgICAvLyBzaG91bGRSZW1vdmVcbiAgICAgICk7XG4gICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgbW91bnRGYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbW92ZShjb250YWluZXIyLCBhbmNob3IyLCB0eXBlKSB7XG4gICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiYgbW92ZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIGNvbnRhaW5lcjIsIGFuY2hvcjIsIHR5cGUpO1xuICAgICAgc3VzcGVuc2UuY29udGFpbmVyID0gY29udGFpbmVyMjtcbiAgICB9LFxuICAgIG5leHQoKSB7XG4gICAgICByZXR1cm4gc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG5leHQoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCwgb3B0aW1pemVkMikge1xuICAgICAgY29uc3QgaXNJblBlbmRpbmdTdXNwZW5zZSA9ICEhc3VzcGVuc2UucGVuZGluZ0JyYW5jaDtcbiAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlKSB7XG4gICAgICAgIHN1c3BlbnNlLmRlcHMrKztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGh5ZHJhdGVkRWwgPSBpbnN0YW5jZS52bm9kZS5lbDtcbiAgICAgIGluc3RhbmNlLmFzeW5jRGVwLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMCk7XG4gICAgICB9KS50aGVuKChhc3luY1NldHVwUmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZCB8fCBzdXNwZW5zZS5pc1VubW91bnRlZCB8fCBzdXNwZW5zZS5wZW5kaW5nSWQgIT09IGluc3RhbmNlLnN1c3BlbnNlSWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgdm5vZGU6IHZub2RlMiB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlMik7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIGFzeW5jU2V0dXBSZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgaWYgKGh5ZHJhdGVkRWwpIHtcbiAgICAgICAgICB2bm9kZTIuZWwgPSBoeWRyYXRlZEVsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gIWh5ZHJhdGVkRWwgJiYgaW5zdGFuY2Uuc3ViVHJlZS5lbDtcbiAgICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgdm5vZGUyLFxuICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgaGF2ZSBiZWVuIG1vdmVkIGJlZm9yZSByZXNvbHZlLlxuICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgaHlkcmF0aW9uLCBpbnN0YW5jZS5zdWJUcmVlIHdpbGwgYmUgdGhlIGNvbW1lbnRcbiAgICAgICAgICAvLyBwbGFjZWhvbGRlci5cbiAgICAgICAgICBwYXJlbnROb2RlKGh5ZHJhdGVkRWwgfHwgaW5zdGFuY2Uuc3ViVHJlZS5lbCksXG4gICAgICAgICAgLy8gYW5jaG9yIHdpbGwgbm90IGJlIHVzZWQgaWYgdGhpcyBpcyBoeWRyYXRpb24sIHNvIG9ubHkgbmVlZCB0b1xuICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBjb21tZW50IHBsYWNlaG9sZGVyIGNhc2UuXG4gICAgICAgICAgaHlkcmF0ZWRFbCA/IG51bGwgOiBuZXh0KGluc3RhbmNlLnN1YlRyZWUpLFxuICAgICAgICAgIHN1c3BlbnNlLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBvcHRpbWl6ZWQyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChwbGFjZWhvbGRlcikge1xuICAgICAgICAgIHZub2RlMi5wbGFjZWhvbGRlciA9IG51bGw7XG4gICAgICAgICAgcmVtb3ZlKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIHZub2RlMi5lbCk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSAmJiAtLXN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZTIsIGRvUmVtb3ZlKSB7XG4gICAgICBzdXNwZW5zZS5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgICBpZiAoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKSB7XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoLFxuICAgICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgICBwYXJlbnRTdXNwZW5zZTIsXG4gICAgICAgICAgZG9SZW1vdmVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgIHVubW91bnQoXG4gICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCxcbiAgICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgcGFyZW50U3VzcGVuc2UyLFxuICAgICAgICAgIGRvUmVtb3ZlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gc3VzcGVuc2U7XG59XG5mdW5jdGlvbiBoeWRyYXRlU3VzcGVuc2Uobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG5hbWVzcGFjZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSkge1xuICBjb25zdCBzdXNwZW5zZSA9IHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShcbiAgICB2bm9kZSxcbiAgICBwYXJlbnRTdXNwZW5zZSxcbiAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgbm9kZS5wYXJlbnROb2RlLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgIG51bGwsXG4gICAgbmFtZXNwYWNlLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWQsXG4gICAgcmVuZGVyZXJJbnRlcm5hbHMsXG4gICAgdHJ1ZVxuICApO1xuICBjb25zdCByZXN1bHQgPSBoeWRyYXRlTm9kZShcbiAgICBub2RlLFxuICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQsXG4gICAgcGFyZW50Q29tcG9uZW50LFxuICAgIHN1c3BlbnNlLFxuICAgIHNsb3RTY29wZUlkcyxcbiAgICBvcHRpbWl6ZWRcbiAgKTtcbiAgaWYgKHN1c3BlbnNlLmRlcHMgPT09IDApIHtcbiAgICBzdXNwZW5zZS5yZXNvbHZlKGZhbHNlLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbih2bm9kZSkge1xuICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xuICBjb25zdCBpc1Nsb3RDaGlsZHJlbiA9IHNoYXBlRmxhZyAmIDMyO1xuICB2bm9kZS5zc0NvbnRlbnQgPSBub3JtYWxpemVTdXNwZW5zZVNsb3QoXG4gICAgaXNTbG90Q2hpbGRyZW4gPyBjaGlsZHJlbi5kZWZhdWx0IDogY2hpbGRyZW5cbiAgKTtcbiAgdm5vZGUuc3NGYWxsYmFjayA9IGlzU2xvdENoaWxkcmVuID8gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmZhbGxiYWNrKSA6IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VTbG90KHMpIHtcbiAgbGV0IGJsb2NrO1xuICBpZiAoaXNGdW5jdGlvbihzKSkge1xuICAgIGNvbnN0IHRyYWNrQmxvY2sgPSBpc0Jsb2NrVHJlZUVuYWJsZWQgJiYgcy5fYztcbiAgICBpZiAodHJhY2tCbG9jaykge1xuICAgICAgcy5fZCA9IGZhbHNlO1xuICAgICAgb3BlbkJsb2NrKCk7XG4gICAgfVxuICAgIHMgPSBzKCk7XG4gICAgaWYgKHRyYWNrQmxvY2spIHtcbiAgICAgIHMuX2QgPSB0cnVlO1xuICAgICAgYmxvY2sgPSBjdXJyZW50QmxvY2s7XG4gICAgICBjbG9zZUJsb2NrKCk7XG4gICAgfVxuICB9XG4gIGlmIChpc0FycmF5KHMpKSB7XG4gICAgY29uc3Qgc2luZ2xlQ2hpbGQgPSBmaWx0ZXJTaW5nbGVSb290KHMpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFzaW5nbGVDaGlsZCAmJiBzLmZpbHRlcigoY2hpbGQpID0+IGNoaWxkICE9PSBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKS5sZW5ndGggPiAwKSB7XG4gICAgICB3YXJuJDEoYDxTdXNwZW5zZT4gc2xvdHMgZXhwZWN0IGEgc2luZ2xlIHJvb3Qgbm9kZS5gKTtcbiAgICB9XG4gICAgcyA9IHNpbmdsZUNoaWxkO1xuICB9XG4gIHMgPSBub3JtYWxpemVWTm9kZShzKTtcbiAgaWYgKGJsb2NrICYmICFzLmR5bmFtaWNDaGlsZHJlbikge1xuICAgIHMuZHluYW1pY0NoaWxkcmVuID0gYmxvY2suZmlsdGVyKChjKSA9PiBjICE9PSBzKTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKGZuLCBzdXNwZW5zZSkge1xuICBpZiAoc3VzcGVuc2UgJiYgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgIGlmIChpc0FycmF5KGZuKSkge1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKC4uLmZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKGZuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcXVldWVQb3N0Rmx1c2hDYihmbik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgYnJhbmNoKSB7XG4gIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IGJyYW5jaDtcbiAgY29uc3QgeyB2bm9kZSwgcGFyZW50Q29tcG9uZW50IH0gPSBzdXNwZW5zZTtcbiAgbGV0IGVsID0gYnJhbmNoLmVsO1xuICB3aGlsZSAoIWVsICYmIGJyYW5jaC5jb21wb25lbnQpIHtcbiAgICBicmFuY2ggPSBicmFuY2guY29tcG9uZW50LnN1YlRyZWU7XG4gICAgZWwgPSBicmFuY2guZWw7XG4gIH1cbiAgdm5vZGUuZWwgPSBlbDtcbiAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcbiAgICBwYXJlbnRDb21wb25lbnQudm5vZGUuZWwgPSBlbDtcbiAgICB1cGRhdGVIT0NIb3N0RWwocGFyZW50Q29tcG9uZW50LCBlbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVk5vZGVTdXNwZW5zaWJsZSh2bm9kZSkge1xuICBjb25zdCBzdXNwZW5zaWJsZSA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnN1c3BlbnNpYmxlO1xuICByZXR1cm4gc3VzcGVuc2libGUgIT0gbnVsbCAmJiBzdXNwZW5zaWJsZSAhPT0gZmFsc2U7XG59XG5cbmNvbnN0IEZyYWdtZW50ID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJ2LWZndFwiKTtcbmNvbnN0IFRleHQgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInYtdHh0XCIpO1xuY29uc3QgQ29tbWVudCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwidi1jbXRcIik7XG5jb25zdCBTdGF0aWMgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInYtc3RjXCIpO1xuY29uc3QgYmxvY2tTdGFjayA9IFtdO1xubGV0IGN1cnJlbnRCbG9jayA9IG51bGw7XG5mdW5jdGlvbiBvcGVuQmxvY2soZGlzYWJsZVRyYWNraW5nID0gZmFsc2UpIHtcbiAgYmxvY2tTdGFjay5wdXNoKGN1cnJlbnRCbG9jayA9IGRpc2FibGVUcmFja2luZyA/IG51bGwgOiBbXSk7XG59XG5mdW5jdGlvbiBjbG9zZUJsb2NrKCkge1xuICBibG9ja1N0YWNrLnBvcCgpO1xuICBjdXJyZW50QmxvY2sgPSBibG9ja1N0YWNrW2Jsb2NrU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbDtcbn1cbmxldCBpc0Jsb2NrVHJlZUVuYWJsZWQgPSAxO1xuZnVuY3Rpb24gc2V0QmxvY2tUcmFja2luZyh2YWx1ZSwgaW5WT25jZSA9IGZhbHNlKSB7XG4gIGlzQmxvY2tUcmVlRW5hYmxlZCArPSB2YWx1ZTtcbiAgaWYgKHZhbHVlIDwgMCAmJiBjdXJyZW50QmxvY2sgJiYgaW5WT25jZSkge1xuICAgIGN1cnJlbnRCbG9jay5oYXNPbmNlID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0dXBCbG9jayh2bm9kZSkge1xuICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwID8gY3VycmVudEJsb2NrIHx8IEVNUFRZX0FSUiA6IG51bGw7XG4gIGNsb3NlQmxvY2soKTtcbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xuICB9XG4gIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBzaGFwZUZsYWcpIHtcbiAgcmV0dXJuIHNldHVwQmxvY2soXG4gICAgY3JlYXRlQmFzZVZOb2RlKFxuICAgICAgdHlwZSxcbiAgICAgIHByb3BzLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBwYXRjaEZsYWcsXG4gICAgICBkeW5hbWljUHJvcHMsXG4gICAgICBzaGFwZUZsYWcsXG4gICAgICB0cnVlXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlQmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcykge1xuICByZXR1cm4gc2V0dXBCbG9jayhcbiAgICBjcmVhdGVWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgcGF0Y2hGbGFnLFxuICAgICAgZHluYW1pY1Byb3BzLFxuICAgICAgdHJ1ZVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzVk5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID8gdmFsdWUuX192X2lzVk5vZGUgPT09IHRydWUgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpIHtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgbjIuc2hhcGVGbGFnICYgNiAmJiBuMS5jb21wb25lbnQpIHtcbiAgICBjb25zdCBkaXJ0eUluc3RhbmNlcyA9IGhtckRpcnR5Q29tcG9uZW50cy5nZXQobjIudHlwZSk7XG4gICAgaWYgKGRpcnR5SW5zdGFuY2VzICYmIGRpcnR5SW5zdGFuY2VzLmhhcyhuMS5jb21wb25lbnQpKSB7XG4gICAgICBuMS5zaGFwZUZsYWcgJj0gLTI1NztcbiAgICAgIG4yLnNoYXBlRmxhZyAmPSAtNTEzO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbjEudHlwZSA9PT0gbjIudHlwZSAmJiBuMS5rZXkgPT09IG4yLmtleTtcbn1cbmxldCB2bm9kZUFyZ3NUcmFuc2Zvcm1lcjtcbmZ1bmN0aW9uIHRyYW5zZm9ybVZOb2RlQXJncyh0cmFuc2Zvcm1lcikge1xuICB2bm9kZUFyZ3NUcmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyO1xufVxuY29uc3QgY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA9ICguLi5hcmdzKSA9PiB7XG4gIHJldHVybiBfY3JlYXRlVk5vZGUoXG4gICAgLi4udm5vZGVBcmdzVHJhbnNmb3JtZXIgPyB2bm9kZUFyZ3NUcmFuc2Zvcm1lcihhcmdzLCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIDogYXJnc1xuICApO1xufTtcbmNvbnN0IG5vcm1hbGl6ZUtleSA9ICh7IGtleSB9KSA9PiBrZXkgIT0gbnVsbCA/IGtleSA6IG51bGw7XG5jb25zdCBub3JtYWxpemVSZWYgPSAoe1xuICByZWYsXG4gIHJlZl9rZXksXG4gIHJlZl9mb3Jcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiByZWYgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZWYgPSBcIlwiICsgcmVmO1xuICB9XG4gIHJldHVybiByZWYgIT0gbnVsbCA/IGlzU3RyaW5nKHJlZikgfHwgaXNSZWYocmVmKSB8fCBpc0Z1bmN0aW9uKHJlZikgPyB7IGk6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgcjogcmVmLCBrOiByZWZfa2V5LCBmOiAhIXJlZl9mb3IgfSA6IHJlZiA6IG51bGw7XG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBzaGFwZUZsYWcgPSB0eXBlID09PSBGcmFnbWVudCA/IDAgOiAxLCBpc0Jsb2NrTm9kZSA9IGZhbHNlLCBuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHZub2RlID0ge1xuICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxuICAgIF9fdl9za2lwOiB0cnVlLFxuICAgIHR5cGUsXG4gICAgcHJvcHMsXG4gICAga2V5OiBwcm9wcyAmJiBub3JtYWxpemVLZXkocHJvcHMpLFxuICAgIHJlZjogcHJvcHMgJiYgbm9ybWFsaXplUmVmKHByb3BzKSxcbiAgICBzY29wZUlkOiBjdXJyZW50U2NvcGVJZCxcbiAgICBzbG90U2NvcGVJZHM6IG51bGwsXG4gICAgY2hpbGRyZW4sXG4gICAgY29tcG9uZW50OiBudWxsLFxuICAgIHN1c3BlbnNlOiBudWxsLFxuICAgIHNzQ29udGVudDogbnVsbCxcbiAgICBzc0ZhbGxiYWNrOiBudWxsLFxuICAgIGRpcnM6IG51bGwsXG4gICAgdHJhbnNpdGlvbjogbnVsbCxcbiAgICBlbDogbnVsbCxcbiAgICBhbmNob3I6IG51bGwsXG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIHRhcmdldFN0YXJ0OiBudWxsLFxuICAgIHRhcmdldEFuY2hvcjogbnVsbCxcbiAgICBzdGF0aWNDb3VudDogMCxcbiAgICBzaGFwZUZsYWcsXG4gICAgcGF0Y2hGbGFnLFxuICAgIGR5bmFtaWNQcm9wcyxcbiAgICBkeW5hbWljQ2hpbGRyZW46IG51bGwsXG4gICAgYXBwQ29udGV4dDogbnVsbCxcbiAgICBjdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZVxuICB9O1xuICBpZiAobmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24pIHtcbiAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pO1xuICAgIGlmIChzaGFwZUZsYWcgJiAxMjgpIHtcbiAgICAgIHR5cGUubm9ybWFsaXplKHZub2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICB2bm9kZS5zaGFwZUZsYWcgfD0gaXNTdHJpbmcoY2hpbGRyZW4pID8gOCA6IDE2O1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHZub2RlLmtleSAhPT0gdm5vZGUua2V5KSB7XG4gICAgd2FybiQxKGBWTm9kZSBjcmVhdGVkIHdpdGggaW52YWxpZCBrZXkgKE5hTikuIFZOb2RlIHR5cGU6YCwgdm5vZGUudHlwZSk7XG4gIH1cbiAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgLy8gYXZvaWQgYSBibG9jayBub2RlIGZyb20gdHJhY2tpbmcgaXRzZWxmXG4gICFpc0Jsb2NrTm9kZSAmJiAvLyBoYXMgY3VycmVudCBwYXJlbnQgYmxvY2tcbiAgY3VycmVudEJsb2NrICYmIC8vIHByZXNlbmNlIG9mIGEgcGF0Y2ggZmxhZyBpbmRpY2F0ZXMgdGhpcyBub2RlIG5lZWRzIHBhdGNoaW5nIG9uIHVwZGF0ZXMuXG4gIC8vIGNvbXBvbmVudCBub2RlcyBhbHNvIHNob3VsZCBhbHdheXMgYmUgcGF0Y2hlZCwgYmVjYXVzZSBldmVuIGlmIHRoZVxuICAvLyBjb21wb25lbnQgZG9lc24ndCBuZWVkIHRvIHVwZGF0ZSwgaXQgbmVlZHMgdG8gcGVyc2lzdCB0aGUgaW5zdGFuY2Ugb24gdG9cbiAgLy8gdGhlIG5leHQgdm5vZGUgc28gdGhhdCBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkIGxhdGVyLlxuICAodm5vZGUucGF0Y2hGbGFnID4gMCB8fCBzaGFwZUZsYWcgJiA2KSAmJiAvLyB0aGUgRVZFTlRTIGZsYWcgaXMgb25seSBmb3IgaHlkcmF0aW9uIGFuZCBpZiBpdCBpcyB0aGUgb25seSBmbGFnLCB0aGVcbiAgLy8gdm5vZGUgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGR5bmFtaWMgZHVlIHRvIGhhbmRsZXIgY2FjaGluZy5cbiAgdm5vZGUucGF0Y2hGbGFnICE9PSAzMikge1xuICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5jb25zdCBjcmVhdGVWTm9kZSA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtIDogX2NyZWF0ZVZOb2RlO1xuZnVuY3Rpb24gX2NyZWF0ZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBpc0Jsb2NrTm9kZSA9IGZhbHNlKSB7XG4gIGlmICghdHlwZSB8fCB0eXBlID09PSBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIXR5cGUpIHtcbiAgICAgIHdhcm4kMShgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XG4gICAgfVxuICAgIHR5cGUgPSBDb21tZW50O1xuICB9XG4gIGlmIChpc1ZOb2RlKHR5cGUpKSB7XG4gICAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZShcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIHRydWVcbiAgICAgIC8qIG1lcmdlUmVmOiB0cnVlICovXG4gICAgKTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKGNsb25lZCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiAhaXNCbG9ja05vZGUgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgICBpZiAoY2xvbmVkLnNoYXBlRmxhZyAmIDYpIHtcbiAgICAgICAgY3VycmVudEJsb2NrW2N1cnJlbnRCbG9jay5pbmRleE9mKHR5cGUpXSA9IGNsb25lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKGNsb25lZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsb25lZC5wYXRjaEZsYWcgPSAtMjtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGlmIChpc0NsYXNzQ29tcG9uZW50KHR5cGUpKSB7XG4gICAgdHlwZSA9IHR5cGUuX192Y2NPcHRzO1xuICB9XG4gIGlmIChwcm9wcykge1xuICAgIHByb3BzID0gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKTtcbiAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChzdHlsZSkpIHtcbiAgICAgIGlmIChpc1Byb3h5KHN0eWxlKSAmJiAhaXNBcnJheShzdHlsZSkpIHtcbiAgICAgICAgc3R5bGUgPSBleHRlbmQoe30sIHN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICAgIH1cbiAgfVxuICBjb25zdCBzaGFwZUZsYWcgPSBpc1N0cmluZyh0eXBlKSA/IDEgOiBpc1N1c3BlbnNlKHR5cGUpID8gMTI4IDogaXNUZWxlcG9ydCh0eXBlKSA/IDY0IDogaXNPYmplY3QodHlwZSkgPyA0IDogaXNGdW5jdGlvbih0eXBlKSA/IDIgOiAwO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzaGFwZUZsYWcgJiA0ICYmIGlzUHJveHkodHlwZSkpIHtcbiAgICB0eXBlID0gdG9SYXcodHlwZSk7XG4gICAgd2FybiQxKFxuICAgICAgYFZ1ZSByZWNlaXZlZCBhIENvbXBvbmVudCB0aGF0IHdhcyBtYWRlIGEgcmVhY3RpdmUgb2JqZWN0LiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHBlcmZvcm1hbmNlIG92ZXJoZWFkIGFuZCBzaG91bGQgYmUgYXZvaWRlZCBieSBtYXJraW5nIHRoZSBjb21wb25lbnQgd2l0aCBcXGBtYXJrUmF3XFxgIG9yIHVzaW5nIFxcYHNoYWxsb3dSZWZcXGAgaW5zdGVhZCBvZiBcXGByZWZcXGAuYCxcbiAgICAgIGBcbkNvbXBvbmVudCB0aGF0IHdhcyBtYWRlIHJlYWN0aXZlOiBgLFxuICAgICAgdHlwZVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJhc2VWTm9kZShcbiAgICB0eXBlLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHMsXG4gICAgc2hhcGVGbGFnLFxuICAgIGlzQmxvY2tOb2RlLFxuICAgIHRydWVcbiAgKTtcbn1cbmZ1bmN0aW9uIGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcykge1xuICBpZiAoIXByb3BzKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGlzUHJveHkocHJvcHMpIHx8IGlzSW50ZXJuYWxPYmplY3QocHJvcHMpID8gZXh0ZW5kKHt9LCBwcm9wcykgOiBwcm9wcztcbn1cbmZ1bmN0aW9uIGNsb25lVk5vZGUodm5vZGUsIGV4dHJhUHJvcHMsIG1lcmdlUmVmID0gZmFsc2UsIGNsb25lVHJhbnNpdGlvbiA9IGZhbHNlKSB7XG4gIGNvbnN0IHsgcHJvcHMsIHJlZiwgcGF0Y2hGbGFnLCBjaGlsZHJlbiwgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XG4gIGNvbnN0IG1lcmdlZFByb3BzID0gZXh0cmFQcm9wcyA/IG1lcmdlUHJvcHMocHJvcHMgfHwge30sIGV4dHJhUHJvcHMpIDogcHJvcHM7XG4gIGNvbnN0IGNsb25lZCA9IHtcbiAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICBfX3Zfc2tpcDogdHJ1ZSxcbiAgICB0eXBlOiB2bm9kZS50eXBlLFxuICAgIHByb3BzOiBtZXJnZWRQcm9wcyxcbiAgICBrZXk6IG1lcmdlZFByb3BzICYmIG5vcm1hbGl6ZUtleShtZXJnZWRQcm9wcyksXG4gICAgcmVmOiBleHRyYVByb3BzICYmIGV4dHJhUHJvcHMucmVmID8gKFxuICAgICAgLy8gIzIwNzggaW4gdGhlIGNhc2Ugb2YgPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiIHJlZj1cImV4dHJhXCIvPlxuICAgICAgLy8gaWYgdGhlIHZub2RlIGl0c2VsZiBhbHJlYWR5IGhhcyBhIHJlZiwgY2xvbmVWTm9kZSB3aWxsIG5lZWQgdG8gbWVyZ2VcbiAgICAgIC8vIHRoZSByZWZzIHNvIHRoZSBzaW5nbGUgdm5vZGUgY2FuIGJlIHNldCBvbiBtdWx0aXBsZSByZWZzXG4gICAgICBtZXJnZVJlZiAmJiByZWYgPyBpc0FycmF5KHJlZikgPyByZWYuY29uY2F0KG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKSkgOiBbcmVmLCBub3JtYWxpemVSZWYoZXh0cmFQcm9wcyldIDogbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXG4gICAgKSA6IHJlZixcbiAgICBzY29wZUlkOiB2bm9kZS5zY29wZUlkLFxuICAgIHNsb3RTY29wZUlkczogdm5vZGUuc2xvdFNjb3BlSWRzLFxuICAgIGNoaWxkcmVuOiAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHBhdGNoRmxhZyA9PT0gLTEgJiYgaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpIDogY2hpbGRyZW4sXG4gICAgdGFyZ2V0OiB2bm9kZS50YXJnZXQsXG4gICAgdGFyZ2V0U3RhcnQ6IHZub2RlLnRhcmdldFN0YXJ0LFxuICAgIHRhcmdldEFuY2hvcjogdm5vZGUudGFyZ2V0QW5jaG9yLFxuICAgIHN0YXRpY0NvdW50OiB2bm9kZS5zdGF0aWNDb3VudCxcbiAgICBzaGFwZUZsYWc6IHZub2RlLnNoYXBlRmxhZyxcbiAgICAvLyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIHdpdGggZXh0cmEgcHJvcHMsIHdlIGNhbiBubyBsb25nZXIgYXNzdW1lIGl0c1xuICAgIC8vIGV4aXN0aW5nIHBhdGNoIGZsYWcgdG8gYmUgcmVsaWFibGUgYW5kIG5lZWQgdG8gYWRkIHRoZSBGVUxMX1BST1BTIGZsYWcuXG4gICAgLy8gbm90ZTogcHJlc2VydmUgZmxhZyBmb3IgZnJhZ21lbnRzIHNpbmNlIHRoZXkgdXNlIHRoZSBmbGFnIGZvciBjaGlsZHJlblxuICAgIC8vIGZhc3QgcGF0aHMgb25seS5cbiAgICBwYXRjaEZsYWc6IGV4dHJhUHJvcHMgJiYgdm5vZGUudHlwZSAhPT0gRnJhZ21lbnQgPyBwYXRjaEZsYWcgPT09IC0xID8gMTYgOiBwYXRjaEZsYWcgfCAxNiA6IHBhdGNoRmxhZyxcbiAgICBkeW5hbWljUHJvcHM6IHZub2RlLmR5bmFtaWNQcm9wcyxcbiAgICBkeW5hbWljQ2hpbGRyZW46IHZub2RlLmR5bmFtaWNDaGlsZHJlbixcbiAgICBhcHBDb250ZXh0OiB2bm9kZS5hcHBDb250ZXh0LFxuICAgIGRpcnM6IHZub2RlLmRpcnMsXG4gICAgdHJhbnNpdGlvbixcbiAgICAvLyBUaGVzZSBzaG91bGQgdGVjaG5pY2FsbHkgb25seSBiZSBub24tbnVsbCBvbiBtb3VudGVkIFZOb2Rlcy4gSG93ZXZlcixcbiAgICAvLyB0aGV5ICpzaG91bGQqIGJlIGNvcGllZCBmb3Iga2VwdC1hbGl2ZSB2bm9kZXMuIFNvIHdlIGp1c3QgYWx3YXlzIGNvcHlcbiAgICAvLyB0aGVtIHNpbmNlIHRoZW0gYmVpbmcgbm9uLW51bGwgZHVyaW5nIGEgbW91bnQgZG9lc24ndCBhZmZlY3QgdGhlIGxvZ2ljIGFzXG4gICAgLy8gdGhleSB3aWxsIHNpbXBseSBiZSBvdmVyd3JpdHRlbi5cbiAgICBjb21wb25lbnQ6IHZub2RlLmNvbXBvbmVudCxcbiAgICBzdXNwZW5zZTogdm5vZGUuc3VzcGVuc2UsXG4gICAgc3NDb250ZW50OiB2bm9kZS5zc0NvbnRlbnQgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0NvbnRlbnQpLFxuICAgIHNzRmFsbGJhY2s6IHZub2RlLnNzRmFsbGJhY2sgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0ZhbGxiYWNrKSxcbiAgICBwbGFjZWhvbGRlcjogdm5vZGUucGxhY2Vob2xkZXIsXG4gICAgZWw6IHZub2RlLmVsLFxuICAgIGFuY2hvcjogdm5vZGUuYW5jaG9yLFxuICAgIGN0eDogdm5vZGUuY3R4LFxuICAgIGNlOiB2bm9kZS5jZVxuICB9O1xuICBpZiAodHJhbnNpdGlvbiAmJiBjbG9uZVRyYW5zaXRpb24pIHtcbiAgICBzZXRUcmFuc2l0aW9uSG9va3MoXG4gICAgICBjbG9uZWQsXG4gICAgICB0cmFuc2l0aW9uLmNsb25lKGNsb25lZClcbiAgICApO1xuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5mdW5jdGlvbiBkZWVwQ2xvbmVWTm9kZSh2bm9kZSkge1xuICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgaWYgKGlzQXJyYXkodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgY2xvbmVkLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKTtcbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlKHRleHQgPSBcIiBcIiwgZmxhZyA9IDApIHtcbiAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIHRleHQsIGZsYWcpO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGljVk5vZGUoY29udGVudCwgbnVtYmVyT2ZOb2Rlcykge1xuICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKFN0YXRpYywgbnVsbCwgY29udGVudCk7XG4gIHZub2RlLnN0YXRpY0NvdW50ID0gbnVtYmVyT2ZOb2RlcztcbiAgcmV0dXJuIHZub2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudFZOb2RlKHRleHQgPSBcIlwiLCBhc0Jsb2NrID0gZmFsc2UpIHtcbiAgcmV0dXJuIGFzQmxvY2sgPyAob3BlbkJsb2NrKCksIGNyZWF0ZUJsb2NrKENvbW1lbnQsIG51bGwsIHRleHQpKSA6IGNyZWF0ZVZOb2RlKENvbW1lbnQsIG51bGwsIHRleHQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUoY2hpbGQpIHtcbiAgaWYgKGNoaWxkID09IG51bGwgfHwgdHlwZW9mIGNoaWxkID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShDb21tZW50KTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KGNoaWxkKSkge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShcbiAgICAgIEZyYWdtZW50LFxuICAgICAgbnVsbCxcbiAgICAgIC8vICMzNjY2LCBhdm9pZCByZWZlcmVuY2UgcG9sbHV0aW9uIHdoZW4gcmV1c2luZyB2bm9kZVxuICAgICAgY2hpbGQuc2xpY2UoKVxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNWTm9kZShjaGlsZCkpIHtcbiAgICByZXR1cm4gY2xvbmVJZk1vdW50ZWQoY2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCBTdHJpbmcoY2hpbGQpKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmVJZk1vdW50ZWQoY2hpbGQpIHtcbiAgcmV0dXJuIGNoaWxkLmVsID09PSBudWxsICYmIGNoaWxkLnBhdGNoRmxhZyAhPT0gLTEgfHwgY2hpbGQubWVtbyA/IGNoaWxkIDogY2xvbmVWTm9kZShjaGlsZCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pIHtcbiAgbGV0IHR5cGUgPSAwO1xuICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gdm5vZGU7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgdHlwZSA9IDE2O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChzaGFwZUZsYWcgJiAoMSB8IDY0KSkge1xuICAgICAgY29uc3Qgc2xvdCA9IGNoaWxkcmVuLmRlZmF1bHQ7XG4gICAgICBpZiAoc2xvdCkge1xuICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gZmFsc2UpO1xuICAgICAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgc2xvdCgpKTtcbiAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gMzI7XG4gICAgICBjb25zdCBzbG90RmxhZyA9IGNoaWxkcmVuLl87XG4gICAgICBpZiAoIXNsb3RGbGFnICYmICFpc0ludGVybmFsT2JqZWN0KGNoaWxkcmVuKSkge1xuICAgICAgICBjaGlsZHJlbi5fY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgICAgfSBlbHNlIGlmIChzbG90RmxhZyA9PT0gMyAmJiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5zbG90cy5fID09PSAxKSB7XG4gICAgICAgICAgY2hpbGRyZW4uXyA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGRyZW4uXyA9IDI7XG4gICAgICAgICAgdm5vZGUucGF0Y2hGbGFnIHw9IDEwMjQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcbiAgICBjaGlsZHJlbiA9IHsgZGVmYXVsdDogY2hpbGRyZW4sIF9jdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB9O1xuICAgIHR5cGUgPSAzMjtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZHJlbiA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgaWYgKHNoYXBlRmxhZyAmIDY0KSB7XG4gICAgICB0eXBlID0gMTY7XG4gICAgICBjaGlsZHJlbiA9IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IDg7XG4gICAgfVxuICB9XG4gIHZub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHZub2RlLnNoYXBlRmxhZyB8PSB0eXBlO1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wcyguLi5hcmdzKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b01lcmdlID0gYXJnc1tpXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0b01lcmdlKSB7XG4gICAgICBpZiAoa2V5ID09PSBcImNsYXNzXCIpIHtcbiAgICAgICAgaWYgKHJldC5jbGFzcyAhPT0gdG9NZXJnZS5jbGFzcykge1xuICAgICAgICAgIHJldC5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKFtyZXQuY2xhc3MsIHRvTWVyZ2UuY2xhc3NdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwic3R5bGVcIikge1xuICAgICAgICByZXQuc3R5bGUgPSBub3JtYWxpemVTdHlsZShbcmV0LnN0eWxlLCB0b01lcmdlLnN0eWxlXSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IHJldFtrZXldO1xuICAgICAgICBjb25zdCBpbmNvbWluZyA9IHRvTWVyZ2Vba2V5XTtcbiAgICAgICAgaWYgKGluY29taW5nICYmIGV4aXN0aW5nICE9PSBpbmNvbWluZyAmJiAhKGlzQXJyYXkoZXhpc3RpbmcpICYmIGV4aXN0aW5nLmluY2x1ZGVzKGluY29taW5nKSkpIHtcbiAgICAgICAgICByZXRba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBpbmNvbWluZykgOiBpbmNvbWluZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgIT09IFwiXCIpIHtcbiAgICAgICAgcmV0W2tleV0gPSB0b01lcmdlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBpbnZva2VWTm9kZUhvb2soaG9vaywgaW5zdGFuY2UsIHZub2RlLCBwcmV2Vk5vZGUgPSBudWxsKSB7XG4gIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA3LCBbXG4gICAgdm5vZGUsXG4gICAgcHJldlZOb2RlXG4gIF0pO1xufVxuXG5jb25zdCBlbXB0eUFwcENvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XG5sZXQgdWlkID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKHZub2RlLCBwYXJlbnQsIHN1c3BlbnNlKSB7XG4gIGNvbnN0IHR5cGUgPSB2bm9kZS50eXBlO1xuICBjb25zdCBhcHBDb250ZXh0ID0gKHBhcmVudCA/IHBhcmVudC5hcHBDb250ZXh0IDogdm5vZGUuYXBwQ29udGV4dCkgfHwgZW1wdHlBcHBDb250ZXh0O1xuICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICB1aWQ6IHVpZCsrLFxuICAgIHZub2RlLFxuICAgIHR5cGUsXG4gICAgcGFyZW50LFxuICAgIGFwcENvbnRleHQsXG4gICAgcm9vdDogbnVsbCxcbiAgICAvLyB0byBiZSBpbW1lZGlhdGVseSBzZXRcbiAgICBuZXh0OiBudWxsLFxuICAgIHN1YlRyZWU6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgc3luY2hyb25vdXNseSByaWdodCBhZnRlciBjcmVhdGlvblxuICAgIGVmZmVjdDogbnVsbCxcbiAgICB1cGRhdGU6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgc3luY2hyb25vdXNseSByaWdodCBhZnRlciBjcmVhdGlvblxuICAgIGpvYjogbnVsbCxcbiAgICBzY29wZTogbmV3IEVmZmVjdFNjb3BlKFxuICAgICAgdHJ1ZVxuICAgICAgLyogZGV0YWNoZWQgKi9cbiAgICApLFxuICAgIHJlbmRlcjogbnVsbCxcbiAgICBwcm94eTogbnVsbCxcbiAgICBleHBvc2VkOiBudWxsLFxuICAgIGV4cG9zZVByb3h5OiBudWxsLFxuICAgIHdpdGhQcm94eTogbnVsbCxcbiAgICBwcm92aWRlczogcGFyZW50ID8gcGFyZW50LnByb3ZpZGVzIDogT2JqZWN0LmNyZWF0ZShhcHBDb250ZXh0LnByb3ZpZGVzKSxcbiAgICBpZHM6IHBhcmVudCA/IHBhcmVudC5pZHMgOiBbXCJcIiwgMCwgMF0sXG4gICAgYWNjZXNzQ2FjaGU6IG51bGwsXG4gICAgcmVuZGVyQ2FjaGU6IFtdLFxuICAgIC8vIGxvY2FsIHJlc29sdmVkIGFzc2V0c1xuICAgIGNvbXBvbmVudHM6IG51bGwsXG4gICAgZGlyZWN0aXZlczogbnVsbCxcbiAgICAvLyByZXNvbHZlZCBwcm9wcyBhbmQgZW1pdHMgb3B0aW9uc1xuICAgIHByb3BzT3B0aW9uczogbm9ybWFsaXplUHJvcHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgIGVtaXRzT3B0aW9uczogbm9ybWFsaXplRW1pdHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgIC8vIGVtaXRcbiAgICBlbWl0OiBudWxsLFxuICAgIC8vIHRvIGJlIHNldCBpbW1lZGlhdGVseVxuICAgIGVtaXR0ZWQ6IG51bGwsXG4gICAgLy8gcHJvcHMgZGVmYXVsdCB2YWx1ZVxuICAgIHByb3BzRGVmYXVsdHM6IEVNUFRZX09CSixcbiAgICAvLyBpbmhlcml0QXR0cnNcbiAgICBpbmhlcml0QXR0cnM6IHR5cGUuaW5oZXJpdEF0dHJzLFxuICAgIC8vIHN0YXRlXG4gICAgY3R4OiBFTVBUWV9PQkosXG4gICAgZGF0YTogRU1QVFlfT0JKLFxuICAgIHByb3BzOiBFTVBUWV9PQkosXG4gICAgYXR0cnM6IEVNUFRZX09CSixcbiAgICBzbG90czogRU1QVFlfT0JKLFxuICAgIHJlZnM6IEVNUFRZX09CSixcbiAgICBzZXR1cFN0YXRlOiBFTVBUWV9PQkosXG4gICAgc2V0dXBDb250ZXh0OiBudWxsLFxuICAgIC8vIHN1c3BlbnNlIHJlbGF0ZWRcbiAgICBzdXNwZW5zZSxcbiAgICBzdXNwZW5zZUlkOiBzdXNwZW5zZSA/IHN1c3BlbnNlLnBlbmRpbmdJZCA6IDAsXG4gICAgYXN5bmNEZXA6IG51bGwsXG4gICAgYXN5bmNSZXNvbHZlZDogZmFsc2UsXG4gICAgLy8gbGlmZWN5Y2xlIGhvb2tzXG4gICAgLy8gbm90IHVzaW5nIGVudW1zIGhlcmUgYmVjYXVzZSBpdCByZXN1bHRzIGluIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcbiAgICBpc0RlYWN0aXZhdGVkOiBmYWxzZSxcbiAgICBiYzogbnVsbCxcbiAgICBjOiBudWxsLFxuICAgIGJtOiBudWxsLFxuICAgIG06IG51bGwsXG4gICAgYnU6IG51bGwsXG4gICAgdTogbnVsbCxcbiAgICB1bTogbnVsbCxcbiAgICBidW06IG51bGwsXG4gICAgZGE6IG51bGwsXG4gICAgYTogbnVsbCxcbiAgICBydGc6IG51bGwsXG4gICAgcnRjOiBudWxsLFxuICAgIGVjOiBudWxsLFxuICAgIHNwOiBudWxsXG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5zdGFuY2UuY3R4ID0gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UuY3R4ID0geyBfOiBpbnN0YW5jZSB9O1xuICB9XG4gIGluc3RhbmNlLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IGluc3RhbmNlO1xuICBpbnN0YW5jZS5lbWl0ID0gZW1pdC5iaW5kKG51bGwsIGluc3RhbmNlKTtcbiAgaWYgKHZub2RlLmNlKSB7XG4gICAgdm5vZGUuY2UoaW5zdGFuY2UpO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmxldCBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xuY29uc3QgZ2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbmxldCBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZTtcbmxldCBzZXRJblNTUlNldHVwU3RhdGU7XG57XG4gIGNvbnN0IGcgPSBnZXRHbG9iYWxUaGlzKCk7XG4gIGNvbnN0IHJlZ2lzdGVyR2xvYmFsU2V0dGVyID0gKGtleSwgc2V0dGVyKSA9PiB7XG4gICAgbGV0IHNldHRlcnM7XG4gICAgaWYgKCEoc2V0dGVycyA9IGdba2V5XSkpIHNldHRlcnMgPSBnW2tleV0gPSBbXTtcbiAgICBzZXR0ZXJzLnB1c2goc2V0dGVyKTtcbiAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgIGlmIChzZXR0ZXJzLmxlbmd0aCA+IDEpIHNldHRlcnMuZm9yRWFjaCgoc2V0KSA9PiBzZXQodikpO1xuICAgICAgZWxzZSBzZXR0ZXJzWzBdKHYpO1xuICAgIH07XG4gIH07XG4gIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlID0gcmVnaXN0ZXJHbG9iYWxTZXR0ZXIoXG4gICAgYF9fVlVFX0lOU1RBTkNFX1NFVFRFUlNfX2AsXG4gICAgKHYpID0+IGN1cnJlbnRJbnN0YW5jZSA9IHZcbiAgKTtcbiAgc2V0SW5TU1JTZXR1cFN0YXRlID0gcmVnaXN0ZXJHbG9iYWxTZXR0ZXIoXG4gICAgYF9fVlVFX1NTUl9TRVRURVJTX19gLFxuICAgICh2KSA9PiBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSB2XG4gICk7XG59XG5jb25zdCBzZXRDdXJyZW50SW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgY29uc3QgcHJldiA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgaW50ZXJuYWxTZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICBpbnN0YW5jZS5zY29wZS5vbigpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGluc3RhbmNlLnNjb3BlLm9mZigpO1xuICAgIGludGVybmFsU2V0Q3VycmVudEluc3RhbmNlKHByZXYpO1xuICB9O1xufTtcbmNvbnN0IHVuc2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4ge1xuICBjdXJyZW50SW5zdGFuY2UgJiYgY3VycmVudEluc3RhbmNlLnNjb3BlLm9mZigpO1xuICBpbnRlcm5hbFNldEN1cnJlbnRJbnN0YW5jZShudWxsKTtcbn07XG5jb25zdCBpc0J1aWx0SW5UYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcInNsb3QsY29tcG9uZW50XCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUsIHsgaXNOYXRpdmVUYWcgfSkge1xuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGlzTmF0aXZlVGFnKG5hbWUpKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCJEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50IGlkOiBcIiArIG5hbWVcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiA0O1xufVxubGV0IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSB7XG4gIGlzU1NSICYmIHNldEluU1NSU2V0dXBTdGF0ZShpc1NTUik7XG4gIGNvbnN0IHsgcHJvcHMsIGNoaWxkcmVuIH0gPSBpbnN0YW5jZS52bm9kZTtcbiAgY29uc3QgaXNTdGF0ZWZ1bCA9IGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpO1xuICBpbml0UHJvcHMoaW5zdGFuY2UsIHByb3BzLCBpc1N0YXRlZnVsLCBpc1NTUik7XG4gIGluaXRTbG90cyhpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCB8fCBpc1NTUik7XG4gIGNvbnN0IHNldHVwUmVzdWx0ID0gaXNTdGF0ZWZ1bCA/IHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKSA6IHZvaWQgMDtcbiAgaXNTU1IgJiYgc2V0SW5TU1JTZXR1cFN0YXRlKGZhbHNlKTtcbiAgcmV0dXJuIHNldHVwUmVzdWx0O1xufVxuZnVuY3Rpb24gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpIHtcbiAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpZiAoQ29tcG9uZW50Lm5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShDb21wb25lbnQubmFtZSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xuICAgIH1cbiAgICBpZiAoQ29tcG9uZW50LmNvbXBvbmVudHMpIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmNvbXBvbmVudHMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZXNbaV0sIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5kaXJlY3RpdmVzKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5kaXJlY3RpdmVzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKENvbXBvbmVudC5jb21waWxlck9wdGlvbnMgJiYgaXNSdW50aW1lT25seSgpKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGBcImNvbXBpbGVyT3B0aW9uc1wiIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdXNpbmcgYSBidWlsZCBvZiBWdWUgdGhhdCBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlci4gU2luY2UgeW91IGFyZSB1c2luZyBhIHJ1bnRpbWUtb25seSBidWlsZCwgdGhlIG9wdGlvbnMgc2hvdWxkIGJlIHBhc3NlZCB2aWEgeW91ciBidWlsZCB0b29sIGNvbmZpZyBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGluc3RhbmNlLmFjY2Vzc0NhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGluc3RhbmNlLnByb3h5ID0gbmV3IFByb3h5KGluc3RhbmNlLmN0eCwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gIH1cbiAgY29uc3QgeyBzZXR1cCB9ID0gQ29tcG9uZW50O1xuICBpZiAoc2V0dXApIHtcbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgY29uc3Qgc2V0dXBDb250ZXh0ID0gaW5zdGFuY2Uuc2V0dXBDb250ZXh0ID0gc2V0dXAubGVuZ3RoID4gMSA/IGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkgOiBudWxsO1xuICAgIGNvbnN0IHJlc2V0ID0gc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICBjb25zdCBzZXR1cFJlc3VsdCA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhcbiAgICAgIHNldHVwLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICAwLFxuICAgICAgW1xuICAgICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnByb3BzKSA6IGluc3RhbmNlLnByb3BzLFxuICAgICAgICBzZXR1cENvbnRleHRcbiAgICAgIF1cbiAgICApO1xuICAgIGNvbnN0IGlzQXN5bmNTZXR1cCA9IGlzUHJvbWlzZShzZXR1cFJlc3VsdCk7XG4gICAgcmVzZXRUcmFja2luZygpO1xuICAgIHJlc2V0KCk7XG4gICAgaWYgKChpc0FzeW5jU2V0dXAgfHwgaW5zdGFuY2Uuc3ApICYmICFpc0FzeW5jV3JhcHBlcihpbnN0YW5jZSkpIHtcbiAgICAgIG1hcmtBc3luY0JvdW5kYXJ5KGluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKGlzQXN5bmNTZXR1cCkge1xuICAgICAgc2V0dXBSZXN1bHQudGhlbih1bnNldEN1cnJlbnRJbnN0YW5jZSwgdW5zZXRDdXJyZW50SW5zdGFuY2UpO1xuICAgICAgaWYgKGlzU1NSKSB7XG4gICAgICAgIHJldHVybiBzZXR1cFJlc3VsdC50aGVuKChyZXNvbHZlZFJlc3VsdCkgPT4ge1xuICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCByZXNvbHZlZFJlc3VsdCwgaXNTU1IpO1xuICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGluc3RhbmNlLCAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5hc3luY0RlcCA9IHNldHVwUmVzdWx0O1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhaW5zdGFuY2Uuc3VzcGVuc2UpIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgQ29tcG9uZW50KTtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgQ29tcG9uZW50IDwke25hbWV9Pjogc2V0dXAgZnVuY3Rpb24gcmV0dXJuZWQgYSBwcm9taXNlLCBidXQgbm8gPFN1c3BlbnNlPiBib3VuZGFyeSB3YXMgZm91bmQgaW4gdGhlIHBhcmVudCBjb21wb25lbnQgdHJlZS4gQSBjb21wb25lbnQgd2l0aCBhc3luYyBzZXR1cCgpIG11c3QgYmUgbmVzdGVkIGluIGEgPFN1c3BlbnNlPiBpbiBvcmRlciB0byBiZSByZW5kZXJlZC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUikge1xuICBpZiAoaXNGdW5jdGlvbihzZXR1cFJlc3VsdCkpIHtcbiAgICBpZiAoaW5zdGFuY2UudHlwZS5fX3NzcklubGluZVJlbmRlcikge1xuICAgICAgaW5zdGFuY2Uuc3NyUmVuZGVyID0gc2V0dXBSZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChzZXR1cFJlc3VsdCkpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBpc1ZOb2RlKHNldHVwUmVzdWx0KSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgc2V0dXAoKSBzaG91bGQgbm90IHJldHVybiBWTm9kZXMgZGlyZWN0bHkgLSByZXR1cm4gYSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgIGluc3RhbmNlLmRldnRvb2xzUmF3U2V0dXBTdGF0ZSA9IHNldHVwUmVzdWx0O1xuICAgIH1cbiAgICBpbnN0YW5jZS5zZXR1cFN0YXRlID0gcHJveHlSZWZzKHNldHVwUmVzdWx0KTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgc2V0dXBSZXN1bHQgIT09IHZvaWQgMCkge1xuICAgIHdhcm4kMShcbiAgICAgIGBzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogJHtzZXR1cFJlc3VsdCA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHNldHVwUmVzdWx0fWBcbiAgICApO1xuICB9XG4gIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XG59XG5sZXQgY29tcGlsZTtcbmxldCBpbnN0YWxsV2l0aFByb3h5O1xuZnVuY3Rpb24gcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIoX2NvbXBpbGUpIHtcbiAgY29tcGlsZSA9IF9jb21waWxlO1xuICBpbnN0YWxsV2l0aFByb3h5ID0gKGkpID0+IHtcbiAgICBpZiAoaS5yZW5kZXIuX3JjKSB7XG4gICAgICBpLndpdGhQcm94eSA9IG5ldyBQcm94eShpLmN0eCwgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBpc1J1bnRpbWVPbmx5ID0gKCkgPT4gIWNvbXBpbGU7XG5mdW5jdGlvbiBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IsIHNraXBPcHRpb25zKSB7XG4gIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XG4gIGlmICghaW5zdGFuY2UucmVuZGVyKSB7XG4gICAgaWYgKCFpc1NTUiAmJiBjb21waWxlICYmICFDb21wb25lbnQucmVuZGVyKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IENvbXBvbmVudC50ZW1wbGF0ZSB8fCBfX1ZVRV9PUFRJT05TX0FQSV9fICYmIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKS50ZW1wbGF0ZTtcbiAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlzQ3VzdG9tRWxlbWVudCwgY29tcGlsZXJPcHRpb25zIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZztcbiAgICAgICAgY29uc3QgeyBkZWxpbWl0ZXJzLCBjb21waWxlck9wdGlvbnM6IGNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyB9ID0gQ29tcG9uZW50O1xuICAgICAgICBjb25zdCBmaW5hbENvbXBpbGVyT3B0aW9ucyA9IGV4dGVuZChcbiAgICAgICAgICBleHRlbmQoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgZGVsaW1pdGVyc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBpbGVyT3B0aW9uc1xuICAgICAgICAgICksXG4gICAgICAgICAgY29tcG9uZW50Q29tcGlsZXJPcHRpb25zXG4gICAgICAgICk7XG4gICAgICAgIENvbXBvbmVudC5yZW5kZXIgPSBjb21waWxlKHRlbXBsYXRlLCBmaW5hbENvbXBpbGVyT3B0aW9ucyk7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5yZW5kZXIgPSBDb21wb25lbnQucmVuZGVyIHx8IE5PT1A7XG4gICAgaWYgKGluc3RhbGxXaXRoUHJveHkpIHtcbiAgICAgIGluc3RhbGxXaXRoUHJveHkoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiB0cnVlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICB0cnkge1xuICAgICAgYXBwbHlPcHRpb25zKGluc3RhbmNlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgcmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgIUNvbXBvbmVudC5yZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QICYmICFpc1NTUikge1xuICAgIGlmICghY29tcGlsZSAmJiBDb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYENvbXBvbmVudCBwcm92aWRlZCB0ZW1wbGF0ZSBvcHRpb24gYnV0IHJ1bnRpbWUgY29tcGlsYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIFZ1ZS5gICsgKGAgQ29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBhbGlhcyBcInZ1ZVwiIHRvIFwidnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzXCIuYCApXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDEoYENvbXBvbmVudCBpcyBtaXNzaW5nIHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbjogYCwgQ29tcG9uZW50KTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IGF0dHJzUHJveHlIYW5kbGVycyA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB7XG4gIGdldCh0YXJnZXQsIGtleSkge1xuICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBcIlwiKTtcbiAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gIH0sXG4gIHNldCgpIHtcbiAgICB3YXJuJDEoYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5KCkge1xuICAgIHdhcm4kMShgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSA6IHtcbiAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBcIlwiKTtcbiAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRTbG90c1Byb3h5KGluc3RhbmNlKSB7XG4gIHJldHVybiBuZXcgUHJveHkoaW5zdGFuY2Uuc2xvdHMsIHtcbiAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHRyYWNrKGluc3RhbmNlLCBcImdldFwiLCBcIiRzbG90c1wiKTtcbiAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU2V0dXBDb250ZXh0KGluc3RhbmNlKSB7XG4gIGNvbnN0IGV4cG9zZSA9IChleHBvc2VkKSA9PiB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgICAgIHdhcm4kMShgZXhwb3NlKCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UgcGVyIHNldHVwKCkuYCk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwb3NlZCAhPSBudWxsKSB7XG4gICAgICAgIGxldCBleHBvc2VkVHlwZSA9IHR5cGVvZiBleHBvc2VkO1xuICAgICAgICBpZiAoZXhwb3NlZFR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShleHBvc2VkKSkge1xuICAgICAgICAgICAgZXhwb3NlZFR5cGUgPSBcImFycmF5XCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1JlZihleHBvc2VkKSkge1xuICAgICAgICAgICAgZXhwb3NlZFR5cGUgPSBcInJlZlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb3NlZFR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBgZXhwb3NlKCkgc2hvdWxkIGJlIHBhc3NlZCBhIHBsYWluIG9iamVjdCwgcmVjZWl2ZWQgJHtleHBvc2VkVHlwZX0uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UuZXhwb3NlZCA9IGV4cG9zZWQgfHwge307XG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgbGV0IGF0dHJzUHJveHk7XG4gICAgbGV0IHNsb3RzUHJveHk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICByZXR1cm4gYXR0cnNQcm94eSB8fCAoYXR0cnNQcm94eSA9IG5ldyBQcm94eShpbnN0YW5jZS5hdHRycywgYXR0cnNQcm94eUhhbmRsZXJzKSk7XG4gICAgICB9LFxuICAgICAgZ2V0IHNsb3RzKCkge1xuICAgICAgICByZXR1cm4gc2xvdHNQcm94eSB8fCAoc2xvdHNQcm94eSA9IGdldFNsb3RzUHJveHkoaW5zdGFuY2UpKTtcbiAgICAgIH0sXG4gICAgICBnZXQgZW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4gaW5zdGFuY2UuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgZXhwb3NlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF0dHJzOiBuZXcgUHJveHkoaW5zdGFuY2UuYXR0cnMsIGF0dHJzUHJveHlIYW5kbGVycyksXG4gICAgICBzbG90czogaW5zdGFuY2Uuc2xvdHMsXG4gICAgICBlbWl0OiBpbnN0YW5jZS5lbWl0LFxuICAgICAgZXhwb3NlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuZXhwb3NlUHJveHkgfHwgKGluc3RhbmNlLmV4cG9zZVByb3h5ID0gbmV3IFByb3h5KHByb3h5UmVmcyhtYXJrUmF3KGluc3RhbmNlLmV4cG9zZWQpKSwge1xuICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSBpbiBwdWJsaWNQcm9wZXJ0aWVzTWFwKSB7XG4gICAgICAgICAgcmV0dXJuIHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSBpbiB0YXJnZXQgfHwga2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXA7XG4gICAgICB9XG4gICAgfSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbnN0YW5jZS5wcm94eTtcbiAgfVxufVxuY29uc3QgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pXFx3L2c7XG5jb25zdCBjbGFzc2lmeSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIChjKSA9PiBjLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoL1stX10vZywgXCJcIik7XG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCwgaW5jbHVkZUluZmVycmVkID0gdHJ1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbihDb21wb25lbnQpID8gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIDogQ29tcG9uZW50Lm5hbWUgfHwgaW5jbHVkZUluZmVycmVkICYmIENvbXBvbmVudC5fX25hbWU7XG59XG5mdW5jdGlvbiBmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBDb21wb25lbnQsIGlzUm9vdCA9IGZhbHNlKSB7XG4gIGxldCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xuICBpZiAoIW5hbWUgJiYgQ29tcG9uZW50Ll9fZmlsZSkge1xuICAgIGNvbnN0IG1hdGNoID0gQ29tcG9uZW50Ll9fZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC5cXHcrJC8pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgbmFtZSA9IG1hdGNoWzFdO1xuICAgIH1cbiAgfVxuICBpZiAoIW5hbWUgJiYgaW5zdGFuY2UpIHtcbiAgICBjb25zdCBpbmZlckZyb21SZWdpc3RyeSA9IChyZWdpc3RyeSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVnaXN0cnkpIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJ5W2tleV0gPT09IENvbXBvbmVudCkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIG5hbWUgPSBpbmZlckZyb21SZWdpc3RyeShpbnN0YW5jZS5jb21wb25lbnRzKSB8fCBpbnN0YW5jZS5wYXJlbnQgJiYgaW5mZXJGcm9tUmVnaXN0cnkoXG4gICAgICBpbnN0YW5jZS5wYXJlbnQudHlwZS5jb21wb25lbnRzXG4gICAgKSB8fCBpbmZlckZyb21SZWdpc3RyeShpbnN0YW5jZS5hcHBDb250ZXh0LmNvbXBvbmVudHMpO1xuICB9XG4gIHJldHVybiBuYW1lID8gY2xhc3NpZnkobmFtZSkgOiBpc1Jvb3QgPyBgQXBwYCA6IGBBbm9ueW1vdXNgO1xufVxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgJiYgXCJfX3ZjY09wdHNcIiBpbiB2YWx1ZTtcbn1cblxuY29uc3QgY29tcHV0ZWQgPSAoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMpID0+IHtcbiAgY29uc3QgYyA9IGNvbXB1dGVkJDEoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzSW5TU1JDb21wb25lbnRTZXR1cCk7XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGlmIChpICYmIGkuYXBwQ29udGV4dC5jb25maWcud2FyblJlY3Vyc2l2ZUNvbXB1dGVkKSB7XG4gICAgICBjLl93YXJuUmVjdXJzaXZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGM7XG59O1xuXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pIHtcbiAgdHJ5IHtcbiAgICBzZXRCbG9ja1RyYWNraW5nKC0xKTtcbiAgICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gMikge1xuICAgICAgaWYgKGlzT2JqZWN0KHByb3BzT3JDaGlsZHJlbikgJiYgIWlzQXJyYXkocHJvcHNPckNoaWxkcmVuKSkge1xuICAgICAgICBpZiAoaXNWTm9kZShwcm9wc09yQ2hpbGRyZW4pKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIFtwcm9wc09yQ2hpbGRyZW5dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBwcm9wc09yQ2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobCA+IDMpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgfSBlbHNlIGlmIChsID09PSAzICYmIGlzVk5vZGUoY2hpbGRyZW4pKSB7XG4gICAgICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgc2V0QmxvY2tUcmFja2luZygxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q3VzdG9tRm9ybWF0dGVyKCkge1xuICBpZiAoISEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB2dWVTdHlsZSA9IHsgc3R5bGU6IFwiY29sb3I6IzNiYTc3NlwiIH07XG4gIGNvbnN0IG51bWJlclN0eWxlID0geyBzdHlsZTogXCJjb2xvcjojMTY3N2ZmXCIgfTtcbiAgY29uc3Qgc3RyaW5nU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiNmNTIyMmRcIiB9O1xuICBjb25zdCBrZXl3b3JkU3R5bGUgPSB7IHN0eWxlOiBcImNvbG9yOiNlYjJmOTZcIiB9O1xuICBjb25zdCBmb3JtYXR0ZXIgPSB7XG4gICAgX192dWVfY3VzdG9tX2Zvcm1hdHRlcjogdHJ1ZSxcbiAgICBoZWFkZXIob2JqKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAob2JqLl9faXNWdWUpIHtcbiAgICAgICAgcmV0dXJuIFtcImRpdlwiLCB2dWVTdHlsZSwgYFZ1ZUluc3RhbmNlYF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVmKG9iaikpIHtcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9iai52YWx1ZTtcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgZ2VuUmVmRmxhZyhvYmopXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBmb3JtYXRWYWx1ZSh2YWx1ZSksXG4gICAgICAgICAgYD5gXG4gICAgICAgIF07XG4gICAgICB9IGVsc2UgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgW1wic3BhblwiLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyBcIlNoYWxsb3dSZWFjdGl2ZVwiIDogXCJSZWFjdGl2ZVwiXSxcbiAgICAgICAgICBcIjxcIixcbiAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxuICAgICAgICAgIGA+JHtpc1JlYWRvbmx5KG9iaikgPyBgIChyZWFkb25seSlgIDogYGB9YFxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIGlmIChpc1JlYWRvbmx5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIFtcInNwYW5cIiwgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gXCJTaGFsbG93UmVhZG9ubHlcIiA6IFwiUmVhZG9ubHlcIl0sXG4gICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcbiAgICAgICAgICBcIj5cIlxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBoYXNCb2R5KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19pc1Z1ZTtcbiAgICB9LFxuICAgIGJvZHkob2JqKSB7XG4gICAgICBpZiAob2JqICYmIG9iai5fX2lzVnVlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5mb3JtYXRJbnN0YW5jZShvYmouJClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGZvcm1hdEluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgY29uc3QgYmxvY2tzID0gW107XG4gICAgaWYgKGluc3RhbmNlLnR5cGUucHJvcHMgJiYgaW5zdGFuY2UucHJvcHMpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJwcm9wc1wiLCB0b1JhdyhpbnN0YW5jZS5wcm9wcykpKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLnNldHVwU3RhdGUgIT09IEVNUFRZX09CSikge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcInNldHVwXCIsIGluc3RhbmNlLnNldHVwU3RhdGUpKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLmRhdGEgIT09IEVNUFRZX09CSikge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jayhcImRhdGFcIiwgdG9SYXcoaW5zdGFuY2UuZGF0YSkpKTtcbiAgICB9XG4gICAgY29uc3QgY29tcHV0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgXCJjb21wdXRlZFwiKTtcbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJjb21wdXRlZFwiLCBjb21wdXRlZCkpO1xuICAgIH1cbiAgICBjb25zdCBpbmplY3RlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCBcImluamVjdFwiKTtcbiAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soXCJpbmplY3RlZFwiLCBpbmplY3RlZCkpO1xuICAgIH1cbiAgICBibG9ja3MucHVzaChbXG4gICAgICBcImRpdlwiLFxuICAgICAge30sXG4gICAgICBbXG4gICAgICAgIFwic3BhblwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IGtleXdvcmRTdHlsZS5zdHlsZSArIFwiO29wYWNpdHk6MC42NlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJCAoaW50ZXJuYWwpOiBcIlxuICAgICAgXSxcbiAgICAgIFtcIm9iamVjdFwiLCB7IG9iamVjdDogaW5zdGFuY2UgfV1cbiAgICBdKTtcbiAgICByZXR1cm4gYmxvY2tzO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQmxvY2sodHlwZSwgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gZXh0ZW5kKHt9LCB0YXJnZXQpO1xuICAgIGlmICghT2JqZWN0LmtleXModGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHt9XTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7IHN0eWxlOiBcImxpbmUtaGVpZ2h0OjEuMjVlbTttYXJnaW4tYm90dG9tOjAuNmVtXCIgfSxcbiAgICAgIFtcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlOiBcImNvbG9yOiM0NzY1ODJcIlxuICAgICAgICB9LFxuICAgICAgICB0eXBlXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IFwicGFkZGluZy1sZWZ0OjEuMjVlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKHRhcmdldCkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgW1wic3BhblwiLCBrZXl3b3JkU3R5bGUsIGtleSArIFwiOiBcIl0sXG4gICAgICAgICAgICBmb3JtYXRWYWx1ZSh0YXJnZXRba2V5XSwgZmFsc2UpXG4gICAgICAgICAgXTtcbiAgICAgICAgfSlcbiAgICAgIF1cbiAgICBdO1xuICB9XG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYsIGFzUmF3ID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIFtcInNwYW5cIiwgbnVtYmVyU3R5bGUsIHZdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBKU09OLnN0cmluZ2lmeSh2KV07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIGtleXdvcmRTdHlsZSwgdl07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2KSkge1xuICAgICAgcmV0dXJuIFtcIm9iamVjdFwiLCB7IG9iamVjdDogYXNSYXcgPyB0b1Jhdyh2KSA6IHYgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXCJzcGFuXCIsIHN0cmluZ1N0eWxlLCBTdHJpbmcodildO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHRyYWN0S2V5cyhpbnN0YW5jZSwgdHlwZSkge1xuICAgIGNvbnN0IENvbXAgPSBpbnN0YW5jZS50eXBlO1xuICAgIGlmIChpc0Z1bmN0aW9uKENvbXApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhY3RlZCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLmN0eCkge1xuICAgICAgaWYgKGlzS2V5T2ZUeXBlKENvbXAsIGtleSwgdHlwZSkpIHtcbiAgICAgICAgZXh0cmFjdGVkW2tleV0gPSBpbnN0YW5jZS5jdHhba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4dHJhY3RlZDtcbiAgfVxuICBmdW5jdGlvbiBpc0tleU9mVHlwZShDb21wLCBrZXksIHR5cGUpIHtcbiAgICBjb25zdCBvcHRzID0gQ29tcFt0eXBlXTtcbiAgICBpZiAoaXNBcnJheShvcHRzKSAmJiBvcHRzLmluY2x1ZGVzKGtleSkgfHwgaXNPYmplY3Qob3B0cykgJiYga2V5IGluIG9wdHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ29tcC5leHRlbmRzICYmIGlzS2V5T2ZUeXBlKENvbXAuZXh0ZW5kcywga2V5LCB0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChDb21wLm1peGlucyAmJiBDb21wLm1peGlucy5zb21lKChtKSA9PiBpc0tleU9mVHlwZShtLCBrZXksIHR5cGUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdlblJlZkZsYWcodikge1xuICAgIGlmIChpc1NoYWxsb3codikpIHtcbiAgICAgIHJldHVybiBgU2hhbGxvd1JlZmA7XG4gICAgfVxuICAgIGlmICh2LmVmZmVjdCkge1xuICAgICAgcmV0dXJuIGBDb21wdXRlZFJlZmA7XG4gICAgfVxuICAgIHJldHVybiBgUmVmYDtcbiAgfVxuICBpZiAod2luZG93LmRldnRvb2xzRm9ybWF0dGVycykge1xuICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMucHVzaChmb3JtYXR0ZXIpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMgPSBbZm9ybWF0dGVyXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3aXRoTWVtbyhtZW1vLCByZW5kZXIsIGNhY2hlLCBpbmRleCkge1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZVtpbmRleF07XG4gIGlmIChjYWNoZWQgJiYgaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBjb25zdCByZXQgPSByZW5kZXIoKTtcbiAgcmV0Lm1lbW8gPSBtZW1vLnNsaWNlKCk7XG4gIHJldC5jYWNoZUluZGV4ID0gaW5kZXg7XG4gIHJldHVybiBjYWNoZVtpbmRleF0gPSByZXQ7XG59XG5mdW5jdGlvbiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykge1xuICBjb25zdCBwcmV2ID0gY2FjaGVkLm1lbW87XG4gIGlmIChwcmV2Lmxlbmd0aCAhPSBtZW1vLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGFzQ2hhbmdlZChwcmV2W2ldLCBtZW1vW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcbiAgICBjdXJyZW50QmxvY2sucHVzaChjYWNoZWQpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5jb25zdCB2ZXJzaW9uID0gXCIzLjUuMjZcIjtcbmNvbnN0IHdhcm4gPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gd2FybiQxIDogTk9PUDtcbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MgPSBFcnJvclR5cGVTdHJpbmdzJDEgO1xuY29uc3QgZGV2dG9vbHMgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IHRydWUgPyBkZXZ0b29scyQxIDogdm9pZCAwO1xuY29uc3Qgc2V0RGV2dG9vbHNIb29rID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB8fCB0cnVlID8gc2V0RGV2dG9vbHNIb29rJDEgOiBOT09QO1xuY29uc3QgX3NzclV0aWxzID0ge1xuICBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSxcbiAgc2V0dXBDb21wb25lbnQsXG4gIHJlbmRlckNvbXBvbmVudFJvb3QsXG4gIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSxcbiAgaXNWTm9kZTogaXNWTm9kZSxcbiAgbm9ybWFsaXplVk5vZGUsXG4gIGdldENvbXBvbmVudFB1YmxpY0luc3RhbmNlLFxuICBlbnN1cmVWYWxpZFZOb2RlLFxuICBwdXNoV2FybmluZ0NvbnRleHQsXG4gIHBvcFdhcm5pbmdDb250ZXh0XG59O1xuY29uc3Qgc3NyVXRpbHMgPSBfc3NyVXRpbHMgO1xuY29uc3QgcmVzb2x2ZUZpbHRlciA9IG51bGw7XG5jb25zdCBjb21wYXRVdGlscyA9IG51bGw7XG5jb25zdCBEZXByZWNhdGlvblR5cGVzID0gbnVsbDtcblxuZXhwb3J0IHsgQmFzZVRyYW5zaXRpb24sIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCBDb21tZW50LCBEZXByZWNhdGlvblR5cGVzLCBFcnJvckNvZGVzLCBFcnJvclR5cGVTdHJpbmdzLCBGcmFnbWVudCwgS2VlcEFsaXZlLCBTdGF0aWMsIFN1c3BlbnNlLCBUZWxlcG9ydCwgVGV4dCwgYXNzZXJ0TnVtYmVyLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgY2FsbFdpdGhFcnJvckhhbmRsaW5nLCBjbG9uZVZOb2RlLCBjb21wYXRVdGlscywgY29tcHV0ZWQsIGNyZWF0ZUJsb2NrLCBjcmVhdGVDb21tZW50Vk5vZGUsIGNyZWF0ZUVsZW1lbnRCbG9jaywgY3JlYXRlQmFzZVZOb2RlIGFzIGNyZWF0ZUVsZW1lbnRWTm9kZSwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIsIGNyZWF0ZVByb3BzUmVzdFByb3h5LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlU2xvdHMsIGNyZWF0ZVN0YXRpY1ZOb2RlLCBjcmVhdGVUZXh0Vk5vZGUsIGNyZWF0ZVZOb2RlLCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWZpbmVFbWl0cywgZGVmaW5lRXhwb3NlLCBkZWZpbmVNb2RlbCwgZGVmaW5lT3B0aW9ucywgZGVmaW5lUHJvcHMsIGRlZmluZVNsb3RzLCBkZXZ0b29scywgZ2V0Q3VycmVudEluc3RhbmNlLCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIGd1YXJkUmVhY3RpdmVQcm9wcywgaCwgaGFuZGxlRXJyb3IsIGhhc0luamVjdGlvbkNvbnRleHQsIGh5ZHJhdGVPbklkbGUsIGh5ZHJhdGVPbkludGVyYWN0aW9uLCBoeWRyYXRlT25NZWRpYVF1ZXJ5LCBoeWRyYXRlT25WaXNpYmxlLCBpbml0Q3VzdG9tRm9ybWF0dGVyLCBpbmplY3QsIGlzTWVtb1NhbWUsIGlzUnVudGltZU9ubHksIGlzVk5vZGUsIG1lcmdlRGVmYXVsdHMsIG1lcmdlTW9kZWxzLCBtZXJnZVByb3BzLCBuZXh0VGljaywgb25BY3RpdmF0ZWQsIG9uQmVmb3JlTW91bnQsIG9uQmVmb3JlVW5tb3VudCwgb25CZWZvcmVVcGRhdGUsIG9uRGVhY3RpdmF0ZWQsIG9uRXJyb3JDYXB0dXJlZCwgb25Nb3VudGVkLCBvblJlbmRlclRyYWNrZWQsIG9uUmVuZGVyVHJpZ2dlcmVkLCBvblNlcnZlclByZWZldGNoLCBvblVubW91bnRlZCwgb25VcGRhdGVkLCBvcGVuQmxvY2ssIHBvcFNjb3BlSWQsIHByb3ZpZGUsIHB1c2hTY29wZUlkLCBxdWV1ZVBvc3RGbHVzaENiLCByZWdpc3RlclJ1bnRpbWVDb21waWxlciwgcmVuZGVyTGlzdCwgcmVuZGVyU2xvdCwgcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSwgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsIHJlc29sdmVGaWx0ZXIsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIHNldEJsb2NrVHJhY2tpbmcsIHNldERldnRvb2xzSG9vaywgc2V0VHJhbnNpdGlvbkhvb2tzLCBzc3JDb250ZXh0S2V5LCBzc3JVdGlscywgdG9IYW5kbGVycywgdHJhbnNmb3JtVk5vZGVBcmdzLCB1c2VBdHRycywgdXNlSWQsIHVzZU1vZGVsLCB1c2VTU1JDb250ZXh0LCB1c2VTbG90cywgdXNlVGVtcGxhdGVSZWYsIHVzZVRyYW5zaXRpb25TdGF0ZSwgdmVyc2lvbiwgd2Fybiwgd2F0Y2gsIHdhdGNoRWZmZWN0LCB3YXRjaFBvc3RFZmZlY3QsIHdhdGNoU3luY0VmZmVjdCwgd2l0aEFzeW5jQ29udGV4dCwgd2l0aEN0eCwgd2l0aERlZmF1bHRzLCB3aXRoRGlyZWN0aXZlcywgd2l0aE1lbW8sIHdpdGhTY29wZUlkIH07XG4iLCIvKipcbiogQHZ1ZS9ydW50aW1lLWRvbSB2My41LjI2XG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5pbXBvcnQgeyB3YXJuLCBCYXNlVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycywgaCwgQmFzZVRyYW5zaXRpb24sIGFzc2VydE51bWJlciwgZ2V0Q3VycmVudEluc3RhbmNlLCBvbkJlZm9yZVVwZGF0ZSwgcXVldWVQb3N0Rmx1c2hDYiwgb25Nb3VudGVkLCB3YXRjaCwgb25Vbm1vdW50ZWQsIEZyYWdtZW50LCBTdGF0aWMsIGNhbWVsaXplLCBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZywgZGVmaW5lQ29tcG9uZW50LCBuZXh0VGljaywgdW5yZWYsIGNyZWF0ZVZOb2RlLCB1c2VUcmFuc2l0aW9uU3RhdGUsIG9uVXBkYXRlZCwgdG9SYXcsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgc2V0VHJhbnNpdGlvbkhvb2tzLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBUZXh0LCBjcmVhdGVSZW5kZXJlciwgY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIsIGlzUnVudGltZU9ubHkgfSBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XG5pbXBvcnQgeyBleHRlbmQsIGlzT2JqZWN0LCB0b051bWJlciwgaXNBcnJheSwgTk9PUCwgbm9ybWFsaXplQ3NzVmFyVmFsdWUsIGlzU3RyaW5nLCBoeXBoZW5hdGUsIGNhcGl0YWxpemUsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGlzU3ltYm9sLCBpc0Z1bmN0aW9uLCBpc09uLCBpc01vZGVsTGlzdGVuZXIsIGNhbWVsaXplIGFzIGNhbWVsaXplJDEsIGlzUGxhaW5PYmplY3QsIGhhc093biwgRU1QVFlfT0JKLCBsb29zZVRvTnVtYmVyLCBsb29zZUluZGV4T2YsIGlzU2V0LCBsb29zZUVxdWFsLCBpbnZva2VBcnJheUZucywgaXNIVE1MVGFnLCBpc1NWR1RhZywgaXNNYXRoTUxUYWcgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmxldCBwb2xpY3kgPSB2b2lkIDA7XG5jb25zdCB0dCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnRydXN0ZWRUeXBlcztcbmlmICh0dCkge1xuICB0cnkge1xuICAgIHBvbGljeSA9IC8qIEBfX1BVUkVfXyAqLyB0dC5jcmVhdGVQb2xpY3koXCJ2dWVcIiwge1xuICAgICAgY3JlYXRlSFRNTDogKHZhbCkgPT4gdmFsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYEVycm9yIGNyZWF0aW5nIHRydXN0ZWQgdHlwZXMgcG9saWN5OiAke2V9YCk7XG4gIH1cbn1cbmNvbnN0IHVuc2FmZVRvVHJ1c3RlZEhUTUwgPSBwb2xpY3kgPyAodmFsKSA9PiBwb2xpY3kuY3JlYXRlSFRNTCh2YWwpIDogKHZhbCkgPT4gdmFsO1xuY29uc3Qgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5jb25zdCBtYXRobWxOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiO1xuY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiBudWxsO1xuY29uc3QgdGVtcGxhdGVDb250YWluZXIgPSBkb2MgJiYgLyogQF9fUFVSRV9fICovIGRvYy5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG5jb25zdCBub2RlT3BzID0ge1xuICBpbnNlcnQ6IChjaGlsZCwgcGFyZW50LCBhbmNob3IpID0+IHtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBhbmNob3IgfHwgbnVsbCk7XG4gIH0sXG4gIHJlbW92ZTogKGNoaWxkKSA9PiB7XG4gICAgY29uc3QgcGFyZW50ID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlRWxlbWVudDogKHRhZywgbmFtZXNwYWNlLCBpcywgcHJvcHMpID0+IHtcbiAgICBjb25zdCBlbCA9IG5hbWVzcGFjZSA9PT0gXCJzdmdcIiA/IGRvYy5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIHRhZykgOiBuYW1lc3BhY2UgPT09IFwibWF0aG1sXCIgPyBkb2MuY3JlYXRlRWxlbWVudE5TKG1hdGhtbE5TLCB0YWcpIDogaXMgPyBkb2MuY3JlYXRlRWxlbWVudCh0YWcsIHsgaXMgfSkgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmICh0YWcgPT09IFwic2VsZWN0XCIgJiYgcHJvcHMgJiYgcHJvcHMubXVsdGlwbGUgIT0gbnVsbCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIiwgcHJvcHMubXVsdGlwbGUpO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH0sXG4gIGNyZWF0ZVRleHQ6ICh0ZXh0KSA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCksXG4gIGNyZWF0ZUNvbW1lbnQ6ICh0ZXh0KSA9PiBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0KSxcbiAgc2V0VGV4dDogKG5vZGUsIHRleHQpID0+IHtcbiAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XG4gIH0sXG4gIHNldEVsZW1lbnRUZXh0OiAoZWwsIHRleHQpID0+IHtcbiAgICBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH0sXG4gIHBhcmVudE5vZGU6IChub2RlKSA9PiBub2RlLnBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiAobm9kZSkgPT4gbm9kZS5uZXh0U2libGluZyxcbiAgcXVlcnlTZWxlY3RvcjogKHNlbGVjdG9yKSA9PiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXG4gIHNldFNjb3BlSWQoZWwsIGlkKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGlkLCBcIlwiKTtcbiAgfSxcbiAgLy8gX19VTlNBRkVfX1xuICAvLyBSZWFzb246IGlubmVySFRNTC5cbiAgLy8gU3RhdGljIGNvbnRlbnQgaGVyZSBjYW4gb25seSBjb21lIGZyb20gY29tcGlsZWQgdGVtcGxhdGVzLlxuICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxuICBpbnNlcnRTdGF0aWNDb250ZW50KGNvbnRlbnQsIHBhcmVudCwgYW5jaG9yLCBuYW1lc3BhY2UsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBiZWZvcmUgPSBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZDtcbiAgICBpZiAoc3RhcnQgJiYgKHN0YXJ0ID09PSBlbmQgfHwgc3RhcnQubmV4dFNpYmxpbmcpKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHN0YXJ0LmNsb25lTm9kZSh0cnVlKSwgYW5jaG9yKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQgfHwgIShzdGFydCA9IHN0YXJ0Lm5leHRTaWJsaW5nKSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXBsYXRlQ29udGFpbmVyLmlubmVySFRNTCA9IHVuc2FmZVRvVHJ1c3RlZEhUTUwoXG4gICAgICAgIG5hbWVzcGFjZSA9PT0gXCJzdmdcIiA/IGA8c3ZnPiR7Y29udGVudH08L3N2Zz5gIDogbmFtZXNwYWNlID09PSBcIm1hdGhtbFwiID8gYDxtYXRoPiR7Y29udGVudH08L21hdGg+YCA6IGNvbnRlbnRcbiAgICAgICk7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlQ29udGFpbmVyLmNvbnRlbnQ7XG4gICAgICBpZiAobmFtZXNwYWNlID09PSBcInN2Z1wiIHx8IG5hbWVzcGFjZSA9PT0gXCJtYXRobWxcIikge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGVtcGxhdGUuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGUucmVtb3ZlQ2hpbGQod3JhcHBlcik7XG4gICAgICB9XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLCBhbmNob3IpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgLy8gZmlyc3RcbiAgICAgIGJlZm9yZSA/IGJlZm9yZS5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkLFxuICAgICAgLy8gbGFzdFxuICAgICAgYW5jaG9yID8gYW5jaG9yLnByZXZpb3VzU2libGluZyA6IHBhcmVudC5sYXN0Q2hpbGRcbiAgICBdO1xuICB9XG59O1xuXG5jb25zdCBUUkFOU0lUSU9OID0gXCJ0cmFuc2l0aW9uXCI7XG5jb25zdCBBTklNQVRJT04gPSBcImFuaW1hdGlvblwiO1xuY29uc3QgdnRjS2V5ID0gLyogQF9fUFVSRV9fICovIFN5bWJvbChcIl92dGNcIik7XG5jb25zdCBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgY3NzOiB7XG4gICAgdHlwZTogQm9vbGVhbixcbiAgICBkZWZhdWx0OiB0cnVlXG4gIH0sXG4gIGR1cmF0aW9uOiBbU3RyaW5nLCBOdW1iZXIsIE9iamVjdF0sXG4gIGVudGVyRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckZyb21DbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmdcbn07XG5jb25zdCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0gLyogQF9fUFVSRV9fICovIGV4dGVuZChcbiAge30sXG4gIEJhc2VUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLFxuICBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzXG4pO1xuY29uc3QgZGVjb3JhdGUkMSA9ICh0KSA9PiB7XG4gIHQuZGlzcGxheU5hbWUgPSBcIlRyYW5zaXRpb25cIjtcbiAgdC5wcm9wcyA9IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnM7XG4gIHJldHVybiB0O1xufTtcbmNvbnN0IFRyYW5zaXRpb24gPSAvKiBAX19QVVJFX18gKi8gZGVjb3JhdGUkMShcbiAgKHByb3BzLCB7IHNsb3RzIH0pID0+IGgoQmFzZVRyYW5zaXRpb24sIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocHJvcHMpLCBzbG90cylcbik7XG5jb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzID0gW10pID0+IHtcbiAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICBob29rLmZvckVhY2goKGgyKSA9PiBoMiguLi5hcmdzKSk7XG4gIH0gZWxzZSBpZiAoaG9vaykge1xuICAgIGhvb2soLi4uYXJncyk7XG4gIH1cbn07XG5jb25zdCBoYXNFeHBsaWNpdENhbGxiYWNrID0gKGhvb2spID0+IHtcbiAgcmV0dXJuIGhvb2sgPyBpc0FycmF5KGhvb2spID8gaG9vay5zb21lKChoMikgPT4gaDIubGVuZ3RoID4gMSkgOiBob29rLmxlbmd0aCA+IDEgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKSB7XG4gIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiByYXdQcm9wcykge1xuICAgIGlmICghKGtleSBpbiBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSkge1xuICAgICAgYmFzZVByb3BzW2tleV0gPSByYXdQcm9wc1trZXldO1xuICAgIH1cbiAgfVxuICBpZiAocmF3UHJvcHMuY3NzID09PSBmYWxzZSkge1xuICAgIHJldHVybiBiYXNlUHJvcHM7XG4gIH1cbiAgY29uc3Qge1xuICAgIG5hbWUgPSBcInZcIixcbiAgICB0eXBlLFxuICAgIGR1cmF0aW9uLFxuICAgIGVudGVyRnJvbUNsYXNzID0gYCR7bmFtZX0tZW50ZXItZnJvbWAsXG4gICAgZW50ZXJBY3RpdmVDbGFzcyA9IGAke25hbWV9LWVudGVyLWFjdGl2ZWAsXG4gICAgZW50ZXJUb0NsYXNzID0gYCR7bmFtZX0tZW50ZXItdG9gLFxuICAgIGFwcGVhckZyb21DbGFzcyA9IGVudGVyRnJvbUNsYXNzLFxuICAgIGFwcGVhckFjdGl2ZUNsYXNzID0gZW50ZXJBY3RpdmVDbGFzcyxcbiAgICBhcHBlYXJUb0NsYXNzID0gZW50ZXJUb0NsYXNzLFxuICAgIGxlYXZlRnJvbUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtZnJvbWAsXG4gICAgbGVhdmVBY3RpdmVDbGFzcyA9IGAke25hbWV9LWxlYXZlLWFjdGl2ZWAsXG4gICAgbGVhdmVUb0NsYXNzID0gYCR7bmFtZX0tbGVhdmUtdG9gXG4gIH0gPSByYXdQcm9wcztcbiAgY29uc3QgZHVyYXRpb25zID0gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pO1xuICBjb25zdCBlbnRlckR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1swXTtcbiAgY29uc3QgbGVhdmVEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMV07XG4gIGNvbnN0IHtcbiAgICBvbkJlZm9yZUVudGVyLFxuICAgIG9uRW50ZXIsXG4gICAgb25FbnRlckNhbmNlbGxlZCxcbiAgICBvbkxlYXZlLFxuICAgIG9uTGVhdmVDYW5jZWxsZWQsXG4gICAgb25CZWZvcmVBcHBlYXIgPSBvbkJlZm9yZUVudGVyLFxuICAgIG9uQXBwZWFyID0gb25FbnRlcixcbiAgICBvbkFwcGVhckNhbmNlbGxlZCA9IG9uRW50ZXJDYW5jZWxsZWRcbiAgfSA9IGJhc2VQcm9wcztcbiAgY29uc3QgZmluaXNoRW50ZXIgPSAoZWwsIGlzQXBwZWFyLCBkb25lLCBpc0NhbmNlbGxlZCkgPT4ge1xuICAgIGVsLl9lbnRlckNhbmNlbGxlZCA9IGlzQ2FuY2VsbGVkO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcbiAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzKTtcbiAgICBkb25lICYmIGRvbmUoKTtcbiAgfTtcbiAgY29uc3QgZmluaXNoTGVhdmUgPSAoZWwsIGRvbmUpID0+IHtcbiAgICBlbC5faXNMZWF2aW5nID0gZmFsc2U7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgZG9uZSAmJiBkb25lKCk7XG4gIH07XG4gIGNvbnN0IG1ha2VFbnRlckhvb2sgPSAoaXNBcHBlYXIpID0+IHtcbiAgICByZXR1cm4gKGVsLCBkb25lKSA9PiB7XG4gICAgICBjb25zdCBob29rID0gaXNBcHBlYXIgPyBvbkFwcGVhciA6IG9uRW50ZXI7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcbiAgICAgIGNhbGxIb29rKGhvb2ssIFtlbCwgcmVzb2x2ZV0pO1xuICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckZyb21DbGFzcyA6IGVudGVyRnJvbUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xuICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2soaG9vaykpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGVudGVyRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXh0ZW5kKGJhc2VQcm9wcywge1xuICAgIG9uQmVmb3JlRW50ZXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlRW50ZXIsIFtlbF0pO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckZyb21DbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25CZWZvcmVBcHBlYXIoZWwpIHtcbiAgICAgIGNhbGxIb29rKG9uQmVmb3JlQXBwZWFyLCBbZWxdKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyRnJvbUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYXBwZWFyQWN0aXZlQ2xhc3MpO1xuICAgIH0sXG4gICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXG4gICAgb25BcHBlYXI6IG1ha2VFbnRlckhvb2sodHJ1ZSksXG4gICAgb25MZWF2ZShlbCwgZG9uZSkge1xuICAgICAgZWwuX2lzTGVhdmluZyA9IHRydWU7XG4gICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoTGVhdmUoZWwsIGRvbmUpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgICBpZiAoIWVsLl9lbnRlckNhbmNlbGxlZCkge1xuICAgICAgICBmb3JjZVJlZmxvdyhlbCk7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgICBmb3JjZVJlZmxvdyhlbCk7XG4gICAgICB9XG4gICAgICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICBpZiAoIWVsLl9pc0xlYXZpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgaWYgKCFoYXNFeHBsaWNpdENhbGxiYWNrKG9uTGVhdmUpKSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBsZWF2ZUR1cmF0aW9uLCByZXNvbHZlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjYWxsSG9vayhvbkxlYXZlLCBbZWwsIHJlc29sdmVdKTtcbiAgICB9LFxuICAgIG9uRW50ZXJDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaEVudGVyKGVsLCBmYWxzZSwgdm9pZCAwLCB0cnVlKTtcbiAgICAgIGNhbGxIb29rKG9uRW50ZXJDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH0sXG4gICAgb25BcHBlYXJDYW5jZWxsZWQoZWwpIHtcbiAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlLCB2b2lkIDAsIHRydWUpO1xuICAgICAgY2FsbEhvb2sob25BcHBlYXJDYW5jZWxsZWQsIFtlbF0pO1xuICAgIH0sXG4gICAgb25MZWF2ZUNhbmNlbGxlZChlbCkge1xuICAgICAgZmluaXNoTGVhdmUoZWwpO1xuICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKSB7XG4gIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZHVyYXRpb24pKSB7XG4gICAgcmV0dXJuIFtOdW1iZXJPZihkdXJhdGlvbi5lbnRlciksIE51bWJlck9mKGR1cmF0aW9uLmxlYXZlKV07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbiA9IE51bWJlck9mKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gW24sIG5dO1xuICB9XG59XG5mdW5jdGlvbiBOdW1iZXJPZih2YWwpIHtcbiAgY29uc3QgcmVzID0gdG9OdW1iZXIodmFsKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBhc3NlcnROdW1iZXIocmVzLCBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBkdXJhdGlvblwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgoYykgPT4gYyAmJiBlbC5jbGFzc0xpc3QuYWRkKGMpKTtcbiAgKGVsW3Z0Y0tleV0gfHwgKGVsW3Z0Y0tleV0gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSkuYWRkKGNscyk7XG59XG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGVsLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICBjb25zdCBfdnRjID0gZWxbdnRjS2V5XTtcbiAgaWYgKF92dGMpIHtcbiAgICBfdnRjLmRlbGV0ZShjbHMpO1xuICAgIGlmICghX3Z0Yy5zaXplKSB7XG4gICAgICBlbFt2dGNLZXldID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbmV4dEZyYW1lKGNiKSB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcbiAgfSk7XG59XG5sZXQgZW5kSWQgPSAwO1xuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzKGVsLCBleHBlY3RlZFR5cGUsIGV4cGxpY2l0VGltZW91dCwgcmVzb2x2ZSkge1xuICBjb25zdCBpZCA9IGVsLl9lbmRJZCA9ICsrZW5kSWQ7XG4gIGNvbnN0IHJlc29sdmVJZk5vdFN0YWxlID0gKCkgPT4ge1xuICAgIGlmIChpZCA9PT0gZWwuX2VuZElkKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfVxuICB9O1xuICBpZiAoZXhwbGljaXRUaW1lb3V0ICE9IG51bGwpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlSWZOb3RTdGFsZSwgZXhwbGljaXRUaW1lb3V0KTtcbiAgfVxuICBjb25zdCB7IHR5cGUsIHRpbWVvdXQsIHByb3BDb3VudCB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIGlmICghdHlwZSkge1xuICAgIHJldHVybiByZXNvbHZlKCk7XG4gIH1cbiAgY29uc3QgZW5kRXZlbnQgPSB0eXBlICsgXCJlbmRcIjtcbiAgbGV0IGVuZGVkID0gMDtcbiAgY29uc3QgZW5kID0gKCkgPT4ge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcbiAgICByZXNvbHZlSWZOb3RTdGFsZSgpO1xuICB9O1xuICBjb25zdCBvbkVuZCA9IChlKSA9PiB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCAmJiArK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgY29uc3QgZ2V0U3R5bGVQcm9wZXJ0aWVzID0gKGtleSkgPT4gKHN0eWxlc1trZXldIHx8IFwiXCIpLnNwbGl0KFwiLCBcIik7XG4gIGNvbnN0IHRyYW5zaXRpb25EZWxheXMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7VFJBTlNJVElPTn1EZWxheWApO1xuICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059RHVyYXRpb25gKTtcbiAgY29uc3QgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICBjb25zdCBhbmltYXRpb25EZWxheXMgPSBnZXRTdHlsZVByb3BlcnRpZXMoYCR7QU5JTUFUSU9OfURlbGF5YCk7XG4gIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtBTklNQVRJT059RHVyYXRpb25gKTtcbiAgY29uc3QgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuICBsZXQgdHlwZSA9IG51bGw7XG4gIGxldCB0aW1lb3V0ID0gMDtcbiAgbGV0IHByb3BDb3VudCA9IDA7XG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXQgPyBUUkFOU0lUSU9OIDogQU5JTUFUSU9OIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlID8gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aCA6IDA7XG4gIH1cbiAgY29uc3QgaGFzVHJhbnNmb3JtID0gdHlwZSA9PT0gVFJBTlNJVElPTiAmJiAvXFxiKD86dHJhbnNmb3JtfGFsbCkoPzosfCQpLy50ZXN0KFxuICAgIGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfVByb3BlcnR5YCkudG9TdHJpbmcoKVxuICApO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgdGltZW91dCxcbiAgICBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtXG4gIH07XG59XG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoLi4uZHVyYXRpb25zLm1hcCgoZCwgaSkgPT4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKSkpO1xufVxuZnVuY3Rpb24gdG9NcyhzKSB7XG4gIGlmIChzID09PSBcImF1dG9cIikgcmV0dXJuIDA7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZShcIixcIiwgXCIuXCIpKSAqIDFlMztcbn1cbmZ1bmN0aW9uIGZvcmNlUmVmbG93KGVsKSB7XG4gIGNvbnN0IHRhcmdldERvY3VtZW50ID0gZWwgPyBlbC5vd25lckRvY3VtZW50IDogZG9jdW1lbnQ7XG4gIHJldHVybiB0YXJnZXREb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcbn1cblxuZnVuY3Rpb24gcGF0Y2hDbGFzcyhlbCwgdmFsdWUsIGlzU1ZHKSB7XG4gIGNvbnN0IHRyYW5zaXRpb25DbGFzc2VzID0gZWxbdnRjS2V5XTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgdmFsdWUgPSAodmFsdWUgPyBbdmFsdWUsIC4uLnRyYW5zaXRpb25DbGFzc2VzXSA6IFsuLi50cmFuc2l0aW9uQ2xhc3Nlc10pLmpvaW4oXCIgXCIpO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7XG4gIH0gZWxzZSBpZiAoaXNTVkcpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZWwuY2xhc3NOYW1lID0gdmFsdWU7XG4gIH1cbn1cblxuY29uc3QgdlNob3dPcmlnaW5hbERpc3BsYXkgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKFwiX3ZvZFwiKTtcbmNvbnN0IHZTaG93SGlkZGVuID0gLyogQF9fUFVSRV9fICovIFN5bWJvbChcIl92c2hcIik7XG5jb25zdCB2U2hvdyA9IHtcbiAgLy8gdXNlZCBmb3IgcHJvcCBtaXNtYXRjaCBjaGVjayBkdXJpbmcgaHlkcmF0aW9uXG4gIG5hbWU6IFwic2hvd1wiLFxuICBiZWZvcmVNb3VudChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgIGVsW3ZTaG93T3JpZ2luYWxEaXNwbGF5XSA9IGVsLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcbiAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcbiAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgIH1cbiAgfSxcbiAgdXBkYXRlZChlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHJldHVybjtcbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICBzZXREaXNwbGF5KGVsLCB0cnVlKTtcbiAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2l0aW9uLmxlYXZlKGVsLCAoKSA9PiB7XG4gICAgICAgICAgc2V0RGlzcGxheShlbCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlVW5tb3VudChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICB9XG59O1xuZnVuY3Rpb24gc2V0RGlzcGxheShlbCwgdmFsdWUpIHtcbiAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWxbdlNob3dPcmlnaW5hbERpc3BsYXldIDogXCJub25lXCI7XG4gIGVsW3ZTaG93SGlkZGVuXSA9ICF2YWx1ZTtcbn1cbmZ1bmN0aW9uIGluaXRWU2hvd0ZvclNTUigpIHtcbiAgdlNob3cuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHsgc3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSB9O1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgQ1NTX1ZBUl9URVhUID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gXCJDU1NfVkFSX1RFWFRcIiA6IFwiXCIpO1xuZnVuY3Rpb24gdXNlQ3NzVmFycyhnZXR0ZXIpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihgdXNlQ3NzVmFycyBpcyBjYWxsZWQgd2l0aG91dCBjdXJyZW50IGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVwZGF0ZVRlbGVwb3J0cyA9IGluc3RhbmNlLnV0ID0gKHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UucHJveHkpKSA9PiB7XG4gICAgQXJyYXkuZnJvbShcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXYtb3duZXI9XCIke2luc3RhbmNlLnVpZH1cIl1gKVxuICAgICkuZm9yRWFjaCgobm9kZSkgPT4gc2V0VmFyc09uTm9kZShub2RlLCB2YXJzKSk7XG4gIH07XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaW5zdGFuY2UuZ2V0Q3NzVmFycyA9ICgpID0+IGdldHRlcihpbnN0YW5jZS5wcm94eSk7XG4gIH1cbiAgY29uc3Qgc2V0VmFycyA9ICgpID0+IHtcbiAgICBjb25zdCB2YXJzID0gZ2V0dGVyKGluc3RhbmNlLnByb3h5KTtcbiAgICBpZiAoaW5zdGFuY2UuY2UpIHtcbiAgICAgIHNldFZhcnNPbk5vZGUoaW5zdGFuY2UuY2UsIHZhcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRWYXJzT25WTm9kZShpbnN0YW5jZS5zdWJUcmVlLCB2YXJzKTtcbiAgICB9XG4gICAgdXBkYXRlVGVsZXBvcnRzKHZhcnMpO1xuICB9O1xuICBvbkJlZm9yZVVwZGF0ZSgoKSA9PiB7XG4gICAgcXVldWVQb3N0Rmx1c2hDYihzZXRWYXJzKTtcbiAgfSk7XG4gIG9uTW91bnRlZCgoKSA9PiB7XG4gICAgd2F0Y2goc2V0VmFycywgTk9PUCwgeyBmbHVzaDogXCJwb3N0XCIgfSk7XG4gICAgY29uc3Qgb2IgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihzZXRWYXJzKTtcbiAgICBvYi5vYnNlcnZlKGluc3RhbmNlLnN1YlRyZWUuZWwucGFyZW50Tm9kZSwgeyBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgb25Vbm1vdW50ZWQoKCkgPT4gb2IuZGlzY29ubmVjdCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXRWYXJzT25WTm9kZSh2bm9kZSwgdmFycykge1xuICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4KSB7XG4gICAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZTtcbiAgICB2bm9kZSA9IHN1c3BlbnNlLmFjdGl2ZUJyYW5jaDtcbiAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCAmJiAhc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCgoKSA9PiB7XG4gICAgICAgIHNldFZhcnNPblZOb2RlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgdmFycyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKHZub2RlLmNvbXBvbmVudCkge1xuICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50LnN1YlRyZWU7XG4gIH1cbiAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgJiYgdm5vZGUuZWwpIHtcbiAgICBzZXRWYXJzT25Ob2RlKHZub2RlLmVsLCB2YXJzKTtcbiAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBGcmFnbWVudCkge1xuICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IHNldFZhcnNPblZOb2RlKGMsIHZhcnMpKTtcbiAgfSBlbHNlIGlmICh2bm9kZS50eXBlID09PSBTdGF0aWMpIHtcbiAgICBsZXQgeyBlbCwgYW5jaG9yIH0gPSB2bm9kZTtcbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpO1xuICAgICAgaWYgKGVsID09PSBhbmNob3IpIGJyZWFrO1xuICAgICAgZWwgPSBlbC5uZXh0U2libGluZztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpIHtcbiAgaWYgKGVsLm5vZGVUeXBlID09PSAxKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICBsZXQgY3NzVGV4dCA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xuICAgICAgY29uc3QgdmFsdWUgPSBub3JtYWxpemVDc3NWYXJWYWx1ZSh2YXJzW2tleV0pO1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFsdWUpO1xuICAgICAgY3NzVGV4dCArPSBgLS0ke2tleX06ICR7dmFsdWV9O2A7XG4gICAgfVxuICAgIHN0eWxlW0NTU19WQVJfVEVYVF0gPSBjc3NUZXh0O1xuICB9XG59XG5cbmNvbnN0IGRpc3BsYXlSRSA9IC8oPzpefDspXFxzKmRpc3BsYXlcXHMqOi87XG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XG4gIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gIGNvbnN0IGlzQ3NzU3RyaW5nID0gaXNTdHJpbmcobmV4dCk7XG4gIGxldCBoYXNDb250cm9sbGVkRGlzcGxheSA9IGZhbHNlO1xuICBpZiAobmV4dCAmJiAhaXNDc3NTdHJpbmcpIHtcbiAgICBpZiAocHJldikge1xuICAgICAgaWYgKCFpc1N0cmluZyhwcmV2KSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgICAgICAgaWYgKG5leHRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJldlN0eWxlIG9mIHByZXYuc3BsaXQoXCI7XCIpKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gcHJldlN0eWxlLnNsaWNlKDAsIHByZXZTdHlsZS5pbmRleE9mKFwiOlwiKSkudHJpbSgpO1xuICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICAgIGlmIChrZXkgPT09IFwiZGlzcGxheVwiKSB7XG4gICAgICAgIGhhc0NvbnRyb2xsZWREaXNwbGF5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksIG5leHRba2V5XSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0Nzc1N0cmluZykge1xuICAgICAgaWYgKHByZXYgIT09IG5leHQpIHtcbiAgICAgICAgY29uc3QgY3NzVmFyVGV4dCA9IHN0eWxlW0NTU19WQVJfVEVYVF07XG4gICAgICAgIGlmIChjc3NWYXJUZXh0KSB7XG4gICAgICAgICAgbmV4dCArPSBcIjtcIiArIGNzc1ZhclRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUuY3NzVGV4dCA9IG5leHQ7XG4gICAgICAgIGhhc0NvbnRyb2xsZWREaXNwbGF5ID0gZGlzcGxheVJFLnRlc3QobmV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2KSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZTaG93T3JpZ2luYWxEaXNwbGF5IGluIGVsKSB7XG4gICAgZWxbdlNob3dPcmlnaW5hbERpc3BsYXldID0gaGFzQ29udHJvbGxlZERpc3BsYXkgPyBzdHlsZS5kaXNwbGF5IDogXCJcIjtcbiAgICBpZiAoZWxbdlNob3dIaWRkZW5dKSB7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxuICB9XG59XG5jb25zdCBzZW1pY29sb25SRSA9IC9bXlxcXFxdO1xccyokLztcbmNvbnN0IGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdmFsKSB7XG4gIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICB2YWwuZm9yRWFjaCgodikgPT4gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHYpKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID09IG51bGwpIHZhbCA9IFwiXCI7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGlmIChzZW1pY29sb25SRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVW5leHBlY3RlZCBzZW1pY29sb24gYXQgdGhlIGVuZCBvZiAnJHtuYW1lfScgc3R5bGUgdmFsdWU6ICcke3ZhbH0nYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiLS1cIikpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZWZpeGVkID0gYXV0b1ByZWZpeChzdHlsZSwgbmFtZSk7XG4gICAgICBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgICAgIHN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIGh5cGhlbmF0ZShwcmVmaXhlZCksXG4gICAgICAgICAgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsIFwiXCIpLFxuICAgICAgICAgIFwiaW1wb3J0YW50XCJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlW3ByZWZpeGVkXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHByZWZpeGVzID0gW1wiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIl07XG5jb25zdCBwcmVmaXhDYWNoZSA9IHt9O1xuZnVuY3Rpb24gYXV0b1ByZWZpeChzdHlsZSwgcmF3TmFtZSkge1xuICBjb25zdCBjYWNoZWQgPSBwcmVmaXhDYWNoZVtyYXdOYW1lXTtcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbiAgbGV0IG5hbWUgPSBjYW1lbGl6ZShyYXdOYW1lKTtcbiAgaWYgKG5hbWUgIT09IFwiZmlsdGVyXCIgJiYgbmFtZSBpbiBzdHlsZSkge1xuICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IG5hbWU7XG4gIH1cbiAgbmFtZSA9IGNhcGl0YWxpemUobmFtZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcbiAgICBpZiAocHJlZml4ZWQgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmF3TmFtZTtcbn1cblxuY29uc3QgeGxpbmtOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiO1xuZnVuY3Rpb24gcGF0Y2hBdHRyKGVsLCBrZXksIHZhbHVlLCBpc1NWRywgaW5zdGFuY2UsIGlzQm9vbGVhbiA9IGlzU3BlY2lhbEJvb2xlYW5BdHRyKGtleSkpIHtcbiAgaWYgKGlzU1ZHICYmIGtleS5zdGFydHNXaXRoKFwieGxpbms6XCIpKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleS5zbGljZSg2LCBrZXkubGVuZ3RoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBpc0Jvb2xlYW4gJiYgIWluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXG4gICAgICAgIGtleSxcbiAgICAgICAgaXNCb29sZWFuID8gXCJcIiA6IGlzU3ltYm9sKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0Y2hET01Qcm9wKGVsLCBrZXksIHZhbHVlLCBwYXJlbnRDb21wb25lbnQsIGF0dHJOYW1lKSB7XG4gIGlmIChrZXkgPT09IFwiaW5uZXJIVE1MXCIgfHwga2V5ID09PSBcInRleHRDb250ZW50XCIpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgZWxba2V5XSA9IGtleSA9PT0gXCJpbm5lckhUTUxcIiA/IHVuc2FmZVRvVHJ1c3RlZEhUTUwodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YWcgPSBlbC50YWdOYW1lO1xuICBpZiAoa2V5ID09PSBcInZhbHVlXCIgJiYgdGFnICE9PSBcIlBST0dSRVNTXCIgJiYgLy8gY3VzdG9tIGVsZW1lbnRzIG1heSB1c2UgX3ZhbHVlIGludGVybmFsbHlcbiAgIXRhZy5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhZyA9PT0gXCJPUFRJT05cIiA/IGVsLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIHx8IFwiXCIgOiBlbC52YWx1ZTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAoXG4gICAgICAvLyAjMTE2NDc6IHZhbHVlIHNob3VsZCBiZSBzZXQgYXMgZW1wdHkgc3RyaW5nIGZvciBudWxsIGFuZCB1bmRlZmluZWQsXG4gICAgICAvLyBidXQgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiPiBzaG91bGQgYmUgc2V0IGFzICdvbicuXG4gICAgICBlbC50eXBlID09PSBcImNoZWNrYm94XCIgPyBcIm9uXCIgOiBcIlwiXG4gICAgKSA6IFN0cmluZyh2YWx1ZSk7XG4gICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSB8fCAhKFwiX3ZhbHVlXCIgaW4gZWwpKSB7XG4gICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfVxuICAgIGVsLl92YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbmVlZFJlbW92ZSA9IGZhbHNlO1xuICBpZiAodmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcbiAgICBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHZhbHVlID0gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBlbFtrZXldID0gdmFsdWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhbmVlZFJlbW92ZSkge1xuICAgICAgd2FybihcbiAgICAgICAgYEZhaWxlZCBzZXR0aW5nIHByb3AgXCIke2tleX1cIiBvbiA8JHt0YWcudG9Mb3dlckNhc2UoKX0+OiB2YWx1ZSAke3ZhbHVlfSBpcyBpbnZhbGlkLmAsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIG5lZWRSZW1vdmUgJiYgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lIHx8IGtleSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5jb25zdCB2ZWlLZXkgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKFwiX3ZlaVwiKTtcbmZ1bmN0aW9uIHBhdGNoRXZlbnQoZWwsIHJhd05hbWUsIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpbnN0YW5jZSA9IG51bGwpIHtcbiAgY29uc3QgaW52b2tlcnMgPSBlbFt2ZWlLZXldIHx8IChlbFt2ZWlLZXldID0ge30pO1xuICBjb25zdCBleGlzdGluZ0ludm9rZXIgPSBpbnZva2Vyc1tyYXdOYW1lXTtcbiAgaWYgKG5leHRWYWx1ZSAmJiBleGlzdGluZ0ludm9rZXIpIHtcbiAgICBleGlzdGluZ0ludm9rZXIudmFsdWUgPSAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpID8gc2FuaXRpemVFdmVudFZhbHVlKG5leHRWYWx1ZSwgcmF3TmFtZSkgOiBuZXh0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW25hbWUsIG9wdGlvbnNdID0gcGFyc2VOYW1lKHJhd05hbWUpO1xuICAgIGlmIChuZXh0VmFsdWUpIHtcbiAgICAgIGNvbnN0IGludm9rZXIgPSBpbnZva2Vyc1tyYXdOYW1lXSA9IGNyZWF0ZUludm9rZXIoXG4gICAgICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBzYW5pdGl6ZUV2ZW50VmFsdWUobmV4dFZhbHVlLCByYXdOYW1lKSA6IG5leHRWYWx1ZSxcbiAgICAgICAgaW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBpbnZva2VyLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKGV4aXN0aW5nSW52b2tlcikge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgZXhpc3RpbmdJbnZva2VyLCBvcHRpb25zKTtcbiAgICAgIGludm9rZXJzW3Jhd05hbWVdID0gdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuY29uc3Qgb3B0aW9uc01vZGlmaWVyUkUgPSAvKD86T25jZXxQYXNzaXZlfENhcHR1cmUpJC87XG5mdW5jdGlvbiBwYXJzZU5hbWUobmFtZSkge1xuICBsZXQgb3B0aW9ucztcbiAgaWYgKG9wdGlvbnNNb2RpZmllclJFLnRlc3QobmFtZSkpIHtcbiAgICBvcHRpb25zID0ge307XG4gICAgbGV0IG07XG4gICAgd2hpbGUgKG0gPSBuYW1lLm1hdGNoKG9wdGlvbnNNb2RpZmllclJFKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGggLSBtWzBdLmxlbmd0aCk7XG4gICAgICBvcHRpb25zW21bMF0udG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICBjb25zdCBldmVudCA9IG5hbWVbMl0gPT09IFwiOlwiID8gbmFtZS5zbGljZSgzKSA6IGh5cGhlbmF0ZShuYW1lLnNsaWNlKDIpKTtcbiAgcmV0dXJuIFtldmVudCwgb3B0aW9uc107XG59XG5sZXQgY2FjaGVkTm93ID0gMDtcbmNvbnN0IHAgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5jb25zdCBnZXROb3cgPSAoKSA9PiBjYWNoZWROb3cgfHwgKHAudGhlbigoKSA9PiBjYWNoZWROb3cgPSAwKSwgY2FjaGVkTm93ID0gRGF0ZS5ub3coKSk7XG5mdW5jdGlvbiBjcmVhdGVJbnZva2VyKGluaXRpYWxWYWx1ZSwgaW5zdGFuY2UpIHtcbiAgY29uc3QgaW52b2tlciA9IChlKSA9PiB7XG4gICAgaWYgKCFlLl92dHMpIHtcbiAgICAgIGUuX3Z0cyA9IERhdGUubm93KCk7XG4gICAgfSBlbHNlIGlmIChlLl92dHMgPD0gaW52b2tlci5hdHRhY2hlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhcbiAgICAgIHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIGludm9rZXIudmFsdWUpLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICA1LFxuICAgICAgW2VdXG4gICAgKTtcbiAgfTtcbiAgaW52b2tlci52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgaW52b2tlci5hdHRhY2hlZCA9IGdldE5vdygpO1xuICByZXR1cm4gaW52b2tlcjtcbn1cbmZ1bmN0aW9uIHNhbml0aXplRXZlbnRWYWx1ZSh2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpIHx8IGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHdhcm4oXG4gICAgYFdyb25nIHR5cGUgcGFzc2VkIGFzIGV2ZW50IGhhbmRsZXIgdG8gJHtwcm9wTmFtZX0gLSBkaWQgeW91IGZvcmdldCBAIG9yIDogaW4gZnJvbnQgb2YgeW91ciBwcm9wP1xuRXhwZWN0ZWQgZnVuY3Rpb24gb3IgYXJyYXkgb2YgZnVuY3Rpb25zLCByZWNlaXZlZCB0eXBlICR7dHlwZW9mIHZhbHVlfS5gXG4gICk7XG4gIHJldHVybiBOT09QO1xufVxuZnVuY3Rpb24gcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgdmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb247XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSAoKSA9PiB7XG4gICAgICBvcmlnaW5hbFN0b3AuY2FsbChlKTtcbiAgICAgIGUuX3N0b3BwZWQgPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIHZhbHVlLm1hcChcbiAgICAgIChmbikgPT4gKGUyKSA9PiAhZTIuX3N0b3BwZWQgJiYgZm4gJiYgZm4oZTIpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuY29uc3QgaXNOYXRpdmVPbiA9IChrZXkpID0+IGtleS5jaGFyQ29kZUF0KDApID09PSAxMTEgJiYga2V5LmNoYXJDb2RlQXQoMSkgPT09IDExMCAmJiAvLyBsb3dlcmNhc2UgbGV0dGVyXG5rZXkuY2hhckNvZGVBdCgyKSA+IDk2ICYmIGtleS5jaGFyQ29kZUF0KDIpIDwgMTIzO1xuY29uc3QgcGF0Y2hQcm9wID0gKGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBuYW1lc3BhY2UsIHBhcmVudENvbXBvbmVudCkgPT4ge1xuICBjb25zdCBpc1NWRyA9IG5hbWVzcGFjZSA9PT0gXCJzdmdcIjtcbiAgaWYgKGtleSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgcGF0Y2hDbGFzcyhlbCwgbmV4dFZhbHVlLCBpc1NWRyk7XG4gIH0gZWxzZSBpZiAoa2V5ID09PSBcInN0eWxlXCIpIHtcbiAgICBwYXRjaFN0eWxlKGVsLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNPbihrZXkpKSB7XG4gICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xuICAgICAgcGF0Y2hFdmVudChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoa2V5WzBdID09PSBcIi5cIiA/IChrZXkgPSBrZXkuc2xpY2UoMSksIHRydWUpIDoga2V5WzBdID09PSBcIl5cIiA/IChrZXkgPSBrZXkuc2xpY2UoMSksIGZhbHNlKSA6IHNob3VsZFNldEFzUHJvcChlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKSkge1xuICAgIHBhdGNoRE9NUHJvcChlbCwga2V5LCBuZXh0VmFsdWUpO1xuICAgIGlmICghZWwudGFnTmFtZS5pbmNsdWRlcyhcIi1cIikgJiYgKGtleSA9PT0gXCJ2YWx1ZVwiIHx8IGtleSA9PT0gXCJjaGVja2VkXCIgfHwga2V5ID09PSBcInNlbGVjdGVkXCIpKSB7XG4gICAgICBwYXRjaEF0dHIoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRywgcGFyZW50Q29tcG9uZW50LCBrZXkgIT09IFwidmFsdWVcIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgIC8vICMxMTA4MSBmb3JjZSBzZXQgcHJvcHMgZm9yIHBvc3NpYmxlIGFzeW5jIGN1c3RvbSBlbGVtZW50XG4gICAgZWwuX2lzVnVlQ0UgJiYgKC9bQS1aXS8udGVzdChrZXkpIHx8ICFpc1N0cmluZyhuZXh0VmFsdWUpKVxuICApIHtcbiAgICBwYXRjaERPTVByb3AoZWwsIGNhbWVsaXplJDEoa2V5KSwgbmV4dFZhbHVlLCBwYXJlbnRDb21wb25lbnQsIGtleSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGtleSA9PT0gXCJ0cnVlLXZhbHVlXCIpIHtcbiAgICAgIGVsLl90cnVlVmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiZmFsc2UtdmFsdWVcIikge1xuICAgICAgZWwuX2ZhbHNlVmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfVxuICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNob3VsZFNldEFzUHJvcChlbCwga2V5LCB2YWx1ZSwgaXNTVkcpIHtcbiAgaWYgKGlzU1ZHKSB7XG4gICAgaWYgKGtleSA9PT0gXCJpbm5lckhUTUxcIiB8fCBrZXkgPT09IFwidGV4dENvbnRlbnRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChrZXkgaW4gZWwgJiYgaXNOYXRpdmVPbihrZXkpICYmIGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwic3BlbGxjaGVja1wiIHx8IGtleSA9PT0gXCJkcmFnZ2FibGVcIiB8fCBrZXkgPT09IFwidHJhbnNsYXRlXCIgfHwga2V5ID09PSBcImF1dG9jb3JyZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJzYW5kYm94XCIgJiYgZWwudGFnTmFtZSA9PT0gXCJJRlJBTUVcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImZvcm1cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoa2V5ID09PSBcImxpc3RcIiAmJiBlbC50YWdOYW1lID09PSBcIklOUFVUXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGtleSA9PT0gXCJ0eXBlXCIgJiYgZWwudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChrZXkgPT09IFwid2lkdGhcIiB8fCBrZXkgPT09IFwiaGVpZ2h0XCIpIHtcbiAgICBjb25zdCB0YWcgPSBlbC50YWdOYW1lO1xuICAgIGlmICh0YWcgPT09IFwiSU1HXCIgfHwgdGFnID09PSBcIlZJREVPXCIgfHwgdGFnID09PSBcIkNBTlZBU1wiIHx8IHRhZyA9PT0gXCJTT1VSQ0VcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOYXRpdmVPbihrZXkpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5IGluIGVsO1xufVxuXG5jb25zdCBSRU1PVkFMID0ge307XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBleHRyYU9wdGlvbnMsIF9jcmVhdGVBcHApIHtcbiAgbGV0IENvbXAgPSBkZWZpbmVDb21wb25lbnQob3B0aW9ucywgZXh0cmFPcHRpb25zKTtcbiAgaWYgKGlzUGxhaW5PYmplY3QoQ29tcCkpIENvbXAgPSBleHRlbmQoe30sIENvbXAsIGV4dHJhT3B0aW9ucyk7XG4gIGNsYXNzIFZ1ZUN1c3RvbUVsZW1lbnQgZXh0ZW5kcyBWdWVFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsUHJvcHMpIHtcbiAgICAgIHN1cGVyKENvbXAsIGluaXRpYWxQcm9wcywgX2NyZWF0ZUFwcCk7XG4gICAgfVxuICB9XG4gIFZ1ZUN1c3RvbUVsZW1lbnQuZGVmID0gQ29tcDtcbiAgcmV0dXJuIFZ1ZUN1c3RvbUVsZW1lbnQ7XG59XG5jb25zdCBkZWZpbmVTU1JDdXN0b21FbGVtZW50ID0gKC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChvcHRpb25zLCBleHRyYU9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGV4dHJhT3B0aW9ucywgY3JlYXRlU1NSQXBwKTtcbn0pO1xuY29uc3QgQmFzZUNsYXNzID0gdHlwZW9mIEhUTUxFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gSFRNTEVsZW1lbnQgOiBjbGFzcyB7XG59O1xuY2xhc3MgVnVlRWxlbWVudCBleHRlbmRzIEJhc2VDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9kZWYsIF9wcm9wcyA9IHt9LCBfY3JlYXRlQXBwID0gY3JlYXRlQXBwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9kZWYgPSBfZGVmO1xuICAgIHRoaXMuX3Byb3BzID0gX3Byb3BzO1xuICAgIHRoaXMuX2NyZWF0ZUFwcCA9IF9jcmVhdGVBcHA7XG4gICAgdGhpcy5faXNWdWVDRSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2FwcCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fbm9uY2UgPSB0aGlzLl9kZWYubm9uY2U7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXRjaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudWxsO1xuICAgIHRoaXMuX3N0eWxlQ2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICB0aGlzLl9vYiA9IG51bGw7XG4gICAgaWYgKHRoaXMuc2hhZG93Um9vdCAmJiBfY3JlYXRlQXBwICE9PSBjcmVhdGVBcHApIHtcbiAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLnNoYWRvd1Jvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBDdXN0b20gZWxlbWVudCBoYXMgcHJlLXJlbmRlcmVkIGRlY2xhcmF0aXZlIHNoYWRvdyByb290IGJ1dCBpcyBub3QgZGVmaW5lZCBhcyBoeWRyYXRhYmxlLiBVc2UgXFxgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudFxcYC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoX2RlZi5zaGFkb3dSb290ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyhcbiAgICAgICAgICBleHRlbmQoe30sIF9kZWYuc2hhZG93Um9vdE9wdGlvbnMsIHtcbiAgICAgICAgICAgIG1vZGU6IFwib3BlblwiXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuc2hhZG93Um9vdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQpIHJldHVybjtcbiAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCAmJiAhdGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgIHRoaXMuX3BhcnNlU2xvdHMoKTtcbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICBsZXQgcGFyZW50ID0gdGhpcztcbiAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50ICYmIChwYXJlbnQucGFyZW50Tm9kZSB8fCBwYXJlbnQuaG9zdCkpIHtcbiAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBWdWVFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIGlmICh0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICB0aGlzLl9tb3VudCh0aGlzLl9kZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmdSZXNvbHZlKSB7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSBwYXJlbnQuX3BlbmRpbmdSZXNvbHZlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSB2b2lkIDA7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlRGVmKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZURlZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9zZXRQYXJlbnQocGFyZW50ID0gdGhpcy5fcGFyZW50KSB7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy5faW5zdGFuY2UucGFyZW50ID0gcGFyZW50Ll9pbnN0YW5jZTtcbiAgICAgIHRoaXMuX2luaGVyaXRQYXJlbnRDb250ZXh0KHBhcmVudCk7XG4gICAgfVxuICB9XG4gIF9pbmhlcml0UGFyZW50Q29udGV4dChwYXJlbnQgPSB0aGlzLl9wYXJlbnQpIHtcbiAgICBpZiAocGFyZW50ICYmIHRoaXMuX2FwcCkge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKFxuICAgICAgICB0aGlzLl9hcHAuX2NvbnRleHQucHJvdmlkZXMsXG4gICAgICAgIHBhcmVudC5faW5zdGFuY2UucHJvdmlkZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9vYikge1xuICAgICAgICAgIHRoaXMuX29iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICB0aGlzLl9vYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXBwICYmIHRoaXMuX2FwcC51bm1vdW50KCk7XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkgdGhpcy5faW5zdGFuY2UuY2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX2FwcCA9IHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3RlbGVwb3J0VGFyZ2V0cykge1xuICAgICAgICAgIHRoaXMuX3RlbGVwb3J0VGFyZ2V0cy5jbGVhcigpO1xuICAgICAgICAgIHRoaXMuX3RlbGVwb3J0VGFyZ2V0cyA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgIGZvciAoY29uc3QgbSBvZiBtdXRhdGlvbnMpIHtcbiAgICAgIHRoaXMuX3NldEF0dHIobS5hdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIHJlc29sdmUgaW5uZXIgY29tcG9uZW50IGRlZmluaXRpb24gKGhhbmRsZSBwb3NzaWJsZSBhc3luYyBjb21wb25lbnQpXG4gICAqL1xuICBfcmVzb2x2ZURlZigpIHtcbiAgICBpZiAodGhpcy5fcGVuZGluZ1Jlc29sdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3NldEF0dHIodGhpcy5hdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgIH1cbiAgICB0aGlzLl9vYiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3Byb2Nlc3NNdXRhdGlvbnMuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fb2Iub2JzZXJ2ZSh0aGlzLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgY29uc3QgcmVzb2x2ZSA9IChkZWYsIGlzQXN5bmMgPSBmYWxzZSkgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fcGVuZGluZ1Jlc29sdmUgPSB2b2lkIDA7XG4gICAgICBjb25zdCB7IHByb3BzLCBzdHlsZXMgfSA9IGRlZjtcbiAgICAgIGxldCBudW1iZXJQcm9wcztcbiAgICAgIGlmIChwcm9wcyAmJiAhaXNBcnJheShwcm9wcykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICBjb25zdCBvcHQgPSBwcm9wc1trZXldO1xuICAgICAgICAgIGlmIChvcHQgPT09IE51bWJlciB8fCBvcHQgJiYgb3B0LnR5cGUgPT09IE51bWJlcikge1xuICAgICAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9wcm9wcykge1xuICAgICAgICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdG9OdW1iZXIodGhpcy5fcHJvcHNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAobnVtYmVyUHJvcHMgfHwgKG51bWJlclByb3BzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpKVtjYW1lbGl6ZSQxKGtleSldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX251bWJlclByb3BzID0gbnVtYmVyUHJvcHM7XG4gICAgICB0aGlzLl9yZXNvbHZlUHJvcHMoZGVmKTtcbiAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMoc3R5bGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBzdHlsZXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkN1c3RvbSBlbGVtZW50IHN0eWxlIGluamVjdGlvbiBpcyBub3Qgc3VwcG9ydGVkIHdoZW4gdXNpbmcgc2hhZG93Um9vdDogZmFsc2VcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fbW91bnQoZGVmKTtcbiAgICB9O1xuICAgIGNvbnN0IGFzeW5jRGVmID0gdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXI7XG4gICAgaWYgKGFzeW5jRGVmKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nUmVzb2x2ZSA9IGFzeW5jRGVmKCkudGhlbigoZGVmKSA9PiB7XG4gICAgICAgIGRlZi5jb25maWd1cmVBcHAgPSB0aGlzLl9kZWYuY29uZmlndXJlQXBwO1xuICAgICAgICByZXNvbHZlKHRoaXMuX2RlZiA9IGRlZiwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZSh0aGlzLl9kZWYpO1xuICAgIH1cbiAgfVxuICBfbW91bnQoZGVmKSB7XG4gICAgaWYgKCghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykgJiYgIWRlZi5uYW1lKSB7XG4gICAgICBkZWYubmFtZSA9IFwiVnVlRWxlbWVudFwiO1xuICAgIH1cbiAgICB0aGlzLl9hcHAgPSB0aGlzLl9jcmVhdGVBcHAoZGVmKTtcbiAgICB0aGlzLl9pbmhlcml0UGFyZW50Q29udGV4dCgpO1xuICAgIGlmIChkZWYuY29uZmlndXJlQXBwKSB7XG4gICAgICBkZWYuY29uZmlndXJlQXBwKHRoaXMuX2FwcCk7XG4gICAgfVxuICAgIHRoaXMuX2FwcC5fY2VWTm9kZSA9IHRoaXMuX2NyZWF0ZVZOb2RlKCk7XG4gICAgdGhpcy5fYXBwLm1vdW50KHRoaXMuX3Jvb3QpO1xuICAgIGNvbnN0IGV4cG9zZWQgPSB0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9pbnN0YW5jZS5leHBvc2VkO1xuICAgIGlmICghZXhwb3NlZCkgcmV0dXJuO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGV4cG9zZWQpIHtcbiAgICAgIGlmICghaGFzT3duKHRoaXMsIGtleSkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgIC8vIHVud3JhcCByZWYgdG8gYmUgY29uc2lzdGVudCB3aXRoIHB1YmxpYyBpbnN0YW5jZSBiZWhhdmlvclxuICAgICAgICAgIGdldDogKCkgPT4gdW5yZWYoZXhwb3NlZFtrZXldKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICB3YXJuKGBFeHBvc2VkIHByb3BlcnR5IFwiJHtrZXl9XCIgYWxyZWFkeSBleGlzdHMgb24gY3VzdG9tIGVsZW1lbnQuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9yZXNvbHZlUHJvcHMoZGVmKSB7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gZGVmO1xuICAgIGNvbnN0IGRlY2xhcmVkUHJvcEtleXMgPSBpc0FycmF5KHByb3BzKSA/IHByb3BzIDogT2JqZWN0LmtleXMocHJvcHMgfHwge30pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMpKSB7XG4gICAgICBpZiAoa2V5WzBdICE9PSBcIl9cIiAmJiBkZWNsYXJlZFByb3BLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHRoaXNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGRlY2xhcmVkUHJvcEtleXMubWFwKGNhbWVsaXplJDEpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChrZXkpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHZhbCwgdHJ1ZSwgIXRoaXMuX3BhdGNoaW5nKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9zZXRBdHRyKGtleSkge1xuICAgIGlmIChrZXkuc3RhcnRzV2l0aChcImRhdGEtdi1cIikpIHJldHVybjtcbiAgICBjb25zdCBoYXMgPSB0aGlzLmhhc0F0dHJpYnV0ZShrZXkpO1xuICAgIGxldCB2YWx1ZSA9IGhhcyA/IHRoaXMuZ2V0QXR0cmlidXRlKGtleSkgOiBSRU1PVkFMO1xuICAgIGNvbnN0IGNhbWVsS2V5ID0gY2FtZWxpemUkMShrZXkpO1xuICAgIGlmIChoYXMgJiYgdGhpcy5fbnVtYmVyUHJvcHMgJiYgdGhpcy5fbnVtYmVyUHJvcHNbY2FtZWxLZXldKSB7XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0UHJvcChjYW1lbEtleSwgdmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZ2V0UHJvcChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvcHNba2V5XTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2V0UHJvcChrZXksIHZhbCwgc2hvdWxkUmVmbGVjdCA9IHRydWUsIHNob3VsZFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKHZhbCAhPT0gdGhpcy5fcHJvcHNba2V5XSkge1xuICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgaWYgKHZhbCA9PT0gUkVNT1ZBTCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fcHJvcHNba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB2YWw7XG4gICAgICAgIGlmIChrZXkgPT09IFwia2V5XCIgJiYgdGhpcy5fYXBwKSB7XG4gICAgICAgICAgdGhpcy5fYXBwLl9jZVZOb2RlLmtleSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFVwZGF0ZSAmJiB0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZWZsZWN0KSB7XG4gICAgICAgIGNvbnN0IG9iID0gdGhpcy5fb2I7XG4gICAgICAgIGlmIChvYikge1xuICAgICAgICAgIHRoaXMuX3Byb2Nlc3NNdXRhdGlvbnMob2IudGFrZVJlY29yZHMoKSk7XG4gICAgICAgICAgb2IuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSwgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksIHZhbCArIFwiXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKCF2YWwpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgb2IgJiYgb2Iub2JzZXJ2ZSh0aGlzLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF91cGRhdGUoKSB7XG4gICAgY29uc3Qgdm5vZGUgPSB0aGlzLl9jcmVhdGVWTm9kZSgpO1xuICAgIGlmICh0aGlzLl9hcHApIHZub2RlLmFwcENvbnRleHQgPSB0aGlzLl9hcHAuX2NvbnRleHQ7XG4gICAgcmVuZGVyKHZub2RlLCB0aGlzLl9yb290KTtcbiAgfVxuICBfY3JlYXRlVk5vZGUoKSB7XG4gICAgY29uc3QgYmFzZVByb3BzID0ge307XG4gICAgaWYgKCF0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgIGJhc2VQcm9wcy5vblZub2RlTW91bnRlZCA9IGJhc2VQcm9wcy5vblZub2RlVXBkYXRlZCA9IHRoaXMuX3JlbmRlclNsb3RzLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUodGhpcy5fZGVmLCBleHRlbmQoYmFzZVByb3BzLCB0aGlzLl9wcm9wcykpO1xuICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgIHZub2RlLmNlID0gKGluc3RhbmNlKSA9PiB7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIGluc3RhbmNlLmNlID0gdGhpcztcbiAgICAgICAgaW5zdGFuY2UuaXNDRSA9IHRydWU7XG4gICAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgaW5zdGFuY2UuY2VSZWxvYWQgPSAobmV3U3R5bGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3R5bGVzKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5mb3JFYWNoKChzKSA9PiB0aGlzLl9yb290LnJlbW92ZUNoaWxkKHMpKTtcbiAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hcHBseVN0eWxlcyhuZXdTdHlsZXMpO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNwYXRjaCA9IChldmVudCwgYXJncykgPT4ge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudChcbiAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgIGlzUGxhaW5PYmplY3QoYXJnc1swXSkgPyBleHRlbmQoeyBkZXRhaWw6IGFyZ3MgfSwgYXJnc1swXSkgOiB7IGRldGFpbDogYXJncyB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5zdGFuY2UuZW1pdCA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgICAgIGRpc3BhdGNoKGV2ZW50LCBhcmdzKTtcbiAgICAgICAgICBpZiAoaHlwaGVuYXRlKGV2ZW50KSAhPT0gZXZlbnQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGh5cGhlbmF0ZShldmVudCksIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2V0UGFyZW50KCk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG4gIH1cbiAgX2FwcGx5U3R5bGVzKHN0eWxlcywgb3duZXIpIHtcbiAgICBpZiAoIXN0eWxlcykgcmV0dXJuO1xuICAgIGlmIChvd25lcikge1xuICAgICAgaWYgKG93bmVyID09PSB0aGlzLl9kZWYgfHwgdGhpcy5fc3R5bGVDaGlsZHJlbi5oYXMob3duZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0eWxlQ2hpbGRyZW4uYWRkKG93bmVyKTtcbiAgICB9XG4gICAgY29uc3Qgbm9uY2UgPSB0aGlzLl9ub25jZTtcbiAgICBmb3IgKGxldCBpID0gc3R5bGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgaWYgKG5vbmNlKSBzLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgICAgIHMudGV4dENvbnRlbnQgPSBzdHlsZXNbaV07XG4gICAgICB0aGlzLnNoYWRvd1Jvb3QucHJlcGVuZChzKTtcbiAgICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgIGlmIChvd25lcikge1xuICAgICAgICAgIGlmIChvd25lci5fX2htcklkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NoaWxkU3R5bGVzKSB0aGlzLl9jaGlsZFN0eWxlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgICAgICBsZXQgZW50cnkgPSB0aGlzLl9jaGlsZFN0eWxlcy5nZXQob3duZXIuX19obXJJZCk7XG4gICAgICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NoaWxkU3R5bGVzLnNldChvd25lci5fX2htcklkLCBlbnRyeSA9IFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJ5LnB1c2gocyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICh0aGlzLl9zdHlsZXMgfHwgKHRoaXMuX3N0eWxlcyA9IFtdKSkucHVzaChzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogT25seSBjYWxsZWQgd2hlbiBzaGFkb3dSb290IGlzIGZhbHNlXG4gICAqL1xuICBfcGFyc2VTbG90cygpIHtcbiAgICBjb25zdCBzbG90cyA9IHRoaXMuX3Nsb3RzID0ge307XG4gICAgbGV0IG47XG4gICAgd2hpbGUgKG4gPSB0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGNvbnN0IHNsb3ROYW1lID0gbi5ub2RlVHlwZSA9PT0gMSAmJiBuLmdldEF0dHJpYnV0ZShcInNsb3RcIikgfHwgXCJkZWZhdWx0XCI7XG4gICAgICAoc2xvdHNbc2xvdE5hbWVdIHx8IChzbG90c1tzbG90TmFtZV0gPSBbXSkpLnB1c2gobik7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKG4pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogT25seSBjYWxsZWQgd2hlbiBzaGFkb3dSb290IGlzIGZhbHNlXG4gICAqL1xuICBfcmVuZGVyU2xvdHMoKSB7XG4gICAgY29uc3Qgb3V0bGV0cyA9IHRoaXMuX2dldFNsb3RzKCk7XG4gICAgY29uc3Qgc2NvcGVJZCA9IHRoaXMuX2luc3RhbmNlLnR5cGUuX19zY29wZUlkO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0bGV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbyA9IG91dGxldHNbaV07XG4gICAgICBjb25zdCBzbG90TmFtZSA9IG8uZ2V0QXR0cmlidXRlKFwibmFtZVwiKSB8fCBcImRlZmF1bHRcIjtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9zbG90c1tzbG90TmFtZV07XG4gICAgICBjb25zdCBwYXJlbnQgPSBvLnBhcmVudE5vZGU7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgY29udGVudCkge1xuICAgICAgICAgIGlmIChzY29wZUlkICYmIG4ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gc2NvcGVJZCArIFwiLXNcIjtcbiAgICAgICAgICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIobiwgMSk7XG4gICAgICAgICAgICBuLnNldEF0dHJpYnV0ZShpZCwgXCJcIik7XG4gICAgICAgICAgICBsZXQgY2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGQgPSB3YWxrZXIubmV4dE5vZGUoKSkge1xuICAgICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoaWQsIFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG4sIG8pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAoby5maXJzdENoaWxkKSBwYXJlbnQuaW5zZXJ0QmVmb3JlKG8uZmlyc3RDaGlsZCwgbyk7XG4gICAgICB9XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9nZXRTbG90cygpIHtcbiAgICBjb25zdCByb290cyA9IFt0aGlzXTtcbiAgICBpZiAodGhpcy5fdGVsZXBvcnRUYXJnZXRzKSB7XG4gICAgICByb290cy5wdXNoKC4uLnRoaXMuX3RlbGVwb3J0VGFyZ2V0cyk7XG4gICAgfVxuICAgIGNvbnN0IHNsb3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMpIHtcbiAgICAgIGNvbnN0IGZvdW5kID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKFwic2xvdFwiKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm91bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2xvdHMuYWRkKGZvdW5kW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oc2xvdHMpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9pbmplY3RDaGlsZFN0eWxlKGNvbXApIHtcbiAgICB0aGlzLl9hcHBseVN0eWxlcyhjb21wLnN0eWxlcywgY29tcCk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2JlZ2luUGF0Y2goKSB7XG4gICAgdGhpcy5fcGF0Y2hpbmcgPSB0cnVlO1xuICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2VuZFBhdGNoKCkge1xuICAgIHRoaXMuX3BhdGNoaW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuX2RpcnR5ICYmIHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3JlbW92ZUNoaWxkU3R5bGUoY29tcCkge1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICB0aGlzLl9zdHlsZUNoaWxkcmVuLmRlbGV0ZShjb21wKTtcbiAgICAgIGlmICh0aGlzLl9jaGlsZFN0eWxlcyAmJiBjb21wLl9faG1ySWQpIHtcbiAgICAgICAgY29uc3Qgb2xkU3R5bGVzID0gdGhpcy5fY2hpbGRTdHlsZXMuZ2V0KGNvbXAuX19obXJJZCk7XG4gICAgICAgIGlmIChvbGRTdHlsZXMpIHtcbiAgICAgICAgICBvbGRTdHlsZXMuZm9yRWFjaCgocykgPT4gdGhpcy5fcm9vdC5yZW1vdmVDaGlsZChzKSk7XG4gICAgICAgICAgb2xkU3R5bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZUhvc3QoY2FsbGVyKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gIGNvbnN0IGVsID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuY2U7XG4gIGlmIChlbCkge1xuICAgIHJldHVybiBlbDtcbiAgfSBlbHNlIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgd2FybihcbiAgICAgICAgYCR7Y2FsbGVyIHx8IFwidXNlSG9zdFwifSBjYWxsZWQgd2l0aG91dCBhbiBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlLmBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGAke2NhbGxlciB8fCBcInVzZUhvc3RcIn0gY2FuIG9ubHkgYmUgdXNlZCBpbiBjb21wb25lbnRzIGRlZmluZWQgdmlhIGRlZmluZUN1c3RvbUVsZW1lbnQuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1c2VTaGFkb3dSb290KCkge1xuICBjb25zdCBlbCA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyB1c2VIb3N0KFwidXNlU2hhZG93Um9vdFwiKSA6IHVzZUhvc3QoKTtcbiAgcmV0dXJuIGVsICYmIGVsLnNoYWRvd1Jvb3Q7XG59XG5cbmZ1bmN0aW9uIHVzZUNzc01vZHVsZShuYW1lID0gXCIkc3R5bGVcIikge1xuICB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYHVzZUNzc01vZHVsZSBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgc2V0dXAoKWApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlcyA9IGluc3RhbmNlLnR5cGUuX19jc3NNb2R1bGVzO1xuICAgIGlmICghbW9kdWxlcykge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZXMgaW5qZWN0ZWQuYCk7XG4gICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgIH1cbiAgICBjb25zdCBtb2QgPSBtb2R1bGVzW25hbWVdO1xuICAgIGlmICghbW9kKSB7XG4gICAgICAhIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdhcm4oYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlIG5hbWVkIFwiJHtuYW1lfVwiLmApO1xuICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICB9XG4gICAgcmV0dXJuIG1vZDtcbiAgfVxufVxuXG5jb25zdCBwb3NpdGlvbk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuY29uc3QgbmV3UG9zaXRpb25NYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG1vdmVDYktleSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXCJfbW92ZUNiXCIpO1xuY29uc3QgZW50ZXJDYktleSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXCJfZW50ZXJDYlwiKTtcbmNvbnN0IGRlY29yYXRlID0gKHQpID0+IHtcbiAgZGVsZXRlIHQucHJvcHMubW9kZTtcbiAgcmV0dXJuIHQ7XG59O1xuY29uc3QgVHJhbnNpdGlvbkdyb3VwSW1wbCA9IC8qIEBfX1BVUkVfXyAqLyBkZWNvcmF0ZSh7XG4gIG5hbWU6IFwiVHJhbnNpdGlvbkdyb3VwXCIsXG4gIHByb3BzOiAvKiBAX19QVVJFX18gKi8gZXh0ZW5kKHt9LCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCB7XG4gICAgdGFnOiBTdHJpbmcsXG4gICAgbW92ZUNsYXNzOiBTdHJpbmdcbiAgfSksXG4gIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XG4gICAgbGV0IHByZXZDaGlsZHJlbjtcbiAgICBsZXQgY2hpbGRyZW47XG4gICAgb25VcGRhdGVkKCgpID0+IHtcbiAgICAgIGlmICghcHJldkNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBtb3ZlQ2xhc3MgPSBwcm9wcy5tb3ZlQ2xhc3MgfHwgYCR7cHJvcHMubmFtZSB8fCBcInZcIn0tbW92ZWA7XG4gICAgICBpZiAoIWhhc0NTU1RyYW5zZm9ybShcbiAgICAgICAgcHJldkNoaWxkcmVuWzBdLmVsLFxuICAgICAgICBpbnN0YW5jZS52bm9kZS5lbCxcbiAgICAgICAgbW92ZUNsYXNzXG4gICAgICApKSB7XG4gICAgICAgIHByZXZDaGlsZHJlbiA9IFtdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgICBjb25zdCBtb3ZlZENoaWxkcmVuID0gcHJldkNoaWxkcmVuLmZpbHRlcihhcHBseVRyYW5zbGF0aW9uKTtcbiAgICAgIGZvcmNlUmVmbG93KGluc3RhbmNlLnZub2RlLmVsKTtcbiAgICAgIG1vdmVkQ2hpbGRyZW4uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IGMuZWw7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gXCJcIjtcbiAgICAgICAgY29uc3QgY2IgPSBlbFttb3ZlQ2JLZXldID0gKGUpID0+IHtcbiAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFlIHx8IGUucHJvcGVydHlOYW1lLmVuZHNXaXRoKFwidHJhbnNmb3JtXCIpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBjYik7XG4gICAgICAgICAgICBlbFttb3ZlQ2JLZXldID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGNiKTtcbiAgICAgIH0pO1xuICAgICAgcHJldkNoaWxkcmVuID0gW107XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xuICAgICAgY29uc3QgY3NzVHJhbnNpdGlvblByb3BzID0gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcyk7XG4gICAgICBsZXQgdGFnID0gcmF3UHJvcHMudGFnIHx8IEZyYWdtZW50O1xuICAgICAgcHJldkNoaWxkcmVuID0gW107XG4gICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgaWYgKGNoaWxkLmVsICYmIGNoaWxkLmVsIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgcHJldkNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKFxuICAgICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgICAgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhcbiAgICAgICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgICAgICBjc3NUcmFuc2l0aW9uUHJvcHMsXG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChjaGlsZCwge1xuICAgICAgICAgICAgICBsZWZ0OiBjaGlsZC5lbC5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICB0b3A6IGNoaWxkLmVsLm9mZnNldFRvcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgPyBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpKSA6IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoXG4gICAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICAgIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiBjaGlsZC50eXBlICE9PSBUZXh0KSB7XG4gICAgICAgICAgd2FybihgPFRyYW5zaXRpb25Hcm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZC5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHRhZywgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH07XG4gIH1cbn0pO1xuY29uc3QgVHJhbnNpdGlvbkdyb3VwID0gVHJhbnNpdGlvbkdyb3VwSW1wbDtcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzKGMpIHtcbiAgY29uc3QgZWwgPSBjLmVsO1xuICBpZiAoZWxbbW92ZUNiS2V5XSkge1xuICAgIGVsW21vdmVDYktleV0oKTtcbiAgfVxuICBpZiAoZWxbZW50ZXJDYktleV0pIHtcbiAgICBlbFtlbnRlckNiS2V5XSgpO1xuICB9XG59XG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbihjKSB7XG4gIG5ld1Bvc2l0aW9uTWFwLnNldChjLCB7XG4gICAgbGVmdDogYy5lbC5vZmZzZXRMZWZ0LFxuICAgIHRvcDogYy5lbC5vZmZzZXRUb3BcbiAgfSk7XG59XG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uKGMpIHtcbiAgY29uc3Qgb2xkUG9zID0gcG9zaXRpb25NYXAuZ2V0KGMpO1xuICBjb25zdCBuZXdQb3MgPSBuZXdQb3NpdGlvbk1hcC5nZXQoYyk7XG4gIGNvbnN0IGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgY29uc3QgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgY29uc3QgcyA9IGMuZWwuc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLndlYmtpdFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtkeH1weCwke2R5fXB4KWA7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSBcIjBzXCI7XG4gICAgcmV0dXJuIGM7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0NTU1RyYW5zZm9ybShlbCwgcm9vdCwgbW92ZUNsYXNzKSB7XG4gIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gIGNvbnN0IF92dGMgPSBlbFt2dGNLZXldO1xuICBpZiAoX3Z0Yykge1xuICAgIF92dGMuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKChjKSA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgIH0pO1xuICB9XG4gIG1vdmVDbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGMpID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LmFkZChjKSk7XG4gIGNsb25lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgY29uc3QgY29udGFpbmVyID0gcm9vdC5ub2RlVHlwZSA9PT0gMSA/IHJvb3QgOiByb290LnBhcmVudE5vZGU7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjbG9uZSk7XG4gIGNvbnN0IHsgaGFzVHJhbnNmb3JtIH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjbG9uZSk7XG4gIHJldHVybiBoYXNUcmFuc2Zvcm07XG59XG5cbmNvbnN0IGdldE1vZGVsQXNzaWduZXIgPSAodm5vZGUpID0+IHtcbiAgY29uc3QgZm4gPSB2bm9kZS5wcm9wc1tcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIl0gfHwgZmFsc2U7XG4gIHJldHVybiBpc0FycmF5KGZuKSA/ICh2YWx1ZSkgPT4gaW52b2tlQXJyYXlGbnMoZm4sIHZhbHVlKSA6IGZuO1xufTtcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gIGlmICh0YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgdGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIpKTtcbiAgfVxufVxuY29uc3QgYXNzaWduS2V5ID0gLyogQF9fUFVSRV9fICovIFN5bWJvbChcIl9hc3NpZ25cIik7XG5mdW5jdGlvbiBjYXN0VmFsdWUodmFsdWUsIHRyaW0sIG51bWJlcikge1xuICBpZiAodHJpbSkgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIGlmIChudW1iZXIpIHZhbHVlID0gbG9vc2VUb051bWJlcih2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IHZNb2RlbFRleHQgPSB7XG4gIGNyZWF0ZWQoZWwsIHsgbW9kaWZpZXJzOiB7IGxhenksIHRyaW0sIG51bWJlciB9IH0sIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGNvbnN0IGNhc3RUb051bWJlciA9IG51bWJlciB8fCB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlID09PSBcIm51bWJlclwiO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGxhenkgPyBcImNoYW5nZVwiIDogXCJpbnB1dFwiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0LmNvbXBvc2luZykgcmV0dXJuO1xuICAgICAgZWxbYXNzaWduS2V5XShjYXN0VmFsdWUoZWwudmFsdWUsIHRyaW0sIGNhc3RUb051bWJlcikpO1xuICAgIH0pO1xuICAgIGlmICh0cmltIHx8IGNhc3RUb051bWJlcikge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICBlbC52YWx1ZSA9IGNhc3RWYWx1ZShlbC52YWx1ZSwgdHJpbSwgY2FzdFRvTnVtYmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWxhenkpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY29tcG9zaXRpb25zdGFydFwiLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgXCJjb21wb3NpdGlvbmVuZFwiLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgIH1cbiAgfSxcbiAgLy8gc2V0IHZhbHVlIG9uIG1vdW50ZWQgc28gaXQncyBhZnRlciBtaW4vbWF4IGZvciB0eXBlPVwicmFuZ2VcIlxuICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICBlbC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWU7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUsIG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBpZiAoZWwuY29tcG9zaW5nKSByZXR1cm47XG4gICAgY29uc3QgZWxWYWx1ZSA9IChudW1iZXIgfHwgZWwudHlwZSA9PT0gXCJudW1iZXJcIikgJiYgIS9eMFxcZC8udGVzdChlbC52YWx1ZSkgPyBsb29zZVRvTnVtYmVyKGVsLnZhbHVlKSA6IGVsLnZhbHVlO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTtcbiAgICBpZiAoZWxWYWx1ZSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsICYmIGVsLnR5cGUgIT09IFwicmFuZ2VcIikge1xuICAgICAgaWYgKGxhenkgJiYgdmFsdWUgPT09IG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmltICYmIGVsLnZhbHVlLnRyaW0oKSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICB9XG59O1xuY29uc3Qgdk1vZGVsQ2hlY2tib3ggPSB7XG4gIC8vICM0MDk2IGFycmF5IGNoZWNrYm94ZXMgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICBkZWVwOiB0cnVlLFxuICBjcmVhdGVkKGVsLCBfLCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbFZhbHVlID0gZWwuX21vZGVsVmFsdWU7XG4gICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSBnZXRWYWx1ZShlbCk7XG4gICAgICBjb25zdCBjaGVja2VkID0gZWwuY2hlY2tlZDtcbiAgICAgIGNvbnN0IGFzc2lnbiA9IGVsW2Fzc2lnbktleV07XG4gICAgICBpZiAoaXNBcnJheShtb2RlbFZhbHVlKSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGxvb3NlSW5kZXhPZihtb2RlbFZhbHVlLCBlbGVtZW50VmFsdWUpO1xuICAgICAgICBjb25zdCBmb3VuZCA9IGluZGV4ICE9PSAtMTtcbiAgICAgICAgaWYgKGNoZWNrZWQgJiYgIWZvdW5kKSB7XG4gICAgICAgICAgYXNzaWduKG1vZGVsVmFsdWUuY29uY2F0KGVsZW1lbnRWYWx1ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFjaGVja2VkICYmIGZvdW5kKSB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBbLi4ubW9kZWxWYWx1ZV07XG4gICAgICAgICAgZmlsdGVyZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBhc3NpZ24oZmlsdGVyZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzU2V0KG1vZGVsVmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZCA9IG5ldyBTZXQobW9kZWxWYWx1ZSk7XG4gICAgICAgIGlmIChjaGVja2VkKSB7XG4gICAgICAgICAgY2xvbmVkLmFkZChlbGVtZW50VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb25lZC5kZWxldGUoZWxlbWVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NpZ24oY2xvbmVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2lnbihnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIC8vIHNldCBpbml0aWFsIGNoZWNrZWQgb24gbW91bnQgdG8gd2FpdCBmb3IgdHJ1ZS12YWx1ZS9mYWxzZS12YWx1ZVxuICBtb3VudGVkOiBzZXRDaGVja2VkLFxuICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIHNldENoZWNrZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNldENoZWNrZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gIGVsLl9tb2RlbFZhbHVlID0gdmFsdWU7XG4gIGxldCBjaGVja2VkO1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjaGVja2VkID0gbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMTtcbiAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICBjaGVja2VkID0gdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlKSByZXR1cm47XG4gICAgY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIGdldENoZWNrYm94VmFsdWUoZWwsIHRydWUpKTtcbiAgfVxuICBpZiAoZWwuY2hlY2tlZCAhPT0gY2hlY2tlZCkge1xuICAgIGVsLmNoZWNrZWQgPSBjaGVja2VkO1xuICB9XG59XG5jb25zdCB2TW9kZWxSYWRpbyA9IHtcbiAgY3JlYXRlZChlbCwgeyB2YWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGVsW2Fzc2lnbktleV0oZ2V0VmFsdWUoZWwpKTtcbiAgICB9KTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IHZNb2RlbFNlbGVjdCA9IHtcbiAgLy8gPHNlbGVjdCBtdWx0aXBsZT4gdmFsdWUgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICBkZWVwOiB0cnVlLFxuICBjcmVhdGVkKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICBjb25zdCBpc1NldE1vZGVsID0gaXNTZXQodmFsdWUpO1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGVsLm9wdGlvbnMsIChvKSA9PiBvLnNlbGVjdGVkKS5tYXAoXG4gICAgICAgIChvKSA9PiBudW1iZXIgPyBsb29zZVRvTnVtYmVyKGdldFZhbHVlKG8pKSA6IGdldFZhbHVlKG8pXG4gICAgICApO1xuICAgICAgZWxbYXNzaWduS2V5XShcbiAgICAgICAgZWwubXVsdGlwbGUgPyBpc1NldE1vZGVsID8gbmV3IFNldChzZWxlY3RlZFZhbCkgOiBzZWxlY3RlZFZhbCA6IHNlbGVjdGVkVmFsWzBdXG4gICAgICApO1xuICAgICAgZWwuX2Fzc2lnbmluZyA9IHRydWU7XG4gICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGVsLl9hc3NpZ25pbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVsW2Fzc2lnbktleV0gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgfSxcbiAgLy8gc2V0IHZhbHVlIGluIG1vdW50ZWQgJiB1cGRhdGVkIGJlY2F1c2UgPHNlbGVjdD4gcmVsaWVzIG9uIGl0cyBjaGlsZHJlblxuICAvLyA8b3B0aW9uPnMuXG4gIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgX2JpbmRpbmcsIHZub2RlKSB7XG4gICAgZWxbYXNzaWduS2V5XSA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICB9LFxuICB1cGRhdGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICBpZiAoIWVsLl9hc3NpZ25pbmcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKSB7XG4gIGNvbnN0IGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgY29uc3QgaXNBcnJheVZhbHVlID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc011bHRpcGxlICYmICFpc0FycmF5VmFsdWUgJiYgIWlzU2V0KHZhbHVlKSkge1xuICAgICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgJiYgd2FybihcbiAgICAgIGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw+IGV4cGVjdHMgYW4gQXJyYXkgb3IgU2V0IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpfS5gXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBnZXRWYWx1ZShvcHRpb24pO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBpZiAoaXNBcnJheVZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvblR5cGUgPSB0eXBlb2Ygb3B0aW9uVmFsdWU7XG4gICAgICAgIGlmIChvcHRpb25UeXBlID09PSBcInN0cmluZ1wiIHx8IG9wdGlvblR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5zb21lKCh2KSA9PiBTdHJpbmcodikgPT09IFN0cmluZyhvcHRpb25WYWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgb3B0aW9uVmFsdWUpID4gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmhhcyhvcHRpb25WYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUgJiYgZWwuc2VsZWN0ZWRJbmRleCAhPT0gLTEpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XG4gIHJldHVybiBcIl92YWx1ZVwiIGluIGVsID8gZWwuX3ZhbHVlIDogZWwudmFsdWU7XG59XG5mdW5jdGlvbiBnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSB7XG4gIGNvbnN0IGtleSA9IGNoZWNrZWQgPyBcIl90cnVlVmFsdWVcIiA6IFwiX2ZhbHNlVmFsdWVcIjtcbiAgcmV0dXJuIGtleSBpbiBlbCA/IGVsW2tleV0gOiBjaGVja2VkO1xufVxuY29uc3Qgdk1vZGVsRHluYW1pYyA9IHtcbiAgY3JlYXRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgXCJjcmVhdGVkXCIpO1xuICB9LFxuICBtb3VudGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCBcIm1vdW50ZWRcIik7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xuICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIFwiYmVmb3JlVXBkYXRlXCIpO1xuICB9LFxuICB1cGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XG4gICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgXCJ1cGRhdGVkXCIpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNNb2RlbCh0YWdOYW1lLCB0eXBlKSB7XG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIGNhc2UgXCJTRUxFQ1RcIjpcbiAgICAgIHJldHVybiB2TW9kZWxTZWxlY3Q7XG4gICAgY2FzZSBcIlRFWFRBUkVBXCI6XG4gICAgICByZXR1cm4gdk1vZGVsVGV4dDtcbiAgICBkZWZhdWx0OlxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgICAgIHJldHVybiB2TW9kZWxDaGVja2JveDtcbiAgICAgICAgY2FzZSBcInJhZGlvXCI6XG4gICAgICAgICAgcmV0dXJuIHZNb2RlbFJhZGlvO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2TW9kZWxUZXh0O1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBob29rKSB7XG4gIGNvbnN0IG1vZGVsVG9Vc2UgPSByZXNvbHZlRHluYW1pY01vZGVsKFxuICAgIGVsLnRhZ05hbWUsXG4gICAgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZVxuICApO1xuICBjb25zdCBmbiA9IG1vZGVsVG9Vc2VbaG9va107XG4gIGZuICYmIGZuKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKTtcbn1cbmZ1bmN0aW9uIGluaXRWTW9kZWxGb3JTU1IoKSB7XG4gIHZNb2RlbFRleHQuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiAoeyB2YWx1ZSB9KTtcbiAgdk1vZGVsUmFkaW8uZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xuICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUVxdWFsKHZub2RlLnByb3BzLnZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICB9XG4gIH07XG4gIHZNb2RlbENoZWNrYm94LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgaWYgKHZub2RlLnByb3BzICYmIHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICB9XG4gIH07XG4gIHZNb2RlbER5bmFtaWMuZ2V0U1NSUHJvcHMgPSAoYmluZGluZywgdm5vZGUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZub2RlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoXG4gICAgICAvLyByZXNvbHZlRHluYW1pY01vZGVsIGV4cGVjdHMgYW4gdXBwZXJjYXNlIHRhZyBuYW1lLCBidXQgdm5vZGUudHlwZSBpcyBsb3dlcmNhc2VcbiAgICAgIHZub2RlLnR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGVcbiAgICApO1xuICAgIGlmIChtb2RlbFRvVXNlLmdldFNTUlByb3BzKSB7XG4gICAgICByZXR1cm4gbW9kZWxUb1VzZS5nZXRTU1JQcm9wcyhiaW5kaW5nLCB2bm9kZSk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBzeXN0ZW1Nb2RpZmllcnMgPSBbXCJjdHJsXCIsIFwic2hpZnRcIiwgXCJhbHRcIiwgXCJtZXRhXCJdO1xuY29uc3QgbW9kaWZpZXJHdWFyZHMgPSB7XG4gIHN0b3A6IChlKSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLFxuICBwcmV2ZW50OiAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxuICBzZWxmOiAoZSkgPT4gZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCxcbiAgY3RybDogKGUpID0+ICFlLmN0cmxLZXksXG4gIHNoaWZ0OiAoZSkgPT4gIWUuc2hpZnRLZXksXG4gIGFsdDogKGUpID0+ICFlLmFsdEtleSxcbiAgbWV0YTogKGUpID0+ICFlLm1ldGFLZXksXG4gIGxlZnQ6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDAsXG4gIG1pZGRsZTogKGUpID0+IFwiYnV0dG9uXCIgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMSxcbiAgcmlnaHQ6IChlKSA9PiBcImJ1dHRvblwiIGluIGUgJiYgZS5idXR0b24gIT09IDIsXG4gIGV4YWN0OiAoZSwgbW9kaWZpZXJzKSA9PiBzeXN0ZW1Nb2RpZmllcnMuc29tZSgobSkgPT4gZVtgJHttfUtleWBdICYmICFtb2RpZmllcnMuaW5jbHVkZXMobSkpXG59O1xuY29uc3Qgd2l0aE1vZGlmaWVycyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gZm4uX3dpdGhNb2RzIHx8IChmbi5fd2l0aE1vZHMgPSB7fSk7XG4gIGNvbnN0IGNhY2hlS2V5ID0gbW9kaWZpZXJzLmpvaW4oXCIuXCIpO1xuICByZXR1cm4gY2FjaGVbY2FjaGVLZXldIHx8IChjYWNoZVtjYWNoZUtleV0gPSAoKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGd1YXJkID0gbW9kaWZpZXJHdWFyZHNbbW9kaWZpZXJzW2ldXTtcbiAgICAgIGlmIChndWFyZCAmJiBndWFyZChldmVudCwgbW9kaWZpZXJzKSkgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gZm4oZXZlbnQsIC4uLmFyZ3MpO1xuICB9KSk7XG59O1xuY29uc3Qga2V5TmFtZXMgPSB7XG4gIGVzYzogXCJlc2NhcGVcIixcbiAgc3BhY2U6IFwiIFwiLFxuICB1cDogXCJhcnJvdy11cFwiLFxuICBsZWZ0OiBcImFycm93LWxlZnRcIixcbiAgcmlnaHQ6IFwiYXJyb3ctcmlnaHRcIixcbiAgZG93bjogXCJhcnJvdy1kb3duXCIsXG4gIGRlbGV0ZTogXCJiYWNrc3BhY2VcIlxufTtcbmNvbnN0IHdpdGhLZXlzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcbiAgY29uc3QgY2FjaGUgPSBmbi5fd2l0aEtleXMgfHwgKGZuLl93aXRoS2V5cyA9IHt9KTtcbiAgY29uc3QgY2FjaGVLZXkgPSBtb2RpZmllcnMuam9pbihcIi5cIik7XG4gIHJldHVybiBjYWNoZVtjYWNoZUtleV0gfHwgKGNhY2hlW2NhY2hlS2V5XSA9ICgoZXZlbnQpID0+IHtcbiAgICBpZiAoIShcImtleVwiIGluIGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBldmVudEtleSA9IGh5cGhlbmF0ZShldmVudC5rZXkpO1xuICAgIGlmIChtb2RpZmllcnMuc29tZShcbiAgICAgIChrKSA9PiBrID09PSBldmVudEtleSB8fCBrZXlOYW1lc1trXSA9PT0gZXZlbnRLZXlcbiAgICApKSB7XG4gICAgICByZXR1cm4gZm4oZXZlbnQpO1xuICAgIH1cbiAgfSkpO1xufTtcblxuY29uc3QgcmVuZGVyZXJPcHRpb25zID0gLyogQF9fUFVSRV9fICovIGV4dGVuZCh7IHBhdGNoUHJvcCB9LCBub2RlT3BzKTtcbmxldCByZW5kZXJlcjtcbmxldCBlbmFibGVkSHlkcmF0aW9uID0gZmFsc2U7XG5mdW5jdGlvbiBlbnN1cmVSZW5kZXJlcigpIHtcbiAgcmV0dXJuIHJlbmRlcmVyIHx8IChyZW5kZXJlciA9IGNyZWF0ZVJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucykpO1xufVxuZnVuY3Rpb24gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKSB7XG4gIHJlbmRlcmVyID0gZW5hYmxlZEh5ZHJhdGlvbiA/IHJlbmRlcmVyIDogY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKTtcbiAgZW5hYmxlZEh5ZHJhdGlvbiA9IHRydWU7XG4gIHJldHVybiByZW5kZXJlcjtcbn1cbmNvbnN0IHJlbmRlciA9ICgoLi4uYXJncykgPT4ge1xuICBlbnN1cmVSZW5kZXJlcigpLnJlbmRlciguLi5hcmdzKTtcbn0pO1xuY29uc3QgaHlkcmF0ZSA9ICgoLi4uYXJncykgPT4ge1xuICBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmh5ZHJhdGUoLi4uYXJncyk7XG59KTtcbmNvbnN0IGNyZWF0ZUFwcCA9ICgoLi4uYXJncykgPT4ge1xuICBjb25zdCBhcHAgPSBlbnN1cmVSZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xuICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gIH1cbiAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xuICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGFwcC5fY29tcG9uZW50O1xuICAgIGlmICghaXNGdW5jdGlvbihjb21wb25lbnQpICYmICFjb21wb25lbnQucmVuZGVyICYmICFjb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgIGNvbXBvbmVudC50ZW1wbGF0ZSA9IGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgfVxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGNvbnRhaW5lci50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHByb3h5ID0gbW91bnQoY29udGFpbmVyLCBmYWxzZSwgcmVzb2x2ZVJvb3ROYW1lc3BhY2UoY29udGFpbmVyKSk7XG4gICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoXCJ2LWNsb2FrXCIpO1xuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtdi1hcHBcIiwgXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbiAgcmV0dXJuIGFwcDtcbn0pO1xuY29uc3QgY3JlYXRlU1NSQXBwID0gKCguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGFwcCA9IGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xuICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XG4gICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcbiAgfVxuICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XG4gIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIHJldHVybiBtb3VudChjb250YWluZXIsIHRydWUsIHJlc29sdmVSb290TmFtZXNwYWNlKGNvbnRhaW5lcikpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGFwcDtcbn0pO1xuZnVuY3Rpb24gcmVzb2x2ZVJvb3ROYW1lc3BhY2UoY29udGFpbmVyKSB7XG4gIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgcmV0dXJuIFwic3ZnXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBNYXRoTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgY29udGFpbmVyIGluc3RhbmNlb2YgTWF0aE1MRWxlbWVudCkge1xuICAgIHJldHVybiBcIm1hdGhtbFwiO1xuICB9XG59XG5mdW5jdGlvbiBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsIFwiaXNOYXRpdmVUYWdcIiwge1xuICAgIHZhbHVlOiAodGFnKSA9PiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWR1RhZyh0YWcpIHx8IGlzTWF0aE1MVGFnKHRhZyksXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKSB7XG4gIGlmIChpc1J1bnRpbWVPbmx5KCkpIHtcbiAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBhcHAuY29uZmlnLmlzQ3VzdG9tRWxlbWVudDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgXCJpc0N1c3RvbUVsZW1lbnRcIiwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gaXNDdXN0b21FbGVtZW50O1xuICAgICAgfSxcbiAgICAgIHNldCgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgVGhlIFxcYGlzQ3VzdG9tRWxlbWVudFxcYCBjb25maWcgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBcXGBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50XFxgIGluc3RlYWQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGNvbXBpbGVyT3B0aW9ucyA9IGFwcC5jb25maWcuY29tcGlsZXJPcHRpb25zO1xuICAgIGNvbnN0IG1zZyA9IGBUaGUgXFxgY29tcGlsZXJPcHRpb25zXFxgIGNvbmZpZyBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZS5qcyB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyIChha2EgXCJmdWxsIGJ1aWxkXCIpLiBTaW5jZSB5b3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQsIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBtdXN0IGJlIHBhc3NlZCB0byBcXGBAdnVlL2NvbXBpbGVyLWRvbVxcYCBpbiB0aGUgYnVpbGQgc2V0dXAgaW5zdGVhZC5cbi0gRm9yIHZ1ZS1sb2FkZXI6IHBhc3MgaXQgdmlhIHZ1ZS1sb2FkZXIncyBcXGBjb21waWxlck9wdGlvbnNcXGAgbG9hZGVyIG9wdGlvbi5cbi0gRm9yIHZ1ZS1jbGk6IHNlZSBodHRwczovL2NsaS52dWVqcy5vcmcvZ3VpZGUvd2VicGFjay5odG1sI21vZGlmeWluZy1vcHRpb25zLW9mLWEtbG9hZGVyXG4tIEZvciB2aXRlOiBwYXNzIGl0IHZpYSBAdml0ZWpzL3BsdWdpbi12dWUgb3B0aW9ucy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS1wbHVnaW4tdnVlL3RyZWUvbWFpbi9wYWNrYWdlcy9wbHVnaW4tdnVlI2V4YW1wbGUtZm9yLXBhc3Npbmctb3B0aW9ucy10by12dWVjb21waWxlci1zZmNgO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCBcImNvbXBpbGVyT3B0aW9uc1wiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVyT3B0aW9ucztcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoaXNTdHJpbmcoY29udGFpbmVyKSkge1xuICAgIGNvbnN0IHJlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcbiAgICBpZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiAhcmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRmFpbGVkIHRvIG1vdW50IGFwcDogbW91bnQgdGFyZ2V0IHNlbGVjdG9yIFwiJHtjb250YWluZXJ9XCIgcmV0dXJuZWQgbnVsbC5gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmIHdpbmRvdy5TaGFkb3dSb290ICYmIGNvbnRhaW5lciBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290ICYmIGNvbnRhaW5lci5tb2RlID09PSBcImNsb3NlZFwiKSB7XG4gICAgd2FybihcbiAgICAgIGBtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBcXGB7bW9kZTogXCJjbG9zZWRcIn1cXGAgbWF5IGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBidWdzYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cbmxldCBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IGZhbHNlO1xuY29uc3QgaW5pdERpcmVjdGl2ZXNGb3JTU1IgPSAoKSA9PiB7XG4gIGlmICghc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQpIHtcbiAgICBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgaW5pdFZNb2RlbEZvclNTUigpO1xuICAgIGluaXRWU2hvd0ZvclNTUigpO1xuICB9XG59IDtcblxuZXhwb3J0IHsgVHJhbnNpdGlvbiwgVHJhbnNpdGlvbkdyb3VwLCBWdWVFbGVtZW50LCBjcmVhdGVBcHAsIGNyZWF0ZVNTUkFwcCwgZGVmaW5lQ3VzdG9tRWxlbWVudCwgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCwgaHlkcmF0ZSwgaW5pdERpcmVjdGl2ZXNGb3JTU1IsIG5vZGVPcHMsIHBhdGNoUHJvcCwgcmVuZGVyLCB1c2VDc3NNb2R1bGUsIHVzZUNzc1ZhcnMsIHVzZUhvc3QsIHVzZVNoYWRvd1Jvb3QsIHZNb2RlbENoZWNrYm94LCB2TW9kZWxEeW5hbWljLCB2TW9kZWxSYWRpbywgdk1vZGVsU2VsZWN0LCB2TW9kZWxUZXh0LCB2U2hvdywgd2l0aEtleXMsIHdpdGhNb2RpZmllcnMgfTtcbiIsIi8qKlxuKiBAdnVlL3NoYXJlZCB2My41LjI2XG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWFrZU1hcChzdHIpIHtcbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3Qga2V5IG9mIHN0ci5zcGxpdChcIixcIikpIG1hcFtrZXldID0gMTtcbiAgcmV0dXJuICh2YWwpID0+IHZhbCBpbiBtYXA7XG59XG5cbmNvbnN0IEVNUFRZX09CSiA9ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyBPYmplY3QuZnJlZXplKHt9KSA6IHt9O1xuY29uc3QgRU1QVFlfQVJSID0gISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XG5jb25zdCBOT09QID0gKCkgPT4ge1xufTtcbmNvbnN0IE5PID0gKCkgPT4gZmFsc2U7XG5jb25zdCBpc09uID0gKGtleSkgPT4ga2V5LmNoYXJDb2RlQXQoMCkgPT09IDExMSAmJiBrZXkuY2hhckNvZGVBdCgxKSA9PT0gMTEwICYmIC8vIHVwcGVyY2FzZSBsZXR0ZXJcbihrZXkuY2hhckNvZGVBdCgyKSA+IDEyMiB8fCBrZXkuY2hhckNvZGVBdCgyKSA8IDk3KTtcbmNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKFwib25VcGRhdGU6XCIpO1xuY29uc3QgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcbmNvbnN0IHJlbW92ZSA9IChhcnIsIGVsKSA9PiB7XG4gIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihlbCk7XG4gIGlmIChpID4gLTEpIHtcbiAgICBhcnIuc3BsaWNlKGksIDEpO1xuICB9XG59O1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuY29uc3QgaGFzT3duID0gKHZhbCwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwga2V5KTtcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuY29uc3QgaXNNYXAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE1hcF1cIjtcbmNvbnN0IGlzU2V0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBTZXRdXCI7XG5jb25zdCBpc0RhdGUgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IERhdGVdXCI7XG5jb25zdCBpc1JlZ0V4cCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgUmVnRXhwXVwiO1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGlzU3RyaW5nID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IGlzU3ltYm9sID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzeW1ib2xcIjtcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCI7XG5jb25zdCBpc1Byb21pc2UgPSAodmFsKSA9PiB7XG4gIHJldHVybiAoaXNPYmplY3QodmFsKSB8fCBpc0Z1bmN0aW9uKHZhbCkpICYmIGlzRnVuY3Rpb24odmFsLnRoZW4pICYmIGlzRnVuY3Rpb24odmFsLmNhdGNoKTtcbn07XG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCB0b1R5cGVTdHJpbmcgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuY29uc3QgdG9SYXdUeXBlID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB0b1R5cGVTdHJpbmcodmFsdWUpLnNsaWNlKDgsIC0xKTtcbn07XG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG5jb25zdCBpc0ludGVnZXJLZXkgPSAoa2V5KSA9PiBpc1N0cmluZyhrZXkpICYmIGtleSAhPT0gXCJOYU5cIiAmJiBrZXlbMF0gIT09IFwiLVwiICYmIFwiXCIgKyBwYXJzZUludChrZXksIDEwKSA9PT0ga2V5O1xuY29uc3QgaXNSZXNlcnZlZFByb3AgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgLy8gdGhlIGxlYWRpbmcgY29tbWEgaXMgaW50ZW50aW9uYWwgc28gZW1wdHkgc3RyaW5nIFwiXCIgaXMgYWxzbyBpbmNsdWRlZFxuICBcIixrZXkscmVmLHJlZl9mb3IscmVmX2tleSxvblZub2RlQmVmb3JlTW91bnQsb25Wbm9kZU1vdW50ZWQsb25Wbm9kZUJlZm9yZVVwZGF0ZSxvblZub2RlVXBkYXRlZCxvblZub2RlQmVmb3JlVW5tb3VudCxvblZub2RlVW5tb3VudGVkXCJcbik7XG5jb25zdCBpc0J1aWx0SW5EaXJlY3RpdmUgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgXCJiaW5kLGNsb2FrLGVsc2UtaWYsZWxzZSxmb3IsaHRtbCxpZixtb2RlbCxvbixvbmNlLHByZSxzaG93LHNsb3QsdGV4dCxtZW1vXCJcbik7XG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoKHN0cikgPT4ge1xuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICB9KTtcbn07XG5jb25zdCBjYW1lbGl6ZVJFID0gLy1cXHcvZztcbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbihcbiAgKHN0cikgPT4ge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoYykgPT4gYy5zbGljZSgxKS50b1VwcGVyQ2FzZSgpKTtcbiAgfVxuKTtcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oXG4gIChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpXG4pO1xuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufSk7XG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKFxuICAoc3RyKSA9PiB7XG4gICAgY29uc3QgcyA9IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYDtcbiAgICByZXR1cm4gcztcbiAgfVxuKTtcbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiAhT2JqZWN0LmlzKHZhbHVlLCBvbGRWYWx1ZSk7XG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIC4uLmFyZykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGZuc1tpXSguLi5hcmcpO1xuICB9XG59O1xuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSwgd3JpdGFibGUgPSBmYWxzZSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGUsXG4gICAgdmFsdWVcbiAgfSk7XG59O1xuY29uc3QgbG9vc2VUb051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5jb25zdCB0b051bWJlciA9ICh2YWwpID0+IHtcbiAgY29uc3QgbiA9IGlzU3RyaW5nKHZhbCkgPyBOdW1iZXIodmFsKSA6IE5hTjtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5sZXQgX2dsb2JhbFRoaXM7XG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xuICByZXR1cm4gX2dsb2JhbFRoaXMgfHwgKF9nbG9iYWxUaGlzID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSk7XG59O1xuY29uc3QgaWRlbnRSRSA9IC9eW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSokLztcbmZ1bmN0aW9uIGdlblByb3BzQWNjZXNzRXhwKG5hbWUpIHtcbiAgcmV0dXJuIGlkZW50UkUudGVzdChuYW1lKSA/IGBfX3Byb3BzLiR7bmFtZX1gIDogYF9fcHJvcHNbJHtKU09OLnN0cmluZ2lmeShuYW1lKX1dYDtcbn1cbmZ1bmN0aW9uIGdlbkNhY2hlS2V5KHNvdXJjZSwgb3B0aW9ucykge1xuICByZXR1cm4gc291cmNlICsgSlNPTi5zdHJpbmdpZnkoXG4gICAgb3B0aW9ucyxcbiAgICAoXywgdmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCIgPyB2YWwudG9TdHJpbmcoKSA6IHZhbFxuICApO1xufVxuXG5jb25zdCBQYXRjaEZsYWdzID0ge1xuICBcIlRFWFRcIjogMSxcbiAgXCIxXCI6IFwiVEVYVFwiLFxuICBcIkNMQVNTXCI6IDIsXG4gIFwiMlwiOiBcIkNMQVNTXCIsXG4gIFwiU1RZTEVcIjogNCxcbiAgXCI0XCI6IFwiU1RZTEVcIixcbiAgXCJQUk9QU1wiOiA4LFxuICBcIjhcIjogXCJQUk9QU1wiLFxuICBcIkZVTExfUFJPUFNcIjogMTYsXG4gIFwiMTZcIjogXCJGVUxMX1BST1BTXCIsXG4gIFwiTkVFRF9IWURSQVRJT05cIjogMzIsXG4gIFwiMzJcIjogXCJORUVEX0hZRFJBVElPTlwiLFxuICBcIlNUQUJMRV9GUkFHTUVOVFwiOiA2NCxcbiAgXCI2NFwiOiBcIlNUQUJMRV9GUkFHTUVOVFwiLFxuICBcIktFWUVEX0ZSQUdNRU5UXCI6IDEyOCxcbiAgXCIxMjhcIjogXCJLRVlFRF9GUkFHTUVOVFwiLFxuICBcIlVOS0VZRURfRlJBR01FTlRcIjogMjU2LFxuICBcIjI1NlwiOiBcIlVOS0VZRURfRlJBR01FTlRcIixcbiAgXCJORUVEX1BBVENIXCI6IDUxMixcbiAgXCI1MTJcIjogXCJORUVEX1BBVENIXCIsXG4gIFwiRFlOQU1JQ19TTE9UU1wiOiAxMDI0LFxuICBcIjEwMjRcIjogXCJEWU5BTUlDX1NMT1RTXCIsXG4gIFwiREVWX1JPT1RfRlJBR01FTlRcIjogMjA0OCxcbiAgXCIyMDQ4XCI6IFwiREVWX1JPT1RfRlJBR01FTlRcIixcbiAgXCJDQUNIRURcIjogLTEsXG4gIFwiLTFcIjogXCJDQUNIRURcIixcbiAgXCJCQUlMXCI6IC0yLFxuICBcIi0yXCI6IFwiQkFJTFwiXG59O1xuY29uc3QgUGF0Y2hGbGFnTmFtZXMgPSB7XG4gIFsxXTogYFRFWFRgLFxuICBbMl06IGBDTEFTU2AsXG4gIFs0XTogYFNUWUxFYCxcbiAgWzhdOiBgUFJPUFNgLFxuICBbMTZdOiBgRlVMTF9QUk9QU2AsXG4gIFszMl06IGBORUVEX0hZRFJBVElPTmAsXG4gIFs2NF06IGBTVEFCTEVfRlJBR01FTlRgLFxuICBbMTI4XTogYEtFWUVEX0ZSQUdNRU5UYCxcbiAgWzI1Nl06IGBVTktFWUVEX0ZSQUdNRU5UYCxcbiAgWzUxMl06IGBORUVEX1BBVENIYCxcbiAgWzEwMjRdOiBgRFlOQU1JQ19TTE9UU2AsXG4gIFsyMDQ4XTogYERFVl9ST09UX0ZSQUdNRU5UYCxcbiAgWy0xXTogYENBQ0hFRGAsXG4gIFstMl06IGBCQUlMYFxufTtcblxuY29uc3QgU2hhcGVGbGFncyA9IHtcbiAgXCJFTEVNRU5UXCI6IDEsXG4gIFwiMVwiOiBcIkVMRU1FTlRcIixcbiAgXCJGVU5DVElPTkFMX0NPTVBPTkVOVFwiOiAyLFxuICBcIjJcIjogXCJGVU5DVElPTkFMX0NPTVBPTkVOVFwiLFxuICBcIlNUQVRFRlVMX0NPTVBPTkVOVFwiOiA0LFxuICBcIjRcIjogXCJTVEFURUZVTF9DT01QT05FTlRcIixcbiAgXCJURVhUX0NISUxEUkVOXCI6IDgsXG4gIFwiOFwiOiBcIlRFWFRfQ0hJTERSRU5cIixcbiAgXCJBUlJBWV9DSElMRFJFTlwiOiAxNixcbiAgXCIxNlwiOiBcIkFSUkFZX0NISUxEUkVOXCIsXG4gIFwiU0xPVFNfQ0hJTERSRU5cIjogMzIsXG4gIFwiMzJcIjogXCJTTE9UU19DSElMRFJFTlwiLFxuICBcIlRFTEVQT1JUXCI6IDY0LFxuICBcIjY0XCI6IFwiVEVMRVBPUlRcIixcbiAgXCJTVVNQRU5TRVwiOiAxMjgsXG4gIFwiMTI4XCI6IFwiU1VTUEVOU0VcIixcbiAgXCJDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkVcIjogMjU2LFxuICBcIjI1NlwiOiBcIkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRVwiLFxuICBcIkNPTVBPTkVOVF9LRVBUX0FMSVZFXCI6IDUxMixcbiAgXCI1MTJcIjogXCJDT01QT05FTlRfS0VQVF9BTElWRVwiLFxuICBcIkNPTVBPTkVOVFwiOiA2LFxuICBcIjZcIjogXCJDT01QT05FTlRcIlxufTtcblxuY29uc3QgU2xvdEZsYWdzID0ge1xuICBcIlNUQUJMRVwiOiAxLFxuICBcIjFcIjogXCJTVEFCTEVcIixcbiAgXCJEWU5BTUlDXCI6IDIsXG4gIFwiMlwiOiBcIkRZTkFNSUNcIixcbiAgXCJGT1JXQVJERURcIjogMyxcbiAgXCIzXCI6IFwiRk9SV0FSREVEXCJcbn07XG5jb25zdCBzbG90RmxhZ3NUZXh0ID0ge1xuICBbMV06IFwiU1RBQkxFXCIsXG4gIFsyXTogXCJEWU5BTUlDXCIsXG4gIFszXTogXCJGT1JXQVJERURcIlxufTtcblxuY29uc3QgR0xPQkFMU19BTExPV0VEID0gXCJJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsY29uc29sZSxFcnJvcixTeW1ib2xcIjtcbmNvbnN0IGlzR2xvYmFsbHlBbGxvd2VkID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoR0xPQkFMU19BTExPV0VEKTtcbmNvbnN0IGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IGlzR2xvYmFsbHlBbGxvd2VkO1xuXG5jb25zdCByYW5nZSA9IDI7XG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xuICBzdGFydCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHN0YXJ0LCBzb3VyY2UubGVuZ3RoKSk7XG4gIGVuZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGVuZCwgc291cmNlLmxlbmd0aCkpO1xuICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBcIlwiO1xuICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoLyhcXHI/XFxuKS8pO1xuICBjb25zdCBuZXdsaW5lU2VxdWVuY2VzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDEpO1xuICBsaW5lcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAwKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAobmV3bGluZVNlcXVlbmNlc1tpXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2ldLmxlbmd0aCB8fCAwKTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbGluZSA9IGogKyAxO1xuICAgICAgICByZXMucHVzaChcbiAgICAgICAgICBgJHtsaW5lfSR7XCIgXCIucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5ld0xpbmVTZXFMZW5ndGggPSBuZXdsaW5lU2VxdWVuY2VzW2pdICYmIG5ld2xpbmVTZXF1ZW5jZXNbal0ubGVuZ3RoIHx8IDA7XG4gICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSAobGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGgpKTtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyBcIiBcIi5yZXBlYXQocGFkKSArIFwiXlwiLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGlzU3RyaW5nKGl0ZW0pID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKSA6IG5vcm1hbGl6ZVN0eWxlKGl0ZW0pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplZCkge1xuICAgICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplZFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuY29uc3QgbGlzdERlbGltaXRlclJFID0gLzsoPyFbXihdKlxcKSkvZztcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOihbXl0rKS87XG5jb25zdCBzdHlsZUNvbW1lbnRSRSA9IC9cXC9cXCpbXl0qP1xcKlxcLy9nO1xuZnVuY3Rpb24gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjc3NUZXh0LnJlcGxhY2Uoc3R5bGVDb21tZW50UkUsIFwiXCIpLnNwbGl0KGxpc3REZWxpbWl0ZXJSRSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyUkUpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcbiAgaWYgKCFzdHlsZXMpIHJldHVybiBcIlwiO1xuICBpZiAoaXNTdHJpbmcoc3R5bGVzKSkgcmV0dXJuIHN0eWxlcztcbiAgbGV0IHJldCA9IFwiXCI7XG4gIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xuICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBrZXkuc3RhcnRzV2l0aChgLS1gKSA/IGtleSA6IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgcmV0ICs9IGAke25vcm1hbGl6ZWRLZXl9OiR7dmFsdWV9O2A7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzcyh2YWx1ZSkge1xuICBsZXQgcmVzID0gXCJcIjtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHJlcyA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcbiAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW25hbWVdKSB7XG4gICAgICAgIHJlcyArPSBuYW1lICsgXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXMudHJpbSgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMocHJvcHMpIHtcbiAgaWYgKCFwcm9wcykgcmV0dXJuIG51bGw7XG4gIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xuICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICB9XG4gIGlmIChzdHlsZSkge1xuICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICB9XG4gIHJldHVybiBwcm9wcztcbn1cblxuY29uc3QgSFRNTF9UQUdTID0gXCJodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSxhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsaDEsaDIsaDMsaDQsaDUsaDYsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdFwiO1xuY29uc3QgU1ZHX1RBR1MgPSBcInN2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSxkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLGZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsZmVEaXN0YW50TGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUixmZUdhdXNzaWFuQmx1cixmZUltYWdlLGZlTWVyZ2UsZmVNZXJnZU5vZGUsZmVNb3JwaG9sb2d5LGZlT2Zmc2V0LGZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLG1lc2gsbWVzaGdyYWRpZW50LG1lc2hwYXRjaCxtZXNocm93LG1ldGFkYXRhLG1wYXRoLHBhdGgscGF0dGVybixwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlld1wiO1xuY29uc3QgTUFUSF9UQUdTID0gXCJhbm5vdGF0aW9uLGFubm90YXRpb24teG1sLG1hY3Rpb24sbWFsaWduZ3JvdXAsbWFsaWdubWFyayxtYXRoLG1lbmNsb3NlLG1lcnJvcixtZmVuY2VkLG1mcmFjLG1mcmFjdGlvbixtZ2x5cGgsbWksbWxhYmVsZWR0cixtbG9uZ2RpdixtbXVsdGlzY3JpcHRzLG1uLG1vLG1vdmVyLG1wYWRkZWQsbXBoYW50b20sbXByZXNjcmlwdHMsbXJvb3QsbXJvdyxtcyxtc2NhcnJpZXMsbXNjYXJyeSxtc2dyb3VwLG1zbGluZSxtc3BhY2UsbXNxcnQsbXNyb3csbXN0YWNrLG1zdHlsZSxtc3ViLG1zdWJzdXAsbXN1cCxtdGFibGUsbXRkLG10ZXh0LG10cixtdW5kZXIsbXVuZGVyb3Zlcixub25lLHNlbWFudGljc1wiO1xuY29uc3QgVk9JRF9UQUdTID0gXCJhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdiclwiO1xuY29uc3QgaXNIVE1MVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoSFRNTF9UQUdTKTtcbmNvbnN0IGlzU1ZHVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoU1ZHX1RBR1MpO1xuY29uc3QgaXNNYXRoTUxUYWcgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChNQVRIX1RBR1MpO1xuY29uc3QgaXNWb2lkVGFnID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xuY29uc3QgaXNTcGVjaWFsQm9vbGVhbkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcbmNvbnN0IGlzQm9vbGVhbkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgc3BlY2lhbEJvb2xlYW5BdHRycyArIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGluZXJ0LGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGBcbik7XG5mdW5jdGlvbiBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgfHwgdmFsdWUgPT09IFwiXCI7XG59XG5jb25zdCB1bnNhZmVBdHRyQ2hhclJFID0gL1s+Lz1cIidcXHUwMDA5XFx1MDAwYVxcdTAwMGNcXHUwMDIwXS87XG5jb25zdCBhdHRyVmFsaWRhdGlvbkNhY2hlID0ge307XG5mdW5jdGlvbiBpc1NTUlNhZmVBdHRyTmFtZShuYW1lKSB7XG4gIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV07XG4gIH1cbiAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XG4gIGlmIChpc1Vuc2FmZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYHVuc2FmZSBhdHRyaWJ1dGUgbmFtZTogJHtuYW1lfWApO1xuICB9XG4gIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdID0gIWlzVW5zYWZlO1xufVxuY29uc3QgcHJvcHNUb0F0dHJNYXAgPSB7XG4gIGFjY2VwdENoYXJzZXQ6IFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgY2xhc3NOYW1lOiBcImNsYXNzXCIsXG4gIGh0bWxGb3I6IFwiZm9yXCIsXG4gIGh0dHBFcXVpdjogXCJodHRwLWVxdWl2XCJcbn07XG5jb25zdCBpc0tub3duSHRtbEF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW5lcnQsaW50ZWdyaXR5LGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxyZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCx2YWx1ZSx3aWR0aCx3cmFwYFxuKTtcbmNvbnN0IGlzS25vd25TdmdBdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXG4gIGB4bWxucyxhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxpZ25tZW50LWJhc2VsaW5lLGFscGhhYmV0aWMsYW1wbGl0dWRlLGFyYWJpYy1mb3JtLGFzY2VudCxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVR5cGUsYXppbXV0aCxiYXNlRnJlcXVlbmN5LGJhc2VsaW5lLXNoaWZ0LGJhc2VQcm9maWxlLGJib3gsYmVnaW4sYmlhcyxieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGNsaXAsY2xpcFBhdGhVbml0cyxjbGlwLXBhdGgsY2xpcC1ydWxlLGNvbG9yLGNvbG9yLWludGVycG9sYXRpb24sY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzLGNvbG9yLXByb2ZpbGUsY29sb3ItcmVuZGVyaW5nLGNvbnRlbnRTY3JpcHRUeXBlLGNvbnRlbnRTdHlsZVR5cGUsY3Jvc3NvcmlnaW4sY3Vyc29yLGN4LGN5LGQsZGVjZWxlcmF0ZSxkZXNjZW50LGRpZmZ1c2VDb25zdGFudCxkaXJlY3Rpb24sZGlzcGxheSxkaXZpc29yLGRvbWluYW50LWJhc2VsaW5lLGR1cixkeCxkeSxlZGdlTW9kZSxlbGV2YXRpb24sZW5hYmxlLWJhY2tncm91bmQsZW5kLGV4cG9uZW50LGZpbGwsZmlsbC1vcGFjaXR5LGZpbGwtcnVsZSxmaWx0ZXIsZmlsdGVyUmVzLGZpbHRlclVuaXRzLGZsb29kLWNvbG9yLGZsb29kLW9wYWNpdHksZm9udC1mYW1pbHksZm9udC1zaXplLGZvbnQtc2l6ZS1hZGp1c3QsZm9udC1zdHJldGNoLGZvbnQtc3R5bGUsZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZvcm1hdCxmcm9tLGZyLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCxnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCxnbHlwaFJlZixncmFkaWVudFRyYW5zZm9ybSxncmFkaWVudFVuaXRzLGhhbmdpbmcsaGVpZ2h0LGhyZWYsaHJlZmxhbmcsaG9yaXotYWR2LXgsaG9yaXotb3JpZ2luLXgsaWQsaWRlb2dyYXBoaWMsaW1hZ2UtcmVuZGVyaW5nLGluLGluMixpbnRlcmNlcHQsayxrMSxrMixrMyxrNCxrZXJuZWxNYXRyaXgsa2VybmVsVW5pdExlbmd0aCxrZXJuaW5nLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGxhbmcsbGVuZ3RoQWRqdXN0LGxldHRlci1zcGFjaW5nLGxpZ2h0aW5nLWNvbG9yLGxpbWl0aW5nQ29uZUFuZ2xlLGxvY2FsLG1hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLG1hc2ssbWFza0NvbnRlbnRVbml0cyxtYXNrVW5pdHMsbWF0aGVtYXRpY2FsLG1heCxtZWRpYSxtZXRob2QsbWluLG1vZGUsbmFtZSxudW1PY3RhdmVzLG9mZnNldCxvcGFjaXR5LG9wZXJhdG9yLG9yZGVyLG9yaWVudCxvcmllbnRhdGlvbixvcmlnaW4sb3ZlcmZsb3csb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLHBhaW50LW9yZGVyLHBhdGgscGF0aExlbmd0aCxwYXR0ZXJuQ29udGVudFVuaXRzLHBhdHRlcm5UcmFuc2Zvcm0scGF0dGVyblVuaXRzLHBpbmcscG9pbnRlci1ldmVudHMscG9pbnRzLHBvaW50c0F0WCxwb2ludHNBdFkscG9pbnRzQXRaLHByZXNlcnZlQWxwaGEscHJlc2VydmVBc3BlY3RSYXRpbyxwcmltaXRpdmVVbml0cyxyLHJhZGl1cyxyZWZlcnJlclBvbGljeSxyZWZYLHJlZlkscmVsLHJlbmRlcmluZy1pbnRlbnQscmVwZWF0Q291bnQscmVwZWF0RHVyLHJlcXVpcmVkRXh0ZW5zaW9ucyxyZXF1aXJlZEZlYXR1cmVzLHJlc3RhcnQscmVzdWx0LHJvdGF0ZSxyeCxyeSxzY2FsZSxzZWVkLHNoYXBlLXJlbmRlcmluZyxzbG9wZSxzcGFjaW5nLHNwZWN1bGFyQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxzcGVlZCxzcHJlYWRNZXRob2Qsc3RhcnRPZmZzZXQsc3RkRGV2aWF0aW9uLHN0ZW1oLHN0ZW12LHN0aXRjaFRpbGVzLHN0b3AtY29sb3Isc3RvcC1vcGFjaXR5LHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3RyaW5nLHN0cm9rZSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGgsc3R5bGUsc3VyZmFjZVNjYWxlLHN5c3RlbUxhbmd1YWdlLHRhYmluZGV4LHRhYmxlVmFsdWVzLHRhcmdldCx0YXJnZXRYLHRhcmdldFksdGV4dC1hbmNob3IsdGV4dC1kZWNvcmF0aW9uLHRleHQtcmVuZGVyaW5nLHRleHRMZW5ndGgsdG8sdHJhbnNmb3JtLHRyYW5zZm9ybS1vcmlnaW4sdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sdW5kZXJsaW5lLXRoaWNrbmVzcyx1bmljb2RlLHVuaWNvZGUtYmlkaSx1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2LWFscGhhYmV0aWMsdi1oYW5naW5nLHYtaWRlb2dyYXBoaWMsdi1tYXRoZW1hdGljYWwsdmFsdWVzLHZlY3Rvci1lZmZlY3QsdmVyc2lvbix2ZXJ0LWFkdi15LHZlcnQtb3JpZ2luLXgsdmVydC1vcmlnaW4teSx2aWV3Qm94LHZpZXdUYXJnZXQsdmlzaWJpbGl0eSx3aWR0aCx3aWR0aHMsd29yZC1zcGFjaW5nLHdyaXRpbmctbW9kZSx4LHgtaGVpZ2h0LHgxLHgyLHhDaGFubmVsU2VsZWN0b3IseGxpbms6YWN0dWF0ZSx4bGluazphcmNyb2xlLHhsaW5rOmhyZWYseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLHhsaW5rOnR5cGUseG1sbnM6eGxpbmsseG1sOmJhc2UseG1sOmxhbmcseG1sOnNwYWNlLHkseTEseTIseUNoYW5uZWxTZWxlY3Rvcix6LHpvb21BbmRQYW5gXG4pO1xuY29uc3QgaXNLbm93bk1hdGhNTEF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChcbiAgYGFjY2VudCxhY2NlbnR1bmRlcixhY3Rpb250eXBlLGFsaWduLGFsaWdubWVudHNjb3BlLGFsdGltZyxhbHRpbWctaGVpZ2h0LGFsdGltZy12YWxpZ24sYWx0aW1nLXdpZHRoLGFsdHRleHQsYmV2ZWxsZWQsY2xvc2UsY29sdW1uc2FsaWduLGNvbHVtbmxpbmVzLGNvbHVtbnNwYW4sZGVub21hbGlnbixkZXB0aCxkaXIsZGlzcGxheSxkaXNwbGF5c3R5bGUsZW5jb2RpbmcsZXF1YWxjb2x1bW5zLGVxdWFscm93cyxmZW5jZSxmb250c3R5bGUsZm9udHdlaWdodCxmb3JtLGZyYW1lLGZyYW1lc3BhY2luZyxncm91cGFsaWduLGhlaWdodCxocmVmLGlkLGluZGVudGFsaWduLGluZGVudGFsaWduZmlyc3QsaW5kZW50YWxpZ25sYXN0LGluZGVudHNoaWZ0LGluZGVudHNoaWZ0Zmlyc3QsaW5kZW50c2hpZnRsYXN0LGluZGV4dHlwZSxqdXN0aWZ5LGxhcmdldG9wLGxhcmdlb3AsbHF1b3RlLGxzcGFjZSxtYXRoYmFja2dyb3VuZCxtYXRoY29sb3IsbWF0aHNpemUsbWF0aHZhcmlhbnQsbWF4c2l6ZSxtaW5sYWJlbHNwYWNpbmcsbW9kZSxvdGhlcixvdmVyZmxvdyxwb3NpdGlvbixyb3dhbGlnbixyb3dsaW5lcyxyb3dzcGFuLHJxdW90ZSxyc3BhY2Usc2NyaXB0bGV2ZWwsc2NyaXB0bWluc2l6ZSxzY3JpcHRzaXplbXVsdGlwbGllcixzZWxlY3Rpb24sc2VwYXJhdG9yLHNlcGFyYXRvcnMsc2hpZnQsc2lkZSxzcmMsc3RhY2thbGlnbixzdHJldGNoeSxzdWJzY3JpcHRzaGlmdCxzdXBlcnNjcmlwdHNoaWZ0LHN5bW1ldHJpYyx2b2Zmc2V0LHdpZHRoLHdpZHRocyx4bGluazpocmVmLHhsaW5rOnNob3cseGxpbms6dHlwZSx4bWxuc2Bcbik7XG5mdW5jdGlvbiBpc1JlbmRlcmFibGVBdHRyVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIjtcbn1cblxuY29uc3QgZXNjYXBlUkUgPSAvW1wiJyY8Pl0vO1xuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgY29uc3Qgc3RyID0gXCJcIiArIHN0cmluZztcbiAgY29uc3QgbWF0Y2ggPSBlc2NhcGVSRS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGxldCBodG1sID0gXCJcIjtcbiAgbGV0IGVzY2FwZWQ7XG4gIGxldCBpbmRleDtcbiAgbGV0IGxhc3RJbmRleCA9IDA7XG4gIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgIGNhc2UgMzQ6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZxdW90O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIGVzY2FwZWQgPSBcIiZhbXA7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOTpcbiAgICAgICAgZXNjYXBlZCA9IFwiJiMzOTtcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYwOlxuICAgICAgICBlc2NhcGVkID0gXCImbHQ7XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgZXNjYXBlZCA9IFwiJmd0O1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XG4gICAgfVxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZWQ7XG4gIH1cbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbmNvbnN0IGNvbW1lbnRTdHJpcFJFID0gL14tPz58PCEtLXwtLT58LS0hPnw8IS0kL2c7XG5mdW5jdGlvbiBlc2NhcGVIdG1sQ29tbWVudChzcmMpIHtcbiAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRTdHJpcFJFLCBcIlwiKTtcbn1cbmNvbnN0IGNzc1Zhck5hbWVFc2NhcGVTeW1ib2xzUkUgPSAvWyAhXCIjJCUmJygpKissLi86Ozw9Pj9AW1xcXFxcXF1eYHt8fX5dL2c7XG5mdW5jdGlvbiBnZXRFc2NhcGVkQ3NzVmFyTmFtZShrZXksIGRvdWJsZUVzY2FwZSkge1xuICByZXR1cm4ga2V5LnJlcGxhY2UoXG4gICAgY3NzVmFyTmFtZUVzY2FwZVN5bWJvbHNSRSxcbiAgICAocykgPT4gZG91YmxlRXNjYXBlID8gcyA9PT0gJ1wiJyA/ICdcXFxcXFxcXFxcXFxcIicgOiBgXFxcXFxcXFwke3N9YCA6IGBcXFxcJHtzfWBcbiAgKTtcbn1cblxuZnVuY3Rpb24gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBsZXQgZXF1YWwgPSB0cnVlO1xuICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBlcXVhbCA9IGxvb3NlRXF1YWwoYVtpXSwgYltpXSk7XG4gIH1cbiAgcmV0dXJuIGVxdWFsO1xufVxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgbGV0IGFWYWxpZFR5cGUgPSBpc0RhdGUoYSk7XG4gIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc1N5bWJvbChhKTtcbiAgYlZhbGlkVHlwZSA9IGlzU3ltYm9sKGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgYVZhbGlkVHlwZSA9IGlzQXJyYXkoYSk7XG4gIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xuICB9XG4gIGFWYWxpZFR5cGUgPSBpc09iamVjdChhKTtcbiAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xuICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XG4gICAgY29uc3QgYktleXNDb3VudCA9IE9iamVjdC5rZXlzKGIpLmxlbmd0aDtcbiAgICBpZiAoYUtleXNDb3VudCAhPT0gYktleXNDb3VudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgY29uc3QgYkhhc0tleSA9IGIuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGlmIChhSGFzS2V5ICYmICFiSGFzS2V5IHx8ICFhSGFzS2V5ICYmIGJIYXNLZXkgfHwgIWxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xufVxuZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XG4gIHJldHVybiBhcnIuZmluZEluZGV4KChpdGVtKSA9PiBsb29zZUVxdWFsKGl0ZW0sIHZhbCkpO1xufVxuXG5jb25zdCBpc1JlZiA9ICh2YWwpID0+IHtcbiAgcmV0dXJuICEhKHZhbCAmJiB2YWxbXCJfX3ZfaXNSZWZcIl0gPT09IHRydWUpO1xufTtcbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIGlzU3RyaW5nKHZhbCkgPyB2YWwgOiB2YWwgPT0gbnVsbCA/IFwiXCIgOiBpc0FycmF5KHZhbCkgfHwgaXNPYmplY3QodmFsKSAmJiAodmFsLnRvU3RyaW5nID09PSBvYmplY3RUb1N0cmluZyB8fCAhaXNGdW5jdGlvbih2YWwudG9TdHJpbmcpKSA/IGlzUmVmKHZhbCkgPyB0b0Rpc3BsYXlTdHJpbmcodmFsLnZhbHVlKSA6IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpIDogU3RyaW5nKHZhbCk7XG59O1xuY29uc3QgcmVwbGFjZXIgPSAoX2tleSwgdmFsKSA9PiB7XG4gIGlmIChpc1JlZih2YWwpKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VyKF9rZXksIHZhbC52YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBbYE1hcCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC5lbnRyaWVzKCldLnJlZHVjZShcbiAgICAgICAgKGVudHJpZXMsIFtrZXksIHZhbDJdLCBpKSA9PiB7XG4gICAgICAgICAgZW50cmllc1tzdHJpbmdpZnlTeW1ib2woa2V5LCBpKSArIFwiID0+XCJdID0gdmFsMjtcbiAgICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgICAgfSxcbiAgICAgICAge31cbiAgICAgIClcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldLm1hcCgodikgPT4gc3RyaW5naWZ5U3ltYm9sKHYpKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNTeW1ib2wodmFsKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlTeW1ib2wodmFsKTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpICYmICFpc0FycmF5KHZhbCkgJiYgIWlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgIHJldHVybiBTdHJpbmcodmFsKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcbmNvbnN0IHN0cmluZ2lmeVN5bWJvbCA9ICh2LCBpID0gXCJcIikgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiAoXG4gICAgLy8gU3ltYm9sLmRlc2NyaXB0aW9uIGluIGVzMjAxOSsgc28gd2UgbmVlZCB0byBjYXN0IGhlcmUgdG8gcGFzc1xuICAgIC8vIHRoZSBsaWI6IGVzMjAxNiBjaGVja1xuICAgIGlzU3ltYm9sKHYpID8gYFN5bWJvbCgkeyhfYSA9IHYuZGVzY3JpcHRpb24pICE9IG51bGwgPyBfYSA6IGl9KWAgOiB2XG4gICk7XG59O1xuXG5mdW5jdGlvbiBub3JtYWxpemVDc3NWYXJWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBcImluaXRpYWxcIjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBcIlwiID8gXCIgXCIgOiB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8ICFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgaWYgKCEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJbVnVlIHdhcm5dIEludmFsaWQgdmFsdWUgdXNlZCBmb3IgQ1NTIGJpbmRpbmcuIEV4cGVjdGVkIGEgc3RyaW5nIG9yIGEgZmluaXRlIG51bWJlciBidXQgcmVjZWl2ZWQ6XCIsXG4gICAgICAgIHZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgUGF0Y2hGbGFncywgU2hhcGVGbGFncywgU2xvdEZsYWdzLCBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgY3NzVmFyTmFtZUVzY2FwZVN5bWJvbHNSRSwgZGVmLCBlc2NhcGVIdG1sLCBlc2NhcGVIdG1sQ29tbWVudCwgZXh0ZW5kLCBnZW5DYWNoZUtleSwgZ2VuUHJvcHNBY2Nlc3NFeHAsIGdlbmVyYXRlQ29kZUZyYW1lLCBnZXRFc2NhcGVkQ3NzVmFyTmFtZSwgZ2V0R2xvYmFsVGhpcywgaGFzQ2hhbmdlZCwgaGFzT3duLCBoeXBoZW5hdGUsIGluY2x1ZGVCb29sZWFuQXR0ciwgaW52b2tlQXJyYXlGbnMsIGlzQXJyYXksIGlzQm9vbGVhbkF0dHIsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0dsb2JhbGx5QWxsb3dlZCwgaXNHbG9iYWxseVdoaXRlbGlzdGVkLCBpc0hUTUxUYWcsIGlzSW50ZWdlcktleSwgaXNLbm93bkh0bWxBdHRyLCBpc0tub3duTWF0aE1MQXR0ciwgaXNLbm93blN2Z0F0dHIsIGlzTWFwLCBpc01hdGhNTFRhZywgaXNNb2RlbExpc3RlbmVyLCBpc09iamVjdCwgaXNPbiwgaXNQbGFpbk9iamVjdCwgaXNQcm9taXNlLCBpc1JlZ0V4cCwgaXNSZW5kZXJhYmxlQXR0clZhbHVlLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIGxvb3NlVG9OdW1iZXIsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVDc3NWYXJWYWx1ZSwgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCBvYmplY3RUb1N0cmluZywgcGFyc2VTdHJpbmdTdHlsZSwgcHJvcHNUb0F0dHJNYXAsIHJlbW92ZSwgc2xvdEZsYWdzVGV4dCwgc3RyaW5naWZ5U3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgdG9SYXdUeXBlLCB0b1R5cGVTdHJpbmcgfTtcbiIsImNvbnN0IFRZUEVfUkVRVUVTVCA9IFwicVwiO1xuY29uc3QgVFlQRV9SRVNQT05TRSA9IFwic1wiO1xuY29uc3QgREVGQVVMVF9USU1FT1VUID0gNmU0O1xuZnVuY3Rpb24gZGVmYXVsdFNlcmlhbGl6ZShpKSB7XG4gIHJldHVybiBpO1xufVxuY29uc3QgZGVmYXVsdERlc2VyaWFsaXplID0gZGVmYXVsdFNlcmlhbGl6ZTtcbmNvbnN0IHsgY2xlYXJUaW1lb3V0LCBzZXRUaW1lb3V0IH0gPSBnbG9iYWxUaGlzO1xuY29uc3QgcmFuZG9tID0gTWF0aC5yYW5kb20uYmluZChNYXRoKTtcbmZ1bmN0aW9uIGNyZWF0ZUJpcnBjKCRmdW5jdGlvbnMsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHBvc3QsXG4gICAgb24sXG4gICAgb2ZmID0gKCkgPT4ge1xuICAgIH0sXG4gICAgZXZlbnROYW1lcyA9IFtdLFxuICAgIHNlcmlhbGl6ZSA9IGRlZmF1bHRTZXJpYWxpemUsXG4gICAgZGVzZXJpYWxpemUgPSBkZWZhdWx0RGVzZXJpYWxpemUsXG4gICAgcmVzb2x2ZXIsXG4gICAgYmluZCA9IFwicnBjXCIsXG4gICAgdGltZW91dCA9IERFRkFVTFRfVElNRU9VVFxuICB9ID0gb3B0aW9ucztcbiAgbGV0ICRjbG9zZWQgPSBmYWxzZTtcbiAgY29uc3QgX3JwY1Byb21pc2VNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgX3Byb21pc2VJbml0O1xuICBsZXQgcnBjO1xuICBhc3luYyBmdW5jdGlvbiBfY2FsbChtZXRob2QsIGFyZ3MsIGV2ZW50LCBvcHRpb25hbCkge1xuICAgIGlmICgkY2xvc2VkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBbYmlycGNdIHJwYyBpcyBjbG9zZWQsIGNhbm5vdCBjYWxsIFwiJHttZXRob2R9XCJgKTtcbiAgICBjb25zdCByZXEgPSB7IG06IG1ldGhvZCwgYTogYXJncywgdDogVFlQRV9SRVFVRVNUIH07XG4gICAgaWYgKG9wdGlvbmFsKVxuICAgICAgcmVxLm8gPSB0cnVlO1xuICAgIGNvbnN0IHNlbmQgPSBhc3luYyAoX3JlcSkgPT4gcG9zdChzZXJpYWxpemUoX3JlcSkpO1xuICAgIGlmIChldmVudCkge1xuICAgICAgYXdhaXQgc2VuZChyZXEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoX3Byb21pc2VJbml0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBfcHJvbWlzZUluaXQ7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfcHJvbWlzZUluaXQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9ID0gY3JlYXRlUHJvbWlzZVdpdGhSZXNvbHZlcnMoKTtcbiAgICBjb25zdCBpZCA9IG5hbm9pZCgpO1xuICAgIHJlcS5pID0gaWQ7XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKG5ld1JlcSA9IHJlcSkge1xuICAgICAgaWYgKHRpbWVvdXQgPj0gMCkge1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlUmVzdWx0ID0gb3B0aW9ucy5vblRpbWVvdXRFcnJvcj8uY2FsbChycGMsIG1ldGhvZCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoaGFuZGxlUmVzdWx0ICE9PSB0cnVlKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtiaXJwY10gdGltZW91dCBvbiBjYWxsaW5nIFwiJHttZXRob2R9XCJgKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9ycGNQcm9taXNlTWFwLmRlbGV0ZShpZCk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXRJZCA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICB0aW1lb3V0SWQgPSB0aW1lb3V0SWQudW5yZWY/LigpO1xuICAgICAgfVxuICAgICAgX3JwY1Byb21pc2VNYXAuc2V0KGlkLCB7IHJlc29sdmUsIHJlamVjdCwgdGltZW91dElkLCBtZXRob2QgfSk7XG4gICAgICBhd2FpdCBzZW5kKG5ld1JlcSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmIChvcHRpb25zLm9uUmVxdWVzdClcbiAgICAgICAgYXdhaXQgb3B0aW9ucy5vblJlcXVlc3QuY2FsbChycGMsIHJlcSwgaGFuZGxlciwgcmVzb2x2ZSk7XG4gICAgICBlbHNlXG4gICAgICAgIGF3YWl0IGhhbmRsZXIoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAob3B0aW9ucy5vbkdlbmVyYWxFcnJvcj8uY2FsbChycGMsIGUpICE9PSB0cnVlKVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIF9ycGNQcm9taXNlTWFwLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGNvbnN0ICRjYWxsID0gKG1ldGhvZCwgLi4uYXJncykgPT4gX2NhbGwobWV0aG9kLCBhcmdzLCBmYWxzZSk7XG4gIGNvbnN0ICRjYWxsT3B0aW9uYWwgPSAobWV0aG9kLCAuLi5hcmdzKSA9PiBfY2FsbChtZXRob2QsIGFyZ3MsIGZhbHNlLCB0cnVlKTtcbiAgY29uc3QgJGNhbGxFdmVudCA9IChtZXRob2QsIC4uLmFyZ3MpID0+IF9jYWxsKG1ldGhvZCwgYXJncywgdHJ1ZSk7XG4gIGNvbnN0ICRjYWxsUmF3ID0gKG9wdGlvbnMyKSA9PiBfY2FsbChvcHRpb25zMi5tZXRob2QsIG9wdGlvbnMyLmFyZ3MsIG9wdGlvbnMyLmV2ZW50LCBvcHRpb25zMi5vcHRpb25hbCk7XG4gIGNvbnN0IGJ1aWx0aW5NZXRob2RzID0ge1xuICAgICRjYWxsLFxuICAgICRjYWxsT3B0aW9uYWwsXG4gICAgJGNhbGxFdmVudCxcbiAgICAkY2FsbFJhdyxcbiAgICAkcmVqZWN0UGVuZGluZ0NhbGxzLFxuICAgIGdldCAkY2xvc2VkKCkge1xuICAgICAgcmV0dXJuICRjbG9zZWQ7XG4gICAgfSxcbiAgICBnZXQgJG1ldGEoKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5tZXRhO1xuICAgIH0sXG4gICAgJGNsb3NlLFxuICAgICRmdW5jdGlvbnNcbiAgfTtcbiAgcnBjID0gbmV3IFByb3h5KHt9LCB7XG4gICAgZ2V0KF8sIG1ldGhvZCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChidWlsdGluTWV0aG9kcywgbWV0aG9kKSlcbiAgICAgICAgcmV0dXJuIGJ1aWx0aW5NZXRob2RzW21ldGhvZF07XG4gICAgICBpZiAobWV0aG9kID09PSBcInRoZW5cIiAmJiAhZXZlbnROYW1lcy5pbmNsdWRlcyhcInRoZW5cIikgJiYgIShcInRoZW5cIiBpbiAkZnVuY3Rpb25zKSlcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIGNvbnN0IHNlbmRFdmVudCA9ICguLi5hcmdzKSA9PiBfY2FsbChtZXRob2QsIGFyZ3MsIHRydWUpO1xuICAgICAgaWYgKGV2ZW50TmFtZXMuaW5jbHVkZXMobWV0aG9kKSkge1xuICAgICAgICBzZW5kRXZlbnQuYXNFdmVudCA9IHNlbmRFdmVudDtcbiAgICAgICAgcmV0dXJuIHNlbmRFdmVudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbmRDYWxsID0gKC4uLmFyZ3MpID0+IF9jYWxsKG1ldGhvZCwgYXJncywgZmFsc2UpO1xuICAgICAgc2VuZENhbGwuYXNFdmVudCA9IHNlbmRFdmVudDtcbiAgICAgIHJldHVybiBzZW5kQ2FsbDtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiAkY2xvc2UoY3VzdG9tRXJyb3IpIHtcbiAgICAkY2xvc2VkID0gdHJ1ZTtcbiAgICBfcnBjUHJvbWlzZU1hcC5mb3JFYWNoKCh7IHJlamVjdCwgbWV0aG9kIH0pID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBbYmlycGNdIHJwYyBpcyBjbG9zZWQsIGNhbm5vdCBjYWxsIFwiJHttZXRob2R9XCJgKTtcbiAgICAgIGlmIChjdXN0b21FcnJvcikge1xuICAgICAgICBjdXN0b21FcnJvci5jYXVzZSA/Pz0gZXJyb3I7XG4gICAgICAgIHJldHVybiByZWplY3QoY3VzdG9tRXJyb3IpO1xuICAgICAgfVxuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgICBfcnBjUHJvbWlzZU1hcC5jbGVhcigpO1xuICAgIG9mZihvbk1lc3NhZ2UpO1xuICB9XG4gIGZ1bmN0aW9uICRyZWplY3RQZW5kaW5nQ2FsbHMoaGFuZGxlcikge1xuICAgIGNvbnN0IGVudHJpZXMgPSBBcnJheS5mcm9tKF9ycGNQcm9taXNlTWFwLnZhbHVlcygpKTtcbiAgICBjb25zdCBoYW5kbGVyUmVzdWx0cyA9IGVudHJpZXMubWFwKCh7IG1ldGhvZCwgcmVqZWN0IH0pID0+IHtcbiAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihgW2JpcnBjXTogcmVqZWN0ZWQgcGVuZGluZyBjYWxsIFwiJHttZXRob2R9XCIuYCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhbmRsZXIoeyBtZXRob2QsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgICBfcnBjUHJvbWlzZU1hcC5jbGVhcigpO1xuICAgIHJldHVybiBoYW5kbGVyUmVzdWx0cztcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSwgLi4uZXh0cmEpIHtcbiAgICBsZXQgbXNnO1xuICAgIHRyeSB7XG4gICAgICBtc2cgPSBkZXNlcmlhbGl6ZShkYXRhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAob3B0aW9ucy5vbkdlbmVyYWxFcnJvcj8uY2FsbChycGMsIGUpICE9PSB0cnVlKVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobXNnLnQgPT09IFRZUEVfUkVRVUVTVCkge1xuICAgICAgY29uc3QgeyBtOiBtZXRob2QsIGE6IGFyZ3MsIG86IG9wdGlvbmFsIH0gPSBtc2c7XG4gICAgICBsZXQgcmVzdWx0LCBlcnJvcjtcbiAgICAgIGxldCBmbiA9IGF3YWl0IChyZXNvbHZlciA/IHJlc29sdmVyLmNhbGwocnBjLCBtZXRob2QsICRmdW5jdGlvbnNbbWV0aG9kXSkgOiAkZnVuY3Rpb25zW21ldGhvZF0pO1xuICAgICAgaWYgKG9wdGlvbmFsKVxuICAgICAgICBmbiB8fD0gKCkgPT4gdm9pZCAwO1xuICAgICAgaWYgKCFmbikge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihgW2JpcnBjXSBmdW5jdGlvbiBcIiR7bWV0aG9kfVwiIG5vdCBmb3VuZGApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBmbi5hcHBseShiaW5kID09PSBcInJwY1wiID8gcnBjIDogJGZ1bmN0aW9ucywgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtc2cuaSkge1xuICAgICAgICBpZiAoZXJyb3IgJiYgb3B0aW9ucy5vbkVycm9yKVxuICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKHJwYywgZXJyb3IsIG1ldGhvZCwgYXJncyk7XG4gICAgICAgIGlmIChlcnJvciAmJiBvcHRpb25zLm9uRnVuY3Rpb25FcnJvcikge1xuICAgICAgICAgIGlmIChvcHRpb25zLm9uRnVuY3Rpb25FcnJvci5jYWxsKHJwYywgZXJyb3IsIG1ldGhvZCwgYXJncykgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBwb3N0KHNlcmlhbGl6ZSh7IHQ6IFRZUEVfUkVTUE9OU0UsIGk6IG1zZy5pLCByOiByZXN1bHQgfSksIC4uLmV4dHJhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbkdlbmVyYWxFcnJvcj8uY2FsbChycGMsIGUsIG1ldGhvZCwgYXJncykgIT09IHRydWUpXG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgcG9zdChzZXJpYWxpemUoeyB0OiBUWVBFX1JFU1BPTlNFLCBpOiBtc2cuaSwgZTogZXJyb3IgfSksIC4uLmV4dHJhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChvcHRpb25zLm9uR2VuZXJhbEVycm9yPy5jYWxsKHJwYywgZSwgbWV0aG9kLCBhcmdzKSAhPT0gdHJ1ZSlcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBpOiBhY2ssIHI6IHJlc3VsdCwgZTogZXJyb3IgfSA9IG1zZztcbiAgICAgIGNvbnN0IHByb21pc2UgPSBfcnBjUHJvbWlzZU1hcC5nZXQoYWNrKTtcbiAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChwcm9taXNlLnRpbWVvdXRJZCk7XG4gICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBwcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIF9ycGNQcm9taXNlTWFwLmRlbGV0ZShhY2spO1xuICAgIH1cbiAgfVxuICBfcHJvbWlzZUluaXQgPSBvbihvbk1lc3NhZ2UpO1xuICByZXR1cm4gcnBjO1xufVxuY29uc3QgY2FjaGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGNhY2hlZE1hcChpdGVtcywgZm4pIHtcbiAgcmV0dXJuIGl0ZW1zLm1hcCgoaSkgPT4ge1xuICAgIGxldCByID0gY2FjaGVNYXAuZ2V0KGkpO1xuICAgIGlmICghcikge1xuICAgICAgciA9IGZuKGkpO1xuICAgICAgY2FjaGVNYXAuc2V0KGksIHIpO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVCaXJwY0dyb3VwKGZ1bmN0aW9ucywgY2hhbm5lbHMsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBnZXRDaGFubmVscyA9ICgpID0+IHR5cGVvZiBjaGFubmVscyA9PT0gXCJmdW5jdGlvblwiID8gY2hhbm5lbHMoKSA6IGNoYW5uZWxzO1xuICBjb25zdCBnZXRDbGllbnRzID0gKGNoYW5uZWxzMiA9IGdldENoYW5uZWxzKCkpID0+IGNhY2hlZE1hcChjaGFubmVsczIsIChzKSA9PiBjcmVhdGVCaXJwYyhmdW5jdGlvbnMsIHsgLi4ub3B0aW9ucywgLi4ucyB9KSk7XG4gIGZ1bmN0aW9uIF9ib2FyZGNhc3QobWV0aG9kLCBhcmdzLCBldmVudCwgb3B0aW9uYWwpIHtcbiAgICBjb25zdCBjbGllbnRzID0gZ2V0Q2xpZW50cygpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChjbGllbnRzLm1hcCgoYykgPT4gYy4kY2FsbFJhdyh7IG1ldGhvZCwgYXJncywgZXZlbnQsIG9wdGlvbmFsIH0pKSk7XG4gIH1cbiAgZnVuY3Rpb24gJGNhbGwobWV0aG9kLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIF9ib2FyZGNhc3QobWV0aG9kLCBhcmdzLCBmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gJGNhbGxPcHRpb25hbChtZXRob2QsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gX2JvYXJkY2FzdChtZXRob2QsIGFyZ3MsIGZhbHNlLCB0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiAkY2FsbEV2ZW50KG1ldGhvZCwgLi4uYXJncykge1xuICAgIHJldHVybiBfYm9hcmRjYXN0KG1ldGhvZCwgYXJncywgdHJ1ZSk7XG4gIH1cbiAgY29uc3QgYnJvYWRjYXN0QnVpbHRpbiA9IHtcbiAgICAkY2FsbCxcbiAgICAkY2FsbE9wdGlvbmFsLFxuICAgICRjYWxsRXZlbnRcbiAgfTtcbiAgY29uc3QgYnJvYWRjYXN0UHJveHkgPSBuZXcgUHJveHkoe30sIHtcbiAgICBnZXQoXywgbWV0aG9kKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGJyb2FkY2FzdEJ1aWx0aW4sIG1ldGhvZCkpXG4gICAgICAgIHJldHVybiBicm9hZGNhc3RCdWlsdGluW21ldGhvZF07XG4gICAgICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnRzKCk7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSBjbGllbnQubWFwKChjKSA9PiBjW21ldGhvZF0pO1xuICAgICAgY29uc3Qgc2VuZENhbGwgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2FsbGJhY2tzLm1hcCgoaSkgPT4gaSguLi5hcmdzKSkpO1xuICAgICAgfTtcbiAgICAgIHNlbmRDYWxsLmFzRXZlbnQgPSBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjYWxsYmFja3MubWFwKChpKSA9PiBpLmFzRXZlbnQoLi4uYXJncykpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2VuZENhbGw7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gdXBkYXRlQ2hhbm5lbHMoZm4pIHtcbiAgICBjb25zdCBjaGFubmVsczIgPSBnZXRDaGFubmVscygpO1xuICAgIGZuPy4oY2hhbm5lbHMyKTtcbiAgICByZXR1cm4gZ2V0Q2xpZW50cyhjaGFubmVsczIpO1xuICB9XG4gIGdldENsaWVudHMoKTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgY2xpZW50cygpIHtcbiAgICAgIHJldHVybiBnZXRDbGllbnRzKCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbnMsXG4gICAgdXBkYXRlQ2hhbm5lbHMsXG4gICAgYnJvYWRjYXN0OiBicm9hZGNhc3RQcm94eSxcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2UgYGJyb2FkY2FzdGBcbiAgICAgKi9cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGRlcHJlY2F0ZWRcbiAgICBib2FyZGNhc3Q6IGJyb2FkY2FzdFByb3h5XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9taXNlV2l0aFJlc29sdmVycygpIHtcbiAgbGV0IHJlc29sdmU7XG4gIGxldCByZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufVxuY29uc3QgdXJsQWxwaGFiZXQgPSBcInVzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3RcIjtcbmZ1bmN0aW9uIG5hbm9pZChzaXplID0gMjEpIHtcbiAgbGV0IGlkID0gXCJcIjtcbiAgbGV0IGkgPSBzaXplO1xuICB3aGlsZSAoaS0tKVxuICAgIGlkICs9IHVybEFscGhhYmV0W3JhbmRvbSgpICogNjQgfCAwXTtcbiAgcmV0dXJuIGlkO1xufVxuXG5leHBvcnQgeyBERUZBVUxUX1RJTUVPVVQsIGNhY2hlZE1hcCwgY3JlYXRlQmlycGMsIGNyZWF0ZUJpcnBjR3JvdXAgfTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgdHJ5VG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZycpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcih0cnlUb1N0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG5cbnZhciBVTlNDT1BBQkxFUyA9IHdlbGxLbm93blN5bWJvbCgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5pZiAoQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdID09PSB1bmRlZmluZWQpIHtcbiAgZGVmaW5lUHJvcGVydHkoQXJyYXlQcm90b3R5cGUsIFVOU0NPUEFCTEVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjcmVhdGUobnVsbClcbiAgfSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFByb3RvdHlwZSkge1xuICBpZiAoaXNQcm90b3R5cGVPZihQcm90b3R5cGUsIGl0KSkgcmV0dXJuIGl0O1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcignSW5jb3JyZWN0IGludm9jYXRpb24nKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJFN0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT09IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICBpZiAodmFsdWUgIT09IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UnKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGZvckVhY2gsIG1hcCwgZmlsdGVyLCBzb21lLCBldmVyeSwgZmluZCwgZmluZEluZGV4LCBmaWx0ZXJSZWplY3QgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT09IDY7XG4gIHZhciBJU19GSUxURVJfUkVKRUNUID0gVFlQRSA9PT0gNztcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2Uoc2VsZik7XG4gICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIHRoYXQpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSIHx8IElTX0ZJTFRFUl9SRUpFQ1QgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZSwgcmVzdWx0O1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlc3VsdCA9IGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsdWU7ICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiBwdXNoKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2Ugc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSA0OiByZXR1cm4gZmFsc2U7ICAgICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICAgICAgY2FzZSA3OiBwdXNoKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclJlamVjdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuICBmb3JFYWNoOiBjcmVhdGVNZXRob2QoMCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4gIG1hcDogY3JlYXRlTWV0aG9kKDEpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuICBmaWx0ZXI6IGNyZWF0ZU1ldGhvZCgyKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuICBzb21lOiBjcmVhdGVNZXRob2QoMyksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuICBldmVyeTogY3JlYXRlTWV0aG9kKDQpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4gIGZpbmQ6IGNyZWF0ZU1ldGhvZCg1KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcbiAgZmluZEluZGV4OiBjcmVhdGVNZXRob2QoNiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyUmVqZWN0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXktZmlsdGVyaW5nXG4gIGZpbHRlclJlamVjdDogY3JlYXRlTWV0aG9kKDcpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgVjhfVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnZpcm9ubWVudC12OC12ZXJzaW9uJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuICAvLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc3XG4gIHJldHVybiBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gYXJyYXkuY29uc3RydWN0b3IgPSB7fTtcbiAgICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGZvbzogMSB9O1xuICAgIH07XG4gICAgcmV0dXJuIGFycmF5W01FVEhPRF9OQU1FXShCb29sZWFuKS5mb28gIT09IDE7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgYXJndW1lbnQpIHtcbiAgdmFyIG1ldGhvZCA9IFtdW01FVEhPRF9OQU1FXTtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgbWV0aG9kLmNhbGwobnVsbCwgYXJndW1lbnQgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gMTsgfSwgMSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgaXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jb25zdHJ1Y3RvcicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xudmFyICRBcnJheSA9IEFycmF5O1xuXG4vLyBhIHBhcnQgb2YgYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWxBcnJheSkpIHtcbiAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmIChpc0NvbnN0cnVjdG9yKEMpICYmIChDID09PSAkQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGVsc2UgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gJEFycmF5IDogQztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG4vLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoYXJyYXlTcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWxBcnJheSkpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpdGVyYXRvckNsb3NlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlJyk7XG5cbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIEVOVFJJRVMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxudmFyIHRvU3RyaW5nID0gdW5jdXJyeVRoaXMoe30udG9TdHJpbmcpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gc3RyaW5nU2xpY2UodG9TdHJpbmcoaXQpLCA4LCAtMSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgY2xhc3NvZlJhdyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2Bcbm1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9ICRPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PT0gJ09iamVjdCcgJiYgaXNDYWxsYWJsZShPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL293bi1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBleGNlcHRpb25zKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzT3duKHRhcmdldCwga2V5KSAmJiAhKGV4Y2VwdGlvbnMgJiYgaGFzT3duKGV4Y2VwdGlvbnMsIGtleSkpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2woJ21hdGNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHZhciByZWdleHAgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgIHRyeSB7XG4gICAgICByZWdleHBbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlaXRlcnJlc3VsdG9iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIGRvbmUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiBkb25lIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtrZXldID0gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIG1ha2VCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL21ha2UtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcikge1xuICBpZiAoZGVzY3JpcHRvci5nZXQpIG1ha2VCdWlsdEluKGRlc2NyaXB0b3IuZ2V0LCBuYW1lLCB7IGdldHRlcjogdHJ1ZSB9KTtcbiAgaWYgKGRlc2NyaXB0b3Iuc2V0KSBtYWtlQnVpbHRJbihkZXNjcmlwdG9yLnNldCwgbmFtZSwgeyBzZXR0ZXI6IHRydWUgfSk7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eS5mKHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgbWFrZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbWFrZS1idWlsdC1pbicpO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1nbG9iYWwtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMuZW51bWVyYWJsZTtcbiAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubmFtZSA6IGtleTtcbiAgaWYgKGlzQ2FsbGFibGUodmFsdWUpKSBtYWtlQnVpbHRJbih2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0aW9ucy51bnNhZmUpIGRlbGV0ZSBPW2tleV07XG4gICAgICBlbHNlIGlmIChPW2tleV0pIHNpbXBsZSA9IHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihPLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiAhb3B0aW9ucy5ub25Db25maWd1cmFibGUsXG4gICAgICB3cml0YWJsZTogIW9wdGlvbnMubm9uV3JpdGFibGVcbiAgICB9KTtcbiAgfSByZXR1cm4gTztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgZGVmaW5lQnVpbHRJbih0YXJnZXQsIGtleSwgc3JjW2tleV0sIG9wdGlvbnMpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywga2V5LCB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWxUaGlzW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIERldGVjdCBJRTgncyBpbmNvbXBsZXRlIGRlZmluZVByb3BlcnR5IGltcGxlbWVudGF0aW9uXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSlbMV0gIT09IDc7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciBkb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcblxudmFyIG5hdmlnYXRvciA9IGdsb2JhbFRoaXMubmF2aWdhdG9yO1xudmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVzZXJBZ2VudCA/IFN0cmluZyh1c2VyQWdlbnQpIDogJyc7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnZpcm9ubWVudC11c2VyLWFnZW50Jyk7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsVGhpcy5wcm9jZXNzO1xudmFyIERlbm8gPSBnbG9iYWxUaGlzLkRlbm87XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnMgfHwgRGVubyAmJiBEZW5vLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgLy8gaW4gb2xkIENocm9tZSwgdmVyc2lvbnMgb2YgVjggaXNuJ3QgVjggPSBDaHJvbWUgLyAxMFxuICAvLyBidXQgdGhlaXIgY29ycmVjdCB2ZXJzaW9ucyBhcmUgbm90IGludGVyZXN0aW5nIGZvciB1c1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPiAwICYmIG1hdGNoWzBdIDwgNCA/IDEgOiArKG1hdGNoWzBdICsgbWF0Y2hbMV0pO1xufVxuXG4vLyBCcm93c2VyRlMgTm9kZUpTIGBwcm9jZXNzYCBwb2x5ZmlsbCBpbmNvcnJlY3RseSBzZXQgYC52OGAgdG8gYDAuMGBcbi8vIHNvIGNoZWNrIGB1c2VyQWdlbnRgIGV2ZW4gaWYgYC52OGAgZXhpc3RzLCBidXQgMFxuaWYgKCF2ZXJzaW9uICYmIHVzZXJBZ2VudCkge1xuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9ICttYXRjaFsxXTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZlcnNpb247XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5Jyk7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgICAgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5kb250Q2FsbEdldFNldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbFRoaXM7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsVGhpc1tUQVJHRVRdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IGdsb2JhbFRoaXNbVEFSR0VUXSAmJiBnbG9iYWxUaGlzW1RBUkdFVF0ucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMuZG9udENhbGxHZXRTZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmaW5lQnVpbHRJbih0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMtY2xhdXNlJyk7XG52YXIgYUNhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtY2FsbGFibGUnKTtcbnZhciBOQVRJVkVfQklORCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZScpO1xuXG52YXIgYmluZCA9IHVuY3VycnlUaGlzKHVuY3VycnlUaGlzLmJpbmQpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG4gIGFDYWxsYWJsZShmbik7XG4gIHJldHVybiB0aGF0ID09PSB1bmRlZmluZWQgPyBmbiA6IE5BVElWRV9CSU5EID8gYmluZChmbiwgdGhhdCkgOiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBOQVRJVkVfQklORCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZScpO1xuXG52YXIgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX0JJTkQgPyBjYWxsLmJpbmQoY2FsbCkgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsLmFwcGx5KGNhbGwsIGFyZ3VtZW50cyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgRVhJU1RTID0gaGFzT3duKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpO1xuLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xudmFyIFBST1BFUiA9IEVYSVNUUyAmJiAoZnVuY3Rpb24gc29tZXRoaW5nKCkgeyAvKiBlbXB0eSAqLyB9KS5uYW1lID09PSAnc29tZXRoaW5nJztcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyB8fCAoREVTQ1JJUFRPUlMgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKS5jb25maWd1cmFibGUpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2xhc3NvZlJhdyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbikge1xuICAvLyBOYXNob3JuIGJ1ZzpcbiAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTEyOFxuICAvLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xMTMwXG4gIGlmIChjbGFzc29mUmF3KGZuKSA9PT0gJ0Z1bmN0aW9uJykgcmV0dXJuIHVuY3VycnlUaGlzKGZuKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTkFUSVZFX0JJTkQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUnKTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kIC0tIHNhZmVcbnZhciB1bmN1cnJ5VGhpc1dpdGhCaW5kID0gTkFUSVZFX0JJTkQgJiYgRnVuY3Rpb25Qcm90b3R5cGUuYmluZC5iaW5kKGNhbGwsIGNhbGwpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9CSU5EID8gdW5jdXJyeVRoaXNXaXRoQmluZCA6IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc0NhbGxhYmxlKGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKGdsb2JhbFRoaXNbbmFtZXNwYWNlXSkgOiBnbG9iYWxUaGlzW25hbWVzcGFjZV0gJiYgZ2xvYmFsVGhpc1tuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gYEdldEl0ZXJhdG9yRGlyZWN0KG9iailgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRpdGVyYXRvcmRpcmVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgaXRlcmF0b3I6IG9iaixcbiAgICBuZXh0OiBvYmoubmV4dCxcbiAgICBkb25lOiBmYWxzZVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkJyk7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQoZnVuYykgPyB1bmRlZmluZWQgOiBhQ2FsbGFibGUoZnVuYyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbm1vZHVsZS5leHBvcnRzID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgfHxcbiAgY2hlY2sodHlwZW9mIHRoaXMgPT0gJ29iamVjdCcgJiYgdGhpcykgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jIC0tIGZhbGxiYWNrXG4gIChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKHt9Lmhhc093blByb3BlcnR5KTtcblxuLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaGFzb3duIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QoaXQpLCBrZXkpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0ge307XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xuXG4vLyBUaGFua3MgdG8gSUU4IGZvciBpdHMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIURFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT09IDc7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcblxudmFyICRPYmplY3QgPSBPYmplY3Q7XG52YXIgc3BsaXQgPSB1bmN1cnJ5VGhpcygnJy5zcGxpdCk7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICEkT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZihpdCkgPT09ICdTdHJpbmcnID8gc3BsaXQoaXQsICcnKSA6ICRPYmplY3QoaXQpO1xufSA6ICRPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIHN0b3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzKEZ1bmN0aW9uLnRvU3RyaW5nKTtcblxuLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGBjb3JlLWpzQDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuaWYgKCFpc0NhbGxhYmxlKHN0b3JlLmluc3BlY3RTb3VyY2UpKSB7XG4gIHN0b3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub1N0cmluZyhpdCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBOQVRJVkVfV0VBS19NQVAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2Vhay1tYXAtYmFzaWMtZGV0ZWN0aW9uJyk7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxudmFyIE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gJ09iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWxUaGlzLlR5cGVFcnJvcjtcbnZhciBXZWFrTWFwID0gZ2xvYmFsVGhpcy5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVAgfHwgc2hhcmVkLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtYXNzaWduIC0tIHByb3RvdHlwZSBtZXRob2RzIHByb3RlY3Rpb24gKi9cbiAgc3RvcmUuZ2V0ID0gc3RvcmUuZ2V0O1xuICBzdG9yZS5oYXMgPSBzdG9yZS5oYXM7XG4gIHN0b3JlLnNldCA9IHN0b3JlLnNldDtcbiAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWFzc2lnbiAtLSBwcm90b3R5cGUgbWV0aG9kcyBwcm90ZWN0aW9uICovXG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoc3RvcmUuaGFzKGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgc3RvcmUuc2V0KGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gc3RvcmUuZ2V0KGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHN0b3JlLmhhcyhpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChoYXNPd24oaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093bihpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24oaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcblxuLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2FycmF5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktaXNhcnJheSAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmd1bWVudCkge1xuICByZXR1cm4gY2xhc3NvZihhcmd1bWVudCkgPT09ICdBcnJheSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1Jc0hUTUxEREEtaW50ZXJuYWwtc2xvdFxudmFyIGRvY3VtZW50QWxsID0gdHlwZW9mIGRvY3VtZW50ID09ICdvYmplY3QnICYmIGRvY3VtZW50LmFsbDtcblxuLy8gYElzQ2FsbGFibGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby10eXBlb2YtdW5kZWZpbmVkIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBkb2N1bWVudEFsbCA9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudEFsbCAhPT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJyB8fCBhcmd1bWVudCA9PT0gZG9jdW1lbnRBbGw7XG59IDogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBpbnNwZWN0U291cmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlJyk7XG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIGNvbnN0cnVjdCA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnY29uc3RydWN0Jyk7XG52YXIgY29uc3RydWN0b3JSZWdFeHAgPSAvXlxccyooPzpjbGFzc3xmdW5jdGlvbilcXGIvO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcyhjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKTtcbnZhciBJTkNPUlJFQ1RfVE9fU1RSSU5HID0gIWNvbnN0cnVjdG9yUmVnRXhwLnRlc3Qobm9vcCk7XG5cbnZhciBpc0NvbnN0cnVjdG9yTW9kZXJuID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3RydWN0KG5vb3AsIFtdLCBhcmd1bWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgaXNDb25zdHJ1Y3RvckxlZ2FjeSA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKGNsYXNzb2YoYXJndW1lbnQpKSB7XG4gICAgY2FzZSAnQXN5bmNGdW5jdGlvbic6XG4gICAgY2FzZSAnR2VuZXJhdG9yRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nOiByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyB3ZSBjYW4ndCBjaGVjayAucHJvdG90eXBlIHNpbmNlIGNvbnN0cnVjdG9ycyBwcm9kdWNlZCBieSAuYmluZCBoYXZlbid0IGl0XG4gICAgLy8gYEZ1bmN0aW9uI3RvU3RyaW5nYCB0aHJvd3Mgb24gc29tZSBidWlsdC1pdCBmdW5jdGlvbiBpbiBzb21lIGxlZ2FjeSBlbmdpbmVzXG4gICAgLy8gKGZvciBleGFtcGxlLCBgRE9NUXVhZGAgYW5kIHNpbWlsYXIgaW4gRkY0MS0pXG4gICAgcmV0dXJuIElOQ09SUkVDVF9UT19TVFJJTkcgfHwgISFleGVjKGNvbnN0cnVjdG9yUmVnRXhwLCBpbnNwZWN0U291cmNlKGFyZ3VtZW50KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbmlzQ29uc3RydWN0b3JMZWdhY3kuc2hhbSA9IHRydWU7XG5cbi8vIGBJc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjb25zdHJ1Y3RvclxubW9kdWxlLmV4cG9ydHMgPSAhY29uc3RydWN0IHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxlZDtcbiAgcmV0dXJuIGlzQ29uc3RydWN0b3JNb2Rlcm4oaXNDb25zdHJ1Y3Rvck1vZGVybi5jYWxsKVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKE9iamVjdClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihmdW5jdGlvbiAoKSB7IGNhbGxlZCA9IHRydWU7IH0pXG4gICAgfHwgY2FsbGVkO1xufSkgPyBpc0NvbnN0cnVjdG9yTGVnYWN5IDogaXNDb25zdHJ1Y3Rvck1vZGVybjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUoZGV0ZWN0aW9uKSA/IGZhaWxzKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gd2UgY2FuJ3QgdXNlIGp1c3QgYGl0ID09IG51bGxgIHNpbmNlIG9mIGBkb2N1bWVudC5hbGxgIHNwZWNpYWwgY2FzZVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1Jc0hUTUxEREEtaW50ZXJuYWwtc2xvdC1hZWNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gbnVsbCB8fCBpdCA9PT0gdW5kZWZpbmVkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUoaXQpO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2woJ21hdGNoJyk7XG5cbi8vIGBJc1JlZ0V4cGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzcmVnZXhwXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjbGFzc29mKGl0KSA9PT0gJ1JlZ0V4cCcpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZCcpO1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxubW9kdWxlLmV4cG9ydHMgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpO1xuICByZXR1cm4gaXNDYWxsYWJsZSgkU3ltYm9sKSAmJiBpc1Byb3RvdHlwZU9mKCRTeW1ib2wucHJvdG90eXBlLCAkT2JqZWN0KGl0KSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3ItY2xvc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcnMsIGtpbmQsIHZhbHVlKSB7XG4gIGZvciAodmFyIGkgPSBpdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChpdGVyc1tpXSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBpdGVyYXRvckNsb3NlKGl0ZXJzW2ldLml0ZXJhdG9yLCBraW5kLCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGtpbmQgPSAndGhyb3cnO1xuICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICB9XG4gIH1cbiAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICByZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGdldE1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtbWV0aG9kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBraW5kLCB2YWx1ZSkge1xuICB2YXIgaW5uZXJSZXN1bHQsIGlubmVyRXJyb3I7XG4gIGFuT2JqZWN0KGl0ZXJhdG9yKTtcbiAgdHJ5IHtcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZChpdGVyYXRvciwgJ3JldHVybicpO1xuICAgIGlmICghaW5uZXJSZXN1bHQpIHtcbiAgICAgIGlmIChraW5kID09PSAndGhyb3cnKSB0aHJvdyB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaW5uZXJSZXN1bHQgPSBjYWxsKGlubmVyUmVzdWx0LCBpdGVyYXRvcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW5uZXJFcnJvciA9IHRydWU7XG4gICAgaW5uZXJSZXN1bHQgPSBlcnJvcjtcbiAgfVxuICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gIGlmIChpbm5lckVycm9yKSB0aHJvdyBpbm5lclJlc3VsdDtcbiAgYW5PYmplY3QoaW5uZXJSZXN1bHQpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIGRlZmluZUJ1aWx0SW5zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbnMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgZ2V0TWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1tZXRob2QnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZScpLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdCcpO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3ItY2xvc2UnKTtcbnZhciBpdGVyYXRvckNsb3NlQWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlLWFsbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciBJVEVSQVRPUl9IRUxQRVIgPSAnSXRlcmF0b3JIZWxwZXInO1xudmFyIFdSQVBfRk9SX1ZBTElEX0lURVJBVE9SID0gJ1dyYXBGb3JWYWxpZEl0ZXJhdG9yJztcbnZhciBOT1JNQUwgPSAnbm9ybWFsJztcbnZhciBUSFJPVyA9ICd0aHJvdyc7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xuXG52YXIgY3JlYXRlSXRlcmF0b3JQcm94eVByb3RvdHlwZSA9IGZ1bmN0aW9uIChJU19JVEVSQVRPUikge1xuICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKElTX0lURVJBVE9SID8gV1JBUF9GT1JfVkFMSURfSVRFUkFUT1IgOiBJVEVSQVRPUl9IRUxQRVIpO1xuXG4gIHJldHVybiBkZWZpbmVCdWlsdElucyhjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpLCB7XG4gICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAvLyBmb3Igc2ltcGxpZmljYXRpb246XG4gICAgICAvLyAgIGZvciBgJVdyYXBGb3JWYWxpZEl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBvciB3aXRoIGBzdGF0ZS5yZXR1cm5IYW5kbGVyUmVzdWx0YCBvdXIgYG5leHRIYW5kbGVyYCByZXR1cm5zIGBJdGVyUmVzdWx0T2JqZWN0YFxuICAgICAgLy8gICBmb3IgYCVJdGVyYXRvckhlbHBlclByb3RvdHlwZSUubmV4dGAgLSBqdXN0IGEgdmFsdWVcbiAgICAgIGlmIChJU19JVEVSQVRPUikgcmV0dXJuIHN0YXRlLm5leHRIYW5kbGVyKCk7XG4gICAgICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBzdGF0ZS5uZXh0SGFuZGxlcigpO1xuICAgICAgICByZXR1cm4gc3RhdGUucmV0dXJuSGFuZGxlclJlc3VsdCA/IHJlc3VsdCA6IGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QocmVzdWx0LCBzdGF0ZS5kb25lKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHN0YXRlLmRvbmUgPSB0cnVlO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9LFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gc3RhdGUuaXRlcmF0b3I7XG4gICAgICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgICAgIGlmIChJU19JVEVSQVRPUikge1xuICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZ2V0TWV0aG9kKGl0ZXJhdG9yLCAncmV0dXJuJyk7XG4gICAgICAgIHJldHVybiByZXR1cm5NZXRob2QgPyBjYWxsKHJldHVybk1ldGhvZCwgaXRlcmF0b3IpIDogY3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmlubmVyKSB0cnkge1xuICAgICAgICBpdGVyYXRvckNsb3NlKHN0YXRlLmlubmVyLml0ZXJhdG9yLCBOT1JNQUwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIFRIUk9XLCBlcnJvcik7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUub3Blbkl0ZXJzKSB0cnkge1xuICAgICAgICBpdGVyYXRvckNsb3NlQWxsKHN0YXRlLm9wZW5JdGVycywgTk9STUFMKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBUSFJPVywgZXJyb3IpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBOT1JNQUwpO1xuICAgICAgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIFdyYXBGb3JWYWxpZEl0ZXJhdG9yUHJvdG90eXBlID0gY3JlYXRlSXRlcmF0b3JQcm94eVByb3RvdHlwZSh0cnVlKTtcbnZhciBJdGVyYXRvckhlbHBlclByb3RvdHlwZSA9IGNyZWF0ZUl0ZXJhdG9yUHJveHlQcm90b3R5cGUoZmFsc2UpO1xuXG5jcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoSXRlcmF0b3JIZWxwZXJQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsICdJdGVyYXRvciBIZWxwZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmV4dEhhbmRsZXIsIElTX0lURVJBVE9SLCBSRVRVUk5fSEFORExFUl9SRVNVTFQpIHtcbiAgdmFyIEl0ZXJhdG9yUHJveHkgPSBmdW5jdGlvbiBJdGVyYXRvcihyZWNvcmQsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICBzdGF0ZS5pdGVyYXRvciA9IHJlY29yZC5pdGVyYXRvcjtcbiAgICAgIHN0YXRlLm5leHQgPSByZWNvcmQubmV4dDtcbiAgICB9IGVsc2Ugc3RhdGUgPSByZWNvcmQ7XG4gICAgc3RhdGUudHlwZSA9IElTX0lURVJBVE9SID8gV1JBUF9GT1JfVkFMSURfSVRFUkFUT1IgOiBJVEVSQVRPUl9IRUxQRVI7XG4gICAgc3RhdGUucmV0dXJuSGFuZGxlclJlc3VsdCA9ICEhUkVUVVJOX0hBTkRMRVJfUkVTVUxUO1xuICAgIHN0YXRlLm5leHRIYW5kbGVyID0gbmV4dEhhbmRsZXI7XG4gICAgc3RhdGUuY291bnRlciA9IDA7XG4gICAgc3RhdGUuZG9uZSA9IGZhbHNlO1xuICAgIHNldEludGVybmFsU3RhdGUodGhpcywgc3RhdGUpO1xuICB9O1xuXG4gIEl0ZXJhdG9yUHJveHkucHJvdG90eXBlID0gSVNfSVRFUkFUT1IgPyBXcmFwRm9yVmFsaWRJdGVyYXRvclByb3RvdHlwZSA6IEl0ZXJhdG9ySGVscGVyUHJvdG90eXBlO1xuXG4gIHJldHVybiBJdGVyYXRvclByb3h5O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFNob3VsZCB0aHJvdyBhbiBlcnJvciBvbiBpbnZhbGlkIGl0ZXJhdG9yXG4vLyBodHRwczovL2lzc3Vlcy5jaHJvbWl1bS5vcmcvaXNzdWVzLzMzNjgzOTExNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgYXJndW1lbnQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWl0ZXJhdG9yIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHZhciBtZXRob2QgPSB0eXBlb2YgSXRlcmF0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBJdGVyYXRvci5wcm90b3R5cGVbbWV0aG9kTmFtZV07XG4gIGlmIChtZXRob2QpIHRyeSB7XG4gICAgbWV0aG9kLmNhbGwoeyBuZXh0OiBudWxsIH0sIGFyZ3VtZW50KS5uZXh0KCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9lY21hMjYyL3B1bGwvMzQ2N1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUsIEV4cGVjdGVkRXJyb3IpIHtcbiAgdmFyIEl0ZXJhdG9yID0gZ2xvYmFsVGhpcy5JdGVyYXRvcjtcbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gSXRlcmF0b3IgJiYgSXRlcmF0b3IucHJvdG90eXBlO1xuICB2YXIgbWV0aG9kID0gSXRlcmF0b3JQcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGVbTUVUSE9EX05BTUVdO1xuXG4gIHZhciBDTE9TRUQgPSBmYWxzZTtcblxuICBpZiAobWV0aG9kKSB0cnkge1xuICAgIG1ldGhvZC5jYWxsKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyB9LFxuICAgICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHsgQ0xPU0VEID0gdHJ1ZTsgfVxuICAgIH0sIC0xKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkxMTk1XG4gICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFeHBlY3RlZEVycm9yKSkgQ0xPU0VEID0gZmFsc2U7XG4gIH1cblxuICBpZiAoIUNMT1NFRCkgcmV0dXJuIG1ldGhvZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1hcnJheS1wcm90b3R5cGUta2V5cyAtLSBzYWZlICovXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbnZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gIWlzT2JqZWN0KEl0ZXJhdG9yUHJvdG90eXBlKSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXN0ID0ge307XG4gIC8vIEZGNDQtIGxlZ2FjeSBpdGVyYXRvcnMgY2FzZVxuICByZXR1cm4gSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdLmNhbGwodGVzdCkgIT09IHRlc3Q7XG59KTtcblxuaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5lbHNlIGlmIChJU19QVVJFKSBJdGVyYXRvclByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLUBAaXRlcmF0b3JcbmlmICghaXNDYWxsYWJsZShJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0pKSB7XG4gIGRlZmluZUJ1aWx0SW4oSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xuXG4vLyBgTGVuZ3RoT2ZBcnJheUxpa2VgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1sZW5ndGhvZmFycmF5bGlrZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0b0xlbmd0aChvYmoubGVuZ3RoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUnKS5DT05GSUdVUkFCTEU7XG52YXIgaW5zcGVjdFNvdXJjZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZScpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKCcnLnJlcGxhY2UpO1xudmFyIGpvaW4gPSB1bmN1cnJ5VGhpcyhbXS5qb2luKTtcblxudmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAnbGVuZ3RoJywgeyB2YWx1ZTogOCB9KS5sZW5ndGggIT09IDg7XG59KTtcblxudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xuXG52YXIgbWFrZUJ1aWx0SW4gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuICBpZiAoc3RyaW5nU2xpY2UoJFN0cmluZyhuYW1lKSwgMCwgNykgPT09ICdTeW1ib2woJykge1xuICAgIG5hbWUgPSAnWycgKyByZXBsYWNlKCRTdHJpbmcobmFtZSksIC9eU3ltYm9sXFwoKFteKV0qKVxcKS4qJC8sICckMScpICsgJ10nO1xuICB9XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2V0dGVyKSBuYW1lID0gJ2dldCAnICsgbmFtZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuICBpZiAoIWhhc093bih2YWx1ZSwgJ25hbWUnKSB8fCAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIHsgdmFsdWU6IG5hbWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICBlbHNlIHZhbHVlLm5hbWUgPSBuYW1lO1xuICB9XG4gIGlmIChDT05GSUdVUkFCTEVfTEVOR1RIICYmIG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsICdhcml0eScpICYmIHZhbHVlLmxlbmd0aCAhPT0gb3B0aW9ucy5hcml0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KHZhbHVlLCAnbGVuZ3RoJywgeyB2YWx1ZTogb3B0aW9ucy5hcml0eSB9KTtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCAnY29uc3RydWN0b3InKSAmJiBvcHRpb25zLmNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5KHZhbHVlLCAncHJvdG90eXBlJywgeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgLy8gaW4gVjggfiBDaHJvbWUgNTMsIHByb3RvdHlwZXMgb2Ygc29tZSBtZXRob2RzLCBsaWtlIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCwgYXJlIG5vbi13cml0YWJsZVxuICAgIH0gZWxzZSBpZiAodmFsdWUucHJvdG90eXBlKSB2YWx1ZS5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpO1xuICBpZiAoIWhhc093bihzdGF0ZSwgJ3NvdXJjZScpKSB7XG4gICAgc3RhdGUuc291cmNlID0gam9pbihURU1QTEFURSwgdHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmUgLS0gcmVxdWlyZWRcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSh0aGlzKSAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xufSwgJ3RvU3RyaW5nJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBNYXRoLnRydW5jYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC50cnVuY1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW1hdGgtdHJ1bmMgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yIDogY2VpbCkobik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXJlZ2V4cCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzUmVnRXhwKGl0KSkge1xuICAgIHRocm93IG5ldyAkVHlwZUVycm9yKFwiVGhlIG1ldGhvZCBkb2Vzbid0IGFjY2VwdCByZWd1bGFyIGV4cHJlc3Npb25zXCIpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAtLSBvbGQgSUUsIFdTSCAqL1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2h0bWwnKTtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xuXG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtYXNzaWdubWVudCAtLSBhdm9pZCBtZW1vcnkgbGVha1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsO1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGlnbm9yZSAqLyB9XG4gIE51bGxQcm90b09iamVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJ1xuICAgID8gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudFxuICAgICAgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgLy8gb2xkIElFXG4gICAgICA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpXG4gICAgOiBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7IC8vIFdTSFxuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtY3JlYXRlIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXNNb2R1bGUuZihyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyAmJiAhVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0KFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pZTgtZG9tLWRlZmluZScpO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXknKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbnZhciBDT05GSUdVUkFCTEUgPSAnY29uZmlndXJhYmxlJztcbnZhciBXUklUQUJMRSA9ICd3cml0YWJsZSc7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmICh0eXBlb2YgTyA9PT0gJ2Z1bmN0aW9uJyAmJiBQID09PSAncHJvdG90eXBlJyAmJiAndmFsdWUnIGluIEF0dHJpYnV0ZXMgJiYgV1JJVEFCTEUgaW4gQXR0cmlidXRlcyAmJiAhQXR0cmlidXRlc1tXUklUQUJMRV0pIHtcbiAgICB2YXIgY3VycmVudCA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcbiAgICAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgQXR0cmlidXRlcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFXSxcbiAgICAgICAgZW51bWVyYWJsZTogRU5VTUVSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tFTlVNRVJBQkxFXSA6IGN1cnJlbnRbRU5VTUVSQUJMRV0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH0gcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbn0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IG5ldyAkVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhc093bihPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighY2FsbChwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLCBPLCBQKSwgT1tQXSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlcicpO1xuXG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciBPYmplY3RQcm90b3R5cGUgPSAkT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/ICRPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXNPd24ob2JqZWN0LCBJRV9QUk9UTykpIHJldHVybiBvYmplY3RbSUVfUFJPVE9dO1xuICB2YXIgY29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmIChpc0NhbGxhYmxlKGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mICRPYmplY3QgPyBPYmplY3RQcm90b3R5cGUgOiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmN1cnJ5VGhpcyh7fS5pc1Byb3RvdHlwZU9mKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhc093bihoaWRkZW5LZXlzLCBrZXkpICYmIGhhc093bihPLCBrZXkpICYmIHB1c2gocmVzdWx0LCBrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gocmVzdWx0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyB7fS50b1N0cmluZyA6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoaXNDYWxsYWJsZShmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QodmFsID0gY2FsbChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG5cbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNOdWxsT3JVbmRlZmluZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtbnVsbC1vci11bmRlZmluZWQnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKGl0KSkgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xuXG52YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eScpO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbFRoaXNbU0hBUkVEXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShTSEFSRUQsIHt9KTtcblxuKHN0b3JlLnZlcnNpb25zIHx8IChzdG9yZS52ZXJzaW9ucyA9IFtdKSkucHVzaCh7XG4gIHZlcnNpb246ICczLjQ3LjAnLFxuICBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyNSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSwgMjAyNSBDb3JlSlMgQ29tcGFueSAoY29yZS1qcy5pbyknLFxuICBsaWNlbnNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My40Ny4wL0xJQ0VOU0UnLFxuICBzb3VyY2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcydcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0b3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgfHwge30pO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW52aXJvbm1lbnQtdjgtdmVyc2lvbicpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xuXG52YXIgJFN0cmluZyA9IGdsb2JhbFRoaXMuU3RyaW5nO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgnc3ltYm9sIGRldGVjdGlvbicpO1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG4gIC8vIG5iOiBEbyBub3QgY2FsbCBgU3RyaW5nYCBkaXJlY3RseSB0byBhdm9pZCB0aGlzIGJlaW5nIG9wdGltaXplZCBvdXQgdG8gYHN5bWJvbCsnJ2Agd2hpY2ggd2lsbCxcbiAgLy8gb2YgY291cnNlLCBmYWlsLlxuICByZXR1cm4gISRTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04gJiYgVjhfVkVSU0lPTiA8IDQxO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5Jyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRydW5jID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL21hdGgtdHJ1bmMnKTtcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgbnVtYmVyID0gK2FyZ3VtZW50O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICByZXR1cm4gbnVtYmVyICE9PSBudW1iZXIgfHwgbnVtYmVyID09PSAwID8gMCA6IHRydW5jKG51bWJlcik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xuXG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgbGVuID0gdG9JbnRlZ2VyT3JJbmZpbml0eShhcmd1bWVudCk7XG4gIHJldHVybiBsZW4gPiAwID8gbWluKGxlbiwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuICRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1zeW1ib2wnKTtcbnZhciBnZXRNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LW1ldGhvZCcpO1xudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcblxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIGlmICghaXNPYmplY3QoaW5wdXQpIHx8IGlzU3ltYm9sKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kKGlucHV0LCBUT19QUklNSVRJVkUpO1xuICB2YXIgcmVzdWx0O1xuICBpZiAoZXhvdGljVG9QcmltKSB7XG4gICAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdkZWZhdWx0JztcbiAgICByZXN1bHQgPSBjYWxsKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QocmVzdWx0KSB8fCBpc1N5bWJvbChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHRocm93IG5ldyAkVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1zeW1ib2wnKTtcblxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBrZXkgKyAnJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLWltbWVkaWF0ZS1tdXRhdGlvbiAtLSBFUzMgc3ludGF4IGxpbWl0YXRpb25cbnRlc3RbVE9fU1RSSU5HX1RBR10gPSAneic7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoY2xhc3NvZihhcmd1bWVudCkgPT09ICdTeW1ib2wnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZycpO1xuICByZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRTdHJpbmcgPSBTdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbnZhciB0b1N0cmluZyA9IHVuY3VycnlUaGlzKDEuMS50b1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nKCsraWQgKyBwb3N0Zml4LCAzNik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTCAmJlxuICAhU3ltYm9sLnNoYW0gJiZcbiAgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIFY4IH4gQ2hyb21lIDM2LVxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdwcm90b3R5cGUnLCB7XG4gICAgdmFsdWU6IDQyLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KS5wcm90b3R5cGUgIT09IDQyO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWxUaGlzLldlYWtNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNDYWxsYWJsZShXZWFrTWFwKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoU3RyaW5nKFdlYWtNYXApKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbicpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkJyk7XG5cbnZhciBTeW1ib2wgPSBnbG9iYWxUaGlzLlN5bWJvbDtcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sWydmb3InXSB8fCBTeW1ib2wgOiBTeW1ib2wgJiYgU3ltYm9sLndpdGhvdXRTZXR0ZXIgfHwgdWlkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzT3duKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkpIHtcbiAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBOQVRJVkVfU1lNQk9MICYmIGhhc093bihTeW1ib2wsIG5hbWUpXG4gICAgICA/IFN5bWJvbFtuYW1lXVxuICAgICAgOiBjcmVhdGVXZWxsS25vd25TeW1ib2woJ1N5bWJvbC4nICsgbmFtZSk7XG4gIH0gcmV0dXJuIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkZmlsdGVyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLmZpbHRlcjtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0Jyk7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnZmlsdGVyJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIH0sIHtcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJGluY2x1ZGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzJykuaW5jbHVkZXM7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcycpO1xuXG4vLyBGRjk5KyBidWdcbnZhciBCUk9LRU5fT05fU1BBUlNFID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWluY2x1ZGVzIC0tIGRldGVjdGlvblxuICByZXR1cm4gIUFycmF5KDEpLmluY2x1ZGVzKCk7XG59KTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogQlJPS0VOX09OX1NQQVJTRSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdpbmNsdWRlcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdCcpO1xuXG52YXIgbmF0aXZlSm9pbiA9IHVuY3VycnlUaGlzKFtdLmpvaW4pO1xuXG52YXIgRVMzX1NUUklOR1MgPSBJbmRleGVkT2JqZWN0ICE9PSBPYmplY3Q7XG52YXIgRk9SQ0VEID0gRVMzX1NUUklOR1MgfHwgIWFycmF5TWV0aG9kSXNTdHJpY3QoJ2pvaW4nLCAnLCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmpvaW5gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuam9pblxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbmF0aXZlSm9pbih0b0luZGV4ZWRPYmplY3QodGhpcyksIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJywnIDogc2VwYXJhdG9yKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkbWFwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLm1hcDtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0Jyk7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnbWFwJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIH0sIHtcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBkZWZpbmVCdWlsdEluQWNjZXNzb3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLWFjY2Vzc29yJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJykuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcblxudmFyIENPTlNUUlVDVE9SID0gJ2NvbnN0cnVjdG9yJztcbnZhciBJVEVSQVRPUiA9ICdJdGVyYXRvcic7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG52YXIgTmF0aXZlSXRlcmF0b3IgPSBnbG9iYWxUaGlzW0lURVJBVE9SXTtcblxuLy8gRkY1Ni0gaGF2ZSBub24tc3RhbmRhcmQgZ2xvYmFsIGhlbHBlciBgSXRlcmF0b3JgXG52YXIgRk9SQ0VEID0gSVNfUFVSRVxuICB8fCAhaXNDYWxsYWJsZShOYXRpdmVJdGVyYXRvcilcbiAgfHwgTmF0aXZlSXRlcmF0b3IucHJvdG90eXBlICE9PSBJdGVyYXRvclByb3RvdHlwZVxuICAvLyBGRjQ0LSBub24tc3RhbmRhcmQgYEl0ZXJhdG9yYCBwYXNzZXMgcHJldmlvdXMgdGVzdHNcbiAgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHsgTmF0aXZlSXRlcmF0b3Ioe30pOyB9KTtcblxudmFyIEl0ZXJhdG9yQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBJdGVyYXRvcigpIHtcbiAgYW5JbnN0YW5jZSh0aGlzLCBJdGVyYXRvclByb3RvdHlwZSk7XG4gIGlmIChnZXRQcm90b3R5cGVPZih0aGlzKSA9PT0gSXRlcmF0b3JQcm90b3R5cGUpIHRocm93IG5ldyAkVHlwZUVycm9yKCdBYnN0cmFjdCBjbGFzcyBJdGVyYXRvciBub3QgZGlyZWN0bHkgY29uc3RydWN0YWJsZScpO1xufTtcblxudmFyIGRlZmluZUl0ZXJhdG9yUHJvdG90eXBlQWNjZXNzb3IgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgICBkZWZpbmVCdWlsdEluQWNjZXNzb3IoSXRlcmF0b3JQcm90b3R5cGUsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChyZXBsYWNlbWVudCkge1xuICAgICAgICBhbk9iamVjdCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMgPT09IEl0ZXJhdG9yUHJvdG90eXBlKSB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIllvdSBjYW4ndCByZWRlZmluZSB0aGlzIHByb3BlcnR5XCIpO1xuICAgICAgICBpZiAoaGFzT3duKHRoaXMsIGtleSkpIHRoaXNba2V5XSA9IHJlcGxhY2VtZW50O1xuICAgICAgICBlbHNlIGNyZWF0ZVByb3BlcnR5KHRoaXMsIGtleSwgcmVwbGFjZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgSXRlcmF0b3JQcm90b3R5cGVba2V5XSA9IHZhbHVlO1xufTtcblxuaWYgKCFoYXNPd24oSXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcpKSBkZWZpbmVJdGVyYXRvclByb3RvdHlwZUFjY2Vzc29yKFRPX1NUUklOR19UQUcsIElURVJBVE9SKTtcblxuaWYgKEZPUkNFRCB8fCAhaGFzT3duKEl0ZXJhdG9yUHJvdG90eXBlLCBDT05TVFJVQ1RPUikgfHwgSXRlcmF0b3JQcm90b3R5cGVbQ09OU1RSVUNUT1JdID09PSBPYmplY3QpIHtcbiAgZGVmaW5lSXRlcmF0b3JQcm90b3R5cGVBY2Nlc3NvcihDT05TVFJVQ1RPUiwgSXRlcmF0b3JDb25zdHJ1Y3Rvcik7XG59XG5cbkl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gSXRlcmF0b3JQcm90b3R5cGU7XG5cbi8vIGBJdGVyYXRvcmAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXRlcmF0b3JcbiQoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIEl0ZXJhdG9yOiBJdGVyYXRvckNvbnN0cnVjdG9yXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGFDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWNhbGxhYmxlJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgZ2V0SXRlcmF0b3JEaXJlY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLWRpcmVjdCcpO1xudmFyIGNyZWF0ZUl0ZXJhdG9yUHJveHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3ItY3JlYXRlLXByb3h5Jyk7XG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZycpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3ItY2xvc2UnKTtcbnZhciBpdGVyYXRvckhlbHBlclRocm93c09uSW52YWxpZEl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWhlbHBlci10aHJvd3Mtb24taW52YWxpZC1pdGVyYXRvcicpO1xudmFyIGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3ItaGVscGVyLXdpdGhvdXQtY2xvc2luZy1vbi1lYXJseS1lcnJvcicpO1xuXG52YXIgRklMVEVSX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiA9ICFJU19QVVJFICYmICFpdGVyYXRvckhlbHBlclRocm93c09uSW52YWxpZEl0ZXJhdG9yKCdmaWx0ZXInLCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xudmFyIGZpbHRlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gIUlTX1BVUkUgJiYgIUZJTFRFUl9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1JcbiAgJiYgaXRlcmF0b3JIZWxwZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcignZmlsdGVyJywgVHlwZUVycm9yKTtcblxudmFyIEZPUkNFRCA9IElTX1BVUkUgfHwgRklMVEVSX1dJVEhPVVRfVEhST1dJTkdfT05fSU5WQUxJRF9JVEVSQVRPUiB8fCBmaWx0ZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvcjtcblxudmFyIEl0ZXJhdG9yUHJveHkgPSBjcmVhdGVJdGVyYXRvclByb3h5KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcjtcbiAgdmFyIHByZWRpY2F0ZSA9IHRoaXMucHJlZGljYXRlO1xuICB2YXIgbmV4dCA9IHRoaXMubmV4dDtcbiAgdmFyIHJlc3VsdCwgZG9uZSwgdmFsdWU7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgcmVzdWx0ID0gYW5PYmplY3QoY2FsbChuZXh0LCBpdGVyYXRvcikpO1xuICAgIGRvbmUgPSB0aGlzLmRvbmUgPSAhIXJlc3VsdC5kb25lO1xuICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgaWYgKGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIHByZWRpY2F0ZSwgW3ZhbHVlLCB0aGlzLmNvdW50ZXIrK10sIHRydWUpKSByZXR1cm4gdmFsdWU7XG4gIH1cbn0pO1xuXG4vLyBgSXRlcmF0b3IucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yLnByb3RvdHlwZS5maWx0ZXJcbiQoeyB0YXJnZXQ6ICdJdGVyYXRvcicsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgIGFuT2JqZWN0KHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBhQ2FsbGFibGUocHJlZGljYXRlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZSh0aGlzLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKGZpbHRlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKSByZXR1cm4gY2FsbChmaWx0ZXJXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciwgdGhpcywgcHJlZGljYXRlKTtcblxuICAgIHJldHVybiBuZXcgSXRlcmF0b3JQcm94eShnZXRJdGVyYXRvckRpcmVjdCh0aGlzKSwge1xuICAgICAgcHJlZGljYXRlOiBwcmVkaWNhdGVcbiAgICB9KTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGdldEl0ZXJhdG9yRGlyZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1kaXJlY3QnKTtcbnZhciBjcmVhdGVJdGVyYXRvclByb3h5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWNyZWF0ZS1wcm94eScpO1xudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcnKTtcbnZhciBpdGVyYXRvckNsb3NlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWNsb3NlJyk7XG52YXIgaXRlcmF0b3JIZWxwZXJUaHJvd3NPbkludmFsaWRJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvci1oZWxwZXItdGhyb3dzLW9uLWludmFsaWQtaXRlcmF0b3InKTtcbnZhciBpdGVyYXRvckhlbHBlcldpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWhlbHBlci13aXRob3V0LWNsb3Npbmctb24tZWFybHktZXJyb3InKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcblxudmFyIE1BUF9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1IgPSAhSVNfUFVSRSAmJiAhaXRlcmF0b3JIZWxwZXJUaHJvd3NPbkludmFsaWRJdGVyYXRvcignbWFwJywgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbnZhciBtYXBXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciA9ICFJU19QVVJFICYmICFNQVBfV0lUSE9VVF9USFJPV0lOR19PTl9JTlZBTElEX0lURVJBVE9SXG4gICYmIGl0ZXJhdG9ySGVscGVyV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3IoJ21hcCcsIFR5cGVFcnJvcik7XG5cbnZhciBGT1JDRUQgPSBJU19QVVJFIHx8IE1BUF9XSVRIT1VUX1RIUk9XSU5HX09OX0lOVkFMSURfSVRFUkFUT1IgfHwgbWFwV2l0aG91dENsb3NpbmdPbkVhcmx5RXJyb3I7XG5cbnZhciBJdGVyYXRvclByb3h5ID0gY3JlYXRlSXRlcmF0b3JQcm94eShmdW5jdGlvbiAoKSB7XG4gIHZhciBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3I7XG4gIHZhciByZXN1bHQgPSBhbk9iamVjdChjYWxsKHRoaXMubmV4dCwgaXRlcmF0b3IpKTtcbiAgdmFyIGRvbmUgPSB0aGlzLmRvbmUgPSAhIXJlc3VsdC5kb25lO1xuICBpZiAoIWRvbmUpIHJldHVybiBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCB0aGlzLm1hcHBlciwgW3Jlc3VsdC52YWx1ZSwgdGhpcy5jb3VudGVyKytdLCB0cnVlKTtcbn0pO1xuXG4vLyBgSXRlcmF0b3IucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yLnByb3RvdHlwZS5tYXBcbiQoeyB0YXJnZXQ6ICdJdGVyYXRvcicsIHByb3RvOiB0cnVlLCByZWFsOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIG1hcDogZnVuY3Rpb24gbWFwKG1hcHBlcikge1xuICAgIGFuT2JqZWN0KHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBhQ2FsbGFibGUobWFwcGVyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaXRlcmF0b3JDbG9zZSh0aGlzLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKG1hcFdpdGhvdXRDbG9zaW5nT25FYXJseUVycm9yKSByZXR1cm4gY2FsbChtYXBXaXRob3V0Q2xvc2luZ09uRWFybHlFcnJvciwgdGhpcywgbWFwcGVyKTtcblxuICAgIHJldHVybiBuZXcgSXRlcmF0b3JQcm94eShnZXRJdGVyYXRvckRpcmVjdCh0aGlzKSwge1xuICAgICAgbWFwcGVyOiBtYXBwZXJcbiAgICB9KTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gZGVmaW5lUHJvcGVydHksIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIGRlZmluZVByb3BlcnR5OiBkZWZpbmVQcm9wZXJ0eVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCcpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZycpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbmlmICghVE9fU1RSSU5HX1RBR19TVVBQT1JUKSB7XG4gIGRlZmluZUJ1aWx0SW4oT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgdG9TdHJpbmcsIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgbm90QVJlZ0V4cCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9ub3QtYS1yZWdleHAnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZycpO1xudmFyIGNvcnJlY3RJc1JlZ0V4cExvZ2ljID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcnJlY3QtaXMtcmVnZXhwLWxvZ2ljJyk7XG5cbnZhciBzdHJpbmdJbmRleE9mID0gdW5jdXJyeVRoaXMoJycuaW5kZXhPZik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc1xuJCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFjb3JyZWN0SXNSZWdFeHBMb2dpYygnaW5jbHVkZXMnKSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICByZXR1cm4gISF+c3RyaW5nSW5kZXhPZihcbiAgICAgIHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpLFxuICAgICAgdG9TdHJpbmcobm90QVJlZ0V4cChzZWFyY2hTdHJpbmcpKSxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5pdGVyYXRvci5jb25zdHJ1Y3RvcicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuaXRlcmF0b3IuZmlsdGVyJyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5pdGVyYXRvci5tYXAnKTtcbiIsImZ1bmN0aW9uIGZsYXRIb29rcyhjb25maWdIb29rcywgaG9va3MgPSB7fSwgcGFyZW50TmFtZSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBjb25maWdIb29rcykge1xuICAgIGNvbnN0IHN1Ykhvb2sgPSBjb25maWdIb29rc1trZXldO1xuICAgIGNvbnN0IG5hbWUgPSBwYXJlbnROYW1lID8gYCR7cGFyZW50TmFtZX06JHtrZXl9YCA6IGtleTtcbiAgICBpZiAodHlwZW9mIHN1Ykhvb2sgPT09IFwib2JqZWN0XCIgJiYgc3ViSG9vayAhPT0gbnVsbCkge1xuICAgICAgZmxhdEhvb2tzKHN1Ykhvb2ssIGhvb2tzLCBuYW1lKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdWJIb29rID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGhvb2tzW25hbWVdID0gc3ViSG9vaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhvb2tzO1xufVxuZnVuY3Rpb24gbWVyZ2VIb29rcyguLi5ob29rcykge1xuICBjb25zdCBmaW5hbEhvb2tzID0ge307XG4gIGZvciAoY29uc3QgaG9vayBvZiBob29rcykge1xuICAgIGNvbnN0IGZsYXRlbkhvb2sgPSBmbGF0SG9va3MoaG9vayk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZmxhdGVuSG9vaykge1xuICAgICAgaWYgKGZpbmFsSG9va3Nba2V5XSkge1xuICAgICAgICBmaW5hbEhvb2tzW2tleV0ucHVzaChmbGF0ZW5Ib29rW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluYWxIb29rc1trZXldID0gW2ZsYXRlbkhvb2tba2V5XV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGZpbmFsSG9va3MpIHtcbiAgICBpZiAoZmluYWxIb29rc1trZXldLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IGFycmF5ID0gZmluYWxIb29rc1trZXldO1xuICAgICAgZmluYWxIb29rc1trZXldID0gKC4uLmFyZ3VtZW50c18pID0+IHNlcmlhbChhcnJheSwgKGZ1bmN0aW9uXykgPT4gZnVuY3Rpb25fKC4uLmFyZ3VtZW50c18pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluYWxIb29rc1trZXldID0gZmluYWxIb29rc1trZXldWzBdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmluYWxIb29rcztcbn1cbmZ1bmN0aW9uIHNlcmlhbCh0YXNrcywgZnVuY3Rpb25fKSB7XG4gIHJldHVybiB0YXNrcy5yZWR1Y2UoXG4gICAgKHByb21pc2UsIHRhc2spID0+IHByb21pc2UudGhlbigoKSA9PiBmdW5jdGlvbl8odGFzaykpLFxuICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICk7XG59XG5jb25zdCBkZWZhdWx0VGFzayA9IHsgcnVuOiAoZnVuY3Rpb25fKSA9PiBmdW5jdGlvbl8oKSB9O1xuY29uc3QgX2NyZWF0ZVRhc2sgPSAoKSA9PiBkZWZhdWx0VGFzaztcbmNvbnN0IGNyZWF0ZVRhc2sgPSB0eXBlb2YgY29uc29sZS5jcmVhdGVUYXNrICE9PSBcInVuZGVmaW5lZFwiID8gY29uc29sZS5jcmVhdGVUYXNrIDogX2NyZWF0ZVRhc2s7XG5mdW5jdGlvbiBzZXJpYWxUYXNrQ2FsbGVyKGhvb2tzLCBhcmdzKSB7XG4gIGNvbnN0IG5hbWUgPSBhcmdzLnNoaWZ0KCk7XG4gIGNvbnN0IHRhc2sgPSBjcmVhdGVUYXNrKG5hbWUpO1xuICByZXR1cm4gaG9va3MucmVkdWNlKFxuICAgIChwcm9taXNlLCBob29rRnVuY3Rpb24pID0+IHByb21pc2UudGhlbigoKSA9PiB0YXNrLnJ1bigoKSA9PiBob29rRnVuY3Rpb24oLi4uYXJncykpKSxcbiAgICBQcm9taXNlLnJlc29sdmUoKVxuICApO1xufVxuZnVuY3Rpb24gcGFyYWxsZWxUYXNrQ2FsbGVyKGhvb2tzLCBhcmdzKSB7XG4gIGNvbnN0IG5hbWUgPSBhcmdzLnNoaWZ0KCk7XG4gIGNvbnN0IHRhc2sgPSBjcmVhdGVUYXNrKG5hbWUpO1xuICByZXR1cm4gUHJvbWlzZS5hbGwoaG9va3MubWFwKChob29rKSA9PiB0YXNrLnJ1bigoKSA9PiBob29rKC4uLmFyZ3MpKSkpO1xufVxuZnVuY3Rpb24gc2VyaWFsQ2FsbGVyKGhvb2tzLCBhcmd1bWVudHNfKSB7XG4gIHJldHVybiBob29rcy5yZWR1Y2UoXG4gICAgKHByb21pc2UsIGhvb2tGdW5jdGlvbikgPT4gcHJvbWlzZS50aGVuKCgpID0+IGhvb2tGdW5jdGlvbiguLi5hcmd1bWVudHNfIHx8IFtdKSksXG4gICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgKTtcbn1cbmZ1bmN0aW9uIHBhcmFsbGVsQ2FsbGVyKGhvb2tzLCBhcmdzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChob29rcy5tYXAoKGhvb2spID0+IGhvb2soLi4uYXJncyB8fCBbXSkpKTtcbn1cbmZ1bmN0aW9uIGNhbGxFYWNoV2l0aChjYWxsYmFja3MsIGFyZzApIHtcbiAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBbLi4uY2FsbGJhY2tzXSkge1xuICAgIGNhbGxiYWNrKGFyZzApO1xuICB9XG59XG5cbmNsYXNzIEhvb2thYmxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faG9va3MgPSB7fTtcbiAgICB0aGlzLl9iZWZvcmUgPSB2b2lkIDA7XG4gICAgdGhpcy5fYWZ0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5fZGVwcmVjYXRlZE1lc3NhZ2VzID0gdm9pZCAwO1xuICAgIHRoaXMuX2RlcHJlY2F0ZWRIb29rcyA9IHt9O1xuICAgIHRoaXMuaG9vayA9IHRoaXMuaG9vay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuY2FsbEhvb2sgPSB0aGlzLmNhbGxIb29rLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jYWxsSG9va1dpdGggPSB0aGlzLmNhbGxIb29rV2l0aC5iaW5kKHRoaXMpO1xuICB9XG4gIGhvb2sobmFtZSwgZnVuY3Rpb25fLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIW5hbWUgfHwgdHlwZW9mIGZ1bmN0aW9uXyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWxOYW1lID0gbmFtZTtcbiAgICBsZXQgZGVwO1xuICAgIHdoaWxlICh0aGlzLl9kZXByZWNhdGVkSG9va3NbbmFtZV0pIHtcbiAgICAgIGRlcCA9IHRoaXMuX2RlcHJlY2F0ZWRIb29rc1tuYW1lXTtcbiAgICAgIG5hbWUgPSBkZXAudG87XG4gICAgfVxuICAgIGlmIChkZXAgJiYgIW9wdGlvbnMuYWxsb3dEZXByZWNhdGVkKSB7XG4gICAgICBsZXQgbWVzc2FnZSA9IGRlcC5tZXNzYWdlO1xuICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBgJHtvcmlnaW5hbE5hbWV9IGhvb2sgaGFzIGJlZW4gZGVwcmVjYXRlZGAgKyAoZGVwLnRvID8gYCwgcGxlYXNlIHVzZSAke2RlcC50b31gIDogXCJcIik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2RlcHJlY2F0ZWRNZXNzYWdlcykge1xuICAgICAgICB0aGlzLl9kZXByZWNhdGVkTWVzc2FnZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9kZXByZWNhdGVkTWVzc2FnZXMuaGFzKG1lc3NhZ2UpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fZGVwcmVjYXRlZE1lc3NhZ2VzLmFkZChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmdW5jdGlvbl8ubmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uXywgXCJuYW1lXCIsIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IFwiX1wiICsgbmFtZS5yZXBsYWNlKC9cXFcrL2csIFwiX1wiKSArIFwiX2hvb2tfY2JcIixcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faG9va3NbbmFtZV0gPSB0aGlzLl9ob29rc1tuYW1lXSB8fCBbXTtcbiAgICB0aGlzLl9ob29rc1tuYW1lXS5wdXNoKGZ1bmN0aW9uXyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChmdW5jdGlvbl8pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVIb29rKG5hbWUsIGZ1bmN0aW9uXyk7XG4gICAgICAgIGZ1bmN0aW9uXyA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGhvb2tPbmNlKG5hbWUsIGZ1bmN0aW9uXykge1xuICAgIGxldCBfdW5yZWc7XG4gICAgbGV0IF9mdW5jdGlvbiA9ICguLi5hcmd1bWVudHNfKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIF91bnJlZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIF91bnJlZygpO1xuICAgICAgfVxuICAgICAgX3VucmVnID0gdm9pZCAwO1xuICAgICAgX2Z1bmN0aW9uID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uXyguLi5hcmd1bWVudHNfKTtcbiAgICB9O1xuICAgIF91bnJlZyA9IHRoaXMuaG9vayhuYW1lLCBfZnVuY3Rpb24pO1xuICAgIHJldHVybiBfdW5yZWc7XG4gIH1cbiAgcmVtb3ZlSG9vayhuYW1lLCBmdW5jdGlvbl8pIHtcbiAgICBpZiAodGhpcy5faG9va3NbbmFtZV0pIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5faG9va3NbbmFtZV0uaW5kZXhPZihmdW5jdGlvbl8pO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLl9ob29rc1tuYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2hvb2tzW25hbWVdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy5faG9va3NbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlcHJlY2F0ZUhvb2sobmFtZSwgZGVwcmVjYXRlZCkge1xuICAgIHRoaXMuX2RlcHJlY2F0ZWRIb29rc1tuYW1lXSA9IHR5cGVvZiBkZXByZWNhdGVkID09PSBcInN0cmluZ1wiID8geyB0bzogZGVwcmVjYXRlZCB9IDogZGVwcmVjYXRlZDtcbiAgICBjb25zdCBfaG9va3MgPSB0aGlzLl9ob29rc1tuYW1lXSB8fCBbXTtcbiAgICBkZWxldGUgdGhpcy5faG9va3NbbmFtZV07XG4gICAgZm9yIChjb25zdCBob29rIG9mIF9ob29rcykge1xuICAgICAgdGhpcy5ob29rKG5hbWUsIGhvb2spO1xuICAgIH1cbiAgfVxuICBkZXByZWNhdGVIb29rcyhkZXByZWNhdGVkSG9va3MpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX2RlcHJlY2F0ZWRIb29rcywgZGVwcmVjYXRlZEhvb2tzKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVwcmVjYXRlZEhvb2tzKSB7XG4gICAgICB0aGlzLmRlcHJlY2F0ZUhvb2sobmFtZSwgZGVwcmVjYXRlZEhvb2tzW25hbWVdKTtcbiAgICB9XG4gIH1cbiAgYWRkSG9va3MoY29uZmlnSG9va3MpIHtcbiAgICBjb25zdCBob29rcyA9IGZsYXRIb29rcyhjb25maWdIb29rcyk7XG4gICAgY29uc3QgcmVtb3ZlRm5zID0gT2JqZWN0LmtleXMoaG9va3MpLm1hcChcbiAgICAgIChrZXkpID0+IHRoaXMuaG9vayhrZXksIGhvb2tzW2tleV0pXG4gICAgKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCB1bnJlZyBvZiByZW1vdmVGbnMuc3BsaWNlKDAsIHJlbW92ZUZucy5sZW5ndGgpKSB7XG4gICAgICAgIHVucmVnKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZW1vdmVIb29rcyhjb25maWdIb29rcykge1xuICAgIGNvbnN0IGhvb2tzID0gZmxhdEhvb2tzKGNvbmZpZ0hvb2tzKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBob29rcykge1xuICAgICAgdGhpcy5yZW1vdmVIb29rKGtleSwgaG9va3Nba2V5XSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZUFsbEhvb2tzKCkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuX2hvb2tzKSB7XG4gICAgICBkZWxldGUgdGhpcy5faG9va3Nba2V5XTtcbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sobmFtZSwgLi4uYXJndW1lbnRzXykge1xuICAgIGFyZ3VtZW50c18udW5zaGlmdChuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5jYWxsSG9va1dpdGgoc2VyaWFsVGFza0NhbGxlciwgbmFtZSwgLi4uYXJndW1lbnRzXyk7XG4gIH1cbiAgY2FsbEhvb2tQYXJhbGxlbChuYW1lLCAuLi5hcmd1bWVudHNfKSB7XG4gICAgYXJndW1lbnRzXy51bnNoaWZ0KG5hbWUpO1xuICAgIHJldHVybiB0aGlzLmNhbGxIb29rV2l0aChwYXJhbGxlbFRhc2tDYWxsZXIsIG5hbWUsIC4uLmFyZ3VtZW50c18pO1xuICB9XG4gIGNhbGxIb29rV2l0aChjYWxsZXIsIG5hbWUsIC4uLmFyZ3VtZW50c18pIHtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuX2JlZm9yZSB8fCB0aGlzLl9hZnRlciA/IHsgbmFtZSwgYXJnczogYXJndW1lbnRzXywgY29udGV4dDoge30gfSA6IHZvaWQgMDtcbiAgICBpZiAodGhpcy5fYmVmb3JlKSB7XG4gICAgICBjYWxsRWFjaFdpdGgodGhpcy5fYmVmb3JlLCBldmVudCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxlcihcbiAgICAgIG5hbWUgaW4gdGhpcy5faG9va3MgPyBbLi4udGhpcy5faG9va3NbbmFtZV1dIDogW10sXG4gICAgICBhcmd1bWVudHNfXG4gICAgKTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2FmdGVyICYmIGV2ZW50KSB7XG4gICAgICAgICAgY2FsbEVhY2hXaXRoKHRoaXMuX2FmdGVyLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYWZ0ZXIgJiYgZXZlbnQpIHtcbiAgICAgIGNhbGxFYWNoV2l0aCh0aGlzLl9hZnRlciwgZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGJlZm9yZUVhY2goZnVuY3Rpb25fKSB7XG4gICAgdGhpcy5fYmVmb3JlID0gdGhpcy5fYmVmb3JlIHx8IFtdO1xuICAgIHRoaXMuX2JlZm9yZS5wdXNoKGZ1bmN0aW9uXyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9iZWZvcmUgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2JlZm9yZS5pbmRleE9mKGZ1bmN0aW9uXyk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9iZWZvcmUuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYWZ0ZXJFYWNoKGZ1bmN0aW9uXykge1xuICAgIHRoaXMuX2FmdGVyID0gdGhpcy5fYWZ0ZXIgfHwgW107XG4gICAgdGhpcy5fYWZ0ZXIucHVzaChmdW5jdGlvbl8pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fYWZ0ZXIgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2FmdGVyLmluZGV4T2YoZnVuY3Rpb25fKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX2FmdGVyLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVIb29rcygpIHtcbiAgcmV0dXJuIG5ldyBIb29rYWJsZSgpO1xufVxuXG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuZnVuY3Rpb24gY3JlYXRlRGVidWdnZXIoaG9va3MsIF9vcHRpb25zID0ge30pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBpbnNwZWN0OiBpc0Jyb3dzZXIsXG4gICAgZ3JvdXA6IGlzQnJvd3NlcixcbiAgICBmaWx0ZXI6ICgpID0+IHRydWUsXG4gICAgLi4uX29wdGlvbnNcbiAgfTtcbiAgY29uc3QgX2ZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICBjb25zdCBmaWx0ZXIgPSB0eXBlb2YgX2ZpbHRlciA9PT0gXCJzdHJpbmdcIiA/IChuYW1lKSA9PiBuYW1lLnN0YXJ0c1dpdGgoX2ZpbHRlcikgOiBfZmlsdGVyO1xuICBjb25zdCBfdGFnID0gb3B0aW9ucy50YWcgPyBgWyR7b3B0aW9ucy50YWd9XSBgIDogXCJcIjtcbiAgY29uc3QgbG9nUHJlZml4ID0gKGV2ZW50KSA9PiBfdGFnICsgZXZlbnQubmFtZSArIFwiXCIucGFkRW5kKGV2ZW50Ll9pZCwgXCJcXDBcIik7XG4gIGNvbnN0IF9pZEN0ciA9IHt9O1xuICBjb25zdCB1bnN1YnNjcmliZUJlZm9yZSA9IGhvb2tzLmJlZm9yZUVhY2goKGV2ZW50KSA9PiB7XG4gICAgaWYgKGZpbHRlciAhPT0gdm9pZCAwICYmICFmaWx0ZXIoZXZlbnQubmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX2lkQ3RyW2V2ZW50Lm5hbWVdID0gX2lkQ3RyW2V2ZW50Lm5hbWVdIHx8IDA7XG4gICAgZXZlbnQuX2lkID0gX2lkQ3RyW2V2ZW50Lm5hbWVdKys7XG4gICAgY29uc29sZS50aW1lKGxvZ1ByZWZpeChldmVudCkpO1xuICB9KTtcbiAgY29uc3QgdW5zdWJzY3JpYmVBZnRlciA9IGhvb2tzLmFmdGVyRWFjaCgoZXZlbnQpID0+IHtcbiAgICBpZiAoZmlsdGVyICE9PSB2b2lkIDAgJiYgIWZpbHRlcihldmVudC5uYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ncm91cCkge1xuICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChldmVudC5uYW1lKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaW5zcGVjdCkge1xuICAgICAgY29uc29sZS50aW1lTG9nKGxvZ1ByZWZpeChldmVudCksIGV2ZW50LmFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLnRpbWVFbmQobG9nUHJlZml4KGV2ZW50KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmdyb3VwKSB7XG4gICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfVxuICAgIF9pZEN0cltldmVudC5uYW1lXS0tO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICAvKiogU3RvcCBkZWJ1Z2dpbmcgYW5kIHJlbW92ZSBsaXN0ZW5lcnMgKi9cbiAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgdW5zdWJzY3JpYmVCZWZvcmUoKTtcbiAgICAgIHVuc3Vic2NyaWJlQWZ0ZXIoKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IEhvb2thYmxlLCBjcmVhdGVEZWJ1Z2dlciwgY3JlYXRlSG9va3MsIGZsYXRIb29rcywgbWVyZ2VIb29rcywgcGFyYWxsZWxDYWxsZXIsIHNlcmlhbCwgc2VyaWFsQ2FsbGVyIH07XG4iLCJjb25zdCBERUJPVU5DRV9ERUZBVUxUUyA9IHtcbiAgdHJhaWxpbmc6IHRydWVcbn07XG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgd2FpdCA9IDI1LCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucyA9IHsgLi4uREVCT1VOQ0VfREVGQVVMVFMsIC4uLm9wdGlvbnMgfTtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUod2FpdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYHdhaXRgIHRvIGJlIGEgZmluaXRlIG51bWJlclwiKTtcbiAgfVxuICBsZXQgbGVhZGluZ1ZhbHVlO1xuICBsZXQgdGltZW91dDtcbiAgbGV0IHJlc29sdmVMaXN0ID0gW107XG4gIGxldCBjdXJyZW50UHJvbWlzZTtcbiAgbGV0IHRyYWlsaW5nQXJncztcbiAgY29uc3QgYXBwbHlGbiA9IChfdGhpcywgYXJncykgPT4ge1xuICAgIGN1cnJlbnRQcm9taXNlID0gX2FwcGx5UHJvbWlzZWQoZm4sIF90aGlzLCBhcmdzKTtcbiAgICBjdXJyZW50UHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gbnVsbDtcbiAgICAgIGlmIChvcHRpb25zLnRyYWlsaW5nICYmIHRyYWlsaW5nQXJncyAmJiAhdGltZW91dCkge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gYXBwbHlGbihfdGhpcywgdHJhaWxpbmdBcmdzKTtcbiAgICAgICAgdHJhaWxpbmdBcmdzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGN1cnJlbnRQcm9taXNlO1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGlmIChjdXJyZW50UHJvbWlzZSkge1xuICAgICAgaWYgKG9wdGlvbnMudHJhaWxpbmcpIHtcbiAgICAgICAgdHJhaWxpbmdBcmdzID0gYXJncztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50UHJvbWlzZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBzaG91bGRDYWxsTm93ID0gIXRpbWVvdXQgJiYgb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG9wdGlvbnMubGVhZGluZyA/IGxlYWRpbmdWYWx1ZSA6IGFwcGx5Rm4odGhpcywgYXJncyk7XG4gICAgICAgIGZvciAoY29uc3QgX3Jlc29sdmUgb2YgcmVzb2x2ZUxpc3QpIHtcbiAgICAgICAgICBfcmVzb2x2ZShwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlTGlzdCA9IFtdO1xuICAgICAgfSwgd2FpdCk7XG4gICAgICBpZiAoc2hvdWxkQ2FsbE5vdykge1xuICAgICAgICBsZWFkaW5nVmFsdWUgPSBhcHBseUZuKHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXNvbHZlKGxlYWRpbmdWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlTGlzdC5wdXNoKHJlc29sdmUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gX2FwcGx5UHJvbWlzZWQoZm4sIF90aGlzLCBhcmdzKSB7XG4gIHJldHVybiBhd2FpdCBmbi5hcHBseShfdGhpcywgYXJncyk7XG59XG5cbmV4cG9ydCB7IGRlYm91bmNlIH07XG4iLCIvKiFcbiAqIHBpbmlhIHYzLjAuNFxuICogKGMpIDIwMjUgRWR1YXJkbyBTYW4gTWFydGluIE1vcm90ZVxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IGhhc0luamVjdGlvbkNvbnRleHQsIGluamVjdCwgdG9SYXcsIHdhdGNoLCB1bnJlZiwgbWFya1JhdywgZWZmZWN0U2NvcGUsIHJlZiwgaXNSZWYsIGlzUmVhY3RpdmUsIGdldEN1cnJlbnRTY29wZSwgb25TY29wZURpc3Bvc2UsIGdldEN1cnJlbnRJbnN0YW5jZSwgcmVhY3RpdmUsIHRvUmVmLCBuZXh0VGljaywgY29tcHV0ZWQsIHRvUmVmcyB9IGZyb20gJ3Z1ZSc7XG5pbXBvcnQgeyBzZXR1cERldnRvb2xzUGx1Z2luIH0gZnJvbSAnQHZ1ZS9kZXZ0b29scy1hcGknO1xuXG5jb25zdCBJU19DTElFTlQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBzZXRBY3RpdmVQaW5pYSBtdXN0IGJlIGNhbGxlZCB0byBoYW5kbGUgU1NSIGF0IHRoZSB0b3Agb2YgZnVuY3Rpb25zIGxpa2VcbiAqIGBmZXRjaGAsIGBzZXR1cGAsIGBzZXJ2ZXJQcmVmZXRjaGAgYW5kIG90aGVyc1xuICovXG5sZXQgYWN0aXZlUGluaWE7XG4vKipcbiAqIFNldHMgb3IgdW5zZXRzIHRoZSBhY3RpdmUgcGluaWEuIFVzZWQgaW4gU1NSIGFuZCBpbnRlcm5hbGx5IHdoZW4gY2FsbGluZ1xuICogYWN0aW9ucyBhbmQgZ2V0dGVyc1xuICpcbiAqIEBwYXJhbSBwaW5pYSAtIFBpbmlhIGluc3RhbmNlXG4gKi9cbi8vIEB0cy1leHBlY3QtZXJyb3I6IGNhbm5vdCBjb25zdHJhaW4gdGhlIHR5cGUgb2YgdGhlIHJldHVyblxuY29uc3Qgc2V0QWN0aXZlUGluaWEgPSAocGluaWEpID0+IChhY3RpdmVQaW5pYSA9IHBpbmlhKTtcbi8qKlxuICogR2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIHBpbmlhIGlmIHRoZXJlIGlzIGFueS5cbiAqL1xuY29uc3QgZ2V0QWN0aXZlUGluaWEgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICA/ICgpID0+IHtcbiAgICAgICAgY29uc3QgcGluaWEgPSBoYXNJbmplY3Rpb25Db250ZXh0KCkgJiYgaW5qZWN0KHBpbmlhU3ltYm9sKTtcbiAgICAgICAgaWYgKCFwaW5pYSAmJiAhSVNfQ0xJRU5UKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBb8J+NjV06IFBpbmlhIGluc3RhbmNlIG5vdCBmb3VuZCBpbiBjb250ZXh0LiBUaGlzIGZhbGxzIGJhY2sgdG8gdGhlIGdsb2JhbCBhY3RpdmVQaW5pYSB3aGljaCBleHBvc2VzIHlvdSB0byBjcm9zcy1yZXF1ZXN0IHBvbGx1dGlvbiBvbiB0aGUgc2VydmVyLiBNb3N0IG9mIHRoZSB0aW1lLCBpdCBtZWFucyB5b3UgYXJlIGNhbGxpbmcgXCJ1c2VTdG9yZSgpXCIgaW4gdGhlIHdyb25nIHBsYWNlLlxcbmAgK1xuICAgICAgICAgICAgICAgIGBSZWFkIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL3JldXNhYmlsaXR5L2NvbXBvc2FibGVzLmh0bWwgdG8gbGVhcm4gbW9yZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaW5pYSB8fCBhY3RpdmVQaW5pYTtcbiAgICB9XG4gICAgOiAoKSA9PiAoaGFzSW5qZWN0aW9uQ29udGV4dCgpICYmIGluamVjdChwaW5pYVN5bWJvbCkpIHx8IGFjdGl2ZVBpbmlhO1xuY29uc3QgcGluaWFTeW1ib2wgPSAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gU3ltYm9sKCdwaW5pYScpIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gU3ltYm9sKCkpO1xuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbm8pIHtcbiAgICByZXR1cm4gKG8gJiZcbiAgICAgICAgdHlwZW9mIG8gPT09ICdvYmplY3QnICYmXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiZcbiAgICAgICAgdHlwZW9mIG8udG9KU09OICE9PSAnZnVuY3Rpb24nKTtcbn1cbi8vIHR5cGUgRGVlcFJlYWRvbmx5PFQ+ID0geyByZWFkb25seSBbUCBpbiBrZXlvZiBUXTogRGVlcFJlYWRvbmx5PFRbUF0+IH1cbi8vIFRPRE86IGNhbiB3ZSBjaGFuZ2UgdGhlc2UgdG8gbnVtYmVycz9cbi8qKlxuICogUG9zc2libGUgdHlwZXMgZm9yIFN1YnNjcmlwdGlvbkNhbGxiYWNrXG4gKi9cbnZhciBNdXRhdGlvblR5cGU7XG4oZnVuY3Rpb24gKE11dGF0aW9uVHlwZSkge1xuICAgIC8qKlxuICAgICAqIERpcmVjdCBtdXRhdGlvbiBvZiB0aGUgc3RhdGU6XG4gICAgICpcbiAgICAgKiAtIGBzdG9yZS5uYW1lID0gJ25ldyBuYW1lJ2BcbiAgICAgKiAtIGBzdG9yZS4kc3RhdGUubmFtZSA9ICduZXcgbmFtZSdgXG4gICAgICogLSBgc3RvcmUubGlzdC5wdXNoKCduZXcgaXRlbScpYFxuICAgICAqL1xuICAgIE11dGF0aW9uVHlwZVtcImRpcmVjdFwiXSA9IFwiZGlyZWN0XCI7XG4gICAgLyoqXG4gICAgICogTXV0YXRlZCB0aGUgc3RhdGUgd2l0aCBgJHBhdGNoYCBhbmQgYW4gb2JqZWN0XG4gICAgICpcbiAgICAgKiAtIGBzdG9yZS4kcGF0Y2goeyBuYW1lOiAnbmV3TmFtZScgfSlgXG4gICAgICovXG4gICAgTXV0YXRpb25UeXBlW1wicGF0Y2hPYmplY3RcIl0gPSBcInBhdGNoIG9iamVjdFwiO1xuICAgIC8qKlxuICAgICAqIE11dGF0ZWQgdGhlIHN0YXRlIHdpdGggYCRwYXRjaGAgYW5kIGEgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIC0gYHN0b3JlLiRwYXRjaChzdGF0ZSA9PiBzdGF0ZS5uYW1lID0gJ25ld05hbWUnKWBcbiAgICAgKi9cbiAgICBNdXRhdGlvblR5cGVbXCJwYXRjaEZ1bmN0aW9uXCJdID0gXCJwYXRjaCBmdW5jdGlvblwiO1xuICAgIC8vIG1heWJlIHJlc2V0PyBmb3IgJHN0YXRlID0ge30gYW5kICRyZXNldFxufSkoTXV0YXRpb25UeXBlIHx8IChNdXRhdGlvblR5cGUgPSB7fSkpO1xuXG4vKlxuICogRmlsZVNhdmVyLmpzIEEgc2F2ZUFzKCkgRmlsZVNhdmVyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIE9yaWdpbmFsbHkgYnkgRWxpIEdyZXksIGFkYXB0ZWQgYXMgYW4gRVNNIG1vZHVsZSBieSBFZHVhcmRvIFNhbiBNYXJ0aW5cbiAqIE1vcm90ZS5cbiAqXG4gKiBMaWNlbnNlIDogTUlUXG4gKi9cbi8vIFRoZSBvbmUgYW5kIG9ubHkgd2F5IG9mIGdldHRpbmcgZ2xvYmFsIHNjb3BlIGluIGFsbCBlbnZpcm9ubWVudHNcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zMjc3MTgyLzEwMDg5OTlcbmNvbnN0IF9nbG9iYWwgPSAvKiNfX1BVUkVfXyovICgoKSA9PiB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cud2luZG93ID09PSB3aW5kb3dcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZlxuICAgICAgICA/IHNlbGZcbiAgICAgICAgOiB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWxcbiAgICAgICAgICAgID8gZ2xvYmFsXG4gICAgICAgICAgICA6IHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICAgICAgICAgIDogeyBIVE1MRWxlbWVudDogbnVsbCB9KSgpO1xuZnVuY3Rpb24gYm9tKGJsb2IsIHsgYXV0b0JvbSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIC8vIHByZXBlbmQgQk9NIGZvciBVVEYtOCBYTUwgYW5kIHRleHQvKiB0eXBlcyAoaW5jbHVkaW5nIEhUTUwpXG4gICAgLy8gbm90ZTogeW91ciBicm93c2VyIHdpbGwgYXV0b21hdGljYWxseSBjb252ZXJ0IFVURi0xNiBVK0ZFRkYgdG8gRUYgQkIgQkZcbiAgICBpZiAoYXV0b0JvbSAmJlxuICAgICAgICAvXlxccyooPzp0ZXh0XFwvXFxTKnxhcHBsaWNhdGlvblxcL3htbHxcXFMqXFwvXFxTKlxcK3htbClcXHMqOy4qY2hhcnNldFxccyo9XFxzKnV0Zi04L2kudGVzdChibG9iLnR5cGUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbU3RyaW5nLmZyb21DaGFyQ29kZSgweGZlZmYpLCBibG9iXSwgeyB0eXBlOiBibG9iLnR5cGUgfSk7XG4gICAgfVxuICAgIHJldHVybiBibG9iO1xufVxuZnVuY3Rpb24gZG93bmxvYWQodXJsLCBuYW1lLCBvcHRzKSB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzYXZlQXMoeGhyLnJlc3BvbnNlLCBuYW1lLCBvcHRzKTtcbiAgICB9O1xuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdjb3VsZCBub3QgZG93bmxvYWQgZmlsZScpO1xuICAgIH07XG4gICAgeGhyLnNlbmQoKTtcbn1cbmZ1bmN0aW9uIGNvcnNFbmFibGVkKHVybCkge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIC8vIHVzZSBzeW5jIHRvIGF2b2lkIHBvcHVwIGJsb2NrZXJcbiAgICB4aHIub3BlbignSEVBRCcsIHVybCwgZmFsc2UpO1xuICAgIHRyeSB7XG4gICAgICAgIHhoci5zZW5kKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICByZXR1cm4geGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8PSAyOTk7XG59XG4vLyBgYS5jbGljaygpYCBkb2Vzbid0IHdvcmsgZm9yIGFsbCBicm93c2VycyAoIzQ2NSlcbmZ1bmN0aW9uIGNsaWNrKG5vZGUpIHtcbiAgICB0cnkge1xuICAgICAgICBub2RlLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoJ2NsaWNrJykpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBldnQgPSBuZXcgTW91c2VFdmVudCgnY2xpY2snLCB7XG4gICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZpZXc6IHdpbmRvdyxcbiAgICAgICAgICAgIGRldGFpbDogMCxcbiAgICAgICAgICAgIHNjcmVlblg6IDgwLFxuICAgICAgICAgICAgc2NyZWVuWTogMjAsXG4gICAgICAgICAgICBjbGllbnRYOiA4MCxcbiAgICAgICAgICAgIGNsaWVudFk6IDIwLFxuICAgICAgICAgICAgY3RybEtleTogZmFsc2UsXG4gICAgICAgICAgICBhbHRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgbWV0YUtleTogZmFsc2UsXG4gICAgICAgICAgICBidXR0b246IDAsXG4gICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgfVxufVxuY29uc3QgX25hdmlnYXRvciA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnID8gbmF2aWdhdG9yIDogeyB1c2VyQWdlbnQ6ICcnIH07XG4vLyBEZXRlY3QgV2ViVmlldyBpbnNpZGUgYSBuYXRpdmUgbWFjT1MgYXBwIGJ5IHJ1bGluZyBvdXQgYWxsIGJyb3dzZXJzXG4vLyBXZSBqdXN0IG5lZWQgdG8gY2hlY2sgZm9yICdTYWZhcmknIGJlY2F1c2UgYWxsIG90aGVyIGJyb3dzZXJzIChiZXNpZGVzIEZpcmVmb3gpIGluY2x1ZGUgdGhhdCB0b29cbi8vIGh0dHBzOi8vd3d3LndoYXRpc215YnJvd3Nlci5jb20vZ3VpZGVzL3RoZS1sYXRlc3QtdXNlci1hZ2VudC9tYWNvc1xuY29uc3QgaXNNYWNPU1dlYlZpZXcgPSAvKiNfX1BVUkVfXyovICgoKSA9PiAvTWFjaW50b3NoLy50ZXN0KF9uYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgIC9BcHBsZVdlYktpdC8udGVzdChfbmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAhL1NhZmFyaS8udGVzdChfbmF2aWdhdG9yLnVzZXJBZ2VudCkpKCk7XG5jb25zdCBzYXZlQXMgPSAhSVNfQ0xJRU5UXG4gICAgPyAoKSA9PiB7IH0gLy8gbm9vcFxuICAgIDogLy8gVXNlIGRvd25sb2FkIGF0dHJpYnV0ZSBmaXJzdCBpZiBwb3NzaWJsZSAoIzE5MyBMdW1pYSBtb2JpbGUpIHVubGVzcyB0aGlzIGlzIGEgbWFjT1MgV2ViVmlldyBvciBtaW5pIHByb2dyYW1cbiAgICAgICAgdHlwZW9mIEhUTUxBbmNob3JFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgJ2Rvd25sb2FkJyBpbiBIVE1MQW5jaG9yRWxlbWVudC5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgICFpc01hY09TV2ViVmlld1xuICAgICAgICAgICAgPyBkb3dubG9hZFNhdmVBc1xuICAgICAgICAgICAgOiAvLyBVc2UgbXNTYXZlT3JPcGVuQmxvYiBhcyBhIHNlY29uZCBhcHByb2FjaFxuICAgICAgICAgICAgICAgICdtc1NhdmVPck9wZW5CbG9iJyBpbiBfbmF2aWdhdG9yXG4gICAgICAgICAgICAgICAgICAgID8gbXNTYXZlQXNcbiAgICAgICAgICAgICAgICAgICAgOiAvLyBGYWxsYmFjayB0byB1c2luZyBGaWxlUmVhZGVyIGFuZCBhIHBvcHVwXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlU2F2ZXJTYXZlQXM7XG5mdW5jdGlvbiBkb3dubG9hZFNhdmVBcyhibG9iLCBuYW1lID0gJ2Rvd25sb2FkJywgb3B0cykge1xuICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgYS5kb3dubG9hZCA9IG5hbWU7XG4gICAgYS5yZWwgPSAnbm9vcGVuZXInOyAvLyB0YWJuYWJiaW5nXG4gICAgLy8gVE9ETzogZGV0ZWN0IGNocm9tZSBleHRlbnNpb25zICYgcGFja2FnZWQgYXBwc1xuICAgIC8vIGEudGFyZ2V0ID0gJ19ibGFuaydcbiAgICBpZiAodHlwZW9mIGJsb2IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgcmVndWxhciBsaW5rc1xuICAgICAgICBhLmhyZWYgPSBibG9iO1xuICAgICAgICBpZiAoYS5vcmlnaW4gIT09IGxvY2F0aW9uLm9yaWdpbikge1xuICAgICAgICAgICAgaWYgKGNvcnNFbmFibGVkKGEuaHJlZikpIHtcbiAgICAgICAgICAgICAgICBkb3dubG9hZChibG9iLCBuYW1lLCBvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGEudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgICAgICAgICAgY2xpY2soYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGljayhhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gU3VwcG9ydCBibG9ic1xuICAgICAgICBhLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYS5ocmVmKTtcbiAgICAgICAgfSwgNGU0KTsgLy8gNDBzXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xpY2soYSk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1zU2F2ZUFzKGJsb2IsIG5hbWUgPSAnZG93bmxvYWQnLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBibG9iID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoY29yc0VuYWJsZWQoYmxvYikpIHtcbiAgICAgICAgICAgIGRvd25sb2FkKGJsb2IsIG5hbWUsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgIGEuaHJlZiA9IGJsb2I7XG4gICAgICAgICAgICBhLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2xpY2soYSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZTogd29ya3Mgb24gd2luZG93c1xuICAgICAgICBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihib20oYmxvYiwgb3B0cyksIG5hbWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbGVTYXZlclNhdmVBcyhibG9iLCBuYW1lLCBvcHRzLCBwb3B1cCkge1xuICAgIC8vIE9wZW4gYSBwb3B1cCBpbW1lZGlhdGVseSBkbyBnbyBhcm91bmQgcG9wdXAgYmxvY2tlclxuICAgIC8vIE1vc3RseSBvbmx5IGF2YWlsYWJsZSBvbiB1c2VyIGludGVyYWN0aW9uIGFuZCB0aGUgZmlsZVJlYWRlciBpcyBhc3luYyBzby4uLlxuICAgIHBvcHVwID0gcG9wdXAgfHwgb3BlbignJywgJ19ibGFuaycpO1xuICAgIGlmIChwb3B1cCkge1xuICAgICAgICBwb3B1cC5kb2N1bWVudC50aXRsZSA9IHBvcHVwLmRvY3VtZW50LmJvZHkuaW5uZXJUZXh0ID0gJ2Rvd25sb2FkaW5nLi4uJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBibG9iID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGRvd25sb2FkKGJsb2IsIG5hbWUsIG9wdHMpO1xuICAgIGNvbnN0IGZvcmNlID0gYmxvYi50eXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICBjb25zdCBpc1NhZmFyaSA9IC9jb25zdHJ1Y3Rvci9pLnRlc3QoU3RyaW5nKF9nbG9iYWwuSFRNTEVsZW1lbnQpKSB8fCAnc2FmYXJpJyBpbiBfZ2xvYmFsO1xuICAgIGNvbnN0IGlzQ2hyb21lSU9TID0gL0NyaU9TXFwvW1xcZF0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIGlmICgoaXNDaHJvbWVJT1MgfHwgKGZvcmNlICYmIGlzU2FmYXJpKSB8fCBpc01hY09TV2ViVmlldykgJiZcbiAgICAgICAgdHlwZW9mIEZpbGVSZWFkZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IGFsbG93IGRvd25sb2FkaW5nIG9mIGJsb2IgVVJMc1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGV0IHVybCA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwb3B1cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyByZWFkZXIucmVzdWx0IHR5cGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybCA9IGlzQ2hyb21lSU9TXG4gICAgICAgICAgICAgICAgPyB1cmxcbiAgICAgICAgICAgICAgICA6IHVybC5yZXBsYWNlKC9eZGF0YTpbXjtdKjsvLCAnZGF0YTphdHRhY2htZW50L2ZpbGU7Jyk7XG4gICAgICAgICAgICBpZiAocG9wdXApIHtcbiAgICAgICAgICAgICAgICBwb3B1cC5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3B1cCA9IG51bGw7IC8vIHJldmVyc2UtdGFibmFiYmluZyAjNDYwXG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgaWYgKHBvcHVwKVxuICAgICAgICAgICAgcG9wdXAubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgIHBvcHVwID0gbnVsbDsgLy8gcmV2ZXJzZS10YWJuYWJiaW5nICM0NjBcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgICAgIH0sIDRlNCk7IC8vIDQwc1xuICAgIH1cbn1cblxuLyoqXG4gKiBTaG93cyBhIHRvYXN0IG9yIGNvbnNvbGUubG9nXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIHRvIGxvZ1xuICogQHBhcmFtIHR5cGUgLSBkaWZmZXJlbnQgY29sb3Igb2YgdGhlIHRvb2x0aXBcbiAqL1xuZnVuY3Rpb24gdG9hc3RNZXNzYWdlKG1lc3NhZ2UsIHR5cGUpIHtcbiAgICBjb25zdCBwaW5pYU1lc3NhZ2UgPSAn8J+NjSAnICsgbWVzc2FnZTtcbiAgICBpZiAodHlwZW9mIF9fVlVFX0RFVlRPT0xTX1RPQVNUX18gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gTm8gbG9uZ2VyIGF2YWlsYWJsZSA6KFxuICAgICAgICBfX1ZVRV9ERVZUT09MU19UT0FTVF9fKHBpbmlhTWVzc2FnZSwgdHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihwaW5pYU1lc3NhZ2UpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnd2FybicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKHBpbmlhTWVzc2FnZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhwaW5pYU1lc3NhZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUGluaWEobykge1xuICAgIHJldHVybiAnX2EnIGluIG8gJiYgJ2luc3RhbGwnIGluIG87XG59XG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW4gZGV2dG9vbHMgYWN0aW9ucywgdGhleSBhcmUgbm90IFBpbmlhIGFjdGlvbnMuXG4gKi9cbi8vIC0tLVxuZnVuY3Rpb24gY2hlY2tDbGlwYm9hcmRBY2Nlc3MoKSB7XG4gICAgaWYgKCEoJ2NsaXBib2FyZCcgaW4gbmF2aWdhdG9yKSkge1xuICAgICAgICB0b2FzdE1lc3NhZ2UoYFlvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIENsaXBib2FyZCBBUElgLCAnZXJyb3InKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tOb3RGb2N1c2VkRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICBlcnJvci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2RvY3VtZW50IGlzIG5vdCBmb2N1c2VkJykpIHtcbiAgICAgICAgdG9hc3RNZXNzYWdlKCdZb3UgbmVlZCB0byBhY3RpdmF0ZSB0aGUgXCJFbXVsYXRlIGEgZm9jdXNlZCBwYWdlXCIgc2V0dGluZyBpbiB0aGUgXCJSZW5kZXJpbmdcIiBwYW5lbCBvZiBkZXZ0b29scy4nLCAnd2FybicpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuYXN5bmMgZnVuY3Rpb24gYWN0aW9uR2xvYmFsQ29weVN0YXRlKHBpbmlhKSB7XG4gICAgaWYgKGNoZWNrQ2xpcGJvYXJkQWNjZXNzKCkpXG4gICAgICAgIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChKU09OLnN0cmluZ2lmeShwaW5pYS5zdGF0ZS52YWx1ZSkpO1xuICAgICAgICB0b2FzdE1lc3NhZ2UoJ0dsb2JhbCBzdGF0ZSBjb3BpZWQgdG8gY2xpcGJvYXJkLicpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGNoZWNrTm90Rm9jdXNlZEVycm9yKGVycm9yKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdG9hc3RNZXNzYWdlKGBGYWlsZWQgdG8gc2VyaWFsaXplIHRoZSBzdGF0ZS4gQ2hlY2sgdGhlIGNvbnNvbGUgZm9yIG1vcmUgZGV0YWlscy5gLCAnZXJyb3InKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYWN0aW9uR2xvYmFsUGFzdGVTdGF0ZShwaW5pYSkge1xuICAgIGlmIChjaGVja0NsaXBib2FyZEFjY2VzcygpKVxuICAgICAgICByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgICAgbG9hZFN0b3Jlc1N0YXRlKHBpbmlhLCBKU09OLnBhcnNlKGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQucmVhZFRleHQoKSkpO1xuICAgICAgICB0b2FzdE1lc3NhZ2UoJ0dsb2JhbCBzdGF0ZSBwYXN0ZWQgZnJvbSBjbGlwYm9hcmQuJyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoY2hlY2tOb3RGb2N1c2VkRXJyb3IoZXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0b2FzdE1lc3NhZ2UoYEZhaWxlZCB0byBkZXNlcmlhbGl6ZSB0aGUgc3RhdGUgZnJvbSBjbGlwYm9hcmQuIENoZWNrIHRoZSBjb25zb2xlIGZvciBtb3JlIGRldGFpbHMuYCwgJ2Vycm9yJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGFjdGlvbkdsb2JhbFNhdmVTdGF0ZShwaW5pYSkge1xuICAgIHRyeSB7XG4gICAgICAgIHNhdmVBcyhuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkocGluaWEuc3RhdGUudmFsdWUpXSwge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQvcGxhaW47Y2hhcnNldD11dGYtOCcsXG4gICAgICAgIH0pLCAncGluaWEtc3RhdGUuanNvbicpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdG9hc3RNZXNzYWdlKGBGYWlsZWQgdG8gZXhwb3J0IHRoZSBzdGF0ZSBhcyBKU09OLiBDaGVjayB0aGUgY29uc29sZSBmb3IgbW9yZSBkZXRhaWxzLmAsICdlcnJvcicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG59XG5sZXQgZmlsZUlucHV0O1xuZnVuY3Rpb24gZ2V0RmlsZU9wZW5lcigpIHtcbiAgICBpZiAoIWZpbGVJbnB1dCkge1xuICAgICAgICBmaWxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBmaWxlSW5wdXQudHlwZSA9ICdmaWxlJztcbiAgICAgICAgZmlsZUlucHV0LmFjY2VwdCA9ICcuanNvbic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9wZW5GaWxlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZmlsZUlucHV0Lm9uY2hhbmdlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gZmlsZUlucHV0LmZpbGVzO1xuICAgICAgICAgICAgICAgIGlmICghZmlsZXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlcy5pdGVtKDApO1xuICAgICAgICAgICAgICAgIGlmICghZmlsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyB0ZXh0OiBhd2FpdCBmaWxlLnRleHQoKSwgZmlsZSB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlOiBUT0RPOiBjaGFuZ2VkIGZyb20gNC4zIHRvIDQuNFxuICAgICAgICAgICAgZmlsZUlucHV0Lm9uY2FuY2VsID0gKCkgPT4gcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIGZpbGVJbnB1dC5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgZmlsZUlucHV0LmNsaWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3BlbkZpbGU7XG59XG5hc3luYyBmdW5jdGlvbiBhY3Rpb25HbG9iYWxPcGVuU3RhdGVGaWxlKHBpbmlhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3BlbiA9IGdldEZpbGVPcGVuZXIoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3BlbigpO1xuICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyB0ZXh0LCBmaWxlIH0gPSByZXN1bHQ7XG4gICAgICAgIGxvYWRTdG9yZXNTdGF0ZShwaW5pYSwgSlNPTi5wYXJzZSh0ZXh0KSk7XG4gICAgICAgIHRvYXN0TWVzc2FnZShgR2xvYmFsIHN0YXRlIGltcG9ydGVkIGZyb20gXCIke2ZpbGUubmFtZX1cIi5gKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRvYXN0TWVzc2FnZShgRmFpbGVkIHRvIGltcG9ydCB0aGUgc3RhdGUgZnJvbSBKU09OLiBDaGVjayB0aGUgY29uc29sZSBmb3IgbW9yZSBkZXRhaWxzLmAsICdlcnJvcicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb2FkU3RvcmVzU3RhdGUocGluaWEsIHN0YXRlKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHBpbmlhLnN0YXRlLnZhbHVlW2tleV07XG4gICAgICAgIC8vIHN0b3JlIGlzIGFscmVhZHkgaW5zdGFudGlhdGVkLCBwYXRjaCBpdFxuICAgICAgICBpZiAoc3RvcmVTdGF0ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdG9yZVN0YXRlLCBzdGF0ZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIGlzIG5vdCBpbnN0YW50aWF0ZWQsIHNldCB0aGUgaW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgcGluaWEuc3RhdGUudmFsdWVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERpc3BsYXkoZGlzcGxheSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIF9jdXN0b206IHtcbiAgICAgICAgICAgIGRpc3BsYXksXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmNvbnN0IFBJTklBX1JPT1RfTEFCRUwgPSAn8J+NjSBQaW5pYSAocm9vdCknO1xuY29uc3QgUElOSUFfUk9PVF9JRCA9ICdfcm9vdCc7XG5mdW5jdGlvbiBmb3JtYXRTdG9yZUZvckluc3BlY3RvclRyZWUoc3RvcmUpIHtcbiAgICByZXR1cm4gaXNQaW5pYShzdG9yZSlcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBpZDogUElOSUFfUk9PVF9JRCxcbiAgICAgICAgICAgIGxhYmVsOiBQSU5JQV9ST09UX0xBQkVMLFxuICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgaWQ6IHN0b3JlLiRpZCxcbiAgICAgICAgICAgIGxhYmVsOiBzdG9yZS4kaWQsXG4gICAgICAgIH07XG59XG5mdW5jdGlvbiBmb3JtYXRTdG9yZUZvckluc3BlY3RvclN0YXRlKHN0b3JlKSB7XG4gICAgaWYgKGlzUGluaWEoc3RvcmUpKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlTmFtZXMgPSBBcnJheS5mcm9tKHN0b3JlLl9zLmtleXMoKSk7XG4gICAgICAgIGNvbnN0IHN0b3JlTWFwID0gc3RvcmUuX3M7XG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgc3RhdGU6IHN0b3JlTmFtZXMubWFwKChzdG9yZUlkKSA9PiAoe1xuICAgICAgICAgICAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleTogc3RvcmVJZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RvcmUuc3RhdGUudmFsdWVbc3RvcmVJZF0sXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBnZXR0ZXJzOiBzdG9yZU5hbWVzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoaWQpID0+IHN0b3JlTWFwLmdldChpZCkuX2dldHRlcnMpXG4gICAgICAgICAgICAgICAgLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHN0b3JlTWFwLmdldChpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGlkLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RvcmUuX2dldHRlcnMucmVkdWNlKChnZXR0ZXJzLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlcnNba2V5XSA9IHN0b3JlW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVycztcbiAgICAgICAgICAgICAgICAgICAgfSwge30pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgc3RhdGU6IE9iamVjdC5rZXlzKHN0b3JlLiRzdGF0ZSkubWFwKChrZXkpID0+ICh7XG4gICAgICAgICAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBzdG9yZS4kc3RhdGVba2V5XSxcbiAgICAgICAgfSkpLFxuICAgIH07XG4gICAgLy8gYXZvaWQgYWRkaW5nIGVtcHR5IGdldHRlcnNcbiAgICBpZiAoc3RvcmUuX2dldHRlcnMgJiYgc3RvcmUuX2dldHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHN0YXRlLmdldHRlcnMgPSBzdG9yZS5fZ2V0dGVycy5tYXAoKGdldHRlck5hbWUpID0+ICh7XG4gICAgICAgICAgICBlZGl0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBrZXk6IGdldHRlck5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogc3RvcmVbZ2V0dGVyTmFtZV0sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHN0b3JlLl9jdXN0b21Qcm9wZXJ0aWVzLnNpemUpIHtcbiAgICAgICAgc3RhdGUuY3VzdG9tUHJvcGVydGllcyA9IEFycmF5LmZyb20oc3RvcmUuX2N1c3RvbVByb3BlcnRpZXMpLm1hcCgoa2V5KSA9PiAoe1xuICAgICAgICAgICAgZWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTogc3RvcmVba2V5XSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBmb3JtYXRFdmVudERhdGEoZXZlbnRzKSB7XG4gICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudHMpKSB7XG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSBhZGQgYW5kIGRlbGV0ZSBmb3IgYXJyYXlzIGFuZCBvYmplY3RzXG4gICAgICAgIHJldHVybiBldmVudHMucmVkdWNlKChkYXRhLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgZGF0YS5rZXlzLnB1c2goZXZlbnQua2V5KTtcbiAgICAgICAgICAgIGRhdGEub3BlcmF0aW9ucy5wdXNoKGV2ZW50LnR5cGUpO1xuICAgICAgICAgICAgZGF0YS5vbGRWYWx1ZVtldmVudC5rZXldID0gZXZlbnQub2xkVmFsdWU7XG4gICAgICAgICAgICBkYXRhLm5ld1ZhbHVlW2V2ZW50LmtleV0gPSBldmVudC5uZXdWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvbGRWYWx1ZToge30sXG4gICAgICAgICAgICBrZXlzOiBbXSxcbiAgICAgICAgICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgICAgICAgICAgbmV3VmFsdWU6IHt9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcGVyYXRpb246IGZvcm1hdERpc3BsYXkoZXZlbnRzLnR5cGUpLFxuICAgICAgICAgICAga2V5OiBmb3JtYXREaXNwbGF5KGV2ZW50cy5rZXkpLFxuICAgICAgICAgICAgb2xkVmFsdWU6IGV2ZW50cy5vbGRWYWx1ZSxcbiAgICAgICAgICAgIG5ld1ZhbHVlOiBldmVudHMubmV3VmFsdWUsXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZm9ybWF0TXV0YXRpb25UeXBlKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBNdXRhdGlvblR5cGUuZGlyZWN0OlxuICAgICAgICAgICAgcmV0dXJuICdtdXRhdGlvbic7XG4gICAgICAgIGNhc2UgTXV0YXRpb25UeXBlLnBhdGNoRnVuY3Rpb246XG4gICAgICAgICAgICByZXR1cm4gJyRwYXRjaCc7XG4gICAgICAgIGNhc2UgTXV0YXRpb25UeXBlLnBhdGNoT2JqZWN0OlxuICAgICAgICAgICAgcmV0dXJuICckcGF0Y2gnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICB9XG59XG5cbi8vIHRpbWVsaW5lIGNhbiBiZSBwYXVzZWQgd2hlbiBkaXJlY3RseSBjaGFuZ2luZyB0aGUgc3RhdGVcbmxldCBpc1RpbWVsaW5lQWN0aXZlID0gdHJ1ZTtcbmNvbnN0IGNvbXBvbmVudFN0YXRlVHlwZXMgPSBbXTtcbmNvbnN0IE1VVEFUSU9OU19MQVlFUl9JRCA9ICdwaW5pYTptdXRhdGlvbnMnO1xuY29uc3QgSU5TUEVDVE9SX0lEID0gJ3BpbmlhJztcbmNvbnN0IHsgYXNzaWduOiBhc3NpZ24kMSB9ID0gT2JqZWN0O1xuLyoqXG4gKiBHZXRzIHRoZSBkaXNwbGF5ZWQgbmFtZSBvZiBhIHN0b3JlIGluIGRldnRvb2xzXG4gKlxuICogQHBhcmFtIGlkIC0gaWQgb2YgdGhlIHN0b3JlXG4gKiBAcmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmdcbiAqL1xuY29uc3QgZ2V0U3RvcmVUeXBlID0gKGlkKSA9PiAn8J+NjSAnICsgaWQ7XG4vKipcbiAqIEFkZCB0aGUgcGluaWEgcGx1Z2luIHdpdGhvdXQgYW55IHN0b3JlLiBBbGxvd3MgZGlzcGxheWluZyBhIFBpbmlhIHBsdWdpbiB0YWJcbiAqIGFzIHNvb24gYXMgaXQgaXMgYWRkZWQgdG8gdGhlIGFwcGxpY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhcHAgLSBWdWUgYXBwbGljYXRpb25cbiAqIEBwYXJhbSBwaW5pYSAtIHBpbmlhIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyUGluaWFEZXZ0b29scyhhcHAsIHBpbmlhKSB7XG4gICAgc2V0dXBEZXZ0b29sc1BsdWdpbih7XG4gICAgICAgIGlkOiAnZGV2LmVzbS5waW5pYScsXG4gICAgICAgIGxhYmVsOiAnUGluaWEg8J+NjScsXG4gICAgICAgIGxvZ286ICdodHRwczovL3BpbmlhLnZ1ZWpzLm9yZy9sb2dvLnN2ZycsXG4gICAgICAgIHBhY2thZ2VOYW1lOiAncGluaWEnLFxuICAgICAgICBob21lcGFnZTogJ2h0dHBzOi8vcGluaWEudnVlanMub3JnJyxcbiAgICAgICAgY29tcG9uZW50U3RhdGVUeXBlcyxcbiAgICAgICAgYXBwLFxuICAgIH0sIChhcGkpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcGkubm93ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0b2FzdE1lc3NhZ2UoJ1lvdSBzZWVtIHRvIGJlIHVzaW5nIGFuIG91dGRhdGVkIHZlcnNpb24gb2YgVnVlIERldnRvb2xzLiBBcmUgeW91IHN0aWxsIHVzaW5nIHRoZSBCZXRhIHJlbGVhc2UgaW5zdGVhZCBvZiB0aGUgc3RhYmxlIG9uZT8gWW91IGNhbiBmaW5kIHRoZSBsaW5rcyBhdCBodHRwczovL2RldnRvb2xzLnZ1ZWpzLm9yZy9ndWlkZS9pbnN0YWxsYXRpb24uaHRtbC4nKTtcbiAgICAgICAgfVxuICAgICAgICBhcGkuYWRkVGltZWxpbmVMYXllcih7XG4gICAgICAgICAgICBpZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICAgICAgbGFiZWw6IGBQaW5pYSDwn42NYCxcbiAgICAgICAgICAgIGNvbG9yOiAweGU1ZGY4OCxcbiAgICAgICAgfSk7XG4gICAgICAgIGFwaS5hZGRJbnNwZWN0b3Ioe1xuICAgICAgICAgICAgaWQ6IElOU1BFQ1RPUl9JRCxcbiAgICAgICAgICAgIGxhYmVsOiAnUGluaWEg8J+NjScsXG4gICAgICAgICAgICBpY29uOiAnc3RvcmFnZScsXG4gICAgICAgICAgICB0cmVlRmlsdGVyUGxhY2Vob2xkZXI6ICdTZWFyY2ggc3RvcmVzJyxcbiAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGljb246ICdjb250ZW50X2NvcHknLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkdsb2JhbENvcHlTdGF0ZShwaW5pYSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdTZXJpYWxpemUgYW5kIGNvcHkgdGhlIHN0YXRlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2NvbnRlbnRfcGFzdGUnLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGFjdGlvbkdsb2JhbFBhc3RlU3RhdGUocGluaWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JUcmVlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclN0YXRlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdSZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBjb250ZW50IG9mIHlvdXIgY2xpcGJvYXJkJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ3NhdmUnLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkdsb2JhbFNhdmVTdGF0ZShwaW5pYSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdTYXZlIHRoZSBzdGF0ZSBhcyBhIEpTT04gZmlsZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGljb246ICdmb2xkZXJfb3BlbicsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgYWN0aW9uR2xvYmFsT3BlblN0YXRlRmlsZShwaW5pYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclRyZWUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5zZW5kSW5zcGVjdG9yU3RhdGUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcDogJ0ltcG9ydCB0aGUgc3RhdGUgZnJvbSBhIEpTT04gZmlsZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBub2RlQWN0aW9uczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ3Jlc3RvcmUnLFxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwOiAnUmVzZXQgdGhlIHN0YXRlICh3aXRoIFwiJHJlc2V0XCIpJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAobm9kZUlkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHBpbmlhLl9zLmdldChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0TWVzc2FnZShgQ2Fubm90IHJlc2V0IFwiJHtub2RlSWR9XCIgc3RvcmUgYmVjYXVzZSBpdCB3YXNuJ3QgZm91bmQuYCwgJ3dhcm4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdG9yZS4kcmVzZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2FzdE1lc3NhZ2UoYENhbm5vdCByZXNldCBcIiR7bm9kZUlkfVwiIHN0b3JlIGJlY2F1c2UgaXQgZG9lc24ndCBoYXZlIGEgXCIkcmVzZXRcIiBtZXRob2QgaW1wbGVtZW50ZWQuYCwgJ3dhcm4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLiRyZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0TWVzc2FnZShgU3RvcmUgXCIke25vZGVJZH1cIiByZXNldC5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGFwaS5vbi5pbnNwZWN0Q29tcG9uZW50KChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm94eSA9IChwYXlsb2FkLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAgICAgICAgICAgcGF5bG9hZC5jb21wb25lbnRJbnN0YW5jZS5wcm94eSk7XG4gICAgICAgICAgICBpZiAocHJveHkgJiYgcHJveHkuX3BTdG9yZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaW5pYVN0b3JlcyA9IHBheWxvYWQuY29tcG9uZW50SW5zdGFuY2UucHJveHkuX3BTdG9yZXM7XG4gICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhwaW5pYVN0b3JlcykuZm9yRWFjaCgoc3RvcmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pbnN0YW5jZURhdGEuc3RhdGUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBnZXRTdG9yZVR5cGUoc3RvcmUuJGlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ3N0YXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0b3JlLl9pc09wdGlvbnNBUElcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2N1c3RvbToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRvUmF3KHN0b3JlLiRzdGF0ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uOiAncmVzdG9yZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdSZXNldCB0aGUgc3RhdGUgb2YgdGhpcyBzdG9yZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4gc3RvcmUuJHJlc2V0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogLy8gTk9URTogd29ya2Fyb3VuZCB0byB1bndyYXAgdHJhbnNmZXJyZWQgcmVmc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzdG9yZS4kc3RhdGUpLnJlZHVjZSgoc3RhdGUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IHN0b3JlLiRzdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7fSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmUuX2dldHRlcnMgJiYgc3RvcmUuX2dldHRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmluc3RhbmNlRGF0YS5zdGF0ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBnZXRTdG9yZVR5cGUoc3RvcmUuJGlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdnZXR0ZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0b3JlLl9nZXR0ZXJzLnJlZHVjZSgoZ2V0dGVycywga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXJzW2tleV0gPSBzdG9yZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogd2UganVzdCB3YW50IHRvIHNob3cgaXQgaW4gZGV2dG9vbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlcnNba2V5XSA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXR0ZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhcGkub24uZ2V0SW5zcGVjdG9yVHJlZSgocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuYXBwID09PSBhcHAgJiYgcGF5bG9hZC5pbnNwZWN0b3JJZCA9PT0gSU5TUEVDVE9SX0lEKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0b3JlcyA9IFtwaW5pYV07XG4gICAgICAgICAgICAgICAgc3RvcmVzID0gc3RvcmVzLmNvbmNhdChBcnJheS5mcm9tKHBpbmlhLl9zLnZhbHVlcygpKSk7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5yb290Tm9kZXMgPSAocGF5bG9hZC5maWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgPyBzdG9yZXMuZmlsdGVyKChzdG9yZSkgPT4gJyRpZCcgaW4gc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3RvcmUuJGlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW5jbHVkZXMocGF5bG9hZC5maWx0ZXIudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogUElOSUFfUk9PVF9MQUJFTC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHBheWxvYWQuZmlsdGVyLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAgICAgICAgICAgICA6IHN0b3JlcykubWFwKGZvcm1hdFN0b3JlRm9ySW5zcGVjdG9yVHJlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBFeHBvc2UgcGluaWEgaW5zdGFuY2UgYXMgJHBpbmlhIHRvIHdpbmRvd1xuICAgICAgICBnbG9iYWxUaGlzLiRwaW5pYSA9IHBpbmlhO1xuICAgICAgICBhcGkub24uZ2V0SW5zcGVjdG9yU3RhdGUoKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmFwcCA9PT0gYXBwICYmIHBheWxvYWQuaW5zcGVjdG9ySWQgPT09IElOU1BFQ1RPUl9JRCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3BlY3RlZFN0b3JlID0gcGF5bG9hZC5ub2RlSWQgPT09IFBJTklBX1JPT1RfSURcbiAgICAgICAgICAgICAgICAgICAgPyBwaW5pYVxuICAgICAgICAgICAgICAgICAgICA6IHBpbmlhLl9zLmdldChwYXlsb2FkLm5vZGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnNwZWN0ZWRTdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIHRoZSBzZWxlY3RlZCBzdG9yZSByZXN0b3JlZCBmb3IgYSBkaWZmZXJlbnQgcHJvamVjdFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyBpdCdzIGJldHRlciBub3QgdG8gc2F5IGFueXRoaW5nIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5zcGVjdGVkU3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwb3NlIHNlbGVjdGVkIHN0b3JlIGFzICRzdG9yZSB0byB3aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWQubm9kZUlkICE9PSBQSU5JQV9ST09UX0lEKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy4kc3RvcmUgPSB0b1JhdyhpbnNwZWN0ZWRTdG9yZSk7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuc3RhdGUgPSBmb3JtYXRTdG9yZUZvckluc3BlY3RvclN0YXRlKGluc3BlY3RlZFN0b3JlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhcGkub24uZWRpdEluc3BlY3RvclN0YXRlKChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5hcHAgPT09IGFwcCAmJiBwYXlsb2FkLmluc3BlY3RvcklkID09PSBJTlNQRUNUT1JfSUQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNwZWN0ZWRTdG9yZSA9IHBheWxvYWQubm9kZUlkID09PSBQSU5JQV9ST09UX0lEXG4gICAgICAgICAgICAgICAgICAgID8gcGluaWFcbiAgICAgICAgICAgICAgICAgICAgOiBwaW5pYS5fcy5nZXQocGF5bG9hZC5ub2RlSWQpO1xuICAgICAgICAgICAgICAgIGlmICghaW5zcGVjdGVkU3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvYXN0TWVzc2FnZShgc3RvcmUgXCIke3BheWxvYWQubm9kZUlkfVwiIG5vdCBmb3VuZGAsICdlcnJvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGggfSA9IHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1BpbmlhKGluc3BlY3RlZFN0b3JlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhY2Nlc3Mgb25seSB0aGUgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhaW5zcGVjdGVkU3RvcmUuX2N1c3RvbVByb3BlcnRpZXMuaGFzKHBhdGhbMF0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoWzBdIGluIGluc3BlY3RlZFN0b3JlLiRzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC51bnNoaWZ0KCckc3RhdGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUm9vdCBhY2Nlc3MsIHdlIGNhbiBvbWl0IHRoZSBgLnZhbHVlYCBiZWNhdXNlIHRoZSBkZXZ0b29scyBBUEkgZG9lcyBpdCBmb3IgdXNcbiAgICAgICAgICAgICAgICAgICAgcGF0aC51bnNoaWZ0KCdzdGF0ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpc1RpbWVsaW5lQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5zZXQoaW5zcGVjdGVkU3RvcmUsIHBhdGgsIHBheWxvYWQuc3RhdGUudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlzVGltZWxpbmVBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXBpLm9uLmVkaXRDb21wb25lbnRTdGF0ZSgocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQudHlwZS5zdGFydHNXaXRoKCfwn42NJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZUlkID0gcGF5bG9hZC50eXBlLnJlcGxhY2UoL17wn42NXFxzKi8sICcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHBpbmlhLl9zLmdldChzdG9yZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2FzdE1lc3NhZ2UoYHN0b3JlIFwiJHtzdG9yZUlkfVwiIG5vdCBmb3VuZGAsICdlcnJvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGggfSA9IHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhbMF0gIT09ICdzdGF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvYXN0TWVzc2FnZShgSW52YWxpZCBwYXRoIGZvciBzdG9yZSBcIiR7c3RvcmVJZH1cIjpcXG4ke3BhdGh9XFxuT25seSBzdGF0ZSBjYW4gYmUgbW9kaWZpZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJld3JpdGUgdGhlIGZpcnN0IGVudHJ5IHRvIGJlIGFibGUgdG8gZGlyZWN0bHkgc2V0IHRoZSBzdGF0ZSBhc1xuICAgICAgICAgICAgICAgIC8vIHdlbGwgYXMgYW55IG90aGVyIHBhdGhcbiAgICAgICAgICAgICAgICBwYXRoWzBdID0gJyRzdGF0ZSc7XG4gICAgICAgICAgICAgICAgaXNUaW1lbGluZUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBheWxvYWQuc2V0KHN0b3JlLCBwYXRoLCBwYXlsb2FkLnN0YXRlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpc1RpbWVsaW5lQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhZGRTdG9yZVRvRGV2dG9vbHMoYXBwLCBzdG9yZSkge1xuICAgIGlmICghY29tcG9uZW50U3RhdGVUeXBlcy5pbmNsdWRlcyhnZXRTdG9yZVR5cGUoc3RvcmUuJGlkKSkpIHtcbiAgICAgICAgY29tcG9uZW50U3RhdGVUeXBlcy5wdXNoKGdldFN0b3JlVHlwZShzdG9yZS4kaWQpKTtcbiAgICB9XG4gICAgc2V0dXBEZXZ0b29sc1BsdWdpbih7XG4gICAgICAgIGlkOiAnZGV2LmVzbS5waW5pYScsXG4gICAgICAgIGxhYmVsOiAnUGluaWEg8J+NjScsXG4gICAgICAgIGxvZ286ICdodHRwczovL3BpbmlhLnZ1ZWpzLm9yZy9sb2dvLnN2ZycsXG4gICAgICAgIHBhY2thZ2VOYW1lOiAncGluaWEnLFxuICAgICAgICBob21lcGFnZTogJ2h0dHBzOi8vcGluaWEudnVlanMub3JnJyxcbiAgICAgICAgY29tcG9uZW50U3RhdGVUeXBlcyxcbiAgICAgICAgYXBwLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbG9nU3RvcmVDaGFuZ2VzOiB7XG4gICAgICAgICAgICAgICAgbGFiZWw6ICdOb3RpZnkgYWJvdXQgbmV3L2RlbGV0ZWQgc3RvcmVzJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIHVzZUVtb2ppczoge1xuICAgICAgICAgICAgLy8gICBsYWJlbDogJ1VzZSBlbW9qaXMgaW4gbWVzc2FnZXMg4pqh77iPJyxcbiAgICAgICAgICAgIC8vICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgLy8gICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgICAgICAgICAvLyB9LFxuICAgICAgICB9LFxuICAgIH0sIChhcGkpID0+IHtcbiAgICAgICAgLy8gZ3JhY2VmdWxseSBoYW5kbGUgZXJyb3JzXG4gICAgICAgIGNvbnN0IG5vdyA9IHR5cGVvZiBhcGkubm93ID09PSAnZnVuY3Rpb24nID8gYXBpLm5vdy5iaW5kKGFwaSkgOiBEYXRlLm5vdztcbiAgICAgICAgc3RvcmUuJG9uQWN0aW9uKCh7IGFmdGVyLCBvbkVycm9yLCBuYW1lLCBhcmdzIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwSWQgPSBydW5uaW5nQWN0aW9uSWQrKztcbiAgICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcbiAgICAgICAgICAgICAgICBsYXllcklkOiBNVVRBVElPTlNfTEFZRVJfSUQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbm93KCksXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAn8J+bqyAnICsgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3VidGl0bGU6ICdzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlOiBmb3JtYXREaXNwbGF5KHN0b3JlLiRpZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IGZvcm1hdERpc3BsYXkobmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBncm91cElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFmdGVyKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBhY3RpdmVBY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBsYXllcklkOiBNVVRBVElPTlNfTEFZRVJfSUQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAn8J+brCAnICsgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlOiAnZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZTogZm9ybWF0RGlzcGxheShzdG9yZS4kaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZm9ybWF0RGlzcGxheShuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cElkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvbkVycm9yKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUFjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBhcGkuYWRkVGltZWxpbmVFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgIGxheWVySWQ6IE1VVEFUSU9OU19MQVlFUl9JRCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IG5vdygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nVHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAn8J+SpSAnICsgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlOiAnZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZTogZm9ybWF0RGlzcGxheShzdG9yZS4kaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZm9ybWF0RGlzcGxheShuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHN0b3JlLl9jdXN0b21Qcm9wZXJ0aWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHdhdGNoKCgpID0+IHVucmVmKHN0b3JlW25hbWVdKSwgKG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGFwaS5ub3RpZnlDb21wb25lbnRVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclN0YXRlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGltZWxpbmVBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLmFkZFRpbWVsaW5lRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBub3coKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0NoYW5nZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VidGl0bGU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cElkOiBhY3RpdmVBY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7IGRlZXA6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdG9yZS4kc3Vic2NyaWJlKCh7IGV2ZW50cywgdHlwZSB9LCBzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgYXBpLm5vdGlmeUNvbXBvbmVudFVwZGF0ZSgpO1xuICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JTdGF0ZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICAgICAgaWYgKCFpc1RpbWVsaW5lQWN0aXZlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIHJvb3RTdG9yZS5zdGF0ZVtzdG9yZS5pZF0gPSBzdGF0ZVxuICAgICAgICAgICAgY29uc3QgZXZlbnREYXRhID0ge1xuICAgICAgICAgICAgICAgIHRpbWU6IG5vdygpLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBmb3JtYXRNdXRhdGlvblR5cGUodHlwZSksXG4gICAgICAgICAgICAgICAgZGF0YTogYXNzaWduJDEoeyBzdG9yZTogZm9ybWF0RGlzcGxheShzdG9yZS4kaWQpIH0sIGZvcm1hdEV2ZW50RGF0YShldmVudHMpKSxcbiAgICAgICAgICAgICAgICBncm91cElkOiBhY3RpdmVBY3Rpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IE11dGF0aW9uVHlwZS5wYXRjaEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXZlbnREYXRhLnN1YnRpdGxlID0gJ+Kkte+4jyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBNdXRhdGlvblR5cGUucGF0Y2hPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBldmVudERhdGEuc3VidGl0bGUgPSAn8J+nqSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudHMgJiYgIUFycmF5LmlzQXJyYXkoZXZlbnRzKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50RGF0YS5zdWJ0aXRsZSA9IGV2ZW50cy50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGV2ZW50RGF0YS5kYXRhWydyYXdFdmVudChzKSddID0ge1xuICAgICAgICAgICAgICAgICAgICBfY3VzdG9tOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnRGVidWdnZXJFdmVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXA6ICdyYXcgRGVidWdnZXJFdmVudFtdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFwaS5hZGRUaW1lbGluZUV2ZW50KHtcbiAgICAgICAgICAgICAgICBsYXllcklkOiBNVVRBVElPTlNfTEFZRVJfSUQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50RGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB7IGRldGFjaGVkOiB0cnVlLCBmbHVzaDogJ3N5bmMnIH0pO1xuICAgICAgICBjb25zdCBob3RVcGRhdGUgPSBzdG9yZS5faG90VXBkYXRlO1xuICAgICAgICBzdG9yZS5faG90VXBkYXRlID0gbWFya1JhdygobmV3U3RvcmUpID0+IHtcbiAgICAgICAgICAgIGhvdFVwZGF0ZShuZXdTdG9yZSk7XG4gICAgICAgICAgICBhcGkuYWRkVGltZWxpbmVFdmVudCh7XG4gICAgICAgICAgICAgICAgbGF5ZXJJZDogTVVUQVRJT05TX0xBWUVSX0lELFxuICAgICAgICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5vdygpLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ/CflKUgJyArIHN0b3JlLiRpZCxcbiAgICAgICAgICAgICAgICAgICAgc3VidGl0bGU6ICdITVIgdXBkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmU6IGZvcm1hdERpc3BsYXkoc3RvcmUuJGlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm86IGZvcm1hdERpc3BsYXkoYEhNUiB1cGRhdGVgKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGRldnRvb2xzIHRvb1xuICAgICAgICAgICAgYXBpLm5vdGlmeUNvbXBvbmVudFVwZGF0ZSgpO1xuICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JUcmVlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclN0YXRlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7ICRkaXNwb3NlIH0gPSBzdG9yZTtcbiAgICAgICAgc3RvcmUuJGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAkZGlzcG9zZSgpO1xuICAgICAgICAgICAgYXBpLm5vdGlmeUNvbXBvbmVudFVwZGF0ZSgpO1xuICAgICAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JUcmVlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgICAgICBhcGkuc2VuZEluc3BlY3RvclN0YXRlKElOU1BFQ1RPUl9JRCk7XG4gICAgICAgICAgICBhcGkuZ2V0U2V0dGluZ3MoKS5sb2dTdG9yZUNoYW5nZXMgJiZcbiAgICAgICAgICAgICAgICB0b2FzdE1lc3NhZ2UoYERpc3Bvc2VkIFwiJHtzdG9yZS4kaWR9XCIgc3RvcmUg8J+XkWApO1xuICAgICAgICB9O1xuICAgICAgICAvLyB0cmlnZ2VyIGFuIHVwZGF0ZSBzbyBpdCBjYW4gZGlzcGxheSBuZXcgcmVnaXN0ZXJlZCBzdG9yZXNcbiAgICAgICAgYXBpLm5vdGlmeUNvbXBvbmVudFVwZGF0ZSgpO1xuICAgICAgICBhcGkuc2VuZEluc3BlY3RvclRyZWUoSU5TUEVDVE9SX0lEKTtcbiAgICAgICAgYXBpLnNlbmRJbnNwZWN0b3JTdGF0ZShJTlNQRUNUT1JfSUQpO1xuICAgICAgICBhcGkuZ2V0U2V0dGluZ3MoKS5sb2dTdG9yZUNoYW5nZXMgJiZcbiAgICAgICAgICAgIHRvYXN0TWVzc2FnZShgXCIke3N0b3JlLiRpZH1cIiBzdG9yZSBpbnN0YWxsZWQg8J+GlWApO1xuICAgIH0pO1xufVxubGV0IHJ1bm5pbmdBY3Rpb25JZCA9IDA7XG5sZXQgYWN0aXZlQWN0aW9uO1xuLyoqXG4gKiBQYXRjaGVzIGEgc3RvcmUgdG8gZW5hYmxlIGFjdGlvbiBncm91cGluZyBpbiBkZXZ0b29scyBieSB3cmFwcGluZyB0aGUgc3RvcmUgd2l0aCBhIFByb3h5IHRoYXQgaXMgcGFzc2VkIGFzIHRoZVxuICogY29udGV4dCBvZiBhbGwgYWN0aW9ucywgYWxsb3dpbmcgdXMgdG8gc2V0IGBydW5uaW5nQWN0aW9uYCBvbiBlYWNoIGFjY2VzcyBhbmQgZWZmZWN0aXZlbHkgYXNzb2NpYXRpbmcgYW55IHN0YXRlXG4gKiBtdXRhdGlvbiB0byB0aGUgYWN0aW9uLlxuICpcbiAqIEBwYXJhbSBzdG9yZSAtIHN0b3JlIHRvIHBhdGNoXG4gKiBAcGFyYW0gYWN0aW9uTmFtZXMgLSBsaXN0IG9mIGFjdGlvbnN0IHRvIHBhdGNoXG4gKi9cbmZ1bmN0aW9uIHBhdGNoQWN0aW9uRm9yR3JvdXBpbmcoc3RvcmUsIGFjdGlvbk5hbWVzLCB3cmFwV2l0aFByb3h5KSB7XG4gICAgLy8gb3JpZ2luYWwgYWN0aW9ucyBvZiB0aGUgc3RvcmUgYXMgdGhleSBhcmUgZ2l2ZW4gYnkgcGluaWEuIFdlIGFyZSBnb2luZyB0byBvdmVycmlkZSB0aGVtXG4gICAgY29uc3QgYWN0aW9ucyA9IGFjdGlvbk5hbWVzLnJlZHVjZSgoc3RvcmVBY3Rpb25zLCBhY3Rpb25OYW1lKSA9PiB7XG4gICAgICAgIC8vIHVzZSB0b1JhdyB0byBhdm9pZCB0cmFja2luZyAjNTQxXG4gICAgICAgIHN0b3JlQWN0aW9uc1thY3Rpb25OYW1lXSA9IHRvUmF3KHN0b3JlKVthY3Rpb25OYW1lXTtcbiAgICAgICAgcmV0dXJuIHN0b3JlQWN0aW9ucztcbiAgICB9LCB7fSk7XG4gICAgZm9yIChjb25zdCBhY3Rpb25OYW1lIGluIGFjdGlvbnMpIHtcbiAgICAgICAgc3RvcmVbYWN0aW9uTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyB0aGUgcnVubmluZyBhY3Rpb24gaWQgaXMgaW5jcmVtZW50ZWQgaW4gYSBiZWZvcmUgYWN0aW9uIGhvb2tcbiAgICAgICAgICAgIGNvbnN0IF9hY3Rpb25JZCA9IHJ1bm5pbmdBY3Rpb25JZDtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrZWRTdG9yZSA9IHdyYXBXaXRoUHJveHlcbiAgICAgICAgICAgICAgICA/IG5ldyBQcm94eShzdG9yZSwge1xuICAgICAgICAgICAgICAgICAgICBnZXQoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlQWN0aW9uID0gX2FjdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQoLi4uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlQWN0aW9uID0gX2FjdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBzdG9yZTtcbiAgICAgICAgICAgIC8vIEZvciBTZXR1cCBTdG9yZXMgd2UgbmVlZCBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hc3luYy1jb250ZXh0XG4gICAgICAgICAgICBhY3RpdmVBY3Rpb24gPSBfYWN0aW9uSWQ7XG4gICAgICAgICAgICBjb25zdCByZXRWYWx1ZSA9IGFjdGlvbnNbYWN0aW9uTmFtZV0uYXBwbHkodHJhY2tlZFN0b3JlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBzYWZlciBhcyBhc3luYyBhY3Rpb25zIGluIFNldHVwIFN0b3JlcyB3b3VsZCBhc3NvY2lhdGUgbXV0YXRpb25zIGRvbmUgb3V0c2lkZSBvZiB0aGUgYWN0aW9uXG4gICAgICAgICAgICBhY3RpdmVBY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0VmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBwaW5pYS51c2UoZGV2dG9vbHNQbHVnaW4pXG4gKi9cbmZ1bmN0aW9uIGRldnRvb2xzUGx1Z2luKHsgYXBwLCBzdG9yZSwgb3B0aW9ucyB9KSB7XG4gICAgLy8gSE1SIG1vZHVsZVxuICAgIGlmIChzdG9yZS4kaWQuc3RhcnRzV2l0aCgnX19ob3Q6JykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBkZXRlY3Qgb3B0aW9uIGFwaSB2cyBzZXR1cCBhcGlcbiAgICBzdG9yZS5faXNPcHRpb25zQVBJID0gISFvcHRpb25zLnN0YXRlO1xuICAgIC8vIERvIG5vdCBvdmVyd3JpdGUgYWN0aW9ucyBtb2NrZWQgYnkgQHBpbmlhL3Rlc3RpbmcgKCMyMjk4KVxuICAgIGlmICghc3RvcmUuX3AuX3Rlc3RpbmcpIHtcbiAgICAgICAgcGF0Y2hBY3Rpb25Gb3JHcm91cGluZyhzdG9yZSwgT2JqZWN0LmtleXMob3B0aW9ucy5hY3Rpb25zKSwgc3RvcmUuX2lzT3B0aW9uc0FQSSk7XG4gICAgICAgIC8vIFVwZ3JhZGUgdGhlIEhNUiB0byBhbHNvIHVwZGF0ZSB0aGUgbmV3IGFjdGlvbnNcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxIb3RVcGRhdGUgPSBzdG9yZS5faG90VXBkYXRlO1xuICAgICAgICB0b1JhdyhzdG9yZSkuX2hvdFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdTdG9yZSkge1xuICAgICAgICAgICAgb3JpZ2luYWxIb3RVcGRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHBhdGNoQWN0aW9uRm9yR3JvdXBpbmcoc3RvcmUsIE9iamVjdC5rZXlzKG5ld1N0b3JlLl9obXJQYXlsb2FkLmFjdGlvbnMpLCAhIXN0b3JlLl9pc09wdGlvbnNBUEkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGRTdG9yZVRvRGV2dG9vbHMoYXBwLCBcbiAgICAvLyBGSVhNRTogaXMgdGhlcmUgYSB3YXkgdG8gYWxsb3cgdGhlIGFzc2lnbm1lbnQgZnJvbSBTdG9yZTxJZCwgUywgRywgQT4gdG8gU3RvcmVHZW5lcmljP1xuICAgIHN0b3JlKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgUGluaWEgaW5zdGFuY2UgdG8gYmUgdXNlZCBieSB0aGUgYXBwbGljYXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGluaWEoKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBlZmZlY3RTY29wZSh0cnVlKTtcbiAgICAvLyBOT1RFOiBoZXJlIHdlIGNvdWxkIGNoZWNrIHRoZSB3aW5kb3cgb2JqZWN0IGZvciBhIHN0YXRlIGFuZCBkaXJlY3RseSBzZXQgaXRcbiAgICAvLyBpZiB0aGVyZSBpcyBhbnl0aGluZyBsaWtlIGl0IHdpdGggVnVlIDMgU1NSXG4gICAgY29uc3Qgc3RhdGUgPSBzY29wZS5ydW4oKCkgPT4gcmVmKHt9KSk7XG4gICAgbGV0IF9wID0gW107XG4gICAgLy8gcGx1Z2lucyBhZGRlZCBiZWZvcmUgY2FsbGluZyBhcHAudXNlKHBpbmlhKVxuICAgIGxldCB0b0JlSW5zdGFsbGVkID0gW107XG4gICAgY29uc3QgcGluaWEgPSBtYXJrUmF3KHtcbiAgICAgICAgaW5zdGFsbChhcHApIHtcbiAgICAgICAgICAgIC8vIHRoaXMgYWxsb3dzIGNhbGxpbmcgdXNlU3RvcmUoKSBvdXRzaWRlIG9mIGEgY29tcG9uZW50IHNldHVwIGFmdGVyXG4gICAgICAgICAgICAvLyBpbnN0YWxsaW5nIHBpbmlhJ3MgcGx1Z2luXG4gICAgICAgICAgICBzZXRBY3RpdmVQaW5pYShwaW5pYSk7XG4gICAgICAgICAgICBwaW5pYS5fYSA9IGFwcDtcbiAgICAgICAgICAgIGFwcC5wcm92aWRlKHBpbmlhU3ltYm9sLCBwaW5pYSk7XG4gICAgICAgICAgICBhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMuJHBpbmlhID0gcGluaWE7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKCgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSAndW5kZWZpbmVkJyAmJiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pKSAmJiAhKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpKSAmJiBJU19DTElFTlQpIHtcbiAgICAgICAgICAgICAgICByZWdpc3RlclBpbmlhRGV2dG9vbHMoYXBwLCBwaW5pYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b0JlSW5zdGFsbGVkLmZvckVhY2goKHBsdWdpbikgPT4gX3AucHVzaChwbHVnaW4pKTtcbiAgICAgICAgICAgIHRvQmVJbnN0YWxsZWQgPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgdXNlKHBsdWdpbikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hKSB7XG4gICAgICAgICAgICAgICAgdG9CZUluc3RhbGxlZC5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfcC5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgX3AsXG4gICAgICAgIC8vIGl0J3MgYWN0dWFsbHkgdW5kZWZpbmVkIGhlcmVcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBfYTogbnVsbCxcbiAgICAgICAgX2U6IHNjb3BlLFxuICAgICAgICBfczogbmV3IE1hcCgpLFxuICAgICAgICBzdGF0ZSxcbiAgICB9KTtcbiAgICAvLyBwaW5pYSBkZXZ0b29scyByZWx5IG9uIGRldiBvbmx5IGZlYXR1cmVzIHNvIHRoZXkgY2Fubm90IGJlIGZvcmNlZCB1bmxlc3NcbiAgICAvLyB0aGUgZGV2IGJ1aWxkIG9mIFZ1ZSBpcyB1c2VkLiBBdm9pZCBvbGQgYnJvd3NlcnMgbGlrZSBJRTExLlxuICAgIGlmICgoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgX19WVUVfUFJPRF9ERVZUT09MU19fKSkgJiYgIShwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSkgJiYgSVNfQ0xJRU5UICYmIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGluaWEudXNlKGRldnRvb2xzUGx1Z2luKTtcbiAgICB9XG4gICAgcmV0dXJuIHBpbmlhO1xufVxuLyoqXG4gKiBEaXNwb3NlIGEgUGluaWEgaW5zdGFuY2UgYnkgc3RvcHBpbmcgaXRzIGVmZmVjdFNjb3BlIGFuZCByZW1vdmluZyB0aGUgc3RhdGUsIHBsdWdpbnMgYW5kIHN0b3Jlcy4gVGhpcyBpcyBtb3N0bHlcbiAqIHVzZWZ1bCBpbiB0ZXN0cywgd2l0aCBib3RoIGEgdGVzdGluZyBwaW5pYSBvciBhIHJlZ3VsYXIgcGluaWEgYW5kIGluIGFwcGxpY2F0aW9ucyB0aGF0IHVzZSBtdWx0aXBsZSBwaW5pYSBpbnN0YW5jZXMuXG4gKiBPbmNlIGRpc3Bvc2VkLCB0aGUgcGluaWEgaW5zdGFuY2UgY2Fubm90IGJlIHVzZWQgYW55bW9yZS5cbiAqXG4gKiBAcGFyYW0gcGluaWEgLSBwaW5pYSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBkaXNwb3NlUGluaWEocGluaWEpIHtcbiAgICBwaW5pYS5fZS5zdG9wKCk7XG4gICAgcGluaWEuX3MuY2xlYXIoKTtcbiAgICBwaW5pYS5fcC5zcGxpY2UoMCk7XG4gICAgcGluaWEuc3RhdGUudmFsdWUgPSB7fTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBub24gdmFsaWRcbiAgICBwaW5pYS5fYSA9IG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZnVuY3Rpb24gaXMgYSBgU3RvcmVEZWZpbml0aW9uYC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBvYmplY3QgdG8gdGVzdFxuICogQHJldHVybnMgdHJ1ZSBpZiBgZm5gIGlzIGEgU3RvcmVEZWZpbml0aW9uXG4gKi9cbmNvbnN0IGlzVXNlU3RvcmUgPSAoZm4pID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBmbi4kaWQgPT09ICdzdHJpbmcnO1xufTtcbi8qKlxuICogTXV0YXRlcyBpbiBwbGFjZSBgbmV3U3RhdGVgIHdpdGggYG9sZFN0YXRlYCB0byBfaG90IHVwZGF0ZV8gaXQuIEl0IHdpbGxcbiAqIHJlbW92ZSBhbnkga2V5IG5vdCBleGlzdGluZyBpbiBgbmV3U3RhdGVgIGFuZCByZWN1cnNpdmVseSBtZXJnZSBwbGFpblxuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gbmV3U3RhdGUgLSBuZXcgc3RhdGUgb2JqZWN0IHRvIGJlIHBhdGNoZWRcbiAqIEBwYXJhbSBvbGRTdGF0ZSAtIG9sZCBzdGF0ZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHBhdGNoIG5ld1N0YXRlXG4gKiBAcmV0dXJucyAtIG5ld1N0YXRlXG4gKi9cbmZ1bmN0aW9uIHBhdGNoT2JqZWN0KG5ld1N0YXRlLCBvbGRTdGF0ZSkge1xuICAgIC8vIG5vIG5lZWQgdG8gZ28gdGhyb3VnaCBzeW1ib2xzIGJlY2F1c2UgdGhleSBjYW5ub3QgYmUgc2VyaWFsaXplZCBhbnl3YXlcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRTdGF0ZSkge1xuICAgICAgICBjb25zdCBzdWJQYXRjaCA9IG9sZFN0YXRlW2tleV07XG4gICAgICAgIC8vIHNraXAgdGhlIHdob2xlIHN1YiB0cmVlXG4gICAgICAgIGlmICghKGtleSBpbiBuZXdTdGF0ZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gbmV3U3RhdGVba2V5XTtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0VmFsdWUpICYmXG4gICAgICAgICAgICBpc1BsYWluT2JqZWN0KHN1YlBhdGNoKSAmJlxuICAgICAgICAgICAgIWlzUmVmKHN1YlBhdGNoKSAmJlxuICAgICAgICAgICAgIWlzUmVhY3RpdmUoc3ViUGF0Y2gpKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gcGF0Y2hPYmplY3QodGFyZ2V0VmFsdWUsIHN1YlBhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9iamVjdHMgYXJlIGVpdGhlciBhIGJpdCBtb3JlIGNvbXBsZXggKGUuZy4gcmVmcykgb3IgcHJpbWl0aXZlcywgc28gd2VcbiAgICAgICAgICAgIC8vIGp1c3Qgc2V0IHRoZSB3aG9sZSB0aGluZ1xuICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IHN1YlBhdGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdTdGF0ZTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBfYWNjZXB0XyBmdW5jdGlvbiB0byBwYXNzIHRvIGBpbXBvcnQubWV0YS5ob3RgIGluIFZpdGUgYXBwbGljYXRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3QgdXNlVXNlciA9IGRlZmluZVN0b3JlKC4uLilcbiAqIGlmIChpbXBvcnQubWV0YS5ob3QpIHtcbiAqICAgaW1wb3J0Lm1ldGEuaG90LmFjY2VwdChhY2NlcHRITVJVcGRhdGUodXNlVXNlciwgaW1wb3J0Lm1ldGEuaG90KSlcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBpbml0aWFsVXNlU3RvcmUgLSByZXR1cm4gb2YgdGhlIGRlZmluZVN0b3JlIHRvIGhvdCB1cGRhdGVcbiAqIEBwYXJhbSBob3QgLSBgaW1wb3J0Lm1ldGEuaG90YFxuICovXG5mdW5jdGlvbiBhY2NlcHRITVJVcGRhdGUoaW5pdGlhbFVzZVN0b3JlLCBob3QpIHtcbiAgICAvLyBzdHJpcCBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaWlmZS5wcm9kXG4gICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcbiAgICB9XG4gICAgcmV0dXJuIChuZXdNb2R1bGUpID0+IHtcbiAgICAgICAgY29uc3QgcGluaWEgPSBob3QuZGF0YS5waW5pYSB8fCBpbml0aWFsVXNlU3RvcmUuX3BpbmlhO1xuICAgICAgICBpZiAoIXBpbmlhKSB7XG4gICAgICAgICAgICAvLyB0aGlzIHN0b3JlIGlzIHN0aWxsIG5vdCB1c2VkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJlc2VydmUgdGhlIHBpbmlhIGluc3RhbmNlIGFjcm9zcyBsb2Fkc1xuICAgICAgICBob3QuZGF0YS5waW5pYSA9IHBpbmlhO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnZ290IGRhdGEnLCBuZXdTdG9yZSlcbiAgICAgICAgZm9yIChjb25zdCBleHBvcnROYW1lIGluIG5ld01vZHVsZSkge1xuICAgICAgICAgICAgY29uc3QgdXNlU3RvcmUgPSBuZXdNb2R1bGVbZXhwb3J0TmFtZV07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnY2hlY2tpbmcgZm9yJywgZXhwb3J0TmFtZSlcbiAgICAgICAgICAgIGlmIChpc1VzZVN0b3JlKHVzZVN0b3JlKSAmJiBwaW5pYS5fcy5oYXModXNlU3RvcmUuJGlkKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdBY2NlcHRpbmcgdXBkYXRlIGZvcicsIHVzZVN0b3JlLiRpZClcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IHVzZVN0b3JlLiRpZDtcbiAgICAgICAgICAgICAgICBpZiAoaWQgIT09IGluaXRpYWxVc2VTdG9yZS4kaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBUaGUgaWQgb2YgdGhlIHN0b3JlIGNoYW5nZWQgZnJvbSBcIiR7aW5pdGlhbFVzZVN0b3JlLiRpZH1cIiB0byBcIiR7aWR9XCIuIFJlbG9hZGluZy5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIGltcG9ydC5tZXRhLmhvdC5pbnZhbGlkYXRlKClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvdC5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU3RvcmUgPSBwaW5pYS5fcy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmdTdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1BpbmlhXTogc2tpcHBpbmcgaG1yIGJlY2F1c2Ugc3RvcmUgZG9lc24ndCBleGlzdCB5ZXRgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1c2VTdG9yZShwaW5pYSwgZXhpc3RpbmdTdG9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5jb25zdCBub29wID0gKCkgPT4geyB9O1xuZnVuY3Rpb24gYWRkU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbnMsIGNhbGxiYWNrLCBkZXRhY2hlZCwgb25DbGVhbnVwID0gbm9vcCkge1xuICAgIHN1YnNjcmlwdGlvbnMuYWRkKGNhbGxiYWNrKTtcbiAgICBjb25zdCByZW1vdmVTdWJzY3JpcHRpb24gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRGVsID0gc3Vic2NyaXB0aW9ucy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICBpc0RlbCAmJiBvbkNsZWFudXAoKTtcbiAgICB9O1xuICAgIGlmICghZGV0YWNoZWQgJiYgZ2V0Q3VycmVudFNjb3BlKCkpIHtcbiAgICAgICAgb25TY29wZURpc3Bvc2UocmVtb3ZlU3Vic2NyaXB0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW92ZVN1YnNjcmlwdGlvbjtcbn1cbmZ1bmN0aW9uIHRyaWdnZXJTdWJzY3JpcHRpb25zKHN1YnNjcmlwdGlvbnMsIC4uLmFyZ3MpIHtcbiAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgIH0pO1xufVxuXG5jb25zdCBmYWxsYmFja1J1bldpdGhDb250ZXh0ID0gKGZuKSA9PiBmbigpO1xuLyoqXG4gKiBNYXJrcyBhIGZ1bmN0aW9uIGFzIGFuIGFjdGlvbiBmb3IgYCRvbkFjdGlvbmBcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBBQ1RJT05fTUFSS0VSID0gU3ltYm9sKCk7XG4vKipcbiAqIEFjdGlvbiBuYW1lIHN5bWJvbC4gQWxsb3dzIHRvIGFkZCBhIG5hbWUgdG8gYW4gYWN0aW9uIGFmdGVyIGRlZmluaW5nIGl0XG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQUNUSU9OX05BTUUgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIG1lcmdlUmVhY3RpdmVPYmplY3RzKHRhcmdldCwgcGF0Y2hUb0FwcGx5KSB7XG4gICAgLy8gSGFuZGxlIE1hcCBpbnN0YW5jZXNcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTWFwICYmIHBhdGNoVG9BcHBseSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBwYXRjaFRvQXBwbHkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdGFyZ2V0LnNldChrZXksIHZhbHVlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFNldCAmJiBwYXRjaFRvQXBwbHkgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgLy8gSGFuZGxlIFNldCBpbnN0YW5jZXNcbiAgICAgICAgcGF0Y2hUb0FwcGx5LmZvckVhY2godGFyZ2V0LmFkZCwgdGFyZ2V0KTtcbiAgICB9XG4gICAgLy8gbm8gbmVlZCB0byBnbyB0aHJvdWdoIHN5bWJvbHMgYmVjYXVzZSB0aGV5IGNhbm5vdCBiZSBzZXJpYWxpemVkIGFueXdheVxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoVG9BcHBseSkge1xuICAgICAgICBpZiAoIXBhdGNoVG9BcHBseS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHN1YlBhdGNoID0gcGF0Y2hUb0FwcGx5W2tleV07XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldFZhbHVlKSAmJlxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdChzdWJQYXRjaCkgJiZcbiAgICAgICAgICAgIHRhcmdldC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICAgICAhaXNSZWYoc3ViUGF0Y2gpICYmXG4gICAgICAgICAgICAhaXNSZWFjdGl2ZShzdWJQYXRjaCkpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IGhlcmUgSSB3YW50ZWQgdG8gd2FybiBhYm91dCBpbmNvbnNpc3RlbnQgdHlwZXMgYnV0IGl0J3Mgbm90IHBvc3NpYmxlIGJlY2F1c2UgaW4gc2V0dXAgc3RvcmVzIG9uZSBtaWdodFxuICAgICAgICAgICAgLy8gc3RhcnQgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgYXMgYSBjZXJ0YWluIHR5cGUgZS5nLiBhIE1hcCwgYW5kIHRoZW4gZm9yIHNvbWUgcmVhc29uLCBkdXJpbmcgU1NSLCBjaGFuZ2UgdGhhdFxuICAgICAgICAgICAgLy8gdG8gYHVuZGVmaW5lZGAuIFdoZW4gdHJ5aW5nIHRvIGh5ZHJhdGUsIHdlIHdhbnQgdG8gb3ZlcnJpZGUgdGhlIE1hcCB3aXRoIGB1bmRlZmluZWRgLlxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZVJlYWN0aXZlT2JqZWN0cyh0YXJnZXRWYWx1ZSwgc3ViUGF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc3ViUGF0Y2ggaXMgYSB2YWxpZCB2YWx1ZVxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzdWJQYXRjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuY29uc3Qgc2tpcEh5ZHJhdGVTeW1ib2wgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICA/IFN5bWJvbCgncGluaWE6c2tpcEh5ZHJhdGlvbicpXG4gICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBTeW1ib2woKTtcbi8qKlxuICogVGVsbHMgUGluaWEgdG8gc2tpcCB0aGUgaHlkcmF0aW9uIHByb2Nlc3Mgb2YgYSBnaXZlbiBvYmplY3QuIFRoaXMgaXMgdXNlZnVsIGluIHNldHVwIHN0b3JlcyAob25seSkgd2hlbiB5b3UgcmV0dXJuIGFcbiAqIHN0YXRlZnVsIG9iamVjdCBpbiB0aGUgc3RvcmUgYnV0IGl0IGlzbid0IHJlYWxseSBzdGF0ZS4gZS5nLiByZXR1cm5pbmcgYSByb3V0ZXIgaW5zdGFuY2UgaW4gYSBzZXR1cCBzdG9yZS5cbiAqXG4gKiBAcGFyYW0gb2JqIC0gdGFyZ2V0IG9iamVjdFxuICogQHJldHVybnMgb2JqXG4gKi9cbmZ1bmN0aW9uIHNraXBIeWRyYXRlKG9iaikge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBza2lwSHlkcmF0ZVN5bWJvbCwge30pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSB2YWx1ZSBzaG91bGQgYmUgaHlkcmF0ZWRcbiAqXG4gKiBAcGFyYW0gb2JqIC0gdGFyZ2V0IHZhcmlhYmxlXG4gKiBAcmV0dXJucyB0cnVlIGlmIGBvYmpgIHNob3VsZCBiZSBoeWRyYXRlZFxuICovXG5mdW5jdGlvbiBzaG91bGRIeWRyYXRlKG9iaikge1xuICAgIHJldHVybiAoIWlzUGxhaW5PYmplY3Qob2JqKSB8fFxuICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgc2tpcEh5ZHJhdGVTeW1ib2wpKTtcbn1cbmNvbnN0IHsgYXNzaWduIH0gPSBPYmplY3Q7XG5mdW5jdGlvbiBpc0NvbXB1dGVkKG8pIHtcbiAgICByZXR1cm4gISEoaXNSZWYobykgJiYgby5lZmZlY3QpO1xufVxuZnVuY3Rpb24gY3JlYXRlT3B0aW9uc1N0b3JlKGlkLCBvcHRpb25zLCBwaW5pYSwgaG90KSB7XG4gICAgY29uc3QgeyBzdGF0ZSwgYWN0aW9ucywgZ2V0dGVycyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSBwaW5pYS5zdGF0ZS52YWx1ZVtpZF07XG4gICAgbGV0IHN0b3JlO1xuICAgIGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICAgICBpZiAoIWluaXRpYWxTdGF0ZSAmJiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAhaG90KSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBwaW5pYS5zdGF0ZS52YWx1ZVtpZF0gPSBzdGF0ZSA/IHN0YXRlKCkgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhdm9pZCBjcmVhdGluZyBhIHN0YXRlIGluIHBpbmlhLnN0YXRlLnZhbHVlXG4gICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaG90XG4gICAgICAgICAgICA/IC8vIHVzZSByZWYoKSB0byB1bndyYXAgcmVmcyBpbnNpZGUgc3RhdGUgVE9ETzogY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICB0b1JlZnMocmVmKHN0YXRlID8gc3RhdGUoKSA6IHt9KS52YWx1ZSlcbiAgICAgICAgICAgIDogdG9SZWZzKHBpbmlhLnN0YXRlLnZhbHVlW2lkXSk7XG4gICAgICAgIHJldHVybiBhc3NpZ24obG9jYWxTdGF0ZSwgYWN0aW9ucywgT2JqZWN0LmtleXMoZ2V0dGVycyB8fCB7fSkucmVkdWNlKChjb21wdXRlZEdldHRlcnMsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbmFtZSBpbiBsb2NhbFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBb8J+NjV06IEEgZ2V0dGVyIGNhbm5vdCBoYXZlIHRoZSBzYW1lIG5hbWUgYXMgYW5vdGhlciBzdGF0ZSBwcm9wZXJ0eS4gUmVuYW1lIG9uZSBvZiB0aGVtLiBGb3VuZCB3aXRoIFwiJHtuYW1lfVwiIGluIHN0b3JlIFwiJHtpZH1cIi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXB1dGVkR2V0dGVyc1tuYW1lXSA9IG1hcmtSYXcoY29tcHV0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldEFjdGl2ZVBpbmlhKHBpbmlhKTtcbiAgICAgICAgICAgICAgICAvLyBpdCB3YXMgY3JlYXRlZCBqdXN0IGJlZm9yZVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gcGluaWEuX3MuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBjcm9zcyB1c2luZyBzdG9yZXNcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGdldHRlcnMhW25hbWVdLmNhbGwoY29udGV4dCwgY29udGV4dClcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhdm9pZCByZWFkaW5nIHRoZSBnZXR0ZXIgd2hpbGUgYXNzaWduaW5nIHdpdGggYSBnbG9iYWwgdmFyaWFibGVcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyc1tuYW1lXS5jYWxsKHN0b3JlLCBzdG9yZSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZWRHZXR0ZXJzO1xuICAgICAgICB9LCB7fSkpO1xuICAgIH1cbiAgICBzdG9yZSA9IGNyZWF0ZVNldHVwU3RvcmUoaWQsIHNldHVwLCBvcHRpb25zLCBwaW5pYSwgaG90LCB0cnVlKTtcbiAgICByZXR1cm4gc3RvcmU7XG59XG5mdW5jdGlvbiBjcmVhdGVTZXR1cFN0b3JlKCRpZCwgc2V0dXAsIG9wdGlvbnMgPSB7fSwgcGluaWEsIGhvdCwgaXNPcHRpb25zU3RvcmUpIHtcbiAgICBsZXQgc2NvcGU7XG4gICAgY29uc3Qgb3B0aW9uc0ZvclBsdWdpbiA9IGFzc2lnbih7IGFjdGlvbnM6IHt9IH0sIG9wdGlvbnMpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXBpbmlhLl9lLmFjdGl2ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpbmlhIGRlc3Ryb3llZCcpO1xuICAgIH1cbiAgICAvLyB3YXRjaGVyIG9wdGlvbnMgZm9yICRzdWJzY3JpYmVcbiAgICBjb25zdCAkc3Vic2NyaWJlT3B0aW9ucyA9IHsgZGVlcDogdHJ1ZSB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAkc3Vic2NyaWJlT3B0aW9ucy5vblRyaWdnZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoaXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlckV2ZW50cyA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIC8vIGF2b2lkIHRyaWdnZXJpbmcgdGhpcyB3aGlsZSB0aGUgc3RvcmUgaXMgYmVpbmcgYnVpbHQgYW5kIHRoZSBzdGF0ZSBpcyBiZWluZyBzZXQgaW4gcGluaWFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTGlzdGVuaW5nID09IGZhbHNlICYmICFzdG9yZS5faG90VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBsZXQgcGF0Y2ggc2VuZCBhbGwgdGhlIGV2ZW50cyB0b2dldGhlciBsYXRlclxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVidWdnZXJFdmVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyRXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcign8J+NjSBkZWJ1Z2dlckV2ZW50cyBzaG91bGQgYmUgYW4gYXJyYXkuIFRoaXMgaXMgbW9zdCBsaWtlbHkgYW4gaW50ZXJuYWwgUGluaWEgYnVnLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICBsZXQgaXNMaXN0ZW5pbmc7IC8vIHNldCB0byB0cnVlIGF0IHRoZSBlbmRcbiAgICBsZXQgaXNTeW5jTGlzdGVuaW5nOyAvLyBzZXQgdG8gdHJ1ZSBhdCB0aGUgZW5kXG4gICAgbGV0IHN1YnNjcmlwdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IGFjdGlvblN1YnNjcmlwdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IGRlYnVnZ2VyRXZlbnRzO1xuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHBpbmlhLnN0YXRlLnZhbHVlWyRpZF07XG4gICAgLy8gYXZvaWQgc2V0dGluZyB0aGUgc3RhdGUgZm9yIG9wdGlvbiBzdG9yZXMgaWYgaXQgaXMgc2V0XG4gICAgLy8gYnkgdGhlIHNldHVwXG4gICAgaWYgKCFpc09wdGlvbnNTdG9yZSAmJiAhaW5pdGlhbFN0YXRlICYmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICFob3QpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBwaW5pYS5zdGF0ZS52YWx1ZVskaWRdID0ge307XG4gICAgfVxuICAgIGNvbnN0IGhvdFN0YXRlID0gcmVmKHt9KTtcbiAgICAvLyBhdm9pZCB0cmlnZ2VyaW5nIHRvbyBtYW55IGxpc3RlbmVyc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9waW5pYS9pc3N1ZXMvMTEyOVxuICAgIGxldCBhY3RpdmVMaXN0ZW5lcjtcbiAgICBmdW5jdGlvbiAkcGF0Y2gocGFydGlhbFN0YXRlT3JNdXRhdG9yKSB7XG4gICAgICAgIGxldCBzdWJzY3JpcHRpb25NdXRhdGlvbjtcbiAgICAgICAgaXNMaXN0ZW5pbmcgPSBpc1N5bmNMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gcmVzZXQgdGhlIGRlYnVnZ2VyIGV2ZW50cyBzaW5jZSBwYXRjaGVzIGFyZSBzeW5jXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIGRlYnVnZ2VyRXZlbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXJ0aWFsU3RhdGVPck11dGF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBhcnRpYWxTdGF0ZU9yTXV0YXRvcihwaW5pYS5zdGF0ZS52YWx1ZVskaWRdKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbk11dGF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IE11dGF0aW9uVHlwZS5wYXRjaEZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHN0b3JlSWQ6ICRpZCxcbiAgICAgICAgICAgICAgICBldmVudHM6IGRlYnVnZ2VyRXZlbnRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lcmdlUmVhY3RpdmVPYmplY3RzKHBpbmlhLnN0YXRlLnZhbHVlWyRpZF0sIHBhcnRpYWxTdGF0ZU9yTXV0YXRvcik7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25NdXRhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNdXRhdGlvblR5cGUucGF0Y2hPYmplY3QsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcGFydGlhbFN0YXRlT3JNdXRhdG9yLFxuICAgICAgICAgICAgICAgIHN0b3JlSWQ6ICRpZCxcbiAgICAgICAgICAgICAgICBldmVudHM6IGRlYnVnZ2VyRXZlbnRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBteUxpc3RlbmVySWQgPSAoYWN0aXZlTGlzdGVuZXIgPSBTeW1ib2woKSk7XG4gICAgICAgIG5leHRUaWNrKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlTGlzdGVuZXIgPT09IG15TGlzdGVuZXJJZCkge1xuICAgICAgICAgICAgICAgIGlzTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3luY0xpc3RlbmluZyA9IHRydWU7XG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgcGF1c2VkIHRoZSB3YXRjaGVyLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IGNhbGwgdGhlIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgdHJpZ2dlclN1YnNjcmlwdGlvbnMoc3Vic2NyaXB0aW9ucywgc3Vic2NyaXB0aW9uTXV0YXRpb24sIHBpbmlhLnN0YXRlLnZhbHVlWyRpZF0pO1xuICAgIH1cbiAgICBjb25zdCAkcmVzZXQgPSBpc09wdGlvbnNTdG9yZVxuICAgICAgICA/IGZ1bmN0aW9uICRyZXNldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlID8gc3RhdGUoKSA6IHt9O1xuICAgICAgICAgICAgLy8gd2UgdXNlIGEgcGF0Y2ggdG8gZ3JvdXAgYWxsIGNoYW5nZXMgaW50byBvbmUgc2luZ2xlIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgdGhpcy4kcGF0Y2goKCRzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IEZJWE1FOiBzaG91bGRuJ3QgZXJyb3I/XG4gICAgICAgICAgICAgICAgYXNzaWduKCRzdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgICAgICAgICAgPyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihg8J+NjTogU3RvcmUgXCIkeyRpZH1cIiBpcyBidWlsdCB1c2luZyB0aGUgc2V0dXAgc3ludGF4IGFuZCBkb2VzIG5vdCBpbXBsZW1lbnQgJHJlc2V0KCkuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogbm9vcDtcbiAgICBmdW5jdGlvbiAkZGlzcG9zZSgpIHtcbiAgICAgICAgc2NvcGUuc3RvcCgpO1xuICAgICAgICBzdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgICAgIGFjdGlvblN1YnNjcmlwdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgcGluaWEuX3MuZGVsZXRlKCRpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciB0aGF0IHdyYXBzIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSB0cmFja2VkIHdpdGggJG9uQWN0aW9uXG4gICAgICogQHBhcmFtIGZuIC0gYWN0aW9uIHRvIHdyYXBcbiAgICAgKiBAcGFyYW0gbmFtZSAtIG5hbWUgb2YgdGhlIGFjdGlvblxuICAgICAqL1xuICAgIGNvbnN0IGFjdGlvbiA9IChmbiwgbmFtZSA9ICcnKSA9PiB7XG4gICAgICAgIGlmIChBQ1RJT05fTUFSS0VSIGluIGZuKSB7XG4gICAgICAgICAgICBmbltBQ1RJT05fTkFNRV0gPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXBwZWRBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRBY3RpdmVQaW5pYShwaW5pYSk7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgICAgICAgICAgY29uc3QgYWZ0ZXJDYWxsYmFja1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3JDYWxsYmFja1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFmdGVyKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXJDYWxsYmFja1NldC5hZGQoY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gb25FcnJvcihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9uRXJyb3JDYWxsYmFja1NldC5hZGQoY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgdHJpZ2dlclN1YnNjcmlwdGlvbnMoYWN0aW9uU3Vic2NyaXB0aW9ucywge1xuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgbmFtZTogd3JhcHBlZEFjdGlvbltBQ1RJT05fTkFNRV0sXG4gICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgYWZ0ZXIsXG4gICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHJldDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gZm4uYXBwbHkodGhpcyAmJiB0aGlzLiRpZCA9PT0gJGlkID8gdGhpcyA6IHN0b3JlLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3luYyBlcnJvcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJTdWJzY3JpcHRpb25zKG9uRXJyb3JDYWxsYmFja1NldCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0XG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyU3Vic2NyaXB0aW9ucyhhZnRlckNhbGxiYWNrU2V0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJTdWJzY3JpcHRpb25zKG9uRXJyb3JDYWxsYmFja1NldCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJpZ2dlciBhZnRlciBjYWxsYmFja3NcbiAgICAgICAgICAgIHRyaWdnZXJTdWJzY3JpcHRpb25zKGFmdGVyQ2FsbGJhY2tTZXQsIHJldCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgICAgICB3cmFwcGVkQWN0aW9uW0FDVElPTl9NQVJLRVJdID0gdHJ1ZTtcbiAgICAgICAgd3JhcHBlZEFjdGlvbltBQ1RJT05fTkFNRV0gPSBuYW1lOyAvLyB3aWxsIGJlIHNldCBsYXRlclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZSBhcmUgaW50ZW50aW9uYWxseSBsaW1pdGluZyB0aGUgcmV0dXJuZWQgdHlwZSB0byBqdXN0IEZuXG4gICAgICAgIC8vIGJlY2F1c2UgYWxsIHRoZSBhZGRlZCBwcm9wZXJ0aWVzIGFyZSBpbnRlcm5hbHMgdGhhdCBhcmUgZXhwb3NlZCB0aHJvdWdoIGAkb25BY3Rpb24oKWAgb25seVxuICAgICAgICByZXR1cm4gd3JhcHBlZEFjdGlvbjtcbiAgICB9O1xuICAgIGNvbnN0IF9obXJQYXlsb2FkID0gLyojX19QVVJFX18qLyBtYXJrUmF3KHtcbiAgICAgICAgYWN0aW9uczoge30sXG4gICAgICAgIGdldHRlcnM6IHt9LFxuICAgICAgICBzdGF0ZTogW10sXG4gICAgICAgIGhvdFN0YXRlLFxuICAgIH0pO1xuICAgIGNvbnN0IHBhcnRpYWxTdG9yZSA9IHtcbiAgICAgICAgX3A6IHBpbmlhLFxuICAgICAgICAvLyBfczogc2NvcGUsXG4gICAgICAgICRpZCxcbiAgICAgICAgJG9uQWN0aW9uOiBhZGRTdWJzY3JpcHRpb24uYmluZChudWxsLCBhY3Rpb25TdWJzY3JpcHRpb25zKSxcbiAgICAgICAgJHBhdGNoLFxuICAgICAgICAkcmVzZXQsXG4gICAgICAgICRzdWJzY3JpYmUoY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlU3Vic2NyaXB0aW9uID0gYWRkU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbnMsIGNhbGxiYWNrLCBvcHRpb25zLmRldGFjaGVkLCAoKSA9PiBzdG9wV2F0Y2hlcigpKTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3BXYXRjaGVyID0gc2NvcGUucnVuKCgpID0+IHdhdGNoKCgpID0+IHBpbmlhLnN0YXRlLnZhbHVlWyRpZF0sIChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZsdXNoID09PSAnc3luYycgPyBpc1N5bmNMaXN0ZW5pbmcgOiBpc0xpc3RlbmluZykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZUlkOiAkaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNdXRhdGlvblR5cGUuZGlyZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBkZWJ1Z2dlckV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgfSwgc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGFzc2lnbih7fSwgJHN1YnNjcmliZU9wdGlvbnMsIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlU3Vic2NyaXB0aW9uO1xuICAgICAgICB9LFxuICAgICAgICAkZGlzcG9zZSxcbiAgICB9O1xuICAgIGNvbnN0IHN0b3JlID0gcmVhY3RpdmUoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICgoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgX19WVUVfUFJPRF9ERVZUT09MU19fKSkgJiYgIShwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSkgJiYgSVNfQ0xJRU5UKVxuICAgICAgICA/IGFzc2lnbih7XG4gICAgICAgICAgICBfaG1yUGF5bG9hZCxcbiAgICAgICAgICAgIF9jdXN0b21Qcm9wZXJ0aWVzOiBtYXJrUmF3KG5ldyBTZXQoKSksIC8vIGRldnRvb2xzIGN1c3RvbSBwcm9wZXJ0aWVzXG4gICAgICAgIH0sIHBhcnRpYWxTdG9yZVxuICAgICAgICAvLyBtdXN0IGJlIGFkZGVkIGxhdGVyXG4gICAgICAgIC8vIHNldHVwU3RvcmVcbiAgICAgICAgKVxuICAgICAgICA6IHBhcnRpYWxTdG9yZSk7XG4gICAgLy8gc3RvcmUgdGhlIHBhcnRpYWwgc3RvcmUgbm93IHNvIHRoZSBzZXR1cCBvZiBzdG9yZXMgY2FuIGluc3RhbnRpYXRlIGVhY2ggb3RoZXIgYmVmb3JlIHRoZXkgYXJlIGZpbmlzaGVkIHdpdGhvdXRcbiAgICAvLyBjcmVhdGluZyBpbmZpbml0ZSBsb29wcy5cbiAgICBwaW5pYS5fcy5zZXQoJGlkLCBzdG9yZSk7XG4gICAgY29uc3QgcnVuV2l0aENvbnRleHQgPSAocGluaWEuX2EgJiYgcGluaWEuX2EucnVuV2l0aENvbnRleHQpIHx8IGZhbGxiYWNrUnVuV2l0aENvbnRleHQ7XG4gICAgLy8gVE9ETzogaWRlYSBjcmVhdGUgc2tpcFNlcmlhbGl6ZSB0aGF0IG1hcmtzIHByb3BlcnRpZXMgYXMgbm9uIHNlcmlhbGl6YWJsZSBhbmQgdGhleSBhcmUgc2tpcHBlZFxuICAgIGNvbnN0IHNldHVwU3RvcmUgPSBydW5XaXRoQ29udGV4dCgoKSA9PiBwaW5pYS5fZS5ydW4oKCkgPT4gKHNjb3BlID0gZWZmZWN0U2NvcGUoKSkucnVuKCgpID0+IHNldHVwKHsgYWN0aW9uIH0pKSkpO1xuICAgIC8vIG92ZXJ3cml0ZSBleGlzdGluZyBhY3Rpb25zIHRvIHN1cHBvcnQgJG9uQWN0aW9uXG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2V0dXBTdG9yZSkge1xuICAgICAgICBjb25zdCBwcm9wID0gc2V0dXBTdG9yZVtrZXldO1xuICAgICAgICBpZiAoKGlzUmVmKHByb3ApICYmICFpc0NvbXB1dGVkKHByb3ApKSB8fCBpc1JlYWN0aXZlKHByb3ApKSB7XG4gICAgICAgICAgICAvLyBtYXJrIGl0IGFzIGEgcGllY2Ugb2Ygc3RhdGUgdG8gYmUgc2VyaWFsaXplZFxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBob3QpIHtcbiAgICAgICAgICAgICAgICBob3RTdGF0ZS52YWx1ZVtrZXldID0gdG9SZWYoc2V0dXBTdG9yZSwga2V5KTtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGVPcHRpb25TdG9yZSBkaXJlY3RseSBzZXRzIHRoZSBzdGF0ZSBpbiBwaW5pYS5zdGF0ZS52YWx1ZSBzbyB3ZVxuICAgICAgICAgICAgICAgIC8vIGNhbiBqdXN0IHNraXAgdGhhdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzT3B0aW9uc1N0b3JlKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gc2V0dXAgc3RvcmVzIHdlIG11c3QgaHlkcmF0ZSB0aGUgc3RhdGUgYW5kIHN5bmMgcGluaWEgc3RhdGUgdHJlZSB3aXRoIHRoZSByZWZzIHRoZSB1c2VyIGp1c3QgY3JlYXRlZFxuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsU3RhdGUgJiYgc2hvdWxkSHlkcmF0ZShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWYocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AudmFsdWUgPSBpbml0aWFsU3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb2JhYmx5IGEgcmVhY3RpdmUgb2JqZWN0LCBsZXRzIHJlY3Vyc2l2ZWx5IGFzc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJvcCBpcyB1bmtub3duXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZVJlYWN0aXZlT2JqZWN0cyhwcm9wLCBpbml0aWFsU3RhdGVba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmZXIgdGhlIHJlZiB0byB0aGUgcGluaWEgc3RhdGUgdG8ga2VlcCBldmVyeXRoaW5nIGluIHN5bmNcbiAgICAgICAgICAgICAgICBwaW5pYS5zdGF0ZS52YWx1ZVskaWRdW2tleV0gPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBfaG1yUGF5bG9hZC5zdGF0ZS5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhY3Rpb25cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uVmFsdWUgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaG90ID8gcHJvcCA6IGFjdGlvbihwcm9wLCBrZXkpO1xuICAgICAgICAgICAgLy8gdGhpcyBhIGhvdCBtb2R1bGUgcmVwbGFjZW1lbnQgc3RvcmUgYmVjYXVzZSB0aGUgaG90VXBkYXRlIG1ldGhvZCBuZWVkc1xuICAgICAgICAgICAgLy8gdG8gZG8gaXQgd2l0aCB0aGUgcmlnaHQgY29udGV4dFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgc2V0dXBTdG9yZVtrZXldID0gYWN0aW9uVmFsdWU7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIF9obXJQYXlsb2FkLmFjdGlvbnNba2V5XSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsaXN0IGFjdGlvbnMgc28gdGhleSBjYW4gYmUgdXNlZCBpbiBwbHVnaW5zXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBvcHRpb25zRm9yUGx1Z2luLmFjdGlvbnNba2V5XSA9IHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAvLyBhZGQgZ2V0dGVycyBmb3IgZGV2dG9vbHNcbiAgICAgICAgICAgIGlmIChpc0NvbXB1dGVkKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgX2htclBheWxvYWQuZ2V0dGVyc1trZXldID0gaXNPcHRpb25zU3RvcmVcbiAgICAgICAgICAgICAgICAgICAgPyAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmdldHRlcnNba2V5XVxuICAgICAgICAgICAgICAgICAgICA6IHByb3A7XG4gICAgICAgICAgICAgICAgaWYgKElTX0NMSUVOVCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnZXR0ZXJzID0gc2V0dXBTdG9yZS5fZ2V0dGVycyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogc2FtZVxuICAgICAgICAgICAgICAgICAgICAgICAgKHNldHVwU3RvcmUuX2dldHRlcnMgPSBtYXJrUmF3KFtdKSk7XG4gICAgICAgICAgICAgICAgICAgIGdldHRlcnMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgdGhlIHN0YXRlLCBnZXR0ZXJzLCBhbmQgYWN0aW9uIHByb3BlcnRpZXNcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBhc3NpZ24oc3RvcmUsIHNldHVwU3RvcmUpO1xuICAgIC8vIGFsbG93cyByZXRyaWV2aW5nIHJlYWN0aXZlIG9iamVjdHMgd2l0aCBgc3RvcmVUb1JlZnMoKWAuIE11c3QgYmUgY2FsbGVkIGFmdGVyIGFzc2lnbmluZyB0byB0aGUgcmVhY3RpdmUgb2JqZWN0LlxuICAgIC8vIE1ha2UgYHN0b3JlVG9SZWZzKClgIHdvcmsgd2l0aCBgcmVhY3RpdmUoKWAgIzc5OVxuICAgIGFzc2lnbih0b1JhdyhzdG9yZSksIHNldHVwU3RvcmUpO1xuICAgIC8vIHVzZSB0aGlzIGluc3RlYWQgb2YgYSBjb21wdXRlZCB3aXRoIHNldHRlciB0byBiZSBhYmxlIHRvIGNyZWF0ZSBpdCBhbnl3aGVyZVxuICAgIC8vIHdpdGhvdXQgbGlua2luZyB0aGUgY29tcHV0ZWQgbGlmZXNwYW4gdG8gd2hlcmV2ZXIgdGhlIHN0b3JlIGlzIGZpcnN0XG4gICAgLy8gY3JlYXRlZC5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RvcmUsICckc3RhdGUnLCB7XG4gICAgICAgIGdldDogKCkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBob3QgPyBob3RTdGF0ZS52YWx1ZSA6IHBpbmlhLnN0YXRlLnZhbHVlWyRpZF0pLFxuICAgICAgICBzZXQ6IChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGhvdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNldCBob3RTdGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHBhdGNoKCgkc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBGSVhNRTogc2hvdWxkbid0IGVycm9yP1xuICAgICAgICAgICAgICAgIGFzc2lnbigkc3RhdGUsIHN0YXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIC8vIGFkZCB0aGUgaG90VXBkYXRlIGJlZm9yZSBwbHVnaW5zIHRvIGFsbG93IHRoZW0gdG8gb3ZlcnJpZGUgaXRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgc3RvcmUuX2hvdFVwZGF0ZSA9IG1hcmtSYXcoKG5ld1N0b3JlKSA9PiB7XG4gICAgICAgICAgICBzdG9yZS5faG90VXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgbmV3U3RvcmUuX2htclBheWxvYWQuc3RhdGUuZm9yRWFjaCgoc3RhdGVLZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVLZXkgaW4gc3RvcmUuJHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlVGFyZ2V0ID0gbmV3U3RvcmUuJHN0YXRlW3N0YXRlS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkU3RhdGVTb3VyY2UgPSBzdG9yZS4kc3RhdGVbc3RhdGVLZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld1N0YXRlVGFyZ2V0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQbGFpbk9iamVjdChuZXdTdGF0ZVRhcmdldCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGxhaW5PYmplY3Qob2xkU3RhdGVTb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaE9iamVjdChuZXdTdGF0ZVRhcmdldCwgb2xkU3RhdGVTb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmZXIgdGhlIHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RvcmUuJHN0YXRlW3N0YXRlS2V5XSA9IG9sZFN0YXRlU291cmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHBhdGNoIGRpcmVjdCBhY2Nlc3MgcHJvcGVydGllcyB0byBhbGxvdyBzdG9yZS5zdGF0ZVByb3BlcnR5IHRvIHdvcmsgYXNcbiAgICAgICAgICAgICAgICAvLyBzdG9yZS4kc3RhdGUuc3RhdGVQcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGFueSB0eXBlXG4gICAgICAgICAgICAgICAgc3RvcmVbc3RhdGVLZXldID0gdG9SZWYobmV3U3RvcmUuJHN0YXRlLCBzdGF0ZUtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBkZWxldGVkIHN0YXRlIHByb3BlcnRpZXNcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0b3JlLiRzdGF0ZSkuZm9yRWFjaCgoc3RhdGVLZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIShzdGF0ZUtleSBpbiBuZXdTdG9yZS4kc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG5vb3AgaWYgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RvcmVbc3RhdGVLZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gYXZvaWQgZGV2dG9vbHMgbG9nZ2luZyB0aGlzIGFzIGEgbXV0YXRpb25cbiAgICAgICAgICAgIGlzTGlzdGVuaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpc1N5bmNMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHBpbmlhLnN0YXRlLnZhbHVlWyRpZF0gPSB0b1JlZihuZXdTdG9yZS5faG1yUGF5bG9hZCwgJ2hvdFN0YXRlJyk7XG4gICAgICAgICAgICBpc1N5bmNMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgbmV4dFRpY2soKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpc0xpc3RlbmluZyA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWN0aW9uTmFtZSBpbiBuZXdTdG9yZS5faG1yUGF5bG9hZC5hY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aW9uRm4gPSBuZXdTdG9yZVthY3Rpb25OYW1lXTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBhY3Rpb25OYW1lIGlzIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgc3RvcmVbYWN0aW9uTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24oYWN0aW9uRm4sIGFjdGlvbk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogZG9lcyB0aGlzIHdvcmsgaW4gYm90aCBzZXR1cCBhbmQgb3B0aW9uIHN0b3JlP1xuICAgICAgICAgICAgZm9yIChjb25zdCBnZXR0ZXJOYW1lIGluIG5ld1N0b3JlLl9obXJQYXlsb2FkLmdldHRlcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnZXR0ZXIgPSBuZXdTdG9yZS5faG1yUGF5bG9hZC5nZXR0ZXJzW2dldHRlck5hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdldHRlclZhbHVlID0gaXNPcHRpb25zU3RvcmVcbiAgICAgICAgICAgICAgICAgICAgPyAvLyBzcGVjaWFsIGhhbmRsaW5nIG9mIG9wdGlvbnMgYXBpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWN0aXZlUGluaWEocGluaWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXR0ZXIuY2FsbChzdG9yZSwgc3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBnZXR0ZXI7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogZ2V0dGVyTmFtZSBpcyBhIHN0cmluZ1xuICAgICAgICAgICAgICAgIHN0b3JlW2dldHRlck5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgZ2V0dGVyVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1vdmUgZGVsZXRlZCBnZXR0ZXJzXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzdG9yZS5faG1yUGF5bG9hZC5nZXR0ZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gbmV3U3RvcmUuX2htclBheWxvYWQuZ2V0dGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbm9vcCBpZiBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZCBhY3Rpb25zXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzdG9yZS5faG1yUGF5bG9hZC5hY3Rpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gbmV3U3RvcmUuX2htclBheWxvYWQuYWN0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbm9vcCBpZiBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSB2YWx1ZXMgdXNlZCBpbiBkZXZ0b29scyBhbmQgdG8gYWxsb3cgZGVsZXRpbmcgbmV3IHByb3BlcnRpZXMgbGF0ZXIgb25cbiAgICAgICAgICAgIHN0b3JlLl9obXJQYXlsb2FkID0gbmV3U3RvcmUuX2htclBheWxvYWQ7XG4gICAgICAgICAgICBzdG9yZS5fZ2V0dGVycyA9IG5ld1N0b3JlLl9nZXR0ZXJzO1xuICAgICAgICAgICAgc3RvcmUuX2hvdFVwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgKHR5cGVvZiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnICYmIF9fVlVFX1BST0RfREVWVE9PTFNfXykpICYmICEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JykpICYmIElTX0NMSUVOVCkge1xuICAgICAgICBjb25zdCBub25FbnVtZXJhYmxlID0ge1xuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAvLyBhdm9pZCB3YXJuaW5nIG9uIGRldnRvb2xzIHRyeWluZyB0byBkaXNwbGF5IHRoaXMgcHJvcGVydHlcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBbJ19wJywgJ19obXJQYXlsb2FkJywgJ19nZXR0ZXJzJywgJ19jdXN0b21Qcm9wZXJ0aWVzJ10uZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0b3JlLCBwLCBhc3NpZ24oeyB2YWx1ZTogc3RvcmVbcF0gfSwgbm9uRW51bWVyYWJsZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gYXBwbHkgYWxsIHBsdWdpbnNcbiAgICBwaW5pYS5fcC5mb3JFYWNoKChleHRlbmRlcikgPT4ge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgKHR5cGVvZiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnICYmIF9fVlVFX1BST0RfREVWVE9PTFNfXykpICYmICEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JykpICYmIElTX0NMSUVOVCkge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IHNjb3BlLnJ1bigoKSA9PiBleHRlbmRlcih7XG4gICAgICAgICAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICAgICAgICAgIGFwcDogcGluaWEuX2EsXG4gICAgICAgICAgICAgICAgcGluaWEsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc0ZvclBsdWdpbixcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMgfHwge30pLmZvckVhY2goKGtleSkgPT4gc3RvcmUuX2N1c3RvbVByb3BlcnRpZXMuYWRkKGtleSkpO1xuICAgICAgICAgICAgYXNzaWduKHN0b3JlLCBleHRlbnNpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2lnbihzdG9yZSwgc2NvcGUucnVuKCgpID0+IGV4dGVuZGVyKHtcbiAgICAgICAgICAgICAgICBzdG9yZTogc3RvcmUsXG4gICAgICAgICAgICAgICAgYXBwOiBwaW5pYS5fYSxcbiAgICAgICAgICAgICAgICBwaW5pYSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zRm9yUGx1Z2luLFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgc3RvcmUuJHN0YXRlICYmXG4gICAgICAgIHR5cGVvZiBzdG9yZS4kc3RhdGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cGVvZiBzdG9yZS4kc3RhdGUuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgIXN0b3JlLiRzdGF0ZS5jb25zdHJ1Y3Rvci50b1N0cmluZygpLmluY2x1ZGVzKCdbbmF0aXZlIGNvZGVdJykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBb8J+NjV06IFRoZSBcInN0YXRlXCIgbXVzdCBiZSBhIHBsYWluIG9iamVjdC4gSXQgY2Fubm90IGJlXFxuYCArXG4gICAgICAgICAgICBgXFx0c3RhdGU6ICgpID0+IG5ldyBNeUNsYXNzKClcXG5gICtcbiAgICAgICAgICAgIGBGb3VuZCBpbiBzdG9yZSBcIiR7c3RvcmUuJGlkfVwiLmApO1xuICAgIH1cbiAgICAvLyBvbmx5IGFwcGx5IGh5ZHJhdGUgdG8gb3B0aW9uIHN0b3JlcyB3aXRoIGFuIGluaXRpYWwgc3RhdGUgaW4gcGluaWFcbiAgICBpZiAoaW5pdGlhbFN0YXRlICYmXG4gICAgICAgIGlzT3B0aW9uc1N0b3JlICYmXG4gICAgICAgIG9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgICBvcHRpb25zLmh5ZHJhdGUoc3RvcmUuJHN0YXRlLCBpbml0aWFsU3RhdGUpO1xuICAgIH1cbiAgICBpc0xpc3RlbmluZyA9IHRydWU7XG4gICAgaXNTeW5jTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RvcmU7XG59XG4vLyBhbGxvd3MgdW51c2VkIHN0b3JlcyB0byBiZSB0cmVlIHNoYWtlblxuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG5mdW5jdGlvbiBkZWZpbmVTdG9yZShcbi8vIFRPRE86IGFkZCBwcm9wZXIgdHlwZXMgZnJvbSBhYm92ZVxuaWQsIHNldHVwLCBzZXR1cE9wdGlvbnMpIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBjb25zdCBpc1NldHVwU3RvcmUgPSB0eXBlb2Ygc2V0dXAgPT09ICdmdW5jdGlvbic7XG4gICAgLy8gdGhlIG9wdGlvbiBzdG9yZSBzZXR1cCB3aWxsIGNvbnRhaW4gdGhlIGFjdHVhbCBvcHRpb25zIGluIHRoaXMgY2FzZVxuICAgIG9wdGlvbnMgPSBpc1NldHVwU3RvcmUgPyBzZXR1cE9wdGlvbnMgOiBzZXR1cDtcbiAgICBmdW5jdGlvbiB1c2VTdG9yZShwaW5pYSwgaG90KSB7XG4gICAgICAgIGNvbnN0IGhhc0NvbnRleHQgPSBoYXNJbmplY3Rpb25Db250ZXh0KCk7XG4gICAgICAgIHBpbmlhID1cbiAgICAgICAgICAgIC8vIGluIHRlc3QgbW9kZSwgaWdub3JlIHRoZSBhcmd1bWVudCBwcm92aWRlZCBhcyB3ZSBjYW4gYWx3YXlzIHJldHJpZXZlIGFcbiAgICAgICAgICAgIC8vIHBpbmlhIGluc3RhbmNlIHdpdGggZ2V0QWN0aXZlUGluaWEoKVxuICAgICAgICAgICAgKChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSAmJiBhY3RpdmVQaW5pYSAmJiBhY3RpdmVQaW5pYS5fdGVzdGluZyA/IG51bGwgOiBwaW5pYSkgfHxcbiAgICAgICAgICAgICAgICAoaGFzQ29udGV4dCA/IGluamVjdChwaW5pYVN5bWJvbCwgbnVsbCkgOiBudWxsKTtcbiAgICAgICAgaWYgKHBpbmlhKVxuICAgICAgICAgICAgc2V0QWN0aXZlUGluaWEocGluaWEpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFhY3RpdmVQaW5pYSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBb8J+NjV06IFwiZ2V0QWN0aXZlUGluaWEoKVwiIHdhcyBjYWxsZWQgYnV0IHRoZXJlIHdhcyBubyBhY3RpdmUgUGluaWEuIEFyZSB5b3UgdHJ5aW5nIHRvIHVzZSBhIHN0b3JlIGJlZm9yZSBjYWxsaW5nIFwiYXBwLnVzZShwaW5pYSlcIj9cXG5gICtcbiAgICAgICAgICAgICAgICBgU2VlIGh0dHBzOi8vcGluaWEudnVlanMub3JnL2NvcmUtY29uY2VwdHMvb3V0c2lkZS1jb21wb25lbnQtdXNhZ2UuaHRtbCBmb3IgaGVscC5cXG5gICtcbiAgICAgICAgICAgICAgICBgVGhpcyB3aWxsIGZhaWwgaW4gcHJvZHVjdGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgICBwaW5pYSA9IGFjdGl2ZVBpbmlhO1xuICAgICAgICBpZiAoIXBpbmlhLl9zLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0aW5nIHRoZSBzdG9yZSByZWdpc3RlcnMgaXQgaW4gYHBpbmlhLl9zYFxuICAgICAgICAgICAgaWYgKGlzU2V0dXBTdG9yZSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVNldHVwU3RvcmUoaWQsIHNldHVwLCBvcHRpb25zLCBwaW5pYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVPcHRpb25zU3RvcmUoaWQsIG9wdGlvbnMsIHBpbmlhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbm90IHRoZSByaWdodCBpbmZlcnJlZCB0eXBlXG4gICAgICAgICAgICAgICAgdXNlU3RvcmUuX3BpbmlhID0gcGluaWE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RvcmUgPSBwaW5pYS5fcy5nZXQoaWQpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGhvdCkge1xuICAgICAgICAgICAgY29uc3QgaG90SWQgPSAnX19ob3Q6JyArIGlkO1xuICAgICAgICAgICAgY29uc3QgbmV3U3RvcmUgPSBpc1NldHVwU3RvcmVcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZVNldHVwU3RvcmUoaG90SWQsIHNldHVwLCBvcHRpb25zLCBwaW5pYSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZU9wdGlvbnNTdG9yZShob3RJZCwgYXNzaWduKHt9LCBvcHRpb25zKSwgcGluaWEsIHRydWUpO1xuICAgICAgICAgICAgaG90Ll9ob3RVcGRhdGUobmV3U3RvcmUpO1xuICAgICAgICAgICAgLy8gY2xlYW51cCB0aGUgc3RhdGUgcHJvcGVydGllcyBhbmQgdGhlIHN0b3JlIGZyb20gdGhlIGNhY2hlXG4gICAgICAgICAgICBkZWxldGUgcGluaWEuc3RhdGUudmFsdWVbaG90SWRdO1xuICAgICAgICAgICAgcGluaWEuX3MuZGVsZXRlKGhvdElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIElTX0NMSUVOVCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgICAgICAvLyBzYXZlIHN0b3JlcyBpbiBpbnN0YW5jZXMgdG8gYWNjZXNzIHRoZW0gZGV2dG9vbHNcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5zdGFuY2UucHJveHkgJiZcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCBhZGRpbmcgc3RvcmVzIHRoYXQgYXJlIGp1c3QgYnVpbHQgZm9yIGhvdCBtb2R1bGUgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAhaG90KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgdm0gPSBjdXJyZW50SW5zdGFuY2UucHJveHk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGUgPSAnX3BTdG9yZXMnIGluIHZtID8gdm0uX3BTdG9yZXMgOiAodm0uX3BTdG9yZXMgPSB7fSk7XG4gICAgICAgICAgICAgICAgY2FjaGVbaWRdID0gc3RvcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmVHZW5lcmljIGNhbm5vdCBiZSBjYXN0ZWQgdG93YXJkcyBTdG9yZVxuICAgICAgICByZXR1cm4gc3RvcmU7XG4gICAgfVxuICAgIHVzZVN0b3JlLiRpZCA9IGlkO1xuICAgIHJldHVybiB1c2VTdG9yZTtcbn1cblxubGV0IG1hcFN0b3JlU3VmZml4ID0gJ1N0b3JlJztcbi8qKlxuICogQ2hhbmdlcyB0aGUgc3VmZml4IGFkZGVkIGJ5IGBtYXBTdG9yZXMoKWAuIENhbiBiZSBzZXQgdG8gYW4gZW1wdHkgc3RyaW5nLlxuICogRGVmYXVsdHMgdG8gYFwiU3RvcmVcImAuIE1ha2Ugc3VyZSB0byBleHRlbmQgdGhlIE1hcFN0b3Jlc0N1c3RvbWl6YXRpb25cbiAqIGludGVyZmFjZSBpZiB5b3UgYXJlIHVzaW5nIFR5cGVTY3JpcHQuXG4gKlxuICogQHBhcmFtIHN1ZmZpeCAtIG5ldyBzdWZmaXhcbiAqL1xuZnVuY3Rpb24gc2V0TWFwU3RvcmVTdWZmaXgoc3VmZml4IC8vIGNvdWxkIGJlICdTdG9yZScgYnV0IHRoYXQgd291bGQgYmUgYW5ub3lpbmcgZm9yIEpTXG4pIHtcbiAgICBtYXBTdG9yZVN1ZmZpeCA9IHN1ZmZpeDtcbn1cbi8qKlxuICogQWxsb3dzIHVzaW5nIHN0b3JlcyB3aXRob3V0IHRoZSBjb21wb3NpdGlvbiBBUEkgKGBzZXR1cCgpYCkgYnkgZ2VuZXJhdGluZyBhblxuICogb2JqZWN0IHRvIGJlIHNwcmVhZCBpbiB0aGUgYGNvbXB1dGVkYCBmaWVsZCBvZiBhIGNvbXBvbmVudC4gSXQgYWNjZXB0cyBhIGxpc3RcbiAqIG9mIHN0b3JlIGRlZmluaXRpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogZXhwb3J0IGRlZmF1bHQge1xuICogICBjb21wdXRlZDoge1xuICogICAgIC8vIG90aGVyIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAqICAgICAuLi5tYXBTdG9yZXModXNlVXNlclN0b3JlLCB1c2VDYXJ0U3RvcmUpXG4gKiAgIH0sXG4gKlxuICogICBjcmVhdGVkKCkge1xuICogICAgIHRoaXMudXNlclN0b3JlIC8vIHN0b3JlIHdpdGggaWQgXCJ1c2VyXCJcbiAqICAgICB0aGlzLmNhcnRTdG9yZSAvLyBzdG9yZSB3aXRoIGlkIFwiY2FydFwiXG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzdG9yZXMgLSBsaXN0IG9mIHN0b3JlcyB0byBtYXAgdG8gYW4gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1hcFN0b3JlcyguLi5zdG9yZXMpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIEFycmF5LmlzQXJyYXkoc3RvcmVzWzBdKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFvwn42NXTogRGlyZWN0bHkgcGFzcyBhbGwgc3RvcmVzIHRvIFwibWFwU3RvcmVzKClcIiB3aXRob3V0IHB1dHRpbmcgdGhlbSBpbiBhbiBhcnJheTpcXG5gICtcbiAgICAgICAgICAgIGBSZXBsYWNlXFxuYCArXG4gICAgICAgICAgICBgXFx0bWFwU3RvcmVzKFt1c2VBdXRoU3RvcmUsIHVzZUNhcnRTdG9yZV0pXFxuYCArXG4gICAgICAgICAgICBgd2l0aFxcbmAgK1xuICAgICAgICAgICAgYFxcdG1hcFN0b3Jlcyh1c2VBdXRoU3RvcmUsIHVzZUNhcnRTdG9yZSlcXG5gICtcbiAgICAgICAgICAgIGBUaGlzIHdpbGwgZmFpbCBpbiBwcm9kdWN0aW9uIGlmIG5vdCBmaXhlZC5gKTtcbiAgICAgICAgc3RvcmVzID0gc3RvcmVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gc3RvcmVzLnJlZHVjZSgocmVkdWNlZCwgdXNlU3RvcmUpID0+IHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogJGlkIGlzIGFkZGVkIGJ5IGRlZmluZVN0b3JlXG4gICAgICAgIHJlZHVjZWRbdXNlU3RvcmUuJGlkICsgbWFwU3RvcmVTdWZmaXhdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZVN0b3JlKHRoaXMuJHBpbmlhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgfSwge30pO1xufVxuLyoqXG4gKiBBbGxvd3MgdXNpbmcgc3RhdGUgYW5kIGdldHRlcnMgZnJvbSBvbmUgc3RvcmUgd2l0aG91dCB1c2luZyB0aGUgY29tcG9zaXRpb25cbiAqIEFQSSAoYHNldHVwKClgKSBieSBnZW5lcmF0aW5nIGFuIG9iamVjdCB0byBiZSBzcHJlYWQgaW4gdGhlIGBjb21wdXRlZGAgZmllbGRcbiAqIG9mIGEgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB1c2VTdG9yZSAtIHN0b3JlIHRvIG1hcCBmcm9tXG4gKiBAcGFyYW0ga2V5c09yTWFwcGVyIC0gYXJyYXkgb3Igb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1hcFN0YXRlKHVzZVN0b3JlLCBrZXlzT3JNYXBwZXIpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShrZXlzT3JNYXBwZXIpXG4gICAgICAgID8ga2V5c09yTWFwcGVyLnJlZHVjZSgocmVkdWNlZCwga2V5KSA9PiB7XG4gICAgICAgICAgICByZWR1Y2VkW2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogRklYTUU6IHNob3VsZCB3b3JrP1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZSh0aGlzLiRwaW5pYSlba2V5XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVkdWNlZDtcbiAgICAgICAgfSwge30pXG4gICAgICAgIDogT2JqZWN0LmtleXMoa2V5c09yTWFwcGVyKS5yZWR1Y2UoKHJlZHVjZWQsIGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcmVkdWNlZFtrZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUodGhpcy4kcGluaWEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlS2V5ID0ga2V5c09yTWFwcGVyW2tleV07XG4gICAgICAgICAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIFRTIGlzIHVuYWJsZSB0byBpbmZlciB0aGUgdHlwZSBvZiBzdG9yZUtleSB0byBiZSBhXG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHN0b3JlS2V5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gc3RvcmVLZXkuY2FsbCh0aGlzLCBzdG9yZSlcbiAgICAgICAgICAgICAgICAgICAgOiAvLyBAdHMtZXhwZWN0LWVycm9yOiBGSVhNRTogc2hvdWxkIHdvcms/XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVtzdG9yZUtleV07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgICAgIH0sIHt9KTtcbn1cbi8qKlxuICogQWxpYXMgZm9yIGBtYXBTdGF0ZSgpYC4gWW91IHNob3VsZCB1c2UgYG1hcFN0YXRlKClgIGluc3RlYWQuXG4gKiBAZGVwcmVjYXRlZCB1c2UgYG1hcFN0YXRlKClgIGluc3RlYWQuXG4gKi9cbmNvbnN0IG1hcEdldHRlcnMgPSBtYXBTdGF0ZTtcbi8qKlxuICogQWxsb3dzIGRpcmVjdGx5IHVzaW5nIGFjdGlvbnMgZnJvbSB5b3VyIHN0b3JlIHdpdGhvdXQgdXNpbmcgdGhlIGNvbXBvc2l0aW9uXG4gKiBBUEkgKGBzZXR1cCgpYCkgYnkgZ2VuZXJhdGluZyBhbiBvYmplY3QgdG8gYmUgc3ByZWFkIGluIHRoZSBgbWV0aG9kc2AgZmllbGRcbiAqIG9mIGEgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB1c2VTdG9yZSAtIHN0b3JlIHRvIG1hcCBmcm9tXG4gKiBAcGFyYW0ga2V5c09yTWFwcGVyIC0gYXJyYXkgb3Igb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1hcEFjdGlvbnModXNlU3RvcmUsIGtleXNPck1hcHBlcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGtleXNPck1hcHBlcilcbiAgICAgICAgPyBrZXlzT3JNYXBwZXIucmVkdWNlKChyZWR1Y2VkLCBrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHJlZHVjZWRba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogRklYTUU6IHNob3VsZCB3b3JrP1xuICAgICAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZSh0aGlzLiRwaW5pYSlba2V5XSguLi5hcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVkdWNlZDtcbiAgICAgICAgfSwge30pXG4gICAgICAgIDogT2JqZWN0LmtleXMoa2V5c09yTWFwcGVyKS5yZWR1Y2UoKHJlZHVjZWQsIGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcmVkdWNlZFtrZXldID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBGSVhNRTogc2hvdWxkIHdvcms/XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZVN0b3JlKHRoaXMuJHBpbmlhKVtrZXlzT3JNYXBwZXJba2V5XV0oLi4uYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgICAgIH0sIHt9KTtcbn1cbi8qKlxuICogQWxsb3dzIHVzaW5nIHN0YXRlIGFuZCBnZXR0ZXJzIGZyb20gb25lIHN0b3JlIHdpdGhvdXQgdXNpbmcgdGhlIGNvbXBvc2l0aW9uXG4gKiBBUEkgKGBzZXR1cCgpYCkgYnkgZ2VuZXJhdGluZyBhbiBvYmplY3QgdG8gYmUgc3ByZWFkIGluIHRoZSBgY29tcHV0ZWRgIGZpZWxkXG4gKiBvZiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0gdXNlU3RvcmUgLSBzdG9yZSB0byBtYXAgZnJvbVxuICogQHBhcmFtIGtleXNPck1hcHBlciAtIGFycmF5IG9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBtYXBXcml0YWJsZVN0YXRlKHVzZVN0b3JlLCBrZXlzT3JNYXBwZXIpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShrZXlzT3JNYXBwZXIpXG4gICAgICAgID8ga2V5c09yTWFwcGVyLnJlZHVjZSgocmVkdWNlZCwga2V5KSA9PiB7XG4gICAgICAgICAgICByZWR1Y2VkW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlU3RvcmUodGhpcy4kcGluaWEpW2tleV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh1c2VTdG9yZSh0aGlzLiRwaW5pYSlba2V5XSA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgICAgICB9LCB7fSlcbiAgICAgICAgOiBPYmplY3Qua2V5cyhrZXlzT3JNYXBwZXIpLnJlZHVjZSgocmVkdWNlZCwga2V5KSA9PiB7XG4gICAgICAgICAgICByZWR1Y2VkW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlU3RvcmUodGhpcy4kcGluaWEpW2tleXNPck1hcHBlcltrZXldXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHVzZVN0b3JlKHRoaXMuJHBpbmlhKVtrZXlzT3JNYXBwZXJba2V5XV0gPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVkdWNlZDtcbiAgICAgICAgfSwge30pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IG9mIHJlZmVyZW5jZXMgd2l0aCBhbGwgdGhlIHN0YXRlLCBnZXR0ZXJzLCBhbmQgcGx1Z2luLWFkZGVkXG4gKiBzdGF0ZSBwcm9wZXJ0aWVzIG9mIHRoZSBzdG9yZS4gU2ltaWxhciB0byBgdG9SZWZzKClgIGJ1dCBzcGVjaWZpY2FsbHlcbiAqIGRlc2lnbmVkIGZvciBQaW5pYSBzdG9yZXMgc28gbWV0aG9kcyBhbmQgbm9uIHJlYWN0aXZlIHByb3BlcnRpZXMgYXJlXG4gKiBjb21wbGV0ZWx5IGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHN0b3JlIC0gc3RvcmUgdG8gZXh0cmFjdCB0aGUgcmVmcyBmcm9tXG4gKi9cbmZ1bmN0aW9uIHN0b3JlVG9SZWZzKHN0b3JlKSB7XG4gICAgY29uc3QgcmF3U3RvcmUgPSB0b1JhdyhzdG9yZSk7XG4gICAgY29uc3QgcmVmcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1N0b3JlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmF3U3RvcmVba2V5XTtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmF0aXZlIG1ldGhvZCB0byBjaGVjayBmb3IgYSBjb21wdXRlZFxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvY29yZS9wdWxsLzQxNjVcbiAgICAgICAgaWYgKHZhbHVlLmVmZmVjdCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogdG9vIGhhcmQgdG8gdHlwZSBjb3JyZWN0bHlcbiAgICAgICAgICAgIHJlZnNba2V5XSA9XG4gICAgICAgICAgICAgICAgLy8gLi4uXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQoe1xuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHN0b3JlW2tleV0sXG4gICAgICAgICAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmVmKHZhbHVlKSB8fCBpc1JlYWN0aXZlKHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogdGhlIGtleSBpcyBzdGF0ZSBvciBnZXR0ZXJcbiAgICAgICAgICAgIHJlZnNba2V5XSA9XG4gICAgICAgICAgICAgICAgLy8gLS0tXG4gICAgICAgICAgICAgICAgdG9SZWYoc3RvcmUsIGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZnM7XG59XG5cbmV4cG9ydCB7IE11dGF0aW9uVHlwZSwgYWNjZXB0SE1SVXBkYXRlLCBjcmVhdGVQaW5pYSwgZGVmaW5lU3RvcmUsIGRpc3Bvc2VQaW5pYSwgZ2V0QWN0aXZlUGluaWEsIG1hcEFjdGlvbnMsIG1hcEdldHRlcnMsIG1hcFN0YXRlLCBtYXBTdG9yZXMsIG1hcFdyaXRhYmxlU3RhdGUsIHNldEFjdGl2ZVBpbmlhLCBzZXRNYXBTdG9yZVN1ZmZpeCwgc2hvdWxkSHlkcmF0ZSwgc2tpcEh5ZHJhdGUsIHN0b3JlVG9SZWZzIH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHJ1bnRpbWUgaGVscGVyIGZvciBzZXR0aW5nIHByb3BlcnRpZXMgb24gY29tcG9uZW50c1xuLy8gaW4gYSB0cmVlLXNoYWthYmxlIHdheVxuZXhwb3J0cy5kZWZhdWx0ID0gKHNmYywgcHJvcHMpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBzZmMuX192Y2NPcHRzIHx8IHNmYztcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgcHJvcHMpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuIiwiLyoqXG4qIHZ1ZSB2My41LjI2XG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5pbXBvcnQgKiBhcyBydW50aW1lRG9tIGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuaW1wb3J0IHsgaW5pdEN1c3RvbUZvcm1hdHRlciwgcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIsIHdhcm4gfSBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuaW1wb3J0IHsgY29tcGlsZSB9IGZyb20gJ0B2dWUvY29tcGlsZXItZG9tJztcbmltcG9ydCB7IGlzU3RyaW5nLCBOT09QLCBnZW5DYWNoZUtleSwgZXh0ZW5kLCBnZW5lcmF0ZUNvZGVGcmFtZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gaW5pdERldigpIHtcbiAge1xuICAgIGluaXRDdXN0b21Gb3JtYXR0ZXIoKTtcbiAgfVxufVxuXG5pZiAoISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSkge1xuICBpbml0RGV2KCk7XG59XG5jb25zdCBjb21waWxlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9uKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gIGlmICghaXNTdHJpbmcodGVtcGxhdGUpKSB7XG4gICAgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICB9IGVsc2Uge1xuICAgICAgISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3YXJuKGBpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjogYCwgdGVtcGxhdGUpO1xuICAgICAgcmV0dXJuIE5PT1A7XG4gICAgfVxuICB9XG4gIGNvbnN0IGtleSA9IGdlbkNhY2hlS2V5KHRlbXBsYXRlLCBvcHRpb25zKTtcbiAgY29uc3QgY2FjaGVkID0gY29tcGlsZUNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG4gIGlmICh0ZW1wbGF0ZVswXSA9PT0gXCIjXCIpIHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGVtcGxhdGUpO1xuICAgIGlmICghIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpICYmICFlbCkge1xuICAgICAgd2FybihgVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6ICR7dGVtcGxhdGV9YCk7XG4gICAgfVxuICAgIHRlbXBsYXRlID0gZWwgPyBlbC5pbm5lckhUTUwgOiBgYDtcbiAgfVxuICBjb25zdCBvcHRzID0gZXh0ZW5kKFxuICAgIHtcbiAgICAgIGhvaXN0U3RhdGljOiB0cnVlLFxuICAgICAgb25FcnJvcjogISEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSA/IG9uRXJyb3IgOiB2b2lkIDAsXG4gICAgICBvbldhcm46ICEhKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikgPyAoZSkgPT4gb25FcnJvcihlLCB0cnVlKSA6IE5PT1BcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgaWYgKCFvcHRzLmlzQ3VzdG9tRWxlbWVudCAmJiB0eXBlb2YgY3VzdG9tRWxlbWVudHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBvcHRzLmlzQ3VzdG9tRWxlbWVudCA9ICh0YWcpID0+ICEhY3VzdG9tRWxlbWVudHMuZ2V0KHRhZyk7XG4gIH1cbiAgY29uc3QgeyBjb2RlIH0gPSBjb21waWxlKHRlbXBsYXRlLCBvcHRzKTtcbiAgZnVuY3Rpb24gb25FcnJvcihlcnIsIGFzV2FybmluZyA9IGZhbHNlKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGFzV2FybmluZyA/IGVyci5tZXNzYWdlIDogYFRlbXBsYXRlIGNvbXBpbGF0aW9uIGVycm9yOiAke2Vyci5tZXNzYWdlfWA7XG4gICAgY29uc3QgY29kZUZyYW1lID0gZXJyLmxvYyAmJiBnZW5lcmF0ZUNvZGVGcmFtZShcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgZXJyLmxvYy5zdGFydC5vZmZzZXQsXG4gICAgICBlcnIubG9jLmVuZC5vZmZzZXRcbiAgICApO1xuICAgIHdhcm4oY29kZUZyYW1lID8gYCR7bWVzc2FnZX1cbiR7Y29kZUZyYW1lfWAgOiBtZXNzYWdlKTtcbiAgfVxuICBjb25zdCByZW5kZXIgPSBuZXcgRnVuY3Rpb24oXCJWdWVcIiwgY29kZSkocnVudGltZURvbSk7XG4gIHJlbmRlci5fcmMgPSB0cnVlO1xuICByZXR1cm4gY29tcGlsZUNhY2hlW2tleV0gPSByZW5kZXI7XG59XG5yZWdpc3RlclJ1bnRpbWVDb21waWxlcihjb21waWxlVG9GdW5jdGlvbik7XG5cbmV4cG9ydCB7IGNvbXBpbGVUb0Z1bmN0aW9uIGFzIGNvbXBpbGUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=